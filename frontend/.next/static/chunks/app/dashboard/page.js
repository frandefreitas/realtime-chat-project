/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/dashboard/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fixcsoft%2F%C3%81rea%20de%20trabalho%2Frealtime-chat-project%2Ffrontend%2Fapp%2Fdashboard%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!******************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fixcsoft%2F%C3%81rea%20de%20trabalho%2Frealtime-chat-project%2Ffrontend%2Fapp%2Fdashboard%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \******************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/dashboard/page.tsx */ \"(app-pages-browser)/./app/dashboard/page.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGaG9tZSUyRml4Y3NvZnQlMkYlQzMlODFyZWElMjBkZSUyMHRyYWJhbGhvJTJGcmVhbHRpbWUtY2hhdC1wcm9qZWN0JTJGZnJvbnRlbmQlMkZhcHAlMkZkYXNoYm9hcmQlMkZwYWdlLnRzeCUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLDBLQUF5SCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzNjMzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvaG9tZS9peGNzb2Z0L8OBcmVhIGRlIHRyYWJhbGhvL3JlYWx0aW1lLWNoYXQtcHJvamVjdC9mcm9udGVuZC9hcHAvZGFzaGJvYXJkL3BhZ2UudHN4XCIpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fixcsoft%2F%C3%81rea%20de%20trabalho%2Frealtime-chat-project%2Ffrontend%2Fapp%2Fdashboard%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/navigation.js":
/*!**************************************************!*\
  !*** ./node_modules/next/dist/api/navigation.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/components/navigation */ \"(app-pages-browser)/./node_modules/next/dist/client/components/navigation.js\");\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_components_navigation__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n//# sourceMappingURL=navigation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL25hdmlnYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdEOztBQUVoRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9uYXZpZ2F0aW9uLmpzPzM5NTMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi4vY2xpZW50L2NvbXBvbmVudHMvbmF2aWdhdGlvbic7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hdmlnYXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/navigation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/dashboard/page.tsx":
/*!********************************!*\
  !*** ./app/dashboard/page.tsx ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DashboardPage)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lib_presence__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/presence */ \"(app-pages-browser)/./lib/presence.ts\");\n/* harmony import */ var _components_UserList__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/UserList */ \"(app-pages-browser)/./components/UserList.tsx\");\n/* harmony import */ var _components_ChatBox__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/ChatBox */ \"(app-pages-browser)/./components/ChatBox.tsx\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\nfunction getCookie(name) {\n    const part = document.cookie.split('; ').find((r)=>r.startsWith(name + '='));\n    return part ? decodeURIComponent(part.split('=')[1]) : null;\n}\nfunction DashboardPage() {\n    _s();\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_5__.useRouter)();\n    const [me, setMe] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [peer, setPeer] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const u = getCookie('username');\n        const t = getCookie('token');\n        if (!u || !t) {\n            router.push('/login');\n            return;\n        }\n        setMe(u);\n        (0,_lib_presence__WEBPACK_IMPORTED_MODULE_2__.startPresenceHeartbeat)(u);\n        return ()=>(0,_lib_presence__WEBPACK_IMPORTED_MODULE_2__.stopPresenceHeartbeat)();\n    }, [\n        router\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"grid md:grid-cols-[1fr_2fr] gap-4\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"aside\", {\n                className: \"border rounded p-3\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"mb-2 text-sm opacity-70\",\n                        children: [\n                            \"Logado como \",\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"b\", {\n                                children: [\n                                    \"@\",\n                                    me\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/home/ixcsoft/\\xc1rea de trabalho/realtime-chat-project/frontend/app/dashboard/page.tsx\",\n                                lineNumber: 31,\n                                columnNumber: 23\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/home/ixcsoft/\\xc1rea de trabalho/realtime-chat-project/frontend/app/dashboard/page.tsx\",\n                        lineNumber: 30,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_UserList__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                        me: me,\n                        selected: peer === null || peer === void 0 ? void 0 : peer.username,\n                        onSelect: setPeer\n                    }, void 0, false, {\n                        fileName: \"/home/ixcsoft/\\xc1rea de trabalho/realtime-chat-project/frontend/app/dashboard/page.tsx\",\n                        lineNumber: 33,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/home/ixcsoft/\\xc1rea de trabalho/realtime-chat-project/frontend/app/dashboard/page.tsx\",\n                lineNumber: 29,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                className: \"border rounded\",\n                children: me && peer ? peer.online ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ChatBox__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                    me: me,\n                    peer: peer.username\n                }, void 0, false, {\n                    fileName: \"/home/ixcsoft/\\xc1rea de trabalho/realtime-chat-project/frontend/app/dashboard/page.tsx\",\n                    lineNumber: 39,\n                    columnNumber: 13\n                }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"p-6 opacity-60\",\n                    children: [\n                        \"Usu\\xe1rio @\",\n                        peer.username,\n                        \" est\\xe1 offline. Voc\\xea s\\xf3 pode enviar mensagens para usu\\xe1rios online.\"\n                    ]\n                }, void 0, true, {\n                    fileName: \"/home/ixcsoft/\\xc1rea de trabalho/realtime-chat-project/frontend/app/dashboard/page.tsx\",\n                    lineNumber: 41,\n                    columnNumber: 13\n                }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"p-6 opacity-60\",\n                    children: \"Selecione um usu\\xe1rio ao lado para come\\xe7ar a conversar.\"\n                }, void 0, false, {\n                    fileName: \"/home/ixcsoft/\\xc1rea de trabalho/realtime-chat-project/frontend/app/dashboard/page.tsx\",\n                    lineNumber: 47,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: \"/home/ixcsoft/\\xc1rea de trabalho/realtime-chat-project/frontend/app/dashboard/page.tsx\",\n                lineNumber: 36,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/ixcsoft/\\xc1rea de trabalho/realtime-chat-project/frontend/app/dashboard/page.tsx\",\n        lineNumber: 28,\n        columnNumber: 5\n    }, this);\n}\n_s(DashboardPage, \"rBQmKiLjYFkFcuLM0ET7ZTszkVs=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_5__.useRouter\n    ];\n});\n_c = DashboardPage;\nvar _c;\n$RefreshReg$(_c, \"DashboardPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9kYXNoYm9hcmQvcGFnZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUM0QztBQUNtQztBQUNsQztBQUNGO0FBQ0M7QUFFNUMsU0FBU08sVUFBVUMsSUFBWTtJQUM3QixNQUFNQyxPQUFPQyxTQUFTQyxNQUFNLENBQUNDLEtBQUssQ0FBQyxNQUFNQyxJQUFJLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLFVBQVUsQ0FBQ1AsT0FBTztJQUN2RSxPQUFPQyxPQUFPTyxtQkFBbUJQLEtBQUtHLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJO0FBQ3pEO0FBRWUsU0FBU0s7O0lBQ3RCLE1BQU1DLFNBQVNaLDBEQUFTQTtJQUN4QixNQUFNLENBQUNhLElBQUlDLE1BQU0sR0FBR25CLCtDQUFRQSxDQUFDO0lBQzdCLE1BQU0sQ0FBQ29CLE1BQU1DLFFBQVEsR0FBR3JCLCtDQUFRQSxDQUErQztJQUUvRUQsZ0RBQVNBLENBQUM7UUFDUixNQUFNdUIsSUFBSWhCLFVBQVU7UUFDcEIsTUFBTWlCLElBQUlqQixVQUFVO1FBQ3BCLElBQUksQ0FBQ2dCLEtBQUssQ0FBQ0MsR0FBRztZQUFFTixPQUFPTyxJQUFJLENBQUM7WUFBVztRQUFRO1FBQy9DTCxNQUFNRztRQUNOckIscUVBQXNCQSxDQUFDcUI7UUFDdkIsT0FBTyxJQUFNcEIsb0VBQXFCQTtJQUNwQyxHQUFHO1FBQUNlO0tBQU87SUFFWCxxQkFDRSw4REFBQ1E7UUFBSUMsV0FBVTs7MEJBQ2IsOERBQUNDO2dCQUFNRCxXQUFVOztrQ0FDZiw4REFBQ0Q7d0JBQUlDLFdBQVU7OzRCQUEwQjswQ0FDM0IsOERBQUNFOztvQ0FBRTtvQ0FBRVY7Ozs7Ozs7Ozs7Ozs7a0NBRW5CLDhEQUFDZiw0REFBUUE7d0JBQUNlLElBQUlBO3dCQUFJVyxRQUFRLEVBQUVULGlCQUFBQSwyQkFBQUEsS0FBTVUsUUFBUTt3QkFBRUMsVUFBVVY7Ozs7Ozs7Ozs7OzswQkFHeEQsOERBQUNXO2dCQUFRTixXQUFVOzBCQUNoQlIsTUFBTUUsT0FDTEEsS0FBS2EsTUFBTSxpQkFDVCw4REFBQzdCLDJEQUFPQTtvQkFBQ2MsSUFBSUE7b0JBQUlFLE1BQU1BLEtBQUtVLFFBQVE7Ozs7O3lDQUVwQyw4REFBQ0w7b0JBQUlDLFdBQVU7O3dCQUFpQjt3QkFDcEJOLEtBQUtVLFFBQVE7d0JBQUM7Ozs7Ozt5Q0FLNUIsOERBQUNMO29CQUFJQyxXQUFVOzhCQUFpQjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLMUM7R0F2Q3dCVjs7UUFDUFgsc0RBQVNBOzs7S0FERlciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2Rhc2hib2FyZC9wYWdlLnRzeD9kMTI1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBzdGFydFByZXNlbmNlSGVhcnRiZWF0LCBzdG9wUHJlc2VuY2VIZWFydGJlYXQgfSBmcm9tICdAL2xpYi9wcmVzZW5jZSc7XG5pbXBvcnQgVXNlckxpc3QgZnJvbSAnQC9jb21wb25lbnRzL1VzZXJMaXN0JztcbmltcG9ydCBDaGF0Qm94IGZyb20gJ0AvY29tcG9uZW50cy9DaGF0Qm94JztcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gJ25leHQvbmF2aWdhdGlvbic7XG5cbmZ1bmN0aW9uIGdldENvb2tpZShuYW1lOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgcGFydCA9IGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOyAnKS5maW5kKHIgPT4gci5zdGFydHNXaXRoKG5hbWUgKyAnPScpKTtcbiAgcmV0dXJuIHBhcnQgPyBkZWNvZGVVUklDb21wb25lbnQocGFydC5zcGxpdCgnPScpWzFdKSA6IG51bGw7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERhc2hib2FyZFBhZ2UoKSB7XG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xuICBjb25zdCBbbWUsIHNldE1lXSA9IHVzZVN0YXRlKCcnKTtcbiAgY29uc3QgW3BlZXIsIHNldFBlZXJdID0gdXNlU3RhdGU8eyB1c2VybmFtZTogc3RyaW5nOyBvbmxpbmU6IGJvb2xlYW4gfSB8IG51bGw+KG51bGwpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgdSA9IGdldENvb2tpZSgndXNlcm5hbWUnKTtcbiAgICBjb25zdCB0ID0gZ2V0Q29va2llKCd0b2tlbicpO1xuICAgIGlmICghdSB8fCAhdCkgeyByb3V0ZXIucHVzaCgnL2xvZ2luJyk7IHJldHVybjsgfVxuICAgIHNldE1lKHUpO1xuICAgIHN0YXJ0UHJlc2VuY2VIZWFydGJlYXQodSk7XG4gICAgcmV0dXJuICgpID0+IHN0b3BQcmVzZW5jZUhlYXJ0YmVhdCgpO1xuICB9LCBbcm91dGVyXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImdyaWQgbWQ6Z3JpZC1jb2xzLVsxZnJfMmZyXSBnYXAtNFwiPlxuICAgICAgPGFzaWRlIGNsYXNzTmFtZT1cImJvcmRlciByb3VuZGVkIHAtM1wiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1iLTIgdGV4dC1zbSBvcGFjaXR5LTcwXCI+XG4gICAgICAgICAgTG9nYWRvIGNvbW8gPGI+QHttZX08L2I+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8VXNlckxpc3QgbWU9e21lfSBzZWxlY3RlZD17cGVlcj8udXNlcm5hbWV9IG9uU2VsZWN0PXtzZXRQZWVyfSAvPlxuICAgICAgPC9hc2lkZT5cblxuICAgICAgPHNlY3Rpb24gY2xhc3NOYW1lPVwiYm9yZGVyIHJvdW5kZWRcIj5cbiAgICAgICAge21lICYmIHBlZXIgPyAoXG4gICAgICAgICAgcGVlci5vbmxpbmUgPyAoXG4gICAgICAgICAgICA8Q2hhdEJveCBtZT17bWV9IHBlZXI9e3BlZXIudXNlcm5hbWV9IC8+XG4gICAgICAgICAgKSA6IChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicC02IG9wYWNpdHktNjBcIj5cbiAgICAgICAgICAgICAgVXN1w6FyaW8gQHtwZWVyLnVzZXJuYW1lfSBlc3TDoSBvZmZsaW5lLiAgXG4gICAgICAgICAgICAgIFZvY8OqIHPDsyBwb2RlIGVudmlhciBtZW5zYWdlbnMgcGFyYSB1c3XDoXJpb3Mgb25saW5lLlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKVxuICAgICAgICApIDogKFxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicC02IG9wYWNpdHktNjBcIj5TZWxlY2lvbmUgdW0gdXN1w6FyaW8gYW8gbGFkbyBwYXJhIGNvbWXDp2FyIGEgY29udmVyc2FyLjwvZGl2PlxuICAgICAgICApfVxuICAgICAgPC9zZWN0aW9uPlxuICAgIDwvZGl2PlxuICApO1xufVxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVN0YXRlIiwic3RhcnRQcmVzZW5jZUhlYXJ0YmVhdCIsInN0b3BQcmVzZW5jZUhlYXJ0YmVhdCIsIlVzZXJMaXN0IiwiQ2hhdEJveCIsInVzZVJvdXRlciIsImdldENvb2tpZSIsIm5hbWUiLCJwYXJ0IiwiZG9jdW1lbnQiLCJjb29raWUiLCJzcGxpdCIsImZpbmQiLCJyIiwic3RhcnRzV2l0aCIsImRlY29kZVVSSUNvbXBvbmVudCIsIkRhc2hib2FyZFBhZ2UiLCJyb3V0ZXIiLCJtZSIsInNldE1lIiwicGVlciIsInNldFBlZXIiLCJ1IiwidCIsInB1c2giLCJkaXYiLCJjbGFzc05hbWUiLCJhc2lkZSIsImIiLCJzZWxlY3RlZCIsInVzZXJuYW1lIiwib25TZWxlY3QiLCJzZWN0aW9uIiwib25saW5lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/dashboard/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/ChatBox.tsx":
/*!********************************!*\
  !*** ./components/ChatBox.tsx ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ChatBox)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _hooks_useChat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/hooks/useChat */ \"(app-pages-browser)/./hooks/useChat.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nfunction ChatBox(param) {\n    let { me, peer } = param;\n    _s();\n    const { msgs, send } = (0,_hooks_useChat__WEBPACK_IMPORTED_MODULE_2__.useChat)(me, peer);\n    const [text, setText] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    async function onSend() {\n        if (!text.trim() || !peer) return;\n        await send(peer, text);\n        setText('');\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"p-3 flex flex-col gap-2\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex-1 overflow-y-auto rounded bg-black/20\",\n                children: msgs.map((m, i)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"mb-2\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-xs opacity-60\",\n                                children: m.from === me ? 'você' : '@' + m.from\n                            }, void 0, false, {\n                                fileName: \"/home/ixcsoft/\\xc1rea de trabalho/realtime-chat-project/frontend/components/ChatBox.tsx\",\n                                lineNumber: 20,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"inline-block bg-white/10 rounded px-2 py-1\",\n                                children: m.text\n                            }, void 0, false, {\n                                fileName: \"/home/ixcsoft/\\xc1rea de trabalho/realtime-chat-project/frontend/components/ChatBox.tsx\",\n                                lineNumber: 23,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, \"\".concat(m.from, \"-\").concat(m.ts, \"-\").concat(i), true, {\n                        fileName: \"/home/ixcsoft/\\xc1rea de trabalho/realtime-chat-project/frontend/components/ChatBox.tsx\",\n                        lineNumber: 19,\n                        columnNumber: 11\n                    }, this))\n            }, void 0, false, {\n                fileName: \"/home/ixcsoft/\\xc1rea de trabalho/realtime-chat-project/frontend/components/ChatBox.tsx\",\n                lineNumber: 17,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex gap-2\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        value: text,\n                        onChange: (e)=>setText(e.target.value),\n                        placeholder: \"Digite uma mensagem...\",\n                        className: \"flex-1 px-3 py-2 rounded bg-white/5 border\",\n                        onKeyDown: (e)=>e.key === 'Enter' && onSend()\n                    }, void 0, false, {\n                        fileName: \"/home/ixcsoft/\\xc1rea de trabalho/realtime-chat-project/frontend/components/ChatBox.tsx\",\n                        lineNumber: 31,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: onSend,\n                        className: \"px-4 py-2 rounded bg-blue-600\",\n                        children: \"Enviar\"\n                    }, void 0, false, {\n                        fileName: \"/home/ixcsoft/\\xc1rea de trabalho/realtime-chat-project/frontend/components/ChatBox.tsx\",\n                        lineNumber: 38,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/home/ixcsoft/\\xc1rea de trabalho/realtime-chat-project/frontend/components/ChatBox.tsx\",\n                lineNumber: 30,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/ixcsoft/\\xc1rea de trabalho/realtime-chat-project/frontend/components/ChatBox.tsx\",\n        lineNumber: 16,\n        columnNumber: 5\n    }, this);\n}\n_s(ChatBox, \"TfCiC7YqK7xWFdKNdrsa+6+r5XM=\", false, function() {\n    return [\n        _hooks_useChat__WEBPACK_IMPORTED_MODULE_2__.useChat\n    ];\n});\n_c = ChatBox;\nvar _c;\n$RefreshReg$(_c, \"ChatBox\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvQ2hhdEJveC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUNpQztBQUNTO0FBRTNCLFNBQVNFLFFBQVEsS0FBMEM7UUFBMUMsRUFBRUMsRUFBRSxFQUFFQyxJQUFJLEVBQWdDLEdBQTFDOztJQUM5QixNQUFNLEVBQUVDLElBQUksRUFBRUMsSUFBSSxFQUFFLEdBQUdMLHVEQUFPQSxDQUFDRSxJQUFJQztJQUNuQyxNQUFNLENBQUNHLE1BQU1DLFFBQVEsR0FBR1IsK0NBQVFBLENBQUM7SUFFakMsZUFBZVM7UUFDYixJQUFJLENBQUNGLEtBQUtHLElBQUksTUFBTSxDQUFDTixNQUFNO1FBQzNCLE1BQU1FLEtBQUtGLE1BQU1HO1FBQ2pCQyxRQUFRO0lBQ1Y7SUFFQSxxQkFDRSw4REFBQ0c7UUFBSUMsV0FBVTs7MEJBQ2IsOERBQUNEO2dCQUFJQyxXQUFVOzBCQUNaUCxLQUFLUSxHQUFHLENBQUMsQ0FBQ0MsR0FBR0Msa0JBQ1osOERBQUNKO3dCQUFtQ0MsV0FBVTs7MENBQzVDLDhEQUFDRDtnQ0FBSUMsV0FBVTswQ0FDWkUsRUFBRUUsSUFBSSxLQUFLYixLQUFLLFNBQVMsTUFBTVcsRUFBRUUsSUFBSTs7Ozs7OzBDQUV4Qyw4REFBQ0w7Z0NBQUlDLFdBQVU7MENBQ1pFLEVBQUVQLElBQUk7Ozs7Ozs7dUJBTEQsR0FBYU8sT0FBVkEsRUFBRUUsSUFBSSxFQUFDLEtBQVdELE9BQVJELEVBQUVHLEVBQUUsRUFBQyxLQUFLLE9BQUZGOzs7Ozs7Ozs7OzBCQVduQyw4REFBQ0o7Z0JBQUlDLFdBQVU7O2tDQUNiLDhEQUFDTTt3QkFDQ0MsT0FBT1o7d0JBQ1BhLFVBQVUsQ0FBQ0MsSUFBTWIsUUFBUWEsRUFBRUMsTUFBTSxDQUFDSCxLQUFLO3dCQUN2Q0ksYUFBWTt3QkFDWlgsV0FBVTt3QkFDVlksV0FBVyxDQUFDSCxJQUFNQSxFQUFFSSxHQUFHLEtBQUssV0FBV2hCOzs7Ozs7a0NBRXpDLDhEQUFDaUI7d0JBQU9DLFNBQVNsQjt3QkFBUUcsV0FBVTtrQ0FBZ0M7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU0zRTtHQXZDd0JWOztRQUNDRCxtREFBT0E7OztLQURSQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0NoYXRCb3gudHN4PzVhYjUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VDaGF0IH0gZnJvbSAnQC9ob29rcy91c2VDaGF0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2hhdEJveCh7IG1lLCBwZWVyIH06IHsgbWU6IHN0cmluZzsgcGVlcjogc3RyaW5nIH0pIHtcbiAgY29uc3QgeyBtc2dzLCBzZW5kIH0gPSB1c2VDaGF0KG1lLCBwZWVyKTtcbiAgY29uc3QgW3RleHQsIHNldFRleHRdID0gdXNlU3RhdGUoJycpO1xuXG4gIGFzeW5jIGZ1bmN0aW9uIG9uU2VuZCgpIHtcbiAgICBpZiAoIXRleHQudHJpbSgpIHx8ICFwZWVyKSByZXR1cm47XG4gICAgYXdhaXQgc2VuZChwZWVyLCB0ZXh0KTtcbiAgICBzZXRUZXh0KCcnKTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJwLTMgZmxleCBmbGV4LWNvbCBnYXAtMlwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4LTEgb3ZlcmZsb3cteS1hdXRvIHJvdW5kZWQgYmctYmxhY2svMjBcIj5cbiAgICAgICAge21zZ3MubWFwKChtLCBpKSA9PiAoXG4gICAgICAgICAgPGRpdiBrZXk9e2Ake20uZnJvbX0tJHttLnRzfS0ke2l9YH0gY2xhc3NOYW1lPVwibWItMlwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXhzIG9wYWNpdHktNjBcIj5cbiAgICAgICAgICAgICAge20uZnJvbSA9PT0gbWUgPyAndm9jw6onIDogJ0AnICsgbS5mcm9tfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImlubGluZS1ibG9jayBiZy13aGl0ZS8xMCByb3VuZGVkIHB4LTIgcHktMVwiPlxuICAgICAgICAgICAgICB7bS50ZXh0fVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICkpfVxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBnYXAtMlwiPlxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICB2YWx1ZT17dGV4dH1cbiAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldFRleHQoZS50YXJnZXQudmFsdWUpfVxuICAgICAgICAgIHBsYWNlaG9sZGVyPVwiRGlnaXRlIHVtYSBtZW5zYWdlbS4uLlwiXG4gICAgICAgICAgY2xhc3NOYW1lPVwiZmxleC0xIHB4LTMgcHktMiByb3VuZGVkIGJnLXdoaXRlLzUgYm9yZGVyXCJcbiAgICAgICAgICBvbktleURvd249eyhlKSA9PiBlLmtleSA9PT0gJ0VudGVyJyAmJiBvblNlbmQoKX1cbiAgICAgICAgLz5cbiAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtvblNlbmR9IGNsYXNzTmFtZT1cInB4LTQgcHktMiByb3VuZGVkIGJnLWJsdWUtNjAwXCI+XG4gICAgICAgICAgRW52aWFyXG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59XG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VDaGF0IiwiQ2hhdEJveCIsIm1lIiwicGVlciIsIm1zZ3MiLCJzZW5kIiwidGV4dCIsInNldFRleHQiLCJvblNlbmQiLCJ0cmltIiwiZGl2IiwiY2xhc3NOYW1lIiwibWFwIiwibSIsImkiLCJmcm9tIiwidHMiLCJpbnB1dCIsInZhbHVlIiwib25DaGFuZ2UiLCJlIiwidGFyZ2V0IiwicGxhY2Vob2xkZXIiLCJvbktleURvd24iLCJrZXkiLCJidXR0b24iLCJvbkNsaWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/ChatBox.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/UserList.tsx":
/*!*********************************!*\
  !*** ./components/UserList.tsx ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ UserList)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/api */ \"(app-pages-browser)/./lib/api.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nfunction UserList(param) {\n    let { me, selected, onSelect } = param;\n    _s();\n    const [allUsers, setAllUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [onlineUsers, setOnlineUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        async function loadAll() {\n            const { users } = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.listUsers)();\n            const list = Array.isArray(users) ? typeof users[0] === 'string' ? users : users.map((u)=>u.username) : [];\n            setAllUsers(list.filter(Boolean));\n        }\n        loadAll();\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        async function refreshPresence() {\n            const { users } = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.listOnline)();\n            const online = users.map((u)=>{\n                var _u_username;\n                return (_u_username = u.username) !== null && _u_username !== void 0 ? _u_username : u.id;\n            });\n            setOnlineUsers(online);\n        }\n        refreshPresence();\n        const id = setInterval(refreshPresence, 10000);\n        return ()=>clearInterval(id);\n    }, []);\n    const visibleOnline = onlineUsers.filter((u)=>u !== me);\n    const offlineUsers = allUsers.filter((u)=>u !== me && !onlineUsers.includes(u));\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"p-4\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                className: \"font-semibold mb-2\",\n                children: \"Online\"\n            }, void 0, false, {\n                fileName: \"/home/ixcsoft/\\xc1rea de trabalho/realtime-chat-project/frontend/components/UserList.tsx\",\n                lineNumber: 44,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                children: [\n                    visibleOnline.map((u)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            className: \"cursor-pointer p-1 rounded \".concat(selected === u ? 'bg-blue-500/30' : ''),\n                            onClick: ()=>onSelect({\n                                    username: u,\n                                    online: true\n                                }),\n                            children: [\n                                \"\\uD83D\\uDFE2 @\",\n                                u\n                            ]\n                        }, u, true, {\n                            fileName: \"/home/ixcsoft/\\xc1rea de trabalho/realtime-chat-project/frontend/components/UserList.tsx\",\n                            lineNumber: 47,\n                            columnNumber: 11\n                        }, this)),\n                    visibleOnline.length === 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                        className: \"opacity-60 text-sm\",\n                        children: \"Ningu\\xe9m online\"\n                    }, void 0, false, {\n                        fileName: \"/home/ixcsoft/\\xc1rea de trabalho/realtime-chat-project/frontend/components/UserList.tsx\",\n                        lineNumber: 56,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/home/ixcsoft/\\xc1rea de trabalho/realtime-chat-project/frontend/components/UserList.tsx\",\n                lineNumber: 45,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                className: \"font-semibold mt-4 mb-2\",\n                children: \"Offline\"\n            }, void 0, false, {\n                fileName: \"/home/ixcsoft/\\xc1rea de trabalho/realtime-chat-project/frontend/components/UserList.tsx\",\n                lineNumber: 60,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                className: \"opacity-60\",\n                children: offlineUsers.map((u)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                        className: \"cursor-pointer p-1 rounded \".concat(selected === u ? 'bg-gray-500/30' : ''),\n                        onClick: ()=>onSelect({\n                                username: u,\n                                online: false\n                            }),\n                        children: [\n                            \"⚪ @\",\n                            u\n                        ]\n                    }, u, true, {\n                        fileName: \"/home/ixcsoft/\\xc1rea de trabalho/realtime-chat-project/frontend/components/UserList.tsx\",\n                        lineNumber: 63,\n                        columnNumber: 11\n                    }, this))\n            }, void 0, false, {\n                fileName: \"/home/ixcsoft/\\xc1rea de trabalho/realtime-chat-project/frontend/components/UserList.tsx\",\n                lineNumber: 61,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/ixcsoft/\\xc1rea de trabalho/realtime-chat-project/frontend/components/UserList.tsx\",\n        lineNumber: 43,\n        columnNumber: 5\n    }, this);\n}\n_s(UserList, \"zn3XM1XCgZrqLylRiIcpr1B+KtU=\");\n_c = UserList;\nvar _c;\n$RefreshReg$(_c, \"UserList\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvVXNlckxpc3QudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFDNEM7QUFDTTtBQVFuQyxTQUFTSSxTQUFTLEtBQWlDO1FBQWpDLEVBQUVDLEVBQUUsRUFBRUMsUUFBUSxFQUFFQyxRQUFRLEVBQVMsR0FBakM7O0lBQy9CLE1BQU0sQ0FBQ0MsVUFBVUMsWUFBWSxHQUFHUiwrQ0FBUUEsQ0FBVyxFQUFFO0lBQ3JELE1BQU0sQ0FBQ1MsYUFBYUMsZUFBZSxHQUFHViwrQ0FBUUEsQ0FBVyxFQUFFO0lBRTNERCxnREFBU0EsQ0FBQztRQUNSLGVBQWVZO1lBQ2IsTUFBTSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNWCxtREFBU0E7WUFDakMsTUFBTVksT0FBT0MsTUFBTUMsT0FBTyxDQUFDSCxTQUN0QixPQUFPLEtBQWMsQ0FBQyxFQUFFLEtBQUssV0FDekJBLFFBQ0QsTUFBaUJJLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsUUFBUSxJQUN4QyxFQUFFO1lBQ05WLFlBQVlLLEtBQUtNLE1BQU0sQ0FBQ0M7UUFDMUI7UUFDQVQ7SUFDRixHQUFHLEVBQUU7SUFFTFosZ0RBQVNBLENBQUM7UUFDUixlQUFlc0I7WUFDYixNQUFNLEVBQUVULEtBQUssRUFBRSxHQUFHLE1BQU1WLG9EQUFVQTtZQUNsQyxNQUFNb0IsU0FBU1YsTUFBTUksR0FBRyxDQUFDQyxDQUFBQTtvQkFBSzt1QkFBQSxpQkFBV0MsUUFBUSxjQUFuQix1Q0FBdUIsRUFBV0ssRUFBRTs7WUFDbEViLGVBQWVZO1FBQ2pCO1FBQ0FEO1FBQ0EsTUFBTUUsS0FBS0MsWUFBWUgsaUJBQWlCO1FBQ3hDLE9BQU8sSUFBTUksY0FBY0Y7SUFDN0IsR0FBRyxFQUFFO0lBRUwsTUFBTUcsZ0JBQWdCakIsWUFBWVUsTUFBTSxDQUFDRixDQUFBQSxJQUFLQSxNQUFNYjtJQUNwRCxNQUFNdUIsZUFBZXBCLFNBQVNZLE1BQU0sQ0FBQ0YsQ0FBQUEsSUFBS0EsTUFBTWIsTUFBTSxDQUFDSyxZQUFZbUIsUUFBUSxDQUFDWDtJQUU1RSxxQkFDRSw4REFBQ1k7UUFBSUMsV0FBVTs7MEJBQ2IsOERBQUNDO2dCQUFHRCxXQUFVOzBCQUFxQjs7Ozs7OzBCQUNuQyw4REFBQ0U7O29CQUNFTixjQUFjVixHQUFHLENBQUNDLENBQUFBLGtCQUNqQiw4REFBQ2dCOzRCQUVDSCxXQUFXLDhCQUFxRSxPQUF2Q3pCLGFBQWFZLElBQUksbUJBQW1COzRCQUM3RWlCLFNBQVMsSUFBTTVCLFNBQVM7b0NBQUVZLFVBQVVEO29DQUFHSyxRQUFRO2dDQUFLOztnQ0FDckQ7Z0NBQ01MOzsyQkFKQUE7Ozs7O29CQU9SUyxjQUFjUyxNQUFNLEtBQUssbUJBQ3hCLDhEQUFDRjt3QkFBR0gsV0FBVTtrQ0FBcUI7Ozs7Ozs7Ozs7OzswQkFJdkMsOERBQUNDO2dCQUFHRCxXQUFVOzBCQUEwQjs7Ozs7OzBCQUN4Qyw4REFBQ0U7Z0JBQUdGLFdBQVU7MEJBQ1hILGFBQWFYLEdBQUcsQ0FBQ0MsQ0FBQUEsa0JBQ2hCLDhEQUFDZ0I7d0JBRUNILFdBQVcsOEJBQXFFLE9BQXZDekIsYUFBYVksSUFBSSxtQkFBbUI7d0JBQzdFaUIsU0FBUyxJQUFNNUIsU0FBUztnQ0FBRVksVUFBVUQ7Z0NBQUdLLFFBQVE7NEJBQU07OzRCQUN0RDs0QkFDS0w7O3VCQUpDQTs7Ozs7Ozs7Ozs7Ozs7OztBQVVqQjtHQS9Ed0JkO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvVXNlckxpc3QudHN4PzA5NDIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGxpc3RVc2VycywgbGlzdE9ubGluZSB9IGZyb20gJ0AvbGliL2FwaSc7XG5cbnR5cGUgUHJvcHMgPSB7XG4gIG1lOiBzdHJpbmc7XG4gIHNlbGVjdGVkPzogc3RyaW5nO1xuICBvblNlbGVjdDogKHVzZXI6IHsgdXNlcm5hbWU6IHN0cmluZzsgb25saW5lOiBib29sZWFuIH0pID0+IHZvaWQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBVc2VyTGlzdCh7IG1lLCBzZWxlY3RlZCwgb25TZWxlY3QgfTogUHJvcHMpIHtcbiAgY29uc3QgW2FsbFVzZXJzLCBzZXRBbGxVc2Vyc10gPSB1c2VTdGF0ZTxzdHJpbmdbXT4oW10pO1xuICBjb25zdCBbb25saW5lVXNlcnMsIHNldE9ubGluZVVzZXJzXSA9IHVzZVN0YXRlPHN0cmluZ1tdPihbXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBhc3luYyBmdW5jdGlvbiBsb2FkQWxsKCkge1xuICAgICAgY29uc3QgeyB1c2VycyB9ID0gYXdhaXQgbGlzdFVzZXJzKCk7XG4gICAgICBjb25zdCBsaXN0ID0gQXJyYXkuaXNBcnJheSh1c2VycylcbiAgICAgICAgPyAodHlwZW9mICh1c2VycyBhcyBhbnkpWzBdID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyAodXNlcnMgYXMgc3RyaW5nW10pXG4gICAgICAgICAgICA6ICh1c2VycyBhcyBhbnlbXSkubWFwKHUgPT4gdS51c2VybmFtZSkpXG4gICAgICAgIDogW107XG4gICAgICBzZXRBbGxVc2VycyhsaXN0LmZpbHRlcihCb29sZWFuKSk7XG4gICAgfVxuICAgIGxvYWRBbGwoKTtcbiAgfSwgW10pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgYXN5bmMgZnVuY3Rpb24gcmVmcmVzaFByZXNlbmNlKCkge1xuICAgICAgY29uc3QgeyB1c2VycyB9ID0gYXdhaXQgbGlzdE9ubGluZSgpO1xuICAgICAgY29uc3Qgb25saW5lID0gdXNlcnMubWFwKHUgPT4gKHUgYXMgYW55KS51c2VybmFtZSA/PyAodSBhcyBhbnkpLmlkKTtcbiAgICAgIHNldE9ubGluZVVzZXJzKG9ubGluZSk7XG4gICAgfVxuICAgIHJlZnJlc2hQcmVzZW5jZSgpO1xuICAgIGNvbnN0IGlkID0gc2V0SW50ZXJ2YWwocmVmcmVzaFByZXNlbmNlLCAxMF8wMDApO1xuICAgIHJldHVybiAoKSA9PiBjbGVhckludGVydmFsKGlkKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IHZpc2libGVPbmxpbmUgPSBvbmxpbmVVc2Vycy5maWx0ZXIodSA9PiB1ICE9PSBtZSk7XG4gIGNvbnN0IG9mZmxpbmVVc2VycyA9IGFsbFVzZXJzLmZpbHRlcih1ID0+IHUgIT09IG1lICYmICFvbmxpbmVVc2Vycy5pbmNsdWRlcyh1KSk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInAtNFwiPlxuICAgICAgPGgzIGNsYXNzTmFtZT1cImZvbnQtc2VtaWJvbGQgbWItMlwiPk9ubGluZTwvaDM+XG4gICAgICA8dWw+XG4gICAgICAgIHt2aXNpYmxlT25saW5lLm1hcCh1ID0+IChcbiAgICAgICAgICA8bGlcbiAgICAgICAgICAgIGtleT17dX1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17YGN1cnNvci1wb2ludGVyIHAtMSByb3VuZGVkICR7c2VsZWN0ZWQgPT09IHUgPyAnYmctYmx1ZS01MDAvMzAnIDogJyd9YH1cbiAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IG9uU2VsZWN0KHsgdXNlcm5hbWU6IHUsIG9ubGluZTogdHJ1ZSB9KX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICDwn5+iIEB7dX1cbiAgICAgICAgICA8L2xpPlxuICAgICAgICApKX1cbiAgICAgICAge3Zpc2libGVPbmxpbmUubGVuZ3RoID09PSAwICYmIChcbiAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwib3BhY2l0eS02MCB0ZXh0LXNtXCI+TmluZ3XDqW0gb25saW5lPC9saT5cbiAgICAgICAgKX1cbiAgICAgIDwvdWw+XG5cbiAgICAgIDxoMyBjbGFzc05hbWU9XCJmb250LXNlbWlib2xkIG10LTQgbWItMlwiPk9mZmxpbmU8L2gzPlxuICAgICAgPHVsIGNsYXNzTmFtZT1cIm9wYWNpdHktNjBcIj5cbiAgICAgICAge29mZmxpbmVVc2Vycy5tYXAodSA9PiAoXG4gICAgICAgICAgPGxpXG4gICAgICAgICAgICBrZXk9e3V9XG4gICAgICAgICAgICBjbGFzc05hbWU9e2BjdXJzb3ItcG9pbnRlciBwLTEgcm91bmRlZCAke3NlbGVjdGVkID09PSB1ID8gJ2JnLWdyYXktNTAwLzMwJyA6ICcnfWB9XG4gICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBvblNlbGVjdCh7IHVzZXJuYW1lOiB1LCBvbmxpbmU6IGZhbHNlIH0pfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIOKaqiBAe3V9XG4gICAgICAgICAgPC9saT5cbiAgICAgICAgKSl9XG4gICAgICA8L3VsPlxuICAgIDwvZGl2PlxuICApO1xufVxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVN0YXRlIiwibGlzdFVzZXJzIiwibGlzdE9ubGluZSIsIlVzZXJMaXN0IiwibWUiLCJzZWxlY3RlZCIsIm9uU2VsZWN0IiwiYWxsVXNlcnMiLCJzZXRBbGxVc2VycyIsIm9ubGluZVVzZXJzIiwic2V0T25saW5lVXNlcnMiLCJsb2FkQWxsIiwidXNlcnMiLCJsaXN0IiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwidSIsInVzZXJuYW1lIiwiZmlsdGVyIiwiQm9vbGVhbiIsInJlZnJlc2hQcmVzZW5jZSIsIm9ubGluZSIsImlkIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwidmlzaWJsZU9ubGluZSIsIm9mZmxpbmVVc2VycyIsImluY2x1ZGVzIiwiZGl2IiwiY2xhc3NOYW1lIiwiaDMiLCJ1bCIsImxpIiwib25DbGljayIsImxlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/UserList.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./hooks/useChat.ts":
/*!**************************!*\
  !*** ./hooks/useChat.ts ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChat: () => (/* binding */ useChat)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_nats__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/nats */ \"(app-pages-browser)/./lib/nats.ts\");\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/api */ \"(app-pages-browser)/./lib/api.ts\");\n/* __next_internal_client_entry_do_not_use__ useChat auto */ \n\n\nfunction useChat(me, peer) {\n    const [msgs, setMsgs] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const seen = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Set());\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        setMsgs([]);\n        seen.current.clear();\n    }, [\n        peer\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!me) return;\n        let sub;\n        (async ()=>{\n            sub = await (0,_lib_nats__WEBPACK_IMPORTED_MODULE_1__.subscribeJSON)(\"chat.direct.\".concat(me, \".*\"), (m)=>{\n                if (!peer || m.from !== peer && m.to !== peer) return;\n                const key = \"\".concat(m.from, \"-\").concat(m.to, \"-\").concat(m.ts);\n                if (!seen.current.has(key)) {\n                    seen.current.add(key);\n                    setMsgs((prev)=>[\n                            ...prev,\n                            m\n                        ]);\n                }\n            });\n        })();\n        return ()=>sub === null || sub === void 0 ? void 0 : sub.unsubscribe();\n    }, [\n        me,\n        peer\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!me || !peer) return;\n        (async ()=>{\n            const { msgs } = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.listHistory)(me, peer, 100);\n            setMsgs(msgs);\n            msgs.forEach((m)=>seen.current.add(\"\".concat(m.from, \"-\").concat(m.to, \"-\").concat(m.ts)));\n        })();\n    }, [\n        me,\n        peer\n    ]);\n    async function send(to, text) {\n        const msg = {\n            from: me,\n            to,\n            text,\n            ts: Date.now()\n        };\n        setMsgs((prev)=>[\n                ...prev,\n                msg\n            ]);\n        await (0,_lib_api__WEBPACK_IMPORTED_MODULE_2__.sendChat)(msg);\n    }\n    return {\n        msgs,\n        send\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZUNoYXQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7NkRBQ29EO0FBQ1Q7QUFDTztBQUkzQyxTQUFTTSxRQUFRQyxFQUFVLEVBQUVDLElBQWE7SUFDL0MsTUFBTSxDQUFDQyxNQUFNQyxRQUFRLEdBQUdSLCtDQUFRQSxDQUFZLEVBQUU7SUFDOUMsTUFBTVMsT0FBT1YsNkNBQU1BLENBQWMsSUFBSVc7SUFFckNaLGdEQUFTQSxDQUFDO1FBQ1JVLFFBQVEsRUFBRTtRQUNWQyxLQUFLRSxPQUFPLENBQUNDLEtBQUs7SUFDcEIsR0FBRztRQUFDTjtLQUFLO0lBRVRSLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSSxDQUFDTyxJQUFJO1FBQ1QsSUFBSVE7UUFDSDtZQUNDQSxNQUFNLE1BQU1aLHdEQUFhQSxDQUFVLGVBQWtCLE9BQUhJLElBQUcsT0FBSyxDQUFDUztnQkFDekQsSUFBSSxDQUFDUixRQUFTUSxFQUFFQyxJQUFJLEtBQUtULFFBQVFRLEVBQUVFLEVBQUUsS0FBS1YsTUFBTztnQkFDakQsTUFBTVcsTUFBTSxHQUFhSCxPQUFWQSxFQUFFQyxJQUFJLEVBQUMsS0FBV0QsT0FBUkEsRUFBRUUsRUFBRSxFQUFDLEtBQVEsT0FBTEYsRUFBRUksRUFBRTtnQkFDckMsSUFBSSxDQUFDVCxLQUFLRSxPQUFPLENBQUNRLEdBQUcsQ0FBQ0YsTUFBTTtvQkFDMUJSLEtBQUtFLE9BQU8sQ0FBQ1MsR0FBRyxDQUFDSDtvQkFDakJULFFBQVEsQ0FBQ2EsT0FBUzsrQkFBSUE7NEJBQU1QO3lCQUFFO2dCQUNoQztZQUNGO1FBQ0Y7UUFDQSxPQUFPLElBQU1ELGdCQUFBQSwwQkFBQUEsSUFBS1MsV0FBVztJQUMvQixHQUFHO1FBQUNqQjtRQUFJQztLQUFLO0lBRWJSLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSSxDQUFDTyxNQUFNLENBQUNDLE1BQU07UUFDakI7WUFDQyxNQUFNLEVBQUVDLElBQUksRUFBRSxHQUFHLE1BQU1KLHFEQUFXQSxDQUFDRSxJQUFJQyxNQUFNO1lBQzdDRSxRQUFRRDtZQUNSQSxLQUFLZ0IsT0FBTyxDQUFDLENBQUNULElBQU1MLEtBQUtFLE9BQU8sQ0FBQ1MsR0FBRyxDQUFDLEdBQWFOLE9BQVZBLEVBQUVDLElBQUksRUFBQyxLQUFXRCxPQUFSQSxFQUFFRSxFQUFFLEVBQUMsS0FBUSxPQUFMRixFQUFFSSxFQUFFO1FBQ2hFO0lBQ0YsR0FBRztRQUFDYjtRQUFJQztLQUFLO0lBRWIsZUFBZWtCLEtBQUtSLEVBQVUsRUFBRVMsSUFBWTtRQUMxQyxNQUFNQyxNQUFlO1lBQUVYLE1BQU1WO1lBQUlXO1lBQUlTO1lBQU1QLElBQUlTLEtBQUtDLEdBQUc7UUFBRztRQUMxRHBCLFFBQVEsQ0FBQ2EsT0FBUzttQkFBSUE7Z0JBQU1LO2FBQUk7UUFDaEMsTUFBTXhCLGtEQUFRQSxDQUFDd0I7SUFDakI7SUFFQSxPQUFPO1FBQUVuQjtRQUFNaUI7SUFBSztBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ob29rcy91c2VDaGF0LnRzP2MyZGIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgc3Vic2NyaWJlSlNPTiB9IGZyb20gJ0AvbGliL25hdHMnO1xuaW1wb3J0IHsgc2VuZENoYXQsIGxpc3RIaXN0b3J5IH0gZnJvbSAnQC9saWIvYXBpJztcblxuZXhwb3J0IHR5cGUgQ2hhdE1zZyA9IHsgZnJvbTogc3RyaW5nOyB0bzogc3RyaW5nOyB0ZXh0OiBzdHJpbmc7IHRzOiBudW1iZXIgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoYXQobWU6IHN0cmluZywgcGVlcj86IHN0cmluZykge1xuICBjb25zdCBbbXNncywgc2V0TXNnc10gPSB1c2VTdGF0ZTxDaGF0TXNnW10+KFtdKTtcbiAgY29uc3Qgc2VlbiA9IHVzZVJlZjxTZXQ8c3RyaW5nPj4obmV3IFNldCgpKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldE1zZ3MoW10pO1xuICAgIHNlZW4uY3VycmVudC5jbGVhcigpO1xuICB9LCBbcGVlcl0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFtZSkgcmV0dXJuO1xuICAgIGxldCBzdWI6IGFueTtcbiAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgc3ViID0gYXdhaXQgc3Vic2NyaWJlSlNPTjxDaGF0TXNnPihgY2hhdC5kaXJlY3QuJHttZX0uKmAsIChtKSA9PiB7XG4gICAgICAgIGlmICghcGVlciB8fCAobS5mcm9tICE9PSBwZWVyICYmIG0udG8gIT09IHBlZXIpKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGtleSA9IGAke20uZnJvbX0tJHttLnRvfS0ke20udHN9YDtcbiAgICAgICAgaWYgKCFzZWVuLmN1cnJlbnQuaGFzKGtleSkpIHtcbiAgICAgICAgICBzZWVuLmN1cnJlbnQuYWRkKGtleSk7XG4gICAgICAgICAgc2V0TXNncygocHJldikgPT4gWy4uLnByZXYsIG1dKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSkoKTtcbiAgICByZXR1cm4gKCkgPT4gc3ViPy51bnN1YnNjcmliZSgpO1xuICB9LCBbbWUsIHBlZXJdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWUgfHwgIXBlZXIpIHJldHVybjtcbiAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBtc2dzIH0gPSBhd2FpdCBsaXN0SGlzdG9yeShtZSwgcGVlciwgMTAwKTtcbiAgICAgIHNldE1zZ3MobXNncyk7XG4gICAgICBtc2dzLmZvckVhY2goKG0pID0+IHNlZW4uY3VycmVudC5hZGQoYCR7bS5mcm9tfS0ke20udG99LSR7bS50c31gKSk7XG4gICAgfSkoKTtcbiAgfSwgW21lLCBwZWVyXSk7XG5cbiAgYXN5bmMgZnVuY3Rpb24gc2VuZCh0bzogc3RyaW5nLCB0ZXh0OiBzdHJpbmcpIHtcbiAgICBjb25zdCBtc2c6IENoYXRNc2cgPSB7IGZyb206IG1lLCB0bywgdGV4dCwgdHM6IERhdGUubm93KCkgfTtcbiAgICBzZXRNc2dzKChwcmV2KSA9PiBbLi4ucHJldiwgbXNnXSk7XG4gICAgYXdhaXQgc2VuZENoYXQobXNnKTtcbiAgfVxuXG4gIHJldHVybiB7IG1zZ3MsIHNlbmQgfTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInN1YnNjcmliZUpTT04iLCJzZW5kQ2hhdCIsImxpc3RIaXN0b3J5IiwidXNlQ2hhdCIsIm1lIiwicGVlciIsIm1zZ3MiLCJzZXRNc2dzIiwic2VlbiIsIlNldCIsImN1cnJlbnQiLCJjbGVhciIsInN1YiIsIm0iLCJmcm9tIiwidG8iLCJrZXkiLCJ0cyIsImhhcyIsImFkZCIsInByZXYiLCJ1bnN1YnNjcmliZSIsImZvckVhY2giLCJzZW5kIiwidGV4dCIsIm1zZyIsIkRhdGUiLCJub3ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useChat.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   API_BASE: () => (/* binding */ API_BASE),\n/* harmony export */   listHistory: () => (/* binding */ listHistory),\n/* harmony export */   listOnline: () => (/* binding */ listOnline),\n/* harmony export */   listUsers: () => (/* binding */ listUsers),\n/* harmony export */   login: () => (/* binding */ login),\n/* harmony export */   register: () => (/* binding */ register),\n/* harmony export */   sendChat: () => (/* binding */ sendChat)\n/* harmony export */ });\nvar _process_env_NEXT_PUBLIC_API_BASE;\nconst API_BASE = (_process_env_NEXT_PUBLIC_API_BASE = \"http://localhost:4000/api\") !== null && _process_env_NEXT_PUBLIC_API_BASE !== void 0 ? _process_env_NEXT_PUBLIC_API_BASE : 'http://localhost:4000/api';\nasync function handle(res) {\n    const text = await res.text();\n    let body = null;\n    try {\n        body = text ? JSON.parse(text) : null;\n    } catch (e) {}\n    if (!res.ok) {\n        const msg = Array.isArray(body === null || body === void 0 ? void 0 : body.message) ? body.message.join(', ') : (body === null || body === void 0 ? void 0 : body.message) || (body === null || body === void 0 ? void 0 : body.error) || \"HTTP \".concat(res.status);\n        throw new Error(msg);\n    }\n    return body !== null && body !== void 0 ? body : {};\n}\nasync function login(input) {\n    const res = await fetch(\"\".concat(API_BASE, \"/auth/login\"), {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(input)\n    });\n    return handle(res);\n}\nasync function register(input) {\n    const res = await fetch(\"\".concat(API_BASE, \"/auth/register\"), {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(input)\n    });\n    return handle(res);\n}\nasync function listOnline() {\n    const res = await fetch(\"\".concat(API_BASE, \"/presence/online\"), {\n        cache: 'no-store'\n    });\n    return handle(res);\n}\nasync function sendChat(input) {\n    const res = await fetch(\"\".concat(API_BASE, \"/chat/send\"), {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(input)\n    });\n    return handle(res);\n}\nasync function listUsers() {\n    const res = await fetch(\"\".concat(API_BASE, \"/users\"), {\n        cache: 'no-store'\n    });\n    return handle(res);\n}\nasync function listHistory(a, b) {\n    let limit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 100;\n    const res = await fetch(\"\".concat(API_BASE, \"/chat/history/\").concat(a, \"/\").concat(b, \"?limit=\").concat(limit), {\n        cache: 'no-store'\n    });\n    return handle(res);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9hcGkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztJQUNFQTtBQURLLE1BQU1DLFdBQ1hELENBQUFBLG9DQUFBQSwyQkFBZ0MsY0FBaENBLCtDQUFBQSxvQ0FBb0MsNEJBQTRCO0FBRWxFLGVBQWVJLE9BQVVDLEdBQWE7SUFDcEMsTUFBTUMsT0FBTyxNQUFNRCxJQUFJQyxJQUFJO0lBQzNCLElBQUlDLE9BQVk7SUFDaEIsSUFBSTtRQUFFQSxPQUFPRCxPQUFPRSxLQUFLQyxLQUFLLENBQUNILFFBQVE7SUFBTSxFQUFFLFVBQU0sQ0FBQztJQUN0RCxJQUFJLENBQUNELElBQUlLLEVBQUUsRUFBRTtRQUNYLE1BQU1DLE1BQU1DLE1BQU1DLE9BQU8sQ0FBQ04saUJBQUFBLDJCQUFBQSxLQUFNTyxPQUFPLElBQ25DUCxLQUFLTyxPQUFPLENBQUNDLElBQUksQ0FBQyxRQUNsQlIsQ0FBQUEsaUJBQUFBLDJCQUFBQSxLQUFNTyxPQUFPLE1BQUlQLGlCQUFBQSwyQkFBQUEsS0FBTVMsS0FBSyxLQUFJLFFBQW1CLE9BQVhYLElBQUlZLE1BQU07UUFDdEQsTUFBTSxJQUFJQyxNQUFNUDtJQUNsQjtJQUNBLE9BQVFKLGlCQUFBQSxrQkFBQUEsT0FBUyxDQUFDO0FBQ3BCO0FBRU8sZUFBZVksTUFBTUMsS0FBNkM7SUFDdkUsTUFBTWYsTUFBTSxNQUFNZ0IsTUFBTSxHQUFZLE9BQVRwQixVQUFTLGdCQUFjO1FBQ2hEcUIsUUFBUTtRQUFRQyxTQUFTO1lBQUUsZ0JBQWdCO1FBQW1CO1FBQzlEaEIsTUFBTUMsS0FBS2dCLFNBQVMsQ0FBQ0o7SUFDdkI7SUFDQSxPQUFPaEIsT0FBMEJDO0FBQ25DO0FBRU8sZUFBZW9CLFNBQVNMLEtBRTlCO0lBQ0MsTUFBTWYsTUFBTSxNQUFNZ0IsTUFBTSxHQUFZLE9BQVRwQixVQUFTLG1CQUFpQjtRQUNuRHFCLFFBQVE7UUFBUUMsU0FBUztZQUFFLGdCQUFnQjtRQUFtQjtRQUM5RGhCLE1BQU1DLEtBQUtnQixTQUFTLENBQUNKO0lBQ3ZCO0lBQ0EsT0FBT2hCLE9BQTBCQztBQUNuQztBQUVPLGVBQWVxQjtJQUNwQixNQUFNckIsTUFBTSxNQUFNZ0IsTUFBTSxHQUFZLE9BQVRwQixVQUFTLHFCQUFtQjtRQUFFMEIsT0FBTztJQUFXO0lBQzNFLE9BQU92QixPQUEwRUM7QUFDbkY7QUFFTyxlQUFldUIsU0FBU1IsS0FBaUQ7SUFDOUUsTUFBTWYsTUFBTSxNQUFNZ0IsTUFBTSxHQUFZLE9BQVRwQixVQUFTLGVBQWE7UUFDL0NxQixRQUFRO1FBQVFDLFNBQVM7WUFBRSxnQkFBZ0I7UUFBbUI7UUFDOURoQixNQUFNQyxLQUFLZ0IsU0FBUyxDQUFDSjtJQUN2QjtJQUNBLE9BQU9oQixPQUFxQkM7QUFDOUI7QUFFTyxlQUFld0I7SUFDcEIsTUFBTXhCLE1BQU0sTUFBTWdCLE1BQU0sR0FBWSxPQUFUcEIsVUFBUyxXQUFTO1FBQUUwQixPQUFPO0lBQVc7SUFDakUsT0FBT3ZCLE9BQXFEQztBQUM5RDtBQUVPLGVBQWV5QixZQUFZQyxDQUFTLEVBQUVDLENBQVM7UUFBRUMsUUFBQUEsaUVBQVE7SUFDOUQsTUFBTTVCLE1BQU0sTUFBTWdCLE1BQU0sR0FBNEJVLE9BQXpCOUIsVUFBUyxrQkFBcUIrQixPQUFMRCxHQUFFLEtBQWNFLE9BQVhELEdBQUUsV0FBZSxPQUFOQyxRQUFTO1FBQzNFTixPQUFPO0lBQ1Q7SUFDQSxPQUFPdkIsT0FBMkVDO0FBQ3BGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9hcGkudHM/NjhhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgQVBJX0JBU0UgPVxuICBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfQkFTRSA/PyAnaHR0cDovL2xvY2FsaG9zdDo0MDAwL2FwaSc7XG5cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZTxUPihyZXM6IFJlc3BvbnNlKTogUHJvbWlzZTxUPiB7XG4gIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICBsZXQgYm9keTogYW55ID0gbnVsbDtcbiAgdHJ5IHsgYm9keSA9IHRleHQgPyBKU09OLnBhcnNlKHRleHQpIDogbnVsbDsgfSBjYXRjaCB7fVxuICBpZiAoIXJlcy5vaykge1xuICAgIGNvbnN0IG1zZyA9IEFycmF5LmlzQXJyYXkoYm9keT8ubWVzc2FnZSlcbiAgICAgID8gYm9keS5tZXNzYWdlLmpvaW4oJywgJylcbiAgICAgIDogYm9keT8ubWVzc2FnZSB8fCBib2R5Py5lcnJvciB8fCBgSFRUUCAke3Jlcy5zdGF0dXN9YDtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgfVxuICByZXR1cm4gKGJvZHkgPz8gKHt9IGFzIGFueSkpIGFzIFQ7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2dpbihpbnB1dDogeyB1c2VybmFtZTogc3RyaW5nOyBwYXNzd29yZDogc3RyaW5nIH0pIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0V9L2F1dGgvbG9naW5gLCB7XG4gICAgbWV0aG9kOiAnUE9TVCcsIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGlucHV0KSxcbiAgfSk7XG4gIHJldHVybiBoYW5kbGU8eyB0b2tlbjogc3RyaW5nIH0+KHJlcyk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWdpc3RlcihpbnB1dDoge1xuICBuYW1lOiBzdHJpbmc7IHVzZXJuYW1lOiBzdHJpbmc7IGVtYWlsOiBzdHJpbmc7IHBhc3N3b3JkOiBzdHJpbmc7XG59KSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFfS9hdXRoL3JlZ2lzdGVyYCwge1xuICAgIG1ldGhvZDogJ1BPU1QnLCBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeShpbnB1dCksXG4gIH0pO1xuICByZXR1cm4gaGFuZGxlPHsgdG9rZW46IHN0cmluZyB9PihyZXMpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbGlzdE9ubGluZSgpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0V9L3ByZXNlbmNlL29ubGluZWAsIHsgY2FjaGU6ICduby1zdG9yZScgfSk7XG4gIHJldHVybiBoYW5kbGU8eyB1c2VyczogeyBpZD86IHN0cmluZzsgdXNlcm5hbWU/OiBzdHJpbmc7IGxhc3RTZWVuOiBudW1iZXIgfVtdIH0+KHJlcyk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZW5kQ2hhdChpbnB1dDogeyBmcm9tOiBzdHJpbmc7IHRvOiBzdHJpbmc7IHRleHQ6IHN0cmluZyB9KSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFfS9jaGF0L3NlbmRgLCB7XG4gICAgbWV0aG9kOiAnUE9TVCcsIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGlucHV0KSxcbiAgfSk7XG4gIHJldHVybiBoYW5kbGU8eyBvazogdHJ1ZSB9PihyZXMpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbGlzdFVzZXJzKCkge1xuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRX0vdXNlcnNgLCB7IGNhY2hlOiAnbm8tc3RvcmUnIH0pO1xuICByZXR1cm4gaGFuZGxlPHsgdXNlcnM6IHsgdXNlcm5hbWU6IHN0cmluZyB9W10gfCBzdHJpbmdbXSB9PihyZXMpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbGlzdEhpc3RvcnkoYTogc3RyaW5nLCBiOiBzdHJpbmcsIGxpbWl0ID0gMTAwKSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFfS9jaGF0L2hpc3RvcnkvJHthfS8ke2J9P2xpbWl0PSR7bGltaXR9YCwge1xuICAgIGNhY2hlOiAnbm8tc3RvcmUnLFxuICB9KTtcbiAgcmV0dXJuIGhhbmRsZTx7IG1zZ3M6IHsgZnJvbTogc3RyaW5nOyB0bzogc3RyaW5nOyB0ZXh0OiBzdHJpbmc7IHRzOiBudW1iZXIgfVtdIH0+KHJlcyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIkFQSV9CQVNFIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX0JBU0UiLCJoYW5kbGUiLCJyZXMiLCJ0ZXh0IiwiYm9keSIsIkpTT04iLCJwYXJzZSIsIm9rIiwibXNnIiwiQXJyYXkiLCJpc0FycmF5IiwibWVzc2FnZSIsImpvaW4iLCJlcnJvciIsInN0YXR1cyIsIkVycm9yIiwibG9naW4iLCJpbnB1dCIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsInN0cmluZ2lmeSIsInJlZ2lzdGVyIiwibGlzdE9ubGluZSIsImNhY2hlIiwic2VuZENoYXQiLCJsaXN0VXNlcnMiLCJsaXN0SGlzdG9yeSIsImEiLCJiIiwibGltaXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/nats.ts":
/*!*********************!*\
  !*** ./lib/nats.ts ***!
  \*********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getNats: () => (/* binding */ getNats),\n/* harmony export */   publishJSON: () => (/* binding */ publishJSON),\n/* harmony export */   subscribeJSON: () => (/* binding */ subscribeJSON)\n/* harmony export */ });\n/* harmony import */ var nats_ws__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nats.ws */ \"(app-pages-browser)/./node_modules/nats.ws/esm/nats.js\");\n\nconst sc = (0,nats_ws__WEBPACK_IMPORTED_MODULE_0__.StringCodec)();\nlet promise = null;\nfunction getNats() {\n    if (!promise) {\n        const servers = \"ws://localhost:9222\" || 0;\n        promise = (0,nats_ws__WEBPACK_IMPORTED_MODULE_0__.connect)({\n            servers\n        });\n    }\n    return promise;\n}\nasync function publishJSON(subject, payload) {\n    const nc = await getNats();\n    nc.publish(subject, sc.encode(JSON.stringify(payload)));\n}\nasync function subscribeJSON(subject, handler) {\n    const nc = await getNats();\n    const sub = nc.subscribe(subject);\n    (async ()=>{\n        for await (const m of sub){\n            try {\n                handler(JSON.parse(sc.decode(m.data)));\n            } catch (e) {}\n        }\n    })();\n    return sub;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9uYXRzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNkU7QUFFN0UsTUFBTUUsS0FBS0Qsb0RBQVdBO0FBQ3RCLElBQUlFLFVBQTBDO0FBRXZDLFNBQVNDO0lBQ2QsSUFBSSxDQUFDRCxTQUFTO1FBQ1osTUFBTUUsVUFDSkMscUJBQW1DLElBQUksQ0FBcUI7UUFDOURILFVBQVVILGdEQUFPQSxDQUFDO1lBQUVLO1FBQVE7SUFDOUI7SUFDQSxPQUFPRjtBQUNUO0FBRU8sZUFBZU0sWUFBWUMsT0FBZSxFQUFFQyxPQUFnQjtJQUNqRSxNQUFNQyxLQUFLLE1BQU1SO0lBQ2pCUSxHQUFHQyxPQUFPLENBQUNILFNBQVNSLEdBQUdZLE1BQU0sQ0FBQ0MsS0FBS0MsU0FBUyxDQUFDTDtBQUMvQztBQUVPLGVBQWVNLGNBQ3BCUCxPQUFlLEVBQ2ZRLE9BQTBCO0lBRTFCLE1BQU1OLEtBQUssTUFBTVI7SUFDakIsTUFBTWUsTUFBTVAsR0FBR1EsU0FBUyxDQUFDVjtJQUN4QjtRQUNDLFdBQVcsTUFBTVcsS0FBS0YsSUFBSztZQUN6QixJQUFJO2dCQUFFRCxRQUFRSCxLQUFLTyxLQUFLLENBQUNwQixHQUFHcUIsTUFBTSxDQUFDRixFQUFFRyxJQUFJO1lBQUssRUFBRSxVQUFNLENBQUM7UUFDekQ7SUFDRjtJQUNBLE9BQU9MO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL25hdHMudHM/MmE5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb25uZWN0LCBOYXRzQ29ubmVjdGlvbiwgU3RyaW5nQ29kZWMsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ25hdHMud3MnO1xuXG5jb25zdCBzYyA9IFN0cmluZ0NvZGVjKCk7XG5sZXQgcHJvbWlzZTogUHJvbWlzZTxOYXRzQ29ubmVjdGlvbj4gfCBudWxsID0gbnVsbDtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE5hdHMoKTogUHJvbWlzZTxOYXRzQ29ubmVjdGlvbj4ge1xuICBpZiAoIXByb21pc2UpIHtcbiAgICBjb25zdCBzZXJ2ZXJzID1cbiAgICAgIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX05BVFNfV1NfVVJMIHx8ICd3czovL2xvY2FsaG9zdDo5MjIyJztcbiAgICBwcm9taXNlID0gY29ubmVjdCh7IHNlcnZlcnMgfSk7XG4gIH1cbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwdWJsaXNoSlNPTihzdWJqZWN0OiBzdHJpbmcsIHBheWxvYWQ6IHVua25vd24pIHtcbiAgY29uc3QgbmMgPSBhd2FpdCBnZXROYXRzKCk7XG4gIG5jLnB1Ymxpc2goc3ViamVjdCwgc2MuZW5jb2RlKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdWJzY3JpYmVKU09OPFQgPSBhbnk+KFxuICBzdWJqZWN0OiBzdHJpbmcsXG4gIGhhbmRsZXI6IChkYXRhOiBUKSA9PiB2b2lkLFxuKTogUHJvbWlzZTxTdWJzY3JpcHRpb24+IHtcbiAgY29uc3QgbmMgPSBhd2FpdCBnZXROYXRzKCk7XG4gIGNvbnN0IHN1YiA9IG5jLnN1YnNjcmliZShzdWJqZWN0KTtcbiAgKGFzeW5jICgpID0+IHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IG0gb2Ygc3ViKSB7XG4gICAgICB0cnkgeyBoYW5kbGVyKEpTT04ucGFyc2Uoc2MuZGVjb2RlKG0uZGF0YSkpKTsgfSBjYXRjaCB7fVxuICAgIH1cbiAgfSkoKTtcbiAgcmV0dXJuIHN1Yjtcbn1cbiJdLCJuYW1lcyI6WyJjb25uZWN0IiwiU3RyaW5nQ29kZWMiLCJzYyIsInByb21pc2UiLCJnZXROYXRzIiwic2VydmVycyIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19OQVRTX1dTX1VSTCIsInB1Ymxpc2hKU09OIiwic3ViamVjdCIsInBheWxvYWQiLCJuYyIsInB1Ymxpc2giLCJlbmNvZGUiLCJKU09OIiwic3RyaW5naWZ5Iiwic3Vic2NyaWJlSlNPTiIsImhhbmRsZXIiLCJzdWIiLCJzdWJzY3JpYmUiLCJtIiwicGFyc2UiLCJkZWNvZGUiLCJkYXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/nats.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/presence.ts":
/*!*************************!*\
  !*** ./lib/presence.ts ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   startPresenceHeartbeat: () => (/* binding */ startPresenceHeartbeat),\n/* harmony export */   stopPresenceHeartbeat: () => (/* binding */ stopPresenceHeartbeat)\n/* harmony export */ });\n/* harmony import */ var _nats__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nats */ \"(app-pages-browser)/./lib/nats.ts\");\n\nlet timer;\nfunction startPresenceHeartbeat(userId) {\n    stopPresenceHeartbeat();\n    const beat = ()=>(0,_nats__WEBPACK_IMPORTED_MODULE_0__.publishJSON)(\"presence.heartbeat.\".concat(userId), {\n            t: Date.now()\n        });\n    beat();\n    timer = setInterval(beat, 10000);\n}\nfunction stopPresenceHeartbeat() {\n    if (timer) clearInterval(timer);\n    timer = null;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9wcmVzZW5jZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUM7QUFFckMsSUFBSUM7QUFFRyxTQUFTQyx1QkFBdUJDLE1BQWM7SUFDbkRDO0lBQ0EsTUFBTUMsT0FBTyxJQUFNTCxrREFBV0EsQ0FBQyxzQkFBNkIsT0FBUEcsU0FBVTtZQUFFRyxHQUFHQyxLQUFLQyxHQUFHO1FBQUc7SUFDL0VIO0lBQ0FKLFFBQVFRLFlBQVlKLE1BQU07QUFDNUI7QUFFTyxTQUFTRDtJQUNkLElBQUlILE9BQU9TLGNBQWNUO0lBQ3pCQSxRQUFRO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3ByZXNlbmNlLnRzP2EyMTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcHVibGlzaEpTT04gfSBmcm9tICcuL25hdHMnO1xuXG5sZXQgdGltZXI6IGFueTtcblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0UHJlc2VuY2VIZWFydGJlYXQodXNlcklkOiBzdHJpbmcpIHtcbiAgc3RvcFByZXNlbmNlSGVhcnRiZWF0KCk7XG4gIGNvbnN0IGJlYXQgPSAoKSA9PiBwdWJsaXNoSlNPTihgcHJlc2VuY2UuaGVhcnRiZWF0LiR7dXNlcklkfWAsIHsgdDogRGF0ZS5ub3coKSB9KTtcbiAgYmVhdCgpO1xuICB0aW1lciA9IHNldEludGVydmFsKGJlYXQsIDEwXzAwMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdG9wUHJlc2VuY2VIZWFydGJlYXQoKSB7XG4gIGlmICh0aW1lcikgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gIHRpbWVyID0gbnVsbDtcbn1cbiJdLCJuYW1lcyI6WyJwdWJsaXNoSlNPTiIsInRpbWVyIiwic3RhcnRQcmVzZW5jZUhlYXJ0YmVhdCIsInVzZXJJZCIsInN0b3BQcmVzZW5jZUhlYXJ0YmVhdCIsImJlYXQiLCJ0IiwiRGF0ZSIsIm5vdyIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/presence.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE$2\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PORTAL_TYPE:\n          return \"Portal\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function disabledLog() {}\n    function disableLogs() {\n      if (0 === disabledDepth) {\n        prevLog = console.log;\n        prevInfo = console.info;\n        prevWarn = console.warn;\n        prevError = console.error;\n        prevGroup = console.group;\n        prevGroupCollapsed = console.groupCollapsed;\n        prevGroupEnd = console.groupEnd;\n        var props = {\n          configurable: !0,\n          enumerable: !0,\n          value: disabledLog,\n          writable: !0\n        };\n        Object.defineProperties(console, {\n          info: props,\n          log: props,\n          warn: props,\n          error: props,\n          group: props,\n          groupCollapsed: props,\n          groupEnd: props\n        });\n      }\n      disabledDepth++;\n    }\n    function reenableLogs() {\n      disabledDepth--;\n      if (0 === disabledDepth) {\n        var props = { configurable: !0, enumerable: !0, writable: !0 };\n        Object.defineProperties(console, {\n          log: assign({}, props, { value: prevLog }),\n          info: assign({}, props, { value: prevInfo }),\n          warn: assign({}, props, { value: prevWarn }),\n          error: assign({}, props, { value: prevError }),\n          group: assign({}, props, { value: prevGroup }),\n          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),\n          groupEnd: assign({}, props, { value: prevGroupEnd })\n        });\n      }\n      0 > disabledDepth &&\n        console.error(\n          \"disabledDepth fell below zero. This is a bug in React. Please file an issue.\"\n        );\n    }\n    function describeBuiltInComponentFrame(name) {\n      if (void 0 === prefix)\n        try {\n          throw Error();\n        } catch (x) {\n          var match = x.stack.trim().match(/\\n( *(at )?)/);\n          prefix = (match && match[1]) || \"\";\n          suffix =\n            -1 < x.stack.indexOf(\"\\n    at\")\n              ? \" (<anonymous>)\"\n              : -1 < x.stack.indexOf(\"@\")\n                ? \"@unknown:0:0\"\n                : \"\";\n        }\n      return \"\\n\" + prefix + name + suffix;\n    }\n    function describeNativeComponentFrame(fn, construct) {\n      if (!fn || reentry) return \"\";\n      var frame = componentFrameCache.get(fn);\n      if (void 0 !== frame) return frame;\n      reentry = !0;\n      frame = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var previousDispatcher = null;\n      previousDispatcher = ReactSharedInternals.H;\n      ReactSharedInternals.H = null;\n      disableLogs();\n      try {\n        var RunInRootFrame = {\n          DetermineComponentFrameRoot: function () {\n            try {\n              if (construct) {\n                var Fake = function () {\n                  throw Error();\n                };\n                Object.defineProperty(Fake.prototype, \"props\", {\n                  set: function () {\n                    throw Error();\n                  }\n                });\n                if (\"object\" === typeof Reflect && Reflect.construct) {\n                  try {\n                    Reflect.construct(Fake, []);\n                  } catch (x) {\n                    var control = x;\n                  }\n                  Reflect.construct(fn, [], Fake);\n                } else {\n                  try {\n                    Fake.call();\n                  } catch (x$0) {\n                    control = x$0;\n                  }\n                  fn.call(Fake.prototype);\n                }\n              } else {\n                try {\n                  throw Error();\n                } catch (x$1) {\n                  control = x$1;\n                }\n                (Fake = fn()) &&\n                  \"function\" === typeof Fake.catch &&\n                  Fake.catch(function () {});\n              }\n            } catch (sample) {\n              if (sample && control && \"string\" === typeof sample.stack)\n                return [sample.stack, control.stack];\n            }\n            return [null, null];\n          }\n        };\n        RunInRootFrame.DetermineComponentFrameRoot.displayName =\n          \"DetermineComponentFrameRoot\";\n        var namePropDescriptor = Object.getOwnPropertyDescriptor(\n          RunInRootFrame.DetermineComponentFrameRoot,\n          \"name\"\n        );\n        namePropDescriptor &&\n          namePropDescriptor.configurable &&\n          Object.defineProperty(\n            RunInRootFrame.DetermineComponentFrameRoot,\n            \"name\",\n            { value: \"DetermineComponentFrameRoot\" }\n          );\n        var _RunInRootFrame$Deter =\n            RunInRootFrame.DetermineComponentFrameRoot(),\n          sampleStack = _RunInRootFrame$Deter[0],\n          controlStack = _RunInRootFrame$Deter[1];\n        if (sampleStack && controlStack) {\n          var sampleLines = sampleStack.split(\"\\n\"),\n            controlLines = controlStack.split(\"\\n\");\n          for (\n            _RunInRootFrame$Deter = namePropDescriptor = 0;\n            namePropDescriptor < sampleLines.length &&\n            !sampleLines[namePropDescriptor].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            namePropDescriptor++;\n          for (\n            ;\n            _RunInRootFrame$Deter < controlLines.length &&\n            !controlLines[_RunInRootFrame$Deter].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            _RunInRootFrame$Deter++;\n          if (\n            namePropDescriptor === sampleLines.length ||\n            _RunInRootFrame$Deter === controlLines.length\n          )\n            for (\n              namePropDescriptor = sampleLines.length - 1,\n                _RunInRootFrame$Deter = controlLines.length - 1;\n              1 <= namePropDescriptor &&\n              0 <= _RunInRootFrame$Deter &&\n              sampleLines[namePropDescriptor] !==\n                controlLines[_RunInRootFrame$Deter];\n\n            )\n              _RunInRootFrame$Deter--;\n          for (\n            ;\n            1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter;\n            namePropDescriptor--, _RunInRootFrame$Deter--\n          )\n            if (\n              sampleLines[namePropDescriptor] !==\n              controlLines[_RunInRootFrame$Deter]\n            ) {\n              if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {\n                do\n                  if (\n                    (namePropDescriptor--,\n                    _RunInRootFrame$Deter--,\n                    0 > _RunInRootFrame$Deter ||\n                      sampleLines[namePropDescriptor] !==\n                        controlLines[_RunInRootFrame$Deter])\n                  ) {\n                    var _frame =\n                      \"\\n\" +\n                      sampleLines[namePropDescriptor].replace(\n                        \" at new \",\n                        \" at \"\n                      );\n                    fn.displayName &&\n                      _frame.includes(\"<anonymous>\") &&\n                      (_frame = _frame.replace(\"<anonymous>\", fn.displayName));\n                    \"function\" === typeof fn &&\n                      componentFrameCache.set(fn, _frame);\n                    return _frame;\n                  }\n                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);\n              }\n              break;\n            }\n        }\n      } finally {\n        (reentry = !1),\n          (ReactSharedInternals.H = previousDispatcher),\n          reenableLogs(),\n          (Error.prepareStackTrace = frame);\n      }\n      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : \"\")\n        ? describeBuiltInComponentFrame(sampleLines)\n        : \"\";\n      \"function\" === typeof fn && componentFrameCache.set(fn, sampleLines);\n      return sampleLines;\n    }\n    function describeUnknownElementTypeFrameInDEV(type) {\n      if (null == type) return \"\";\n      if (\"function\" === typeof type) {\n        var prototype = type.prototype;\n        return describeNativeComponentFrame(\n          type,\n          !(!prototype || !prototype.isReactComponent)\n        );\n      }\n      if (\"string\" === typeof type) return describeBuiltInComponentFrame(type);\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame(\"Suspense\");\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame(\"SuspenseList\");\n      }\n      if (\"object\" === typeof type)\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return (type = describeNativeComponentFrame(type.render, !1)), type;\n          case REACT_MEMO_TYPE:\n            return describeUnknownElementTypeFrameInDEV(type.type);\n          case REACT_LAZY_TYPE:\n            prototype = type._payload;\n            type = type._init;\n            try {\n              return describeUnknownElementTypeFrameInDEV(type(prototype));\n            } catch (x) {}\n        }\n      return \"\";\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function hasValidRef(config) {\n      if (hasOwnProperty.call(config, \"ref\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.ref;\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(type, key, _ref, self, source, owner, props) {\n      _ref = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== _ref ? _ref : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      if (\n        \"string\" === typeof type ||\n        \"function\" === typeof type ||\n        type === REACT_FRAGMENT_TYPE ||\n        type === REACT_PROFILER_TYPE ||\n        type === REACT_STRICT_MODE_TYPE ||\n        type === REACT_SUSPENSE_TYPE ||\n        type === REACT_SUSPENSE_LIST_TYPE ||\n        type === REACT_OFFSCREEN_TYPE ||\n        (\"object\" === typeof type &&\n          null !== type &&\n          (type.$$typeof === REACT_LAZY_TYPE ||\n            type.$$typeof === REACT_MEMO_TYPE ||\n            type.$$typeof === REACT_CONTEXT_TYPE ||\n            type.$$typeof === REACT_CONSUMER_TYPE ||\n            type.$$typeof === REACT_FORWARD_REF_TYPE ||\n            type.$$typeof === REACT_CLIENT_REFERENCE$1 ||\n            void 0 !== type.getModuleId))\n      ) {\n        var children = config.children;\n        if (void 0 !== children)\n          if (isStaticChildren)\n            if (isArrayImpl(children)) {\n              for (\n                isStaticChildren = 0;\n                isStaticChildren < children.length;\n                isStaticChildren++\n              )\n                validateChildKeys(children[isStaticChildren], type);\n              Object.freeze && Object.freeze(children);\n            } else\n              console.error(\n                \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n              );\n          else validateChildKeys(children, type);\n      } else {\n        children = \"\";\n        if (\n          void 0 === type ||\n          (\"object\" === typeof type &&\n            null !== type &&\n            0 === Object.keys(type).length)\n        )\n          children +=\n            \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n        null === type\n          ? (isStaticChildren = \"null\")\n          : isArrayImpl(type)\n            ? (isStaticChildren = \"array\")\n            : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE\n              ? ((isStaticChildren =\n                  \"<\" +\n                  (getComponentNameFromType(type.type) || \"Unknown\") +\n                  \" />\"),\n                (children =\n                  \" Did you accidentally export a JSX literal instead of a component?\"))\n              : (isStaticChildren = typeof type);\n        console.error(\n          \"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\",\n          isStaticChildren,\n          children\n        );\n      }\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      hasValidRef(config);\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        ((config =\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type),\n        children && defineKeyPropWarningGetter(maybeKey, config));\n      return ReactElement(\n        type,\n        children,\n        null,\n        self,\n        source,\n        getOwner(),\n        maybeKey\n      );\n    }\n    function validateChildKeys(node, parentType) {\n      if (\n        \"object\" === typeof node &&\n        node &&\n        node.$$typeof !== REACT_CLIENT_REFERENCE\n      )\n        if (isArrayImpl(node))\n          for (var i = 0; i < node.length; i++) {\n            var child = node[i];\n            isValidElement(child) && validateExplicitKey(child, parentType);\n          }\n        else if (isValidElement(node))\n          node._store && (node._store.validated = 1);\n        else if (\n          (null === node || \"object\" !== typeof node\n            ? (i = null)\n            : ((i =\n                (MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL]) ||\n                node[\"@@iterator\"]),\n              (i = \"function\" === typeof i ? i : null)),\n          \"function\" === typeof i &&\n            i !== node.entries &&\n            ((i = i.call(node)), i !== node))\n        )\n          for (; !(node = i.next()).done; )\n            isValidElement(node.value) &&\n              validateExplicitKey(node.value, parentType);\n    }\n    function isValidElement(object) {\n      return (\n        \"object\" === typeof object &&\n        null !== object &&\n        object.$$typeof === REACT_ELEMENT_TYPE\n      );\n    }\n    function validateExplicitKey(element, parentType) {\n      if (\n        element._store &&\n        !element._store.validated &&\n        null == element.key &&\n        ((element._store.validated = 1),\n        (parentType = getCurrentComponentErrorInfo(parentType)),\n        !ownerHasKeyUseWarning[parentType])\n      ) {\n        ownerHasKeyUseWarning[parentType] = !0;\n        var childOwner = \"\";\n        element &&\n          null != element._owner &&\n          element._owner !== getOwner() &&\n          ((childOwner = null),\n          \"number\" === typeof element._owner.tag\n            ? (childOwner = getComponentNameFromType(element._owner.type))\n            : \"string\" === typeof element._owner.name &&\n              (childOwner = element._owner.name),\n          (childOwner = \" It was passed a child from \" + childOwner + \".\"));\n        var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;\n        ReactSharedInternals.getCurrentStack = function () {\n          var stack = describeUnknownElementTypeFrameInDEV(element.type);\n          prevGetCurrentStack && (stack += prevGetCurrentStack() || \"\");\n          return stack;\n        };\n        console.error(\n          'Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.',\n          parentType,\n          childOwner\n        );\n        ReactSharedInternals.getCurrentStack = prevGetCurrentStack;\n      }\n    }\n    function getCurrentComponentErrorInfo(parentType) {\n      var info = \"\",\n        owner = getOwner();\n      owner &&\n        (owner = getComponentNameFromType(owner.type)) &&\n        (info = \"\\n\\nCheck the render method of `\" + owner + \"`.\");\n      info ||\n        ((parentType = getComponentNameFromType(parentType)) &&\n          (info =\n            \"\\n\\nCheck the top-level render call using <\" + parentType + \">.\"));\n      return info;\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n    Symbol.for(\"react.provider\");\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\"),\n      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,\n      REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      assign = Object.assign,\n      REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"),\n      isArrayImpl = Array.isArray,\n      disabledDepth = 0,\n      prevLog,\n      prevInfo,\n      prevWarn,\n      prevError,\n      prevGroup,\n      prevGroupCollapsed,\n      prevGroupEnd;\n    disabledLog.__reactDisabledLog = !0;\n    var prefix,\n      suffix,\n      reentry = !1;\n    var componentFrameCache = new (\n      \"function\" === typeof WeakMap ? WeakMap : Map\n    )();\n    var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var didWarnAboutKeySpread = {},\n      ownerHasKeyUseWarning = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self);\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHdCQUF3QixXQUFXLGdCQUFnQjtBQUNuRCx5QkFBeUIsV0FBVyxpQkFBaUI7QUFDckQseUJBQXlCLFdBQVcsaUJBQWlCO0FBQ3JELDBCQUEwQixXQUFXLGtCQUFrQjtBQUN2RCwwQkFBMEIsV0FBVyxrQkFBa0I7QUFDdkQsbUNBQW1DLFdBQVcsMkJBQTJCO0FBQ3pFLDZCQUE2QixXQUFXLHFCQUFxQjtBQUM3RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCwrQ0FBK0MsNkJBQTZCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdCQUFnQixnREFBZ0Q7QUFDaEUsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBLGdDQUFnQyxrQ0FBa0MsT0FBTztBQUN6RTtBQUNBLGdHQUFnRyxTQUFTLFVBQVUsc0ZBQXNGLGFBQWEsVUFBVSxVQUFVO0FBQzFPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzR0FBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQixJQUFJLGNBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/NWJkZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDJcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgIChcIm51bWJlclwiID09PSB0eXBlb2YgdHlwZS50YWcgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB0eXBlLiQkdHlwZW9mKVxuICAgICAgICApIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fFxuICAgICAgICAgICAgICAoKHR5cGUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpbm5lclR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBjb25zb2xlO1xuICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmVycm9yO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID1cbiAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICAgIFwiT2JqZWN0XCI7XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdC5jYWxsKFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG4gICAgZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gICAgICBpZiAoMCA9PT0gZGlzYWJsZWREZXB0aCkge1xuICAgICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkaXNhYmxlZERlcHRoKys7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAgICAgIGRpc2FibGVkRGVwdGgtLTtcbiAgICAgIGlmICgwID09PSBkaXNhYmxlZERlcHRoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHsgY29uZmlndXJhYmxlOiAhMCwgZW51bWVyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2TG9nIH0pLFxuICAgICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZJbmZvIH0pLFxuICAgICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZXYXJuIH0pLFxuICAgICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2RXJyb3IgfSksXG4gICAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cCB9KSxcbiAgICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkIH0pLFxuICAgICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXBFbmQgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAwID4gZGlzYWJsZWREZXB0aCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIHtcbiAgICAgIGlmICh2b2lkIDAgPT09IHByZWZpeClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgICBwcmVmaXggPSAobWF0Y2ggJiYgbWF0Y2hbMV0pIHx8IFwiXCI7XG4gICAgICAgICAgc3VmZml4ID1cbiAgICAgICAgICAgIC0xIDwgeC5zdGFjay5pbmRleE9mKFwiXFxuICAgIGF0XCIpXG4gICAgICAgICAgICAgID8gXCIgKDxhbm9ueW1vdXM+KVwiXG4gICAgICAgICAgICAgIDogLTEgPCB4LnN0YWNrLmluZGV4T2YoXCJAXCIpXG4gICAgICAgICAgICAgICAgPyBcIkB1bmtub3duOjA6MFwiXG4gICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcXG5cIiArIHByZWZpeCArIG5hbWUgKyBzdWZmaXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAgICAgaWYgKCFmbiB8fCByZWVudHJ5KSByZXR1cm4gXCJcIjtcbiAgICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcbiAgICAgIGlmICh2b2lkIDAgIT09IGZyYW1lKSByZXR1cm4gZnJhbWU7XG4gICAgICByZWVudHJ5ID0gITA7XG4gICAgICBmcmFtZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gICAgICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyID0gbnVsbDtcbiAgICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gbnVsbDtcbiAgICAgIGRpc2FibGVMb2dzKCk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgICAgICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCBcInByb3BzXCIsIHtcbiAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgUmVmbGVjdCAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbCA9IHg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sID0geCQwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMSkge1xuICAgICAgICAgICAgICAgICAgY29udHJvbCA9IHgkMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKEZha2UgPSBmbigpKSAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgRmFrZS5jYXRjaCAmJlxuICAgICAgICAgICAgICAgICAgRmFrZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAgICAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNhbXBsZS5zdGFjaylcbiAgICAgICAgICAgICAgICByZXR1cm4gW3NhbXBsZS5zdGFjaywgY29udHJvbC5zdGFja107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID1cbiAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiO1xuICAgICAgICB2YXIgbmFtZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsXG4gICAgICAgICAgXCJuYW1lXCJcbiAgICAgICAgKTtcbiAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSAmJlxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgICAgICAgIFwibmFtZVwiLFxuICAgICAgICAgICAgeyB2YWx1ZTogXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIiB9XG4gICAgICAgICAgKTtcbiAgICAgICAgdmFyIF9SdW5JblJvb3RGcmFtZSREZXRlciA9XG4gICAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgICBzYW1wbGVTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclswXSxcbiAgICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG4gICAgICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdChcIlxcblwiKSxcbiAgICAgICAgICAgIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2xTdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gbmFtZVByb3BEZXNjcmlwdG9yID0gMDtcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIXNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IrKztcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIWNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdLmluY2x1ZGVzKFxuICAgICAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyKys7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHxcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9PT0gY29udHJvbExpbmVzLmxlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgICAgIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyICYmXG4gICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl07XG5cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyLS07XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyO1xuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLS0sIF9SdW5JblJvb3RGcmFtZSREZXRlci0tXG4gICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmICgxICE9PSBuYW1lUHJvcERlc2NyaXB0b3IgfHwgMSAhPT0gX1J1bkluUm9vdEZyYW1lJERldGVyKSB7XG4gICAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKG5hbWVQcm9wRGVzY3JpcHRvci0tLFxuICAgICAgICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLSxcbiAgICAgICAgICAgICAgICAgICAgMCA+IF9SdW5JblJvb3RGcmFtZSREZXRlciB8fFxuICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXSlcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID1cbiAgICAgICAgICAgICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBuZXcgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBcIlxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGZuLmRpc3BsYXlOYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgX2ZyYW1lLmluY2x1ZGVzKFwiPGFub255bW91cz5cIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoXCI8YW5vbnltb3VzPlwiLCBmbi5kaXNwbGF5TmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmbiAmJlxuICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlICgxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJiAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIChyZWVudHJ5ID0gITEpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldmlvdXNEaXNwYXRjaGVyKSxcbiAgICAgICAgICByZWVuYWJsZUxvZ3MoKSxcbiAgICAgICAgICAoRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBmcmFtZSk7XG4gICAgICB9XG4gICAgICBzYW1wbGVMaW5lcyA9IChzYW1wbGVMaW5lcyA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6IFwiXCIpXG4gICAgICAgID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoc2FtcGxlTGluZXMpXG4gICAgICAgIDogXCJcIjtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZuICYmIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzYW1wbGVMaW5lcyk7XG4gICAgICByZXR1cm4gc2FtcGxlTGluZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PSB0eXBlKSByZXR1cm4gXCJcIjtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKSB7XG4gICAgICAgIHZhciBwcm90b3R5cGUgPSB0eXBlLnByb3RvdHlwZTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICAhKCFwcm90b3R5cGUgfHwgIXByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlXCIpO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZSA9IGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIsICExKSksIHR5cGU7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBwcm90b3R5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUocHJvdG90eXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0T3duZXIoKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkE7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gZGlzcGF0Y2hlciA/IG51bGwgOiBkaXNwYXRjaGVyLmdldE93bmVyKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcInJlZlwiKSkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsIFwicmVmXCIpLmdldDtcbiAgICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbmZpZy5yZWY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcImtleVwiKSkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsIFwia2V5XCIpLmdldDtcbiAgICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbmZpZy5rZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICAgICAgZnVuY3Rpb24gd2FybkFib3V0QWNjZXNzaW5nS2V5KCkge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biB8fFxuICAgICAgICAgICgoc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSAhMCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0LmRldi9saW5rL3NwZWNpYWwtcHJvcHMpXCIsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZVxuICAgICAgICAgICkpO1xuICAgICAgfVxuICAgICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gITA7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsIFwia2V5XCIsIHtcbiAgICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZygpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHRoaXMudHlwZSk7XG4gICAgICBkaWRXYXJuQWJvdXRFbGVtZW50UmVmW2NvbXBvbmVudE5hbWVdIHx8XG4gICAgICAgICgoZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSA9ICEwKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkFjY2Vzc2luZyBlbGVtZW50LnJlZiB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gcmVmIGlzIG5vdyBhIHJlZ3VsYXIgcHJvcC4gSXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEpTWCBFbGVtZW50IHR5cGUgaW4gYSBmdXR1cmUgcmVsZWFzZS5cIlxuICAgICAgICApKTtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSB0aGlzLnByb3BzLnJlZjtcbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbXBvbmVudE5hbWUgPyBjb21wb25lbnROYW1lIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgX3JlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgICAgIF9yZWYgPSBwcm9wcy5yZWY7XG4gICAgICB0eXBlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICBfb3duZXI6IG93bmVyXG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gKHZvaWQgMCAhPT0gX3JlZiA/IF9yZWYgOiBudWxsKVxuICAgICAgICA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgIGdldDogZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICB9KVxuICAgICAgICA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7IGVudW1lcmFibGU6ICExLCB2YWx1ZTogbnVsbCB9KTtcbiAgICAgIHR5cGUuX3N0b3JlID0ge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZS5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnSW5mb1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUodHlwZS5wcm9wcyksIE9iamVjdC5mcmVlemUodHlwZSkpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGpzeERFVkltcGwoXG4gICAgICB0eXBlLFxuICAgICAgY29uZmlnLFxuICAgICAgbWF5YmVLZXksXG4gICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgc291cmNlLFxuICAgICAgc2VsZlxuICAgICkge1xuICAgICAgaWYgKFxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSB8fFxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8XG4gICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8XG4gICAgICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHxcbiAgICAgICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OU1VNRVJfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxIHx8XG4gICAgICAgICAgICB2b2lkIDAgIT09IHR5cGUuZ2V0TW9kdWxlSWQpKVxuICAgICAgKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcbiAgICAgICAgaWYgKHZvaWQgMCAhPT0gY2hpbGRyZW4pXG4gICAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pXG4gICAgICAgICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA9IDA7XG4gICAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA8IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuKytcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2lzU3RhdGljQ2hpbGRyZW5dLCB0eXBlKTtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgZWxzZSB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZHJlbiA9IFwiXCI7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB2b2lkIDAgPT09IHR5cGUgfHxcbiAgICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAgIDAgPT09IE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aClcbiAgICAgICAgKVxuICAgICAgICAgIGNoaWxkcmVuICs9XG4gICAgICAgICAgICBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICAgIG51bGwgPT09IHR5cGVcbiAgICAgICAgICA/IChpc1N0YXRpY0NoaWxkcmVuID0gXCJudWxsXCIpXG4gICAgICAgICAgOiBpc0FycmF5SW1wbCh0eXBlKVxuICAgICAgICAgICAgPyAoaXNTdGF0aWNDaGlsZHJlbiA9IFwiYXJyYXlcIilcbiAgICAgICAgICAgIDogdm9pZCAwICE9PSB0eXBlICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgICAgICAgICA/ICgoaXNTdGF0aWNDaGlsZHJlbiA9XG4gICAgICAgICAgICAgICAgICBcIjxcIiArXG4gICAgICAgICAgICAgICAgICAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJVbmtub3duXCIpICtcbiAgICAgICAgICAgICAgICAgIFwiIC8+XCIpLFxuICAgICAgICAgICAgICAgIChjaGlsZHJlbiA9XG4gICAgICAgICAgICAgICAgICBcIiBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50P1wiKSlcbiAgICAgICAgICAgICAgOiAoaXNTdGF0aWNDaGlsZHJlbiA9IHR5cGVvZiB0eXBlKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlJlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lc1wiLFxuICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY29uZmlnKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICByZXR1cm4gXCJrZXlcIiAhPT0gaztcbiAgICAgICAgfSk7XG4gICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPVxuICAgICAgICAgIDAgPCBrZXlzLmxlbmd0aFxuICAgICAgICAgICAgPyBcIntrZXk6IHNvbWVLZXksIFwiICsga2V5cy5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCJcbiAgICAgICAgICAgIDogXCJ7a2V5OiBzb21lS2V5fVwiO1xuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSB8fFxuICAgICAgICAgICgoa2V5cyA9XG4gICAgICAgICAgICAwIDwga2V5cy5sZW5ndGggPyBcIntcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiIDogXCJ7fVwiKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ0EgcHJvcHMgb2JqZWN0IGNvbnRhaW5pbmcgYSBcImtleVwiIHByb3AgaXMgYmVpbmcgc3ByZWFkIGludG8gSlNYOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMgey4uLnByb3BzfSAvPlxcblJlYWN0IGtleXMgbXVzdCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gSlNYIHdpdGhvdXQgdXNpbmcgc3ByZWFkOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JyxcbiAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIGtleXMsXG4gICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5BYm91dEtleVNwcmVhZFtjaGlsZHJlbiArIGlzU3RhdGljQ2hpbGRyZW5dID0gITApKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgICAgIHZvaWQgMCAhPT0gbWF5YmVLZXkgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgbWF5YmVLZXkpKTtcbiAgICAgIGhhc1ZhbGlkS2V5KGNvbmZpZykgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSksIChjaGlsZHJlbiA9IFwiXCIgKyBjb25maWcua2V5KSk7XG4gICAgICBoYXNWYWxpZFJlZihjb25maWcpO1xuICAgICAgaWYgKFwia2V5XCIgaW4gY29uZmlnKSB7XG4gICAgICAgIG1heWJlS2V5ID0ge307XG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIGNvbmZpZylcbiAgICAgICAgICBcImtleVwiICE9PSBwcm9wTmFtZSAmJiAobWF5YmVLZXlbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXSk7XG4gICAgICB9IGVsc2UgbWF5YmVLZXkgPSBjb25maWc7XG4gICAgICBjaGlsZHJlbiAmJlxuICAgICAgICAoKGNvbmZpZyA9XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZVxuICAgICAgICAgICAgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBcIlVua25vd25cIlxuICAgICAgICAgICAgOiB0eXBlKSxcbiAgICAgICAgY2hpbGRyZW4gJiYgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIobWF5YmVLZXksIGNvbmZpZykpO1xuICAgICAgcmV0dXJuIFJlYWN0RWxlbWVudChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIG51bGwsXG4gICAgICAgIHNlbGYsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgZ2V0T3duZXIoKSxcbiAgICAgICAgbWF5YmVLZXlcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5vZGUgJiZcbiAgICAgICAgbm9kZSAmJlxuICAgICAgICBub2RlLiQkdHlwZW9mICE9PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICApXG4gICAgICAgIGlmIChpc0FycmF5SW1wbChub2RlKSlcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG4gICAgICAgICAgICBpc1ZhbGlkRWxlbWVudChjaGlsZCkgJiYgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSlcbiAgICAgICAgICBub2RlLl9zdG9yZSAmJiAobm9kZS5fc3RvcmUudmFsaWRhdGVkID0gMSk7XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgIChudWxsID09PSBub2RlIHx8IFwib2JqZWN0XCIgIT09IHR5cGVvZiBub2RlXG4gICAgICAgICAgICA/IChpID0gbnVsbClcbiAgICAgICAgICAgIDogKChpID1cbiAgICAgICAgICAgICAgICAoTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG5vZGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSkgfHxcbiAgICAgICAgICAgICAgICBub2RlW1wiQEBpdGVyYXRvclwiXSksXG4gICAgICAgICAgICAgIChpID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaSA/IGkgOiBudWxsKSksXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaSAmJlxuICAgICAgICAgICAgaSAhPT0gbm9kZS5lbnRyaWVzICYmXG4gICAgICAgICAgICAoKGkgPSBpLmNhbGwobm9kZSkpLCBpICE9PSBub2RlKSlcbiAgICAgICAgKVxuICAgICAgICAgIGZvciAoOyAhKG5vZGUgPSBpLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICAgICAgaXNWYWxpZEVsZW1lbnQobm9kZS52YWx1ZSkgJiZcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShub2RlLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygb2JqZWN0ICYmXG4gICAgICAgIG51bGwgIT09IG9iamVjdCAmJlxuICAgICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGVsZW1lbnQuX3N0b3JlICYmXG4gICAgICAgICFlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgJiZcbiAgICAgICAgbnVsbCA9PSBlbGVtZW50LmtleSAmJlxuICAgICAgICAoKGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IDEpLFxuICAgICAgICAocGFyZW50VHlwZSA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkpLFxuICAgICAgICAhb3duZXJIYXNLZXlVc2VXYXJuaW5nW3BhcmVudFR5cGVdKVxuICAgICAgKSB7XG4gICAgICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1twYXJlbnRUeXBlXSA9ICEwO1xuICAgICAgICB2YXIgY2hpbGRPd25lciA9IFwiXCI7XG4gICAgICAgIGVsZW1lbnQgJiZcbiAgICAgICAgICBudWxsICE9IGVsZW1lbnQuX293bmVyICYmXG4gICAgICAgICAgZWxlbWVudC5fb3duZXIgIT09IGdldE93bmVyKCkgJiZcbiAgICAgICAgICAoKGNoaWxkT3duZXIgPSBudWxsKSxcbiAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgZWxlbWVudC5fb3duZXIudGFnXG4gICAgICAgICAgICA/IChjaGlsZE93bmVyID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpKVxuICAgICAgICAgICAgOiBcInN0cmluZ1wiID09PSB0eXBlb2YgZWxlbWVudC5fb3duZXIubmFtZSAmJlxuICAgICAgICAgICAgICAoY2hpbGRPd25lciA9IGVsZW1lbnQuX293bmVyLm5hbWUpLFxuICAgICAgICAgIChjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBjaGlsZE93bmVyICsgXCIuXCIpKTtcbiAgICAgICAgdmFyIHByZXZHZXRDdXJyZW50U3RhY2sgPSBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2s7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlKTtcbiAgICAgICAgICBwcmV2R2V0Q3VycmVudFN0YWNrICYmIChzdGFjayArPSBwcmV2R2V0Q3VycmVudFN0YWNrKCkgfHwgXCJcIik7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgICAgICB9O1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyxcbiAgICAgICAgICBwYXJlbnRUeXBlLFxuICAgICAgICAgIGNoaWxkT3duZXJcbiAgICAgICAgKTtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID0gcHJldkdldEN1cnJlbnRTdGFjaztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9IFwiXCIsXG4gICAgICAgIG93bmVyID0gZ2V0T3duZXIoKTtcbiAgICAgIG93bmVyICYmXG4gICAgICAgIChvd25lciA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShvd25lci50eXBlKSkgJiZcbiAgICAgICAgKGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGBcIiArIG93bmVyICsgXCJgLlwiKTtcbiAgICAgIGluZm8gfHxcbiAgICAgICAgKChwYXJlbnRUeXBlID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpKSAmJlxuICAgICAgICAgIChpbmZvID1cbiAgICAgICAgICAgIFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnRUeXBlICsgXCI+LlwiKSk7XG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKSxcbiAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSxcbiAgICAgIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgICAgIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksXG4gICAgICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLFxuICAgICAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKTtcbiAgICBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIik7XG4gICAgdmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29uc3VtZXJcIiksXG4gICAgICBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxcbiAgICAgIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksXG4gICAgICBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcbiAgICAgIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLFxuICAgICAgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpLFxuICAgICAgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQyID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgICAgIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24sXG4gICAgICBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIGRpc2FibGVkRGVwdGggPSAwLFxuICAgICAgcHJldkxvZyxcbiAgICAgIHByZXZJbmZvLFxuICAgICAgcHJldldhcm4sXG4gICAgICBwcmV2RXJyb3IsXG4gICAgICBwcmV2R3JvdXAsXG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQsXG4gICAgICBwcmV2R3JvdXBFbmQ7XG4gICAgZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gITA7XG4gICAgdmFyIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIHJlZW50cnkgPSAhMTtcbiAgICB2YXIgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyAoXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBXZWFrTWFwID8gV2Vha01hcCA6IE1hcFxuICAgICkoKTtcbiAgICB2YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG4gICAgdmFyIGRpZFdhcm5BYm91dEVsZW1lbnRSZWYgPSB7fTtcbiAgICB2YXIgZGlkV2FybkFib3V0S2V5U3ByZWFkID0ge30sXG4gICAgICBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbiAgICBleHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbiAgICBleHBvcnRzLmpzeERFViA9IGZ1bmN0aW9uIChcbiAgICAgIHR5cGUsXG4gICAgICBjb25maWcsXG4gICAgICBtYXliZUtleSxcbiAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICBzb3VyY2UsXG4gICAgICBzZWxmXG4gICAgKSB7XG4gICAgICByZXR1cm4ganN4REVWSW1wbCh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpO1xuICAgIH07XG4gIH0pKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/ZWU5NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/nats.ws/esm/nats.js":
/*!******************************************!*\
  !*** ./node_modules/nats.ws/esm/nats.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AckPolicy: () => (/* binding */ AckPolicy),\n/* harmony export */   AdvisoryKind: () => (/* binding */ AdvisoryKind),\n/* harmony export */   Bench: () => (/* binding */ Bench),\n/* harmony export */   ConsumerDebugEvents: () => (/* binding */ ConsumerDebugEvents),\n/* harmony export */   ConsumerEvents: () => (/* binding */ ConsumerEvents),\n/* harmony export */   DebugEvents: () => (/* binding */ DebugEvents),\n/* harmony export */   DeliverPolicy: () => (/* binding */ DeliverPolicy),\n/* harmony export */   DirectMsgHeaders: () => (/* binding */ DirectMsgHeaders),\n/* harmony export */   DiscardPolicy: () => (/* binding */ DiscardPolicy),\n/* harmony export */   Empty: () => (/* binding */ Empty),\n/* harmony export */   ErrorCode: () => (/* binding */ ErrorCode),\n/* harmony export */   Events: () => (/* binding */ Events),\n/* harmony export */   JSONCodec: () => (/* binding */ JSONCodec),\n/* harmony export */   JsHeaders: () => (/* binding */ JsHeaders),\n/* harmony export */   KvWatchInclude: () => (/* binding */ KvWatchInclude),\n/* harmony export */   Match: () => (/* binding */ Match),\n/* harmony export */   Metric: () => (/* binding */ Metric),\n/* harmony export */   MsgHdrsImpl: () => (/* binding */ MsgHdrsImpl),\n/* harmony export */   NatsError: () => (/* binding */ NatsError),\n/* harmony export */   Nuid: () => (/* binding */ Nuid),\n/* harmony export */   ReplayPolicy: () => (/* binding */ ReplayPolicy),\n/* harmony export */   RepublishHeaders: () => (/* binding */ RepublishHeaders),\n/* harmony export */   RequestStrategy: () => (/* binding */ RequestStrategy),\n/* harmony export */   RetentionPolicy: () => (/* binding */ RetentionPolicy),\n/* harmony export */   ServiceError: () => (/* binding */ ServiceError),\n/* harmony export */   ServiceErrorCodeHeader: () => (/* binding */ ServiceErrorCodeHeader),\n/* harmony export */   ServiceErrorHeader: () => (/* binding */ ServiceErrorHeader),\n/* harmony export */   ServiceResponseType: () => (/* binding */ ServiceResponseType),\n/* harmony export */   ServiceVerb: () => (/* binding */ ServiceVerb),\n/* harmony export */   StorageType: () => (/* binding */ StorageType),\n/* harmony export */   StoreCompression: () => (/* binding */ StoreCompression),\n/* harmony export */   StringCodec: () => (/* binding */ StringCodec),\n/* harmony export */   backoff: () => (/* binding */ backoff),\n/* harmony export */   buildAuthenticator: () => (/* binding */ buildAuthenticator),\n/* harmony export */   canonicalMIMEHeaderKey: () => (/* binding */ canonicalMIMEHeaderKey),\n/* harmony export */   checkJsError: () => (/* binding */ checkJsError),\n/* harmony export */   connect: () => (/* binding */ connect),\n/* harmony export */   consumerOpts: () => (/* binding */ consumerOpts),\n/* harmony export */   createInbox: () => (/* binding */ createInbox),\n/* harmony export */   credsAuthenticator: () => (/* binding */ credsAuthenticator),\n/* harmony export */   deadline: () => (/* binding */ deadline),\n/* harmony export */   deferred: () => (/* binding */ deferred),\n/* harmony export */   delay: () => (/* binding */ delay),\n/* harmony export */   headers: () => (/* binding */ headers),\n/* harmony export */   isFlowControlMsg: () => (/* binding */ isFlowControlMsg),\n/* harmony export */   isHeartbeatMsg: () => (/* binding */ isHeartbeatMsg),\n/* harmony export */   jwtAuthenticator: () => (/* binding */ jwtAuthenticator),\n/* harmony export */   millis: () => (/* binding */ millis),\n/* harmony export */   nanos: () => (/* binding */ nanos),\n/* harmony export */   nkeyAuthenticator: () => (/* binding */ nkeyAuthenticator),\n/* harmony export */   nkeys: () => (/* binding */ mod),\n/* harmony export */   nuid: () => (/* binding */ nuid),\n/* harmony export */   syncIterator: () => (/* binding */ syncIterator),\n/* harmony export */   tokenAuthenticator: () => (/* binding */ tokenAuthenticator),\n/* harmony export */   usernamePasswordAuthenticator: () => (/* binding */ usernamePasswordAuthenticator)\n/* harmony export */ });\n// deno-fmt-ignore-file\n// deno-lint-ignore-file\n// This code was bundled using `deno bundle` and it's not recommended to edit it manually\n\nconst Empty = new Uint8Array(0);\nconst TE = new TextEncoder();\nconst TD = new TextDecoder();\nfunction concat(...bufs) {\n    let max = 0;\n    for(let i = 0; i < bufs.length; i++){\n        max += bufs[i].length;\n    }\n    const out = new Uint8Array(max);\n    let index = 0;\n    for(let i = 0; i < bufs.length; i++){\n        out.set(bufs[i], index);\n        index += bufs[i].length;\n    }\n    return out;\n}\nfunction encode(...a) {\n    const bufs = [];\n    for(let i = 0; i < a.length; i++){\n        bufs.push(TE.encode(a[i]));\n    }\n    if (bufs.length === 0) {\n        return Empty;\n    }\n    if (bufs.length === 1) {\n        return bufs[0];\n    }\n    return concat(...bufs);\n}\nfunction decode(a) {\n    if (!a || a.length === 0) {\n        return \"\";\n    }\n    return TD.decode(a);\n}\n\"use strict\";\nconst digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nconst base = 36;\nconst maxSeq = 3656158440062976;\nconst minInc = 33;\nconst maxInc = 333;\nconst totalLen = 12 + 10;\nfunction _getRandomValues(a) {\n    for(let i = 0; i < a.length; i++){\n        a[i] = Math.floor(Math.random() * 255);\n    }\n}\nfunction fillRandom(a) {\n    if (globalThis?.crypto?.getRandomValues) {\n        globalThis.crypto.getRandomValues(a);\n    } else {\n        _getRandomValues(a);\n    }\n}\nclass Nuid {\n    buf;\n    seq;\n    inc;\n    inited;\n    constructor(){\n        this.buf = new Uint8Array(totalLen);\n        this.inited = false;\n    }\n    init() {\n        this.inited = true;\n        this.setPre();\n        this.initSeqAndInc();\n        this.fillSeq();\n    }\n    initSeqAndInc() {\n        this.seq = Math.floor(Math.random() * maxSeq);\n        this.inc = Math.floor(Math.random() * (maxInc - minInc) + minInc);\n    }\n    setPre() {\n        const cbuf = new Uint8Array(12);\n        fillRandom(cbuf);\n        for(let i = 0; i < 12; i++){\n            const di = cbuf[i] % 36;\n            this.buf[i] = digits.charCodeAt(di);\n        }\n    }\n    fillSeq() {\n        let n = this.seq;\n        for(let i = totalLen - 1; i >= 12; i--){\n            this.buf[i] = digits.charCodeAt(n % base);\n            n = Math.floor(n / base);\n        }\n    }\n    next() {\n        if (!this.inited) {\n            this.init();\n        }\n        this.seq += this.inc;\n        if (this.seq > 3656158440062976) {\n            this.setPre();\n            this.initSeqAndInc();\n        }\n        this.fillSeq();\n        return String.fromCharCode.apply(String, this.buf);\n    }\n    reset() {\n        this.init();\n    }\n}\nconst nuid = new Nuid();\nvar Events;\n(function(Events) {\n    Events[\"Disconnect\"] = \"disconnect\";\n    Events[\"Reconnect\"] = \"reconnect\";\n    Events[\"Update\"] = \"update\";\n    Events[\"LDM\"] = \"ldm\";\n    Events[\"Error\"] = \"error\";\n})(Events || (Events = {}));\nvar DebugEvents;\n(function(DebugEvents) {\n    DebugEvents[\"Reconnecting\"] = \"reconnecting\";\n    DebugEvents[\"PingTimer\"] = \"pingTimer\";\n    DebugEvents[\"StaleConnection\"] = \"staleConnection\";\n    DebugEvents[\"ClientInitiatedReconnect\"] = \"client initiated reconnect\";\n})(DebugEvents || (DebugEvents = {}));\nvar ErrorCode;\n(function(ErrorCode) {\n    ErrorCode[\"ApiError\"] = \"BAD API\";\n    ErrorCode[\"BadAuthentication\"] = \"BAD_AUTHENTICATION\";\n    ErrorCode[\"BadCreds\"] = \"BAD_CREDS\";\n    ErrorCode[\"BadHeader\"] = \"BAD_HEADER\";\n    ErrorCode[\"BadJson\"] = \"BAD_JSON\";\n    ErrorCode[\"BadPayload\"] = \"BAD_PAYLOAD\";\n    ErrorCode[\"BadSubject\"] = \"BAD_SUBJECT\";\n    ErrorCode[\"Cancelled\"] = \"CANCELLED\";\n    ErrorCode[\"ConnectionClosed\"] = \"CONNECTION_CLOSED\";\n    ErrorCode[\"ConnectionDraining\"] = \"CONNECTION_DRAINING\";\n    ErrorCode[\"ConnectionRefused\"] = \"CONNECTION_REFUSED\";\n    ErrorCode[\"ConnectionTimeout\"] = \"CONNECTION_TIMEOUT\";\n    ErrorCode[\"Disconnect\"] = \"DISCONNECT\";\n    ErrorCode[\"InvalidOption\"] = \"INVALID_OPTION\";\n    ErrorCode[\"InvalidPayload\"] = \"INVALID_PAYLOAD\";\n    ErrorCode[\"MaxPayloadExceeded\"] = \"MAX_PAYLOAD_EXCEEDED\";\n    ErrorCode[\"NoResponders\"] = \"503\";\n    ErrorCode[\"NotFunction\"] = \"NOT_FUNC\";\n    ErrorCode[\"RequestError\"] = \"REQUEST_ERROR\";\n    ErrorCode[\"ServerOptionNotAvailable\"] = \"SERVER_OPT_NA\";\n    ErrorCode[\"SubClosed\"] = \"SUB_CLOSED\";\n    ErrorCode[\"SubDraining\"] = \"SUB_DRAINING\";\n    ErrorCode[\"Timeout\"] = \"TIMEOUT\";\n    ErrorCode[\"Tls\"] = \"TLS\";\n    ErrorCode[\"Unknown\"] = \"UNKNOWN_ERROR\";\n    ErrorCode[\"WssRequired\"] = \"WSS_REQUIRED\";\n    ErrorCode[\"JetStreamInvalidAck\"] = \"JESTREAM_INVALID_ACK\";\n    ErrorCode[\"JetStream404NoMessages\"] = \"404\";\n    ErrorCode[\"JetStream408RequestTimeout\"] = \"408\";\n    ErrorCode[\"JetStream409MaxAckPendingExceeded\"] = \"409\";\n    ErrorCode[\"JetStream409\"] = \"409\";\n    ErrorCode[\"JetStreamNotEnabled\"] = \"503\";\n    ErrorCode[\"JetStreamIdleHeartBeat\"] = \"IDLE_HEARTBEAT\";\n    ErrorCode[\"AuthorizationViolation\"] = \"AUTHORIZATION_VIOLATION\";\n    ErrorCode[\"AuthenticationExpired\"] = \"AUTHENTICATION_EXPIRED\";\n    ErrorCode[\"ProtocolError\"] = \"NATS_PROTOCOL_ERR\";\n    ErrorCode[\"PermissionsViolation\"] = \"PERMISSIONS_VIOLATION\";\n    ErrorCode[\"AuthenticationTimeout\"] = \"AUTHENTICATION_TIMEOUT\";\n    ErrorCode[\"AccountExpired\"] = \"ACCOUNT_EXPIRED\";\n})(ErrorCode || (ErrorCode = {}));\nfunction isNatsError(err) {\n    return typeof err.code === \"string\";\n}\nclass Messages {\n    messages;\n    constructor(){\n        this.messages = new Map();\n        this.messages.set(ErrorCode.InvalidPayload, \"Invalid payload type - payloads can be 'binary', 'string', or 'json'\");\n        this.messages.set(ErrorCode.BadJson, \"Bad JSON\");\n        this.messages.set(ErrorCode.WssRequired, \"TLS is required, therefore a secure websocket connection is also required\");\n    }\n    static getMessage(s) {\n        return messages.getMessage(s);\n    }\n    getMessage(s) {\n        return this.messages.get(s) || s;\n    }\n}\nconst messages = new Messages();\nclass NatsError extends Error {\n    name;\n    message;\n    code;\n    permissionContext;\n    chainedError;\n    api_error;\n    constructor(message, code, chainedError){\n        super(message);\n        this.name = \"NatsError\";\n        this.message = message;\n        this.code = code;\n        this.chainedError = chainedError;\n    }\n    static errorForCode(code, chainedError) {\n        const m = Messages.getMessage(code);\n        return new NatsError(m, code, chainedError);\n    }\n    isAuthError() {\n        return this.code === ErrorCode.AuthenticationExpired || this.code === ErrorCode.AuthorizationViolation || this.code === ErrorCode.AccountExpired;\n    }\n    isAuthTimeout() {\n        return this.code === ErrorCode.AuthenticationTimeout;\n    }\n    isPermissionError() {\n        return this.code === ErrorCode.PermissionsViolation;\n    }\n    isProtocolError() {\n        return this.code === ErrorCode.ProtocolError;\n    }\n    isJetStreamError() {\n        return this.api_error !== undefined;\n    }\n    jsError() {\n        return this.api_error ? this.api_error : null;\n    }\n}\nvar Match;\n(function(Match) {\n    Match[Match[\"Exact\"] = 0] = \"Exact\";\n    Match[Match[\"CanonicalMIME\"] = 1] = \"CanonicalMIME\";\n    Match[Match[\"IgnoreCase\"] = 2] = \"IgnoreCase\";\n})(Match || (Match = {}));\nvar RequestStrategy;\n(function(RequestStrategy) {\n    RequestStrategy[\"Timer\"] = \"timer\";\n    RequestStrategy[\"Count\"] = \"count\";\n    RequestStrategy[\"JitterTimer\"] = \"jitterTimer\";\n    RequestStrategy[\"SentinelMsg\"] = \"sentinelMsg\";\n})(RequestStrategy || (RequestStrategy = {}));\nfunction syncIterator(src) {\n    const iter = src[Symbol.asyncIterator]();\n    return {\n        async next () {\n            const m = await iter.next();\n            if (m.done) {\n                return Promise.resolve(null);\n            }\n            return Promise.resolve(m.value);\n        }\n    };\n}\nvar ServiceResponseType;\n(function(ServiceResponseType) {\n    ServiceResponseType[\"STATS\"] = \"io.nats.micro.v1.stats_response\";\n    ServiceResponseType[\"INFO\"] = \"io.nats.micro.v1.info_response\";\n    ServiceResponseType[\"PING\"] = \"io.nats.micro.v1.ping_response\";\n})(ServiceResponseType || (ServiceResponseType = {}));\nconst ServiceErrorHeader = \"Nats-Service-Error\";\nconst ServiceErrorCodeHeader = \"Nats-Service-Error-Code\";\nclass ServiceError extends Error {\n    code;\n    constructor(code, message){\n        super(message);\n        this.code = code;\n    }\n    static isServiceError(msg) {\n        return ServiceError.toServiceError(msg) !== null;\n    }\n    static toServiceError(msg) {\n        const scode = msg?.headers?.get(ServiceErrorCodeHeader) || \"\";\n        if (scode !== \"\") {\n            const code = parseInt(scode) || 400;\n            const description = msg?.headers?.get(ServiceErrorHeader) || \"\";\n            return new ServiceError(code, description.length ? description : scode);\n        }\n        return null;\n    }\n}\nfunction createInbox(prefix = \"\") {\n    prefix = prefix || \"_INBOX\";\n    if (typeof prefix !== \"string\") {\n        throw new Error(\"prefix must be a string\");\n    }\n    prefix.split(\".\").forEach((v)=>{\n        if (v === \"*\" || v === \">\") {\n            throw new Error(`inbox prefixes cannot have wildcards '${prefix}'`);\n        }\n    });\n    return `${prefix}.${nuid.next()}`;\n}\nconst DEFAULT_HOST = \"127.0.0.1\";\nvar ServiceVerb;\n(function(ServiceVerb) {\n    ServiceVerb[\"PING\"] = \"PING\";\n    ServiceVerb[\"STATS\"] = \"STATS\";\n    ServiceVerb[\"INFO\"] = \"INFO\";\n})(ServiceVerb || (ServiceVerb = {}));\nfunction extend(a, ...b) {\n    for(let i = 0; i < b.length; i++){\n        const o = b[i];\n        Object.keys(o).forEach(function(k) {\n            a[k] = o[k];\n        });\n    }\n    return a;\n}\nfunction render(frame) {\n    const cr = \"␍\";\n    const lf = \"␊\";\n    return TD.decode(frame).replace(/\\n/g, lf).replace(/\\r/g, cr);\n}\nfunction timeout(ms, asyncTraces = true) {\n    const err = asyncTraces ? NatsError.errorForCode(ErrorCode.Timeout) : null;\n    let methods;\n    let timer;\n    const p = new Promise((_resolve, reject)=>{\n        const cancel = ()=>{\n            if (timer) {\n                clearTimeout(timer);\n            }\n        };\n        methods = {\n            cancel\n        };\n        timer = setTimeout(()=>{\n            if (err === null) {\n                reject(NatsError.errorForCode(ErrorCode.Timeout));\n            } else {\n                reject(err);\n            }\n        }, ms);\n    });\n    return Object.assign(p, methods);\n}\nfunction delay(ms = 0) {\n    let methods;\n    const p = new Promise((resolve)=>{\n        const timer = setTimeout(()=>{\n            resolve();\n        }, ms);\n        const cancel = ()=>{\n            if (timer) {\n                clearTimeout(timer);\n            }\n        };\n        methods = {\n            cancel\n        };\n    });\n    return Object.assign(p, methods);\n}\nfunction deadline(p, millis = 1000) {\n    const err = new Error(`deadline exceeded`);\n    const d = deferred();\n    const timer = setTimeout(()=>d.reject(err), millis);\n    return Promise.race([\n        p,\n        d\n    ]).finally(()=>clearTimeout(timer));\n}\nfunction deferred() {\n    let methods = {};\n    const p = new Promise((resolve, reject)=>{\n        methods = {\n            resolve,\n            reject\n        };\n    });\n    return Object.assign(p, methods);\n}\nfunction shuffle(a) {\n    for(let i = a.length - 1; i > 0; i--){\n        const j = Math.floor(Math.random() * (i + 1));\n        [a[i], a[j]] = [\n            a[j],\n            a[i]\n        ];\n    }\n    return a;\n}\nclass Perf {\n    timers;\n    measures;\n    constructor(){\n        this.timers = new Map();\n        this.measures = new Map();\n    }\n    mark(key) {\n        this.timers.set(key, performance.now());\n    }\n    measure(key, startKey, endKey) {\n        const s = this.timers.get(startKey);\n        if (s === undefined) {\n            throw new Error(`${startKey} is not defined`);\n        }\n        const e = this.timers.get(endKey);\n        if (e === undefined) {\n            throw new Error(`${endKey} is not defined`);\n        }\n        this.measures.set(key, e - s);\n    }\n    getEntries() {\n        const values = [];\n        this.measures.forEach((v, k)=>{\n            values.push({\n                name: k,\n                duration: v\n            });\n        });\n        return values;\n    }\n}\nfunction jitter(n) {\n    if (n === 0) {\n        return 0;\n    }\n    return Math.floor(n / 2 + Math.random() * n);\n}\nfunction backoff(policy = [\n    0,\n    250,\n    250,\n    500,\n    500,\n    3000,\n    5000\n]) {\n    if (!Array.isArray(policy)) {\n        policy = [\n            0,\n            250,\n            250,\n            500,\n            500,\n            3000,\n            5000\n        ];\n    }\n    const max = policy.length - 1;\n    return {\n        backoff (attempt) {\n            return jitter(attempt > max ? policy[max] : policy[attempt]);\n        }\n    };\n}\nfunction nanos(millis) {\n    return millis * 1000000;\n}\nfunction millis(ns) {\n    return Math.floor(ns / 1000000);\n}\nfunction canonicalMIMEHeaderKey(k) {\n    const dash = 45;\n    const toLower = 97 - 65;\n    let upper = true;\n    const buf = new Array(k.length);\n    for(let i = 0; i < k.length; i++){\n        let c = k.charCodeAt(i);\n        if (c === 58 || c < 33 || c > 126) {\n            throw new NatsError(`'${k[i]}' is not a valid character for a header key`, ErrorCode.BadHeader);\n        }\n        if (upper && 97 <= c && c <= 122) {\n            c -= toLower;\n        } else if (!upper && 65 <= c && c <= 90) {\n            c += toLower;\n        }\n        buf[i] = c;\n        upper = c == dash;\n    }\n    return String.fromCharCode(...buf);\n}\nfunction headers(code = 0, description = \"\") {\n    if (code === 0 && description !== \"\" || code > 0 && description === \"\") {\n        throw new Error(\"setting status requires both code and description\");\n    }\n    return new MsgHdrsImpl(code, description);\n}\nconst HEADER = \"NATS/1.0\";\nclass MsgHdrsImpl {\n    _code;\n    headers;\n    _description;\n    constructor(code = 0, description = \"\"){\n        this._code = code;\n        this._description = description;\n        this.headers = new Map();\n    }\n    [Symbol.iterator]() {\n        return this.headers.entries();\n    }\n    size() {\n        return this.headers.size;\n    }\n    equals(mh) {\n        if (mh && this.headers.size === mh.headers.size && this._code === mh._code) {\n            for (const [k, v] of this.headers){\n                const a = mh.values(k);\n                if (v.length !== a.length) {\n                    return false;\n                }\n                const vv = [\n                    ...v\n                ].sort();\n                const aa = [\n                    ...a\n                ].sort();\n                for(let i = 0; i < vv.length; i++){\n                    if (vv[i] !== aa[i]) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    static decode(a) {\n        const mh = new MsgHdrsImpl();\n        const s = TD.decode(a);\n        const lines = s.split(\"\\r\\n\");\n        const h = lines[0];\n        if (h !== HEADER) {\n            let str = h.replace(HEADER, \"\").trim();\n            if (str.length > 0) {\n                mh._code = parseInt(str, 10);\n                if (isNaN(mh._code)) {\n                    mh._code = 0;\n                }\n                const scode = mh._code.toString();\n                str = str.replace(scode, \"\");\n                mh._description = str.trim();\n            }\n        }\n        if (lines.length >= 1) {\n            lines.slice(1).map((s)=>{\n                if (s) {\n                    const idx = s.indexOf(\":\");\n                    if (idx > -1) {\n                        const k = s.slice(0, idx);\n                        const v = s.slice(idx + 1).trim();\n                        mh.append(k, v);\n                    }\n                }\n            });\n        }\n        return mh;\n    }\n    toString() {\n        if (this.headers.size === 0 && this._code === 0) {\n            return \"\";\n        }\n        let s = HEADER;\n        if (this._code > 0 && this._description !== \"\") {\n            s += ` ${this._code} ${this._description}`;\n        }\n        for (const [k, v] of this.headers){\n            for(let i = 0; i < v.length; i++){\n                s = `${s}\\r\\n${k}: ${v[i]}`;\n            }\n        }\n        return `${s}\\r\\n\\r\\n`;\n    }\n    encode() {\n        return TE.encode(this.toString());\n    }\n    static validHeaderValue(k) {\n        const inv = /[\\r\\n]/;\n        if (inv.test(k)) {\n            throw new NatsError(\"invalid header value - \\\\r and \\\\n are not allowed.\", ErrorCode.BadHeader);\n        }\n        return k.trim();\n    }\n    keys() {\n        const keys = [];\n        for (const sk of this.headers.keys()){\n            keys.push(sk);\n        }\n        return keys;\n    }\n    findKeys(k, match = Match.Exact) {\n        const keys = this.keys();\n        switch(match){\n            case Match.Exact:\n                return keys.filter((v)=>{\n                    return v === k;\n                });\n            case Match.CanonicalMIME:\n                k = canonicalMIMEHeaderKey(k);\n                return keys.filter((v)=>{\n                    return v === k;\n                });\n            default:\n                {\n                    const lci = k.toLowerCase();\n                    return keys.filter((v)=>{\n                        return lci === v.toLowerCase();\n                    });\n                }\n        }\n    }\n    get(k, match = Match.Exact) {\n        const keys = this.findKeys(k, match);\n        if (keys.length) {\n            const v = this.headers.get(keys[0]);\n            if (v) {\n                return Array.isArray(v) ? v[0] : v;\n            }\n        }\n        return \"\";\n    }\n    last(k, match = Match.Exact) {\n        const keys = this.findKeys(k, match);\n        if (keys.length) {\n            const v = this.headers.get(keys[0]);\n            if (v) {\n                return Array.isArray(v) ? v[v.length - 1] : v;\n            }\n        }\n        return \"\";\n    }\n    has(k, match = Match.Exact) {\n        return this.findKeys(k, match).length > 0;\n    }\n    set(k, v, match = Match.Exact) {\n        this.delete(k, match);\n        this.append(k, v, match);\n    }\n    append(k, v, match = Match.Exact) {\n        const ck = canonicalMIMEHeaderKey(k);\n        if (match === Match.CanonicalMIME) {\n            k = ck;\n        }\n        const keys = this.findKeys(k, match);\n        k = keys.length > 0 ? keys[0] : k;\n        const value = MsgHdrsImpl.validHeaderValue(v);\n        let a = this.headers.get(k);\n        if (!a) {\n            a = [];\n            this.headers.set(k, a);\n        }\n        a.push(value);\n    }\n    values(k, match = Match.Exact) {\n        const buf = [];\n        const keys = this.findKeys(k, match);\n        keys.forEach((v)=>{\n            const values = this.headers.get(v);\n            if (values) {\n                buf.push(...values);\n            }\n        });\n        return buf;\n    }\n    delete(k, match = Match.Exact) {\n        const keys = this.findKeys(k, match);\n        keys.forEach((v)=>{\n            this.headers.delete(v);\n        });\n    }\n    get hasError() {\n        return this._code >= 300;\n    }\n    get status() {\n        return `${this._code} ${this._description}`.trim();\n    }\n    toRecord() {\n        const data = {};\n        this.keys().forEach((v)=>{\n            data[v] = this.values(v);\n        });\n        return data;\n    }\n    get code() {\n        return this._code;\n    }\n    get description() {\n        return this._description;\n    }\n    static fromRecord(r) {\n        const h = new MsgHdrsImpl();\n        for(const k in r){\n            h.headers.set(k, r[k]);\n        }\n        return h;\n    }\n}\nfunction StringCodec() {\n    return {\n        encode (d) {\n            return TE.encode(d);\n        },\n        decode (a) {\n            return TD.decode(a);\n        }\n    };\n}\nfunction JSONCodec(reviver) {\n    return {\n        encode (d) {\n            try {\n                if (d === undefined) {\n                    d = null;\n                }\n                return TE.encode(JSON.stringify(d));\n            } catch (err) {\n                throw NatsError.errorForCode(ErrorCode.BadJson, err);\n            }\n        },\n        decode (a) {\n            try {\n                return JSON.parse(TD.decode(a), reviver);\n            } catch (err) {\n                throw NatsError.errorForCode(ErrorCode.BadJson, err);\n            }\n        }\n    };\n}\nfunction isRequestError(msg) {\n    if (msg && msg.data.length === 0 && msg.headers?.code === 503) {\n        return NatsError.errorForCode(ErrorCode.NoResponders);\n    }\n    return null;\n}\nclass MsgImpl {\n    _headers;\n    _msg;\n    _rdata;\n    _reply;\n    _subject;\n    publisher;\n    static jc;\n    constructor(msg, data, publisher){\n        this._msg = msg;\n        this._rdata = data;\n        this.publisher = publisher;\n    }\n    get subject() {\n        if (this._subject) {\n            return this._subject;\n        }\n        this._subject = TD.decode(this._msg.subject);\n        return this._subject;\n    }\n    get reply() {\n        if (this._reply) {\n            return this._reply;\n        }\n        this._reply = TD.decode(this._msg.reply);\n        return this._reply;\n    }\n    get sid() {\n        return this._msg.sid;\n    }\n    get headers() {\n        if (this._msg.hdr > -1 && !this._headers) {\n            const buf = this._rdata.subarray(0, this._msg.hdr);\n            this._headers = MsgHdrsImpl.decode(buf);\n        }\n        return this._headers;\n    }\n    get data() {\n        if (!this._rdata) {\n            return new Uint8Array(0);\n        }\n        return this._msg.hdr > -1 ? this._rdata.subarray(this._msg.hdr) : this._rdata;\n    }\n    respond(data = Empty, opts) {\n        if (this.reply) {\n            this.publisher.publish(this.reply, data, opts);\n            return true;\n        }\n        return false;\n    }\n    size() {\n        const subj = this._msg.subject.length;\n        const reply = this._msg.reply?.length || 0;\n        const payloadAndHeaders = this._msg.size === -1 ? 0 : this._msg.size;\n        return subj + reply + payloadAndHeaders;\n    }\n    json(reviver) {\n        return JSONCodec(reviver).decode(this.data);\n    }\n    string() {\n        return TD.decode(this.data);\n    }\n    requestInfo() {\n        const v = this.headers?.get(\"Nats-Request-Info\");\n        if (v) {\n            return JSON.parse(v, function(key, value) {\n                if ((key === \"start\" || key === \"stop\") && value !== \"\") {\n                    return new Date(Date.parse(value));\n                }\n                return value;\n            });\n        }\n        return null;\n    }\n}\nfunction validateDurableName(name) {\n    return minValidation(\"durable\", name);\n}\nfunction validateStreamName(name) {\n    return minValidation(\"stream\", name);\n}\nfunction minValidation(context, name = \"\") {\n    if (name === \"\") {\n        throw Error(`${context} name required`);\n    }\n    const bad = [\n        \".\",\n        \"*\",\n        \">\",\n        \"/\",\n        \"\\\\\",\n        \" \",\n        \"\\t\",\n        \"\\n\",\n        \"\\r\"\n    ];\n    bad.forEach((v)=>{\n        if (name.indexOf(v) !== -1) {\n            switch(v){\n                case \"\\n\":\n                    v = \"\\\\n\";\n                    break;\n                case \"\\r\":\n                    v = \"\\\\r\";\n                    break;\n                case \"\\t\":\n                    v = \"\\\\t\";\n                    break;\n                default:\n            }\n            throw Error(`invalid ${context} name - ${context} name cannot contain '${v}'`);\n        }\n    });\n    return \"\";\n}\nfunction validateName(context, name = \"\") {\n    if (name === \"\") {\n        throw Error(`${context} name required`);\n    }\n    const m = validName(name);\n    if (m.length) {\n        throw new Error(`invalid ${context} name - ${context} name ${m}`);\n    }\n}\nfunction validName(name = \"\") {\n    if (name === \"\") {\n        throw Error(`name required`);\n    }\n    const RE = /^[-\\w]+$/g;\n    const m = name.match(RE);\n    if (m === null) {\n        for (const c of name.split(\"\")){\n            const mm = c.match(RE);\n            if (mm === null) {\n                return `cannot contain '${c}'`;\n            }\n        }\n    }\n    return \"\";\n}\nfunction isFlowControlMsg(msg) {\n    if (msg.data.length > 0) {\n        return false;\n    }\n    const h = msg.headers;\n    if (!h) {\n        return false;\n    }\n    return h.code >= 100 && h.code < 200;\n}\nfunction isHeartbeatMsg(msg) {\n    return isFlowControlMsg(msg) && msg.headers?.description === \"Idle Heartbeat\";\n}\nfunction newJsErrorMsg(code, description, subject) {\n    const h = headers(code, description);\n    const arg = {\n        hdr: 1,\n        sid: 0,\n        size: 0\n    };\n    const msg = new MsgImpl(arg, Empty, {});\n    msg._headers = h;\n    msg._subject = subject;\n    return msg;\n}\nfunction checkJsError(msg) {\n    if (msg.data.length !== 0) {\n        return null;\n    }\n    const h = msg.headers;\n    if (!h) {\n        return null;\n    }\n    return checkJsErrorCode(h.code, h.description);\n}\nvar Js409Errors;\n(function(Js409Errors) {\n    Js409Errors[\"MaxBatchExceeded\"] = \"exceeded maxrequestbatch of\";\n    Js409Errors[\"MaxExpiresExceeded\"] = \"exceeded maxrequestexpires of\";\n    Js409Errors[\"MaxBytesExceeded\"] = \"exceeded maxrequestmaxbytes of\";\n    Js409Errors[\"MaxMessageSizeExceeded\"] = \"message size exceeds maxbytes\";\n    Js409Errors[\"PushConsumer\"] = \"consumer is push based\";\n    Js409Errors[\"MaxWaitingExceeded\"] = \"exceeded maxwaiting\";\n    Js409Errors[\"IdleHeartbeatMissed\"] = \"idle heartbeats missed\";\n    Js409Errors[\"ConsumerDeleted\"] = \"consumer deleted\";\n})(Js409Errors || (Js409Errors = {}));\nlet MAX_WAITING_FAIL = false;\nfunction isTerminal409(err) {\n    if (err.code !== ErrorCode.JetStream409) {\n        return false;\n    }\n    const fatal = [\n        Js409Errors.MaxBatchExceeded,\n        Js409Errors.MaxExpiresExceeded,\n        Js409Errors.MaxBytesExceeded,\n        Js409Errors.MaxMessageSizeExceeded,\n        Js409Errors.PushConsumer,\n        Js409Errors.IdleHeartbeatMissed,\n        Js409Errors.ConsumerDeleted\n    ];\n    if (MAX_WAITING_FAIL) {\n        fatal.push(Js409Errors.MaxWaitingExceeded);\n    }\n    return fatal.find((s)=>{\n        return err.message.indexOf(s) !== -1;\n    }) !== undefined;\n}\nfunction checkJsErrorCode(code, description = \"\") {\n    if (code < 300) {\n        return null;\n    }\n    description = description.toLowerCase();\n    switch(code){\n        case 404:\n            return new NatsError(description, ErrorCode.JetStream404NoMessages);\n        case 408:\n            return new NatsError(description, ErrorCode.JetStream408RequestTimeout);\n        case 409:\n            {\n                const ec = description.startsWith(Js409Errors.IdleHeartbeatMissed) ? ErrorCode.JetStreamIdleHeartBeat : ErrorCode.JetStream409;\n                return new NatsError(description, ec);\n            }\n        case 503:\n            return NatsError.errorForCode(ErrorCode.JetStreamNotEnabled, new Error(description));\n        default:\n            if (description === \"\") {\n                description = ErrorCode.Unknown;\n            }\n            return new NatsError(description, `${code}`);\n    }\n}\nclass QueuedIteratorImpl {\n    inflight;\n    processed;\n    received;\n    noIterator;\n    iterClosed;\n    done;\n    signal;\n    yields;\n    filtered;\n    pendingFiltered;\n    ingestionFilterFn;\n    protocolFilterFn;\n    dispatchedFn;\n    ctx;\n    _data;\n    err;\n    time;\n    yielding;\n    constructor(){\n        this.inflight = 0;\n        this.filtered = 0;\n        this.pendingFiltered = 0;\n        this.processed = 0;\n        this.received = 0;\n        this.noIterator = false;\n        this.done = false;\n        this.signal = deferred();\n        this.yields = [];\n        this.iterClosed = deferred();\n        this.time = 0;\n        this.yielding = false;\n    }\n    [Symbol.asyncIterator]() {\n        return this.iterate();\n    }\n    push(v) {\n        if (this.done) {\n            return;\n        }\n        if (typeof v === \"function\") {\n            this.yields.push(v);\n            this.signal.resolve();\n            return;\n        }\n        const { ingest, protocol } = this.ingestionFilterFn ? this.ingestionFilterFn(v, this.ctx || this) : {\n            ingest: true,\n            protocol: false\n        };\n        if (ingest) {\n            if (protocol) {\n                this.filtered++;\n                this.pendingFiltered++;\n            }\n            this.yields.push(v);\n            this.signal.resolve();\n        }\n    }\n    async *iterate() {\n        if (this.noIterator) {\n            throw new NatsError(\"unsupported iterator\", ErrorCode.ApiError);\n        }\n        if (this.yielding) {\n            throw new NatsError(\"already yielding\", ErrorCode.ApiError);\n        }\n        this.yielding = true;\n        try {\n            while(true){\n                if (this.yields.length === 0) {\n                    await this.signal;\n                }\n                if (this.err) {\n                    throw this.err;\n                }\n                const yields = this.yields;\n                this.inflight = yields.length;\n                this.yields = [];\n                for(let i = 0; i < yields.length; i++){\n                    if (typeof yields[i] === \"function\") {\n                        const fn = yields[i];\n                        try {\n                            fn();\n                        } catch (err) {\n                            throw err;\n                        }\n                        if (this.err) {\n                            throw this.err;\n                        }\n                        continue;\n                    }\n                    const ok = this.protocolFilterFn ? this.protocolFilterFn(yields[i]) : true;\n                    if (ok) {\n                        this.processed++;\n                        const start = Date.now();\n                        yield yields[i];\n                        this.time = Date.now() - start;\n                        if (this.dispatchedFn && yields[i]) {\n                            this.dispatchedFn(yields[i]);\n                        }\n                    } else {\n                        this.pendingFiltered--;\n                    }\n                    this.inflight--;\n                }\n                if (this.done) {\n                    break;\n                } else if (this.yields.length === 0) {\n                    yields.length = 0;\n                    this.yields = yields;\n                    this.signal = deferred();\n                }\n            }\n        } finally{\n            this.stop();\n        }\n    }\n    stop(err) {\n        if (this.done) {\n            return;\n        }\n        this.err = err;\n        this.done = true;\n        this.signal.resolve();\n        this.iterClosed.resolve(err);\n    }\n    getProcessed() {\n        return this.noIterator ? this.received : this.processed;\n    }\n    getPending() {\n        return this.yields.length + this.inflight - this.pendingFiltered;\n    }\n    getReceived() {\n        return this.received - this.filtered;\n    }\n}\nclass IdleHeartbeatMonitor {\n    interval;\n    maxOut;\n    cancelAfter;\n    timer;\n    autoCancelTimer;\n    last;\n    missed;\n    count;\n    callback;\n    constructor(interval, cb, opts = {\n        maxOut: 2\n    }){\n        this.interval = interval;\n        this.maxOut = opts?.maxOut || 2;\n        this.cancelAfter = opts?.cancelAfter || 0;\n        this.last = Date.now();\n        this.missed = 0;\n        this.count = 0;\n        this.callback = cb;\n        this._schedule();\n    }\n    cancel() {\n        if (this.autoCancelTimer) {\n            clearTimeout(this.autoCancelTimer);\n        }\n        if (this.timer) {\n            clearInterval(this.timer);\n        }\n        this.timer = 0;\n        this.autoCancelTimer = 0;\n        this.missed = 0;\n    }\n    work() {\n        this.last = Date.now();\n        this.missed = 0;\n    }\n    _change(interval, cancelAfter = 0, maxOut = 2) {\n        this.interval = interval;\n        this.maxOut = maxOut;\n        this.cancelAfter = cancelAfter;\n        this.restart();\n    }\n    restart() {\n        this.cancel();\n        this._schedule();\n    }\n    _schedule() {\n        if (this.cancelAfter > 0) {\n            this.autoCancelTimer = setTimeout(()=>{\n                this.cancel();\n            }, this.cancelAfter);\n        }\n        this.timer = setInterval(()=>{\n            this.count++;\n            if (Date.now() - this.last > this.interval) {\n                this.missed++;\n            }\n            if (this.missed >= this.maxOut) {\n                try {\n                    if (this.callback(this.missed) === true) {\n                        this.cancel();\n                    }\n                } catch (err) {\n                    console.log(err);\n                }\n            }\n        }, this.interval);\n    }\n}\nvar RetentionPolicy;\n(function(RetentionPolicy) {\n    RetentionPolicy[\"Limits\"] = \"limits\";\n    RetentionPolicy[\"Interest\"] = \"interest\";\n    RetentionPolicy[\"Workqueue\"] = \"workqueue\";\n})(RetentionPolicy || (RetentionPolicy = {}));\nvar DiscardPolicy;\n(function(DiscardPolicy) {\n    DiscardPolicy[\"Old\"] = \"old\";\n    DiscardPolicy[\"New\"] = \"new\";\n})(DiscardPolicy || (DiscardPolicy = {}));\nvar StorageType;\n(function(StorageType) {\n    StorageType[\"File\"] = \"file\";\n    StorageType[\"Memory\"] = \"memory\";\n})(StorageType || (StorageType = {}));\nvar DeliverPolicy;\n(function(DeliverPolicy) {\n    DeliverPolicy[\"All\"] = \"all\";\n    DeliverPolicy[\"Last\"] = \"last\";\n    DeliverPolicy[\"New\"] = \"new\";\n    DeliverPolicy[\"StartSequence\"] = \"by_start_sequence\";\n    DeliverPolicy[\"StartTime\"] = \"by_start_time\";\n    DeliverPolicy[\"LastPerSubject\"] = \"last_per_subject\";\n})(DeliverPolicy || (DeliverPolicy = {}));\nvar AckPolicy;\n(function(AckPolicy) {\n    AckPolicy[\"None\"] = \"none\";\n    AckPolicy[\"All\"] = \"all\";\n    AckPolicy[\"Explicit\"] = \"explicit\";\n    AckPolicy[\"NotSet\"] = \"\";\n})(AckPolicy || (AckPolicy = {}));\nvar ReplayPolicy;\n(function(ReplayPolicy) {\n    ReplayPolicy[\"Instant\"] = \"instant\";\n    ReplayPolicy[\"Original\"] = \"original\";\n})(ReplayPolicy || (ReplayPolicy = {}));\nvar StoreCompression;\n(function(StoreCompression) {\n    StoreCompression[\"None\"] = \"none\";\n    StoreCompression[\"S2\"] = \"s2\";\n})(StoreCompression || (StoreCompression = {}));\nvar ConsumerApiAction;\n(function(ConsumerApiAction) {\n    ConsumerApiAction[\"CreateOrUpdate\"] = \"\";\n    ConsumerApiAction[\"Update\"] = \"update\";\n    ConsumerApiAction[\"Create\"] = \"create\";\n})(ConsumerApiAction || (ConsumerApiAction = {}));\nfunction defaultConsumer(name, opts = {}) {\n    return Object.assign({\n        name: name,\n        deliver_policy: DeliverPolicy.All,\n        ack_policy: AckPolicy.Explicit,\n        ack_wait: nanos(30 * 1000),\n        replay_policy: ReplayPolicy.Instant\n    }, opts);\n}\nvar AdvisoryKind;\n(function(AdvisoryKind) {\n    AdvisoryKind[\"API\"] = \"api_audit\";\n    AdvisoryKind[\"StreamAction\"] = \"stream_action\";\n    AdvisoryKind[\"ConsumerAction\"] = \"consumer_action\";\n    AdvisoryKind[\"SnapshotCreate\"] = \"snapshot_create\";\n    AdvisoryKind[\"SnapshotComplete\"] = \"snapshot_complete\";\n    AdvisoryKind[\"RestoreCreate\"] = \"restore_create\";\n    AdvisoryKind[\"RestoreComplete\"] = \"restore_complete\";\n    AdvisoryKind[\"MaxDeliver\"] = \"max_deliver\";\n    AdvisoryKind[\"Terminated\"] = \"terminated\";\n    AdvisoryKind[\"Ack\"] = \"consumer_ack\";\n    AdvisoryKind[\"StreamLeaderElected\"] = \"stream_leader_elected\";\n    AdvisoryKind[\"StreamQuorumLost\"] = \"stream_quorum_lost\";\n    AdvisoryKind[\"ConsumerLeaderElected\"] = \"consumer_leader_elected\";\n    AdvisoryKind[\"ConsumerQuorumLost\"] = \"consumer_quorum_lost\";\n})(AdvisoryKind || (AdvisoryKind = {}));\nvar JsHeaders;\n(function(JsHeaders) {\n    JsHeaders[\"StreamSourceHdr\"] = \"Nats-Stream-Source\";\n    JsHeaders[\"LastConsumerSeqHdr\"] = \"Nats-Last-Consumer\";\n    JsHeaders[\"LastStreamSeqHdr\"] = \"Nats-Last-Stream\";\n    JsHeaders[\"ConsumerStalledHdr\"] = \"Nats-Consumer-Stalled\";\n    JsHeaders[\"MessageSizeHdr\"] = \"Nats-Msg-Size\";\n    JsHeaders[\"RollupHdr\"] = \"Nats-Rollup\";\n    JsHeaders[\"RollupValueSubject\"] = \"sub\";\n    JsHeaders[\"RollupValueAll\"] = \"all\";\n    JsHeaders[\"PendingMessagesHdr\"] = \"Nats-Pending-Messages\";\n    JsHeaders[\"PendingBytesHdr\"] = \"Nats-Pending-Bytes\";\n})(JsHeaders || (JsHeaders = {}));\nvar KvWatchInclude;\n(function(KvWatchInclude) {\n    KvWatchInclude[\"LastValue\"] = \"\";\n    KvWatchInclude[\"AllHistory\"] = \"history\";\n    KvWatchInclude[\"UpdatesOnly\"] = \"updates\";\n})(KvWatchInclude || (KvWatchInclude = {}));\nvar DirectMsgHeaders;\n(function(DirectMsgHeaders) {\n    DirectMsgHeaders[\"Stream\"] = \"Nats-Stream\";\n    DirectMsgHeaders[\"Sequence\"] = \"Nats-Sequence\";\n    DirectMsgHeaders[\"TimeStamp\"] = \"Nats-Time-Stamp\";\n    DirectMsgHeaders[\"Subject\"] = \"Nats-Subject\";\n})(DirectMsgHeaders || (DirectMsgHeaders = {}));\nvar RepublishHeaders;\n(function(RepublishHeaders) {\n    RepublishHeaders[\"Stream\"] = \"Nats-Stream\";\n    RepublishHeaders[\"Subject\"] = \"Nats-Subject\";\n    RepublishHeaders[\"Sequence\"] = \"Nats-Sequence\";\n    RepublishHeaders[\"LastSequence\"] = \"Nats-Last-Sequence\";\n    RepublishHeaders[\"Size\"] = \"Nats-Msg-Size\";\n})(RepublishHeaders || (RepublishHeaders = {}));\nconst kvPrefix = \"KV_\";\nclass ConsumerOptsBuilderImpl {\n    config;\n    ordered;\n    mack;\n    stream;\n    callbackFn;\n    max;\n    qname;\n    isBind;\n    filters;\n    constructor(opts){\n        this.stream = \"\";\n        this.mack = false;\n        this.ordered = false;\n        this.config = defaultConsumer(\"\", opts || {});\n    }\n    getOpts() {\n        const o = {};\n        o.config = Object.assign({}, this.config);\n        if (o.config.filter_subject) {\n            this.filterSubject(o.config.filter_subject);\n            o.config.filter_subject = undefined;\n        }\n        if (o.config.filter_subjects) {\n            o.config.filter_subjects?.forEach((v)=>{\n                this.filterSubject(v);\n            });\n            o.config.filter_subjects = undefined;\n        }\n        o.mack = this.mack;\n        o.stream = this.stream;\n        o.callbackFn = this.callbackFn;\n        o.max = this.max;\n        o.queue = this.qname;\n        o.ordered = this.ordered;\n        o.config.ack_policy = o.ordered ? AckPolicy.None : o.config.ack_policy;\n        o.isBind = o.isBind || false;\n        if (this.filters) {\n            switch(this.filters.length){\n                case 0:\n                    break;\n                case 1:\n                    o.config.filter_subject = this.filters[0];\n                    break;\n                default:\n                    o.config.filter_subjects = this.filters;\n            }\n        }\n        return o;\n    }\n    description(description) {\n        this.config.description = description;\n        return this;\n    }\n    deliverTo(subject) {\n        this.config.deliver_subject = subject;\n        return this;\n    }\n    durable(name) {\n        validateDurableName(name);\n        this.config.durable_name = name;\n        return this;\n    }\n    startSequence(seq) {\n        if (seq <= 0) {\n            throw new Error(\"sequence must be greater than 0\");\n        }\n        this.config.deliver_policy = DeliverPolicy.StartSequence;\n        this.config.opt_start_seq = seq;\n        return this;\n    }\n    startTime(time) {\n        this.config.deliver_policy = DeliverPolicy.StartTime;\n        this.config.opt_start_time = time.toISOString();\n        return this;\n    }\n    deliverAll() {\n        this.config.deliver_policy = DeliverPolicy.All;\n        return this;\n    }\n    deliverLastPerSubject() {\n        this.config.deliver_policy = DeliverPolicy.LastPerSubject;\n        return this;\n    }\n    deliverLast() {\n        this.config.deliver_policy = DeliverPolicy.Last;\n        return this;\n    }\n    deliverNew() {\n        this.config.deliver_policy = DeliverPolicy.New;\n        return this;\n    }\n    startAtTimeDelta(millis) {\n        this.startTime(new Date(Date.now() - millis));\n        return this;\n    }\n    headersOnly() {\n        this.config.headers_only = true;\n        return this;\n    }\n    ackNone() {\n        this.config.ack_policy = AckPolicy.None;\n        return this;\n    }\n    ackAll() {\n        this.config.ack_policy = AckPolicy.All;\n        return this;\n    }\n    ackExplicit() {\n        this.config.ack_policy = AckPolicy.Explicit;\n        return this;\n    }\n    ackWait(millis) {\n        this.config.ack_wait = nanos(millis);\n        return this;\n    }\n    maxDeliver(max) {\n        this.config.max_deliver = max;\n        return this;\n    }\n    filterSubject(s) {\n        this.filters = this.filters || [];\n        this.filters.push(s);\n        return this;\n    }\n    replayInstantly() {\n        this.config.replay_policy = ReplayPolicy.Instant;\n        return this;\n    }\n    replayOriginal() {\n        this.config.replay_policy = ReplayPolicy.Original;\n        return this;\n    }\n    sample(n) {\n        n = Math.trunc(n);\n        if (n < 0 || n > 100) {\n            throw new Error(`value must be between 0-100`);\n        }\n        this.config.sample_freq = `${n}%`;\n        return this;\n    }\n    limit(n) {\n        this.config.rate_limit_bps = n;\n        return this;\n    }\n    maxWaiting(max) {\n        this.config.max_waiting = max;\n        return this;\n    }\n    maxAckPending(max) {\n        this.config.max_ack_pending = max;\n        return this;\n    }\n    idleHeartbeat(millis) {\n        this.config.idle_heartbeat = nanos(millis);\n        return this;\n    }\n    flowControl() {\n        this.config.flow_control = true;\n        return this;\n    }\n    deliverGroup(name) {\n        this.queue(name);\n        return this;\n    }\n    manualAck() {\n        this.mack = true;\n        return this;\n    }\n    maxMessages(max) {\n        this.max = max;\n        return this;\n    }\n    callback(fn) {\n        this.callbackFn = fn;\n        return this;\n    }\n    queue(n) {\n        this.qname = n;\n        this.config.deliver_group = n;\n        return this;\n    }\n    orderedConsumer() {\n        this.ordered = true;\n        return this;\n    }\n    bind(stream, durable) {\n        this.stream = stream;\n        this.config.durable_name = durable;\n        this.isBind = true;\n        return this;\n    }\n    bindStream(stream) {\n        this.stream = stream;\n        return this;\n    }\n    inactiveEphemeralThreshold(millis) {\n        this.config.inactive_threshold = nanos(millis);\n        return this;\n    }\n    maxPullBatch(n) {\n        this.config.max_batch = n;\n        return this;\n    }\n    maxPullRequestExpires(millis) {\n        this.config.max_expires = nanos(millis);\n        return this;\n    }\n    memory() {\n        this.config.mem_storage = true;\n        return this;\n    }\n    numReplicas(n) {\n        this.config.num_replicas = n;\n        return this;\n    }\n    consumerName(n) {\n        this.config.name = n;\n        return this;\n    }\n}\nfunction consumerOpts(opts) {\n    return new ConsumerOptsBuilderImpl(opts);\n}\nfunction isConsumerOptsBuilder(o) {\n    return typeof o.getOpts === \"function\";\n}\nclass Base64Codec {\n    static encode(bytes) {\n        if (typeof bytes === \"string\") {\n            return btoa(bytes);\n        }\n        const a = Array.from(bytes);\n        return btoa(String.fromCharCode(...a));\n    }\n    static decode(s, binary = false) {\n        const bin = atob(s);\n        if (!binary) {\n            return bin;\n        }\n        return Uint8Array.from(bin, (c)=>c.charCodeAt(0));\n    }\n}\nclass Base64UrlPaddedCodec {\n    static encode(bytes) {\n        return Base64UrlPaddedCodec.toB64URLEncoding(Base64Codec.encode(bytes));\n    }\n    static decode(s, binary = false) {\n        return Base64UrlPaddedCodec.decode(Base64UrlPaddedCodec.fromB64URLEncoding(s), binary);\n    }\n    static toB64URLEncoding(b64str) {\n        return b64str.replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n    }\n    static fromB64URLEncoding(b64str) {\n        return b64str.replace(/_/g, \"/\").replace(/-/g, \"+\");\n    }\n}\nclass DataBuffer {\n    buffers;\n    byteLength;\n    constructor(){\n        this.buffers = [];\n        this.byteLength = 0;\n    }\n    static concat(...bufs) {\n        let max = 0;\n        for(let i = 0; i < bufs.length; i++){\n            max += bufs[i].length;\n        }\n        const out = new Uint8Array(max);\n        let index = 0;\n        for(let i = 0; i < bufs.length; i++){\n            out.set(bufs[i], index);\n            index += bufs[i].length;\n        }\n        return out;\n    }\n    static fromAscii(m) {\n        if (!m) {\n            m = \"\";\n        }\n        return TE.encode(m);\n    }\n    static toAscii(a) {\n        return TD.decode(a);\n    }\n    reset() {\n        this.buffers.length = 0;\n        this.byteLength = 0;\n    }\n    pack() {\n        if (this.buffers.length > 1) {\n            const v = new Uint8Array(this.byteLength);\n            let index = 0;\n            for(let i = 0; i < this.buffers.length; i++){\n                v.set(this.buffers[i], index);\n                index += this.buffers[i].length;\n            }\n            this.buffers.length = 0;\n            this.buffers.push(v);\n        }\n    }\n    shift() {\n        if (this.buffers.length) {\n            const a = this.buffers.shift();\n            if (a) {\n                this.byteLength -= a.length;\n                return a;\n            }\n        }\n        return new Uint8Array(0);\n    }\n    drain(n) {\n        if (this.buffers.length) {\n            this.pack();\n            const v = this.buffers.pop();\n            if (v) {\n                const max = this.byteLength;\n                if (n === undefined || n > max) {\n                    n = max;\n                }\n                const d = v.subarray(0, n);\n                if (max > n) {\n                    this.buffers.push(v.subarray(n));\n                }\n                this.byteLength = max - n;\n                return d;\n            }\n        }\n        return new Uint8Array(0);\n    }\n    fill(a, ...bufs) {\n        if (a) {\n            this.buffers.push(a);\n            this.byteLength += a.length;\n        }\n        for(let i = 0; i < bufs.length; i++){\n            if (bufs[i] && bufs[i].length) {\n                this.buffers.push(bufs[i]);\n                this.byteLength += bufs[i].length;\n            }\n        }\n    }\n    peek() {\n        if (this.buffers.length) {\n            this.pack();\n            return this.buffers[0];\n        }\n        return new Uint8Array(0);\n    }\n    size() {\n        return this.byteLength;\n    }\n    length() {\n        return this.buffers.length;\n    }\n}\nfunction t(t, e) {\n    return e.forEach(function(e) {\n        e && \"string\" != typeof e && !Array.isArray(e) && Object.keys(e).forEach(function(r) {\n            if (\"default\" !== r && !(r in t)) {\n                var i = Object.getOwnPropertyDescriptor(e, r);\n                Object.defineProperty(t, r, i.get ? i : {\n                    enumerable: !0,\n                    get: function() {\n                        return e[r];\n                    }\n                });\n            }\n        });\n    }), Object.freeze(t);\n}\nvar e = \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : {};\nfunction r() {\n    throw new Error(\"setTimeout has not been defined\");\n}\nfunction i() {\n    throw new Error(\"clearTimeout has not been defined\");\n}\nvar h = r, s = i;\nfunction n(t) {\n    if (h === setTimeout) return setTimeout(t, 0);\n    if ((h === r || !h) && setTimeout) return h = setTimeout, setTimeout(t, 0);\n    try {\n        return h(t, 0);\n    } catch (e) {\n        try {\n            return h.call(null, t, 0);\n        } catch (e) {\n            return h.call(this, t, 0);\n        }\n    }\n}\n\"function\" == typeof e.setTimeout && (h = setTimeout), \"function\" == typeof e.clearTimeout && (s = clearTimeout);\nvar o, a = [], f = !1, u = -1;\nfunction c() {\n    f && o && (f = !1, o.length ? a = o.concat(a) : u = -1, a.length && l());\n}\nfunction l() {\n    if (!f) {\n        var t = n(c);\n        f = !0;\n        for(var e = a.length; e;){\n            for(o = a, a = []; ++u < e;)o && o[u].run();\n            u = -1, e = a.length;\n        }\n        o = null, f = !1, function(t) {\n            if (s === clearTimeout) return clearTimeout(t);\n            if ((s === i || !s) && clearTimeout) return s = clearTimeout, clearTimeout(t);\n            try {\n                return s(t);\n            } catch (e) {\n                try {\n                    return s.call(null, t);\n                } catch (e) {\n                    return s.call(this, t);\n                }\n            }\n        }(t);\n    }\n}\nfunction y(t, e) {\n    this.fun = t, this.array = e;\n}\ny.prototype.run = function() {\n    this.fun.apply(null, this.array);\n};\nfunction p() {}\nvar d = p, w = p, b = p, v = p, A = p, g = p, _ = p;\nvar m = e.performance || {}, O = m.now || m.mozNow || m.msNow || m.oNow || m.webkitNow || function() {\n    return (new Date).getTime();\n};\nvar B = new Date;\nvar E = {\n    nextTick: function(t) {\n        var e = new Array(arguments.length - 1);\n        if (arguments.length > 1) for(var r = 1; r < arguments.length; r++)e[r - 1] = arguments[r];\n        a.push(new y(t, e)), 1 !== a.length || f || n(l);\n    },\n    title: \"browser\",\n    browser: !0,\n    env: {},\n    argv: [],\n    version: \"\",\n    versions: {},\n    on: d,\n    addListener: w,\n    once: b,\n    off: v,\n    removeListener: A,\n    removeAllListeners: g,\n    emit: _,\n    binding: function(t) {\n        throw new Error(\"process.binding is not supported\");\n    },\n    cwd: function() {\n        return \"/\";\n    },\n    chdir: function(t) {\n        throw new Error(\"process.chdir is not supported\");\n    },\n    umask: function() {\n        return 0;\n    },\n    hrtime: function(t) {\n        var e = .001 * O.call(m), r = Math.floor(e), i = Math.floor(e % 1 * 1e9);\n        return t && (r -= t[0], (i -= t[1]) < 0 && (r--, i += 1e9)), [\n            r,\n            i\n        ];\n    },\n    platform: \"browser\",\n    release: {},\n    config: {},\n    uptime: function() {\n        return (new Date - B) / 1e3;\n    }\n}, S = \"undefined\" != typeof globalThis ? globalThis : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : {};\nfunction T(t) {\n    if (t.__esModule) return t;\n    var e = Object.defineProperty({}, \"__esModule\", {\n        value: !0\n    });\n    return Object.keys(t).forEach(function(r) {\n        var i = Object.getOwnPropertyDescriptor(t, r);\n        Object.defineProperty(e, r, i.get ? i : {\n            enumerable: !0,\n            get: function() {\n                return t[r];\n            }\n        });\n    }), e;\n}\nvar k, x = {\n    exports: {}\n}, j = {}, N = T(t({\n    __proto__: null,\n    default: j\n}, [\n    j\n]));\nk = x, function() {\n    var t = \"input is invalid type\", e = \"object\" == typeof window, r = e ? window : {};\n    r.JS_SHA256_NO_WINDOW && (e = !1);\n    var i = !e && \"object\" == typeof self, h = !r.JS_SHA256_NO_NODE_JS && E.versions && E.versions.node;\n    h ? r = S : i && (r = self);\n    var s = !r.JS_SHA256_NO_COMMON_JS && k.exports, n = !r.JS_SHA256_NO_ARRAY_BUFFER && \"undefined\" != typeof ArrayBuffer, o = \"0123456789abcdef\".split(\"\"), a = [\n        -2147483648,\n        8388608,\n        32768,\n        128\n    ], f = [\n        24,\n        16,\n        8,\n        0\n    ], u = [\n        1116352408,\n        1899447441,\n        3049323471,\n        3921009573,\n        961987163,\n        1508970993,\n        2453635748,\n        2870763221,\n        3624381080,\n        310598401,\n        607225278,\n        1426881987,\n        1925078388,\n        2162078206,\n        2614888103,\n        3248222580,\n        3835390401,\n        4022224774,\n        264347078,\n        604807628,\n        770255983,\n        1249150122,\n        1555081692,\n        1996064986,\n        2554220882,\n        2821834349,\n        2952996808,\n        3210313671,\n        3336571891,\n        3584528711,\n        113926993,\n        338241895,\n        666307205,\n        773529912,\n        1294757372,\n        1396182291,\n        1695183700,\n        1986661051,\n        2177026350,\n        2456956037,\n        2730485921,\n        2820302411,\n        3259730800,\n        3345764771,\n        3516065817,\n        3600352804,\n        4094571909,\n        275423344,\n        430227734,\n        506948616,\n        659060556,\n        883997877,\n        958139571,\n        1322822218,\n        1537002063,\n        1747873779,\n        1955562222,\n        2024104815,\n        2227730452,\n        2361852424,\n        2428436474,\n        2756734187,\n        3204031479,\n        3329325298\n    ], c = [\n        \"hex\",\n        \"array\",\n        \"digest\",\n        \"arrayBuffer\"\n    ], l = [];\n    !r.JS_SHA256_NO_NODE_JS && Array.isArray || (Array.isArray = function(t) {\n        return \"[object Array]\" === Object.prototype.toString.call(t);\n    }), !n || !r.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function(t) {\n        return \"object\" == typeof t && t.buffer && t.buffer.constructor === ArrayBuffer;\n    });\n    var y = function(t, e) {\n        return function(r) {\n            return new v(e, !0).update(r)[t]();\n        };\n    }, p = function(t) {\n        var e = y(\"hex\", t);\n        h && (e = d(e, t)), e.create = function() {\n            return new v(t);\n        }, e.update = function(t) {\n            return e.create().update(t);\n        };\n        for(var r = 0; r < c.length; ++r){\n            var i = c[r];\n            e[i] = y(i, t);\n        }\n        return e;\n    }, d = function(e, i) {\n        var h, s = N, n = N.Buffer, o = i ? \"sha224\" : \"sha256\";\n        return h = n.from && !r.JS_SHA256_NO_BUFFER_FROM ? n.from : function(t) {\n            return new n(t);\n        }, function(r) {\n            if (\"string\" == typeof r) return s.createHash(o).update(r, \"utf8\").digest(\"hex\");\n            if (null == r) throw new Error(t);\n            return r.constructor === ArrayBuffer && (r = new Uint8Array(r)), Array.isArray(r) || ArrayBuffer.isView(r) || r.constructor === n ? s.createHash(o).update(h(r)).digest(\"hex\") : e(r);\n        };\n    }, w = function(t, e) {\n        return function(r, i) {\n            return new A(r, e, !0).update(i)[t]();\n        };\n    }, b = function(t) {\n        var e = w(\"hex\", t);\n        e.create = function(e) {\n            return new A(e, t);\n        }, e.update = function(t, r) {\n            return e.create(t).update(r);\n        };\n        for(var r = 0; r < c.length; ++r){\n            var i = c[r];\n            e[i] = w(i, t);\n        }\n        return e;\n    };\n    function v(t, e) {\n        e ? (l[0] = l[16] = l[1] = l[2] = l[3] = l[4] = l[5] = l[6] = l[7] = l[8] = l[9] = l[10] = l[11] = l[12] = l[13] = l[14] = l[15] = 0, this.blocks = l) : this.blocks = [\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0\n        ], t ? (this.h0 = 3238371032, this.h1 = 914150663, this.h2 = 812702999, this.h3 = 4144912697, this.h4 = 4290775857, this.h5 = 1750603025, this.h6 = 1694076839, this.h7 = 3204075428) : (this.h0 = 1779033703, this.h1 = 3144134277, this.h2 = 1013904242, this.h3 = 2773480762, this.h4 = 1359893119, this.h5 = 2600822924, this.h6 = 528734635, this.h7 = 1541459225), this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0, this.is224 = t;\n    }\n    function A(e, r, i) {\n        var h, s = typeof e;\n        if (\"string\" === s) {\n            var o, a = [], f = e.length, u = 0;\n            for(h = 0; h < f; ++h)(o = e.charCodeAt(h)) < 128 ? a[u++] = o : o < 2048 ? (a[u++] = 192 | o >>> 6, a[u++] = 128 | 63 & o) : o < 55296 || o >= 57344 ? (a[u++] = 224 | o >>> 12, a[u++] = 128 | o >>> 6 & 63, a[u++] = 128 | 63 & o) : (o = 65536 + ((1023 & o) << 10 | 1023 & e.charCodeAt(++h)), a[u++] = 240 | o >>> 18, a[u++] = 128 | o >>> 12 & 63, a[u++] = 128 | o >>> 6 & 63, a[u++] = 128 | 63 & o);\n            e = a;\n        } else {\n            if (\"object\" !== s) throw new Error(t);\n            if (null === e) throw new Error(t);\n            if (n && e.constructor === ArrayBuffer) e = new Uint8Array(e);\n            else if (!(Array.isArray(e) || n && ArrayBuffer.isView(e))) throw new Error(t);\n        }\n        e.length > 64 && (e = new v(r, !0).update(e).array());\n        var c = [], l = [];\n        for(h = 0; h < 64; ++h){\n            var y = e[h] || 0;\n            c[h] = 92 ^ y, l[h] = 54 ^ y;\n        }\n        v.call(this, r, i), this.update(l), this.oKeyPad = c, this.inner = !0, this.sharedMemory = i;\n    }\n    v.prototype.update = function(e) {\n        if (!this.finalized) {\n            var r, i = typeof e;\n            if (\"string\" !== i) {\n                if (\"object\" !== i) throw new Error(t);\n                if (null === e) throw new Error(t);\n                if (n && e.constructor === ArrayBuffer) e = new Uint8Array(e);\n                else if (!(Array.isArray(e) || n && ArrayBuffer.isView(e))) throw new Error(t);\n                r = !0;\n            }\n            for(var h, s, o = 0, a = e.length, u = this.blocks; o < a;){\n                if (this.hashed && (this.hashed = !1, u[0] = this.block, this.block = u[16] = u[1] = u[2] = u[3] = u[4] = u[5] = u[6] = u[7] = u[8] = u[9] = u[10] = u[11] = u[12] = u[13] = u[14] = u[15] = 0), r) for(s = this.start; o < a && s < 64; ++o)u[s >>> 2] |= e[o] << f[3 & s++];\n                else for(s = this.start; o < a && s < 64; ++o)(h = e.charCodeAt(o)) < 128 ? u[s >>> 2] |= h << f[3 & s++] : h < 2048 ? (u[s >>> 2] |= (192 | h >>> 6) << f[3 & s++], u[s >>> 2] |= (128 | 63 & h) << f[3 & s++]) : h < 55296 || h >= 57344 ? (u[s >>> 2] |= (224 | h >>> 12) << f[3 & s++], u[s >>> 2] |= (128 | h >>> 6 & 63) << f[3 & s++], u[s >>> 2] |= (128 | 63 & h) << f[3 & s++]) : (h = 65536 + ((1023 & h) << 10 | 1023 & e.charCodeAt(++o)), u[s >>> 2] |= (240 | h >>> 18) << f[3 & s++], u[s >>> 2] |= (128 | h >>> 12 & 63) << f[3 & s++], u[s >>> 2] |= (128 | h >>> 6 & 63) << f[3 & s++], u[s >>> 2] |= (128 | 63 & h) << f[3 & s++]);\n                this.lastByteIndex = s, this.bytes += s - this.start, s >= 64 ? (this.block = u[16], this.start = s - 64, this.hash(), this.hashed = !0) : this.start = s;\n            }\n            return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 | 0, this.bytes = this.bytes % 4294967296), this;\n        }\n    }, v.prototype.finalize = function() {\n        if (!this.finalized) {\n            this.finalized = !0;\n            var t = this.blocks, e = this.lastByteIndex;\n            t[16] = this.block, t[e >>> 2] |= a[3 & e], this.block = t[16], e >= 56 && (this.hashed || this.hash(), t[0] = this.block, t[16] = t[1] = t[2] = t[3] = t[4] = t[5] = t[6] = t[7] = t[8] = t[9] = t[10] = t[11] = t[12] = t[13] = t[14] = t[15] = 0), t[14] = this.hBytes << 3 | this.bytes >>> 29, t[15] = this.bytes << 3, this.hash();\n        }\n    }, v.prototype.hash = function() {\n        var t, e, r, i, h, s, n, o, a, f = this.h0, c = this.h1, l = this.h2, y = this.h3, p = this.h4, d = this.h5, w = this.h6, b = this.h7, v = this.blocks;\n        for(t = 16; t < 64; ++t)e = ((h = v[t - 15]) >>> 7 | h << 25) ^ (h >>> 18 | h << 14) ^ h >>> 3, r = ((h = v[t - 2]) >>> 17 | h << 15) ^ (h >>> 19 | h << 13) ^ h >>> 10, v[t] = v[t - 16] + e + v[t - 7] + r | 0;\n        for(a = c & l, t = 0; t < 64; t += 4)this.first ? (this.is224 ? (s = 300032, b = (h = v[0] - 1413257819) - 150054599 | 0, y = h + 24177077 | 0) : (s = 704751109, b = (h = v[0] - 210244248) - 1521486534 | 0, y = h + 143694565 | 0), this.first = !1) : (e = (f >>> 2 | f << 30) ^ (f >>> 13 | f << 19) ^ (f >>> 22 | f << 10), i = (s = f & c) ^ f & l ^ a, b = y + (h = b + (r = (p >>> 6 | p << 26) ^ (p >>> 11 | p << 21) ^ (p >>> 25 | p << 7)) + (p & d ^ ~p & w) + u[t] + v[t]) | 0, y = h + (e + i) | 0), e = (y >>> 2 | y << 30) ^ (y >>> 13 | y << 19) ^ (y >>> 22 | y << 10), i = (n = y & f) ^ y & c ^ s, w = l + (h = w + (r = (b >>> 6 | b << 26) ^ (b >>> 11 | b << 21) ^ (b >>> 25 | b << 7)) + (b & p ^ ~b & d) + u[t + 1] + v[t + 1]) | 0, e = ((l = h + (e + i) | 0) >>> 2 | l << 30) ^ (l >>> 13 | l << 19) ^ (l >>> 22 | l << 10), i = (o = l & y) ^ l & f ^ n, d = c + (h = d + (r = (w >>> 6 | w << 26) ^ (w >>> 11 | w << 21) ^ (w >>> 25 | w << 7)) + (w & b ^ ~w & p) + u[t + 2] + v[t + 2]) | 0, e = ((c = h + (e + i) | 0) >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10), i = (a = c & l) ^ c & y ^ o, p = f + (h = p + (r = (d >>> 6 | d << 26) ^ (d >>> 11 | d << 21) ^ (d >>> 25 | d << 7)) + (d & w ^ ~d & b) + u[t + 3] + v[t + 3]) | 0, f = h + (e + i) | 0, this.chromeBugWorkAround = !0;\n        this.h0 = this.h0 + f | 0, this.h1 = this.h1 + c | 0, this.h2 = this.h2 + l | 0, this.h3 = this.h3 + y | 0, this.h4 = this.h4 + p | 0, this.h5 = this.h5 + d | 0, this.h6 = this.h6 + w | 0, this.h7 = this.h7 + b | 0;\n    }, v.prototype.hex = function() {\n        this.finalize();\n        var t = this.h0, e = this.h1, r = this.h2, i = this.h3, h = this.h4, s = this.h5, n = this.h6, a = this.h7, f = o[t >>> 28 & 15] + o[t >>> 24 & 15] + o[t >>> 20 & 15] + o[t >>> 16 & 15] + o[t >>> 12 & 15] + o[t >>> 8 & 15] + o[t >>> 4 & 15] + o[15 & t] + o[e >>> 28 & 15] + o[e >>> 24 & 15] + o[e >>> 20 & 15] + o[e >>> 16 & 15] + o[e >>> 12 & 15] + o[e >>> 8 & 15] + o[e >>> 4 & 15] + o[15 & e] + o[r >>> 28 & 15] + o[r >>> 24 & 15] + o[r >>> 20 & 15] + o[r >>> 16 & 15] + o[r >>> 12 & 15] + o[r >>> 8 & 15] + o[r >>> 4 & 15] + o[15 & r] + o[i >>> 28 & 15] + o[i >>> 24 & 15] + o[i >>> 20 & 15] + o[i >>> 16 & 15] + o[i >>> 12 & 15] + o[i >>> 8 & 15] + o[i >>> 4 & 15] + o[15 & i] + o[h >>> 28 & 15] + o[h >>> 24 & 15] + o[h >>> 20 & 15] + o[h >>> 16 & 15] + o[h >>> 12 & 15] + o[h >>> 8 & 15] + o[h >>> 4 & 15] + o[15 & h] + o[s >>> 28 & 15] + o[s >>> 24 & 15] + o[s >>> 20 & 15] + o[s >>> 16 & 15] + o[s >>> 12 & 15] + o[s >>> 8 & 15] + o[s >>> 4 & 15] + o[15 & s] + o[n >>> 28 & 15] + o[n >>> 24 & 15] + o[n >>> 20 & 15] + o[n >>> 16 & 15] + o[n >>> 12 & 15] + o[n >>> 8 & 15] + o[n >>> 4 & 15] + o[15 & n];\n        return this.is224 || (f += o[a >>> 28 & 15] + o[a >>> 24 & 15] + o[a >>> 20 & 15] + o[a >>> 16 & 15] + o[a >>> 12 & 15] + o[a >>> 8 & 15] + o[a >>> 4 & 15] + o[15 & a]), f;\n    }, v.prototype.toString = v.prototype.hex, v.prototype.digest = function() {\n        this.finalize();\n        var t = this.h0, e = this.h1, r = this.h2, i = this.h3, h = this.h4, s = this.h5, n = this.h6, o = this.h7, a = [\n            t >>> 24 & 255,\n            t >>> 16 & 255,\n            t >>> 8 & 255,\n            255 & t,\n            e >>> 24 & 255,\n            e >>> 16 & 255,\n            e >>> 8 & 255,\n            255 & e,\n            r >>> 24 & 255,\n            r >>> 16 & 255,\n            r >>> 8 & 255,\n            255 & r,\n            i >>> 24 & 255,\n            i >>> 16 & 255,\n            i >>> 8 & 255,\n            255 & i,\n            h >>> 24 & 255,\n            h >>> 16 & 255,\n            h >>> 8 & 255,\n            255 & h,\n            s >>> 24 & 255,\n            s >>> 16 & 255,\n            s >>> 8 & 255,\n            255 & s,\n            n >>> 24 & 255,\n            n >>> 16 & 255,\n            n >>> 8 & 255,\n            255 & n\n        ];\n        return this.is224 || a.push(o >>> 24 & 255, o >>> 16 & 255, o >>> 8 & 255, 255 & o), a;\n    }, v.prototype.array = v.prototype.digest, v.prototype.arrayBuffer = function() {\n        this.finalize();\n        var t = new ArrayBuffer(this.is224 ? 28 : 32), e = new DataView(t);\n        return e.setUint32(0, this.h0), e.setUint32(4, this.h1), e.setUint32(8, this.h2), e.setUint32(12, this.h3), e.setUint32(16, this.h4), e.setUint32(20, this.h5), e.setUint32(24, this.h6), this.is224 || e.setUint32(28, this.h7), t;\n    }, A.prototype = new v, A.prototype.finalize = function() {\n        if (v.prototype.finalize.call(this), this.inner) {\n            this.inner = !1;\n            var t = this.array();\n            v.call(this, this.is224, this.sharedMemory), this.update(this.oKeyPad), this.update(t), v.prototype.finalize.call(this);\n        }\n    };\n    var g = p();\n    g.sha256 = g, g.sha224 = p(!0), g.sha256.hmac = b(), g.sha224.hmac = b(!0), s ? k.exports = g : (r.sha256 = g.sha256, r.sha224 = g.sha224);\n}();\nvar U = x.exports, z = x.exports.sha224, J = x.exports.sha256;\nfunction parseSha256(s) {\n    return toByteArray(s);\n}\nfunction isHex(s) {\n    const hexRegex = /^[0-9A-Fa-f]+$/;\n    if (!hexRegex.test(s)) {\n        return false;\n    }\n    const isAllUpperCase = /^[0-9A-F]+$/.test(s);\n    const isAllLowerCase = /^[0-9a-f]+$/.test(s);\n    if (!(isAllUpperCase || isAllLowerCase)) {\n        return false;\n    }\n    return s.length % 2 === 0;\n}\nfunction isBase64(s) {\n    return /^[A-Za-z0-9\\-_]*(={0,2})?$/.test(s) || /^[A-Za-z0-9+/]*(={0,2})?$/.test(s);\n}\nfunction detectEncoding(input) {\n    if (isHex(input)) {\n        return \"hex\";\n    } else if (isBase64(input)) {\n        return \"b64\";\n    }\n    return \"\";\n}\nfunction hexToByteArray(s) {\n    if (s.length % 2 !== 0) {\n        throw new Error(\"hex string must have an even length\");\n    }\n    const a = new Uint8Array(s.length / 2);\n    for(let i = 0; i < s.length; i += 2){\n        a[i / 2] = parseInt(s.substring(i, i + 2), 16);\n    }\n    return a;\n}\nfunction base64ToByteArray(s) {\n    s = s.replace(/-/g, \"+\");\n    s = s.replace(/_/g, \"/\");\n    const sbin = atob(s);\n    return Uint8Array.from(sbin, (c)=>c.charCodeAt(0));\n}\nfunction toByteArray(input) {\n    const encoding = detectEncoding(input);\n    switch(encoding){\n        case \"hex\":\n            return hexToByteArray(input);\n        case \"b64\":\n            return base64ToByteArray(input);\n    }\n    return null;\n}\nfunction checkSha256(a, b) {\n    const aBytes = typeof a === \"string\" ? parseSha256(a) : a;\n    const bBytes = typeof b === \"string\" ? parseSha256(b) : b;\n    if (aBytes === null || bBytes === null) {\n        return false;\n    }\n    if (aBytes.length !== bBytes.length) {\n        return false;\n    }\n    for(let i = 0; i < aBytes.length; i++){\n        if (aBytes[i] !== bBytes[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nclass BaseRequest {\n    token;\n    received;\n    ctx;\n    requestSubject;\n    mux;\n    constructor(mux, requestSubject, asyncTraces = true){\n        this.mux = mux;\n        this.requestSubject = requestSubject;\n        this.received = 0;\n        this.token = nuid.next();\n        if (asyncTraces) {\n            this.ctx = new Error();\n        }\n    }\n}\nclass RequestMany extends BaseRequest {\n    callback;\n    done;\n    timer;\n    max;\n    opts;\n    constructor(mux, requestSubject, opts = {\n        maxWait: 1000\n    }){\n        super(mux, requestSubject);\n        this.opts = opts;\n        if (typeof this.opts.callback !== \"function\") {\n            throw new Error(\"callback is required\");\n        }\n        this.callback = this.opts.callback;\n        this.max = typeof opts.maxMessages === \"number\" && opts.maxMessages > 0 ? opts.maxMessages : -1;\n        this.done = deferred();\n        this.done.then(()=>{\n            this.callback(null, null);\n        });\n        this.timer = setTimeout(()=>{\n            this.cancel();\n        }, opts.maxWait);\n    }\n    cancel(err) {\n        if (err) {\n            this.callback(err, null);\n        }\n        clearTimeout(this.timer);\n        this.mux.cancel(this);\n        this.done.resolve();\n    }\n    resolver(err, msg) {\n        if (err) {\n            if (this.ctx) {\n                err.stack += `\\n\\n${this.ctx.stack}`;\n            }\n            this.cancel(err);\n        } else {\n            this.callback(null, msg);\n            if (this.opts.strategy === RequestStrategy.Count) {\n                this.max--;\n                if (this.max === 0) {\n                    this.cancel();\n                }\n            }\n            if (this.opts.strategy === RequestStrategy.JitterTimer) {\n                clearTimeout(this.timer);\n                this.timer = setTimeout(()=>{\n                    this.cancel();\n                }, this.opts.jitter || 300);\n            }\n            if (this.opts.strategy === RequestStrategy.SentinelMsg) {\n                if (msg && msg.data.length === 0) {\n                    this.cancel();\n                }\n            }\n        }\n    }\n}\nclass RequestOne extends BaseRequest {\n    deferred;\n    timer;\n    constructor(mux, requestSubject, opts = {\n        timeout: 1000\n    }, asyncTraces = true){\n        super(mux, requestSubject, asyncTraces);\n        this.deferred = deferred();\n        this.timer = timeout(opts.timeout, asyncTraces);\n    }\n    resolver(err, msg) {\n        if (this.timer) {\n            this.timer.cancel();\n        }\n        if (err) {\n            if (this.ctx) {\n                err.stack += `\\n\\n${this.ctx.stack}`;\n            }\n            this.deferred.reject(err);\n        } else {\n            this.deferred.resolve(msg);\n        }\n        this.cancel();\n    }\n    cancel(err) {\n        if (this.timer) {\n            this.timer.cancel();\n        }\n        this.mux.cancel(this);\n        this.deferred.reject(err ? err : NatsError.errorForCode(ErrorCode.Cancelled));\n    }\n}\nconst defaultPrefix = \"$JS.API\";\nfunction defaultJsOptions(opts) {\n    opts = opts || {};\n    if (opts.domain) {\n        opts.apiPrefix = `$JS.${opts.domain}.API`;\n        delete opts.domain;\n    }\n    return extend({\n        apiPrefix: defaultPrefix,\n        timeout: 5000\n    }, opts);\n}\nclass BaseApiClient {\n    nc;\n    opts;\n    prefix;\n    timeout;\n    jc;\n    constructor(nc, opts){\n        this.nc = nc;\n        this.opts = defaultJsOptions(opts);\n        this._parseOpts();\n        this.prefix = this.opts.apiPrefix;\n        this.timeout = this.opts.timeout;\n        this.jc = JSONCodec();\n    }\n    getOptions() {\n        return Object.assign({}, this.opts);\n    }\n    _parseOpts() {\n        let prefix = this.opts.apiPrefix;\n        if (!prefix || prefix.length === 0) {\n            throw new Error(\"invalid empty prefix\");\n        }\n        const c = prefix[prefix.length - 1];\n        if (c === \".\") {\n            prefix = prefix.substr(0, prefix.length - 1);\n        }\n        this.opts.apiPrefix = prefix;\n    }\n    async _request(subj, data = null, opts) {\n        opts = opts || {};\n        opts.timeout = this.timeout;\n        let a = Empty;\n        if (data) {\n            a = this.jc.encode(data);\n        }\n        let { retries } = opts;\n        retries = retries || 1;\n        retries = retries === -1 ? Number.MAX_SAFE_INTEGER : retries;\n        const bo = backoff();\n        for(let i = 0; i < retries; i++){\n            try {\n                const m = await this.nc.request(subj, a, opts);\n                return this.parseJsResponse(m);\n            } catch (err) {\n                const ne = err;\n                if ((ne.code === \"503\" || ne.code === ErrorCode.Timeout) && i + 1 < retries) {\n                    await delay(bo.backoff(i));\n                } else {\n                    throw err;\n                }\n            }\n        }\n    }\n    async findStream(subject) {\n        const q = {\n            subject\n        };\n        const r = await this._request(`${this.prefix}.STREAM.NAMES`, q);\n        const names = r;\n        if (!names.streams || names.streams.length !== 1) {\n            throw new Error(\"no stream matches subject\");\n        }\n        return names.streams[0];\n    }\n    getConnection() {\n        return this.nc;\n    }\n    parseJsResponse(m) {\n        const v = this.jc.decode(m.data);\n        const r = v;\n        if (r.error) {\n            const err = checkJsErrorCode(r.error.code, r.error.description);\n            if (err !== null) {\n                err.api_error = r.error;\n                throw err;\n            }\n        }\n        return v;\n    }\n}\nclass ListerImpl {\n    err;\n    offset;\n    pageInfo;\n    subject;\n    jsm;\n    filter;\n    payload;\n    constructor(subject, filter, jsm, payload){\n        if (!subject) {\n            throw new Error(\"subject is required\");\n        }\n        this.subject = subject;\n        this.jsm = jsm;\n        this.offset = 0;\n        this.pageInfo = {};\n        this.filter = filter;\n        this.payload = payload || {};\n    }\n    async next() {\n        if (this.err) {\n            return [];\n        }\n        if (this.pageInfo && this.offset >= this.pageInfo.total) {\n            return [];\n        }\n        const offset = {\n            offset: this.offset\n        };\n        if (this.payload) {\n            Object.assign(offset, this.payload);\n        }\n        try {\n            const r = await this.jsm._request(this.subject, offset, {\n                timeout: this.jsm.timeout\n            });\n            this.pageInfo = r;\n            const count = this.countResponse(r);\n            if (count === 0) {\n                return [];\n            }\n            this.offset += count;\n            const a = this.filter(r);\n            return a;\n        } catch (err) {\n            this.err = err;\n            throw err;\n        }\n    }\n    countResponse(r) {\n        switch(r?.type){\n            case \"io.nats.jetstream.api.v1.stream_names_response\":\n            case \"io.nats.jetstream.api.v1.stream_list_response\":\n                return r.streams?.length || 0;\n            case \"io.nats.jetstream.api.v1.consumer_list_response\":\n                return r.consumers?.length || 0;\n            default:\n                console.error(`jslister.ts: unknown API response for paged output: ${r?.type}`);\n                return r.streams?.length || 0;\n        }\n        return 0;\n    }\n    async *[Symbol.asyncIterator]() {\n        let page = await this.next();\n        while(page.length > 0){\n            for (const item of page){\n                yield item;\n            }\n            page = await this.next();\n        }\n    }\n}\nfunction parseSemVer(s = \"\") {\n    const m = s.match(/(\\d+).(\\d+).(\\d+)/);\n    if (m) {\n        return {\n            major: parseInt(m[1]),\n            minor: parseInt(m[2]),\n            micro: parseInt(m[3])\n        };\n    }\n    throw new Error(`'${s}' is not a semver value`);\n}\nfunction compare(a, b) {\n    if (a.major < b.major) return -1;\n    if (a.major > b.major) return 1;\n    if (a.minor < b.minor) return -1;\n    if (a.minor > b.minor) return 1;\n    if (a.micro < b.micro) return -1;\n    if (a.micro > b.micro) return 1;\n    return 0;\n}\nvar Feature;\n(function(Feature) {\n    Feature[\"JS_KV\"] = \"js_kv\";\n    Feature[\"JS_OBJECTSTORE\"] = \"js_objectstore\";\n    Feature[\"JS_PULL_MAX_BYTES\"] = \"js_pull_max_bytes\";\n    Feature[\"JS_NEW_CONSUMER_CREATE_API\"] = \"js_new_consumer_create\";\n    Feature[\"JS_ALLOW_DIRECT\"] = \"js_allow_direct\";\n    Feature[\"JS_MULTIPLE_CONSUMER_FILTER\"] = \"js_multiple_consumer_filter\";\n    Feature[\"JS_SIMPLIFICATION\"] = \"js_simplification\";\n    Feature[\"JS_STREAM_CONSUMER_METADATA\"] = \"js_stream_consumer_metadata\";\n    Feature[\"JS_CONSUMER_FILTER_SUBJECTS\"] = \"js_consumer_filter_subjects\";\n    Feature[\"JS_STREAM_FIRST_SEQ\"] = \"js_stream_first_seq\";\n    Feature[\"JS_STREAM_SUBJECT_TRANSFORM\"] = \"js_stream_subject_transform\";\n    Feature[\"JS_STREAM_SOURCE_SUBJECT_TRANSFORM\"] = \"js_stream_source_subject_transform\";\n    Feature[\"JS_STREAM_COMPRESSION\"] = \"js_stream_compression\";\n    Feature[\"JS_DEFAULT_CONSUMER_LIMITS\"] = \"js_default_consumer_limits\";\n    Feature[\"JS_BATCH_DIRECT_GET\"] = \"js_batch_direct_get\";\n})(Feature || (Feature = {}));\nclass Features {\n    server;\n    features;\n    disabled;\n    constructor(v){\n        this.features = new Map();\n        this.disabled = [];\n        this.update(v);\n    }\n    resetDisabled() {\n        this.disabled.length = 0;\n        this.update(this.server);\n    }\n    disable(f) {\n        this.disabled.push(f);\n        this.update(this.server);\n    }\n    isDisabled(f) {\n        return this.disabled.indexOf(f) !== -1;\n    }\n    update(v) {\n        if (typeof v === \"string\") {\n            v = parseSemVer(v);\n        }\n        this.server = v;\n        this.set(Feature.JS_KV, \"2.6.2\");\n        this.set(Feature.JS_OBJECTSTORE, \"2.6.3\");\n        this.set(Feature.JS_PULL_MAX_BYTES, \"2.8.3\");\n        this.set(Feature.JS_NEW_CONSUMER_CREATE_API, \"2.9.0\");\n        this.set(Feature.JS_ALLOW_DIRECT, \"2.9.0\");\n        this.set(Feature.JS_MULTIPLE_CONSUMER_FILTER, \"2.10.0\");\n        this.set(Feature.JS_SIMPLIFICATION, \"2.9.4\");\n        this.set(Feature.JS_STREAM_CONSUMER_METADATA, \"2.10.0\");\n        this.set(Feature.JS_CONSUMER_FILTER_SUBJECTS, \"2.10.0\");\n        this.set(Feature.JS_STREAM_FIRST_SEQ, \"2.10.0\");\n        this.set(Feature.JS_STREAM_SUBJECT_TRANSFORM, \"2.10.0\");\n        this.set(Feature.JS_STREAM_SOURCE_SUBJECT_TRANSFORM, \"2.10.0\");\n        this.set(Feature.JS_STREAM_COMPRESSION, \"2.10.0\");\n        this.set(Feature.JS_DEFAULT_CONSUMER_LIMITS, \"2.10.0\");\n        this.set(Feature.JS_BATCH_DIRECT_GET, \"2.11.0\");\n        this.disabled.forEach((f)=>{\n            this.features.delete(f);\n        });\n    }\n    set(f, requires) {\n        this.features.set(f, {\n            min: requires,\n            ok: compare(this.server, parseSemVer(requires)) >= 0\n        });\n    }\n    get(f) {\n        return this.features.get(f) || {\n            min: \"unknown\",\n            ok: false\n        };\n    }\n    supports(f) {\n        return this.get(f)?.ok || false;\n    }\n    require(v) {\n        if (typeof v === \"string\") {\n            v = parseSemVer(v);\n        }\n        return compare(this.server, v) >= 0;\n    }\n}\nclass ConsumerAPIImpl extends BaseApiClient {\n    constructor(nc, opts){\n        super(nc, opts);\n    }\n    async add(stream, cfg, action = ConsumerApiAction.Create) {\n        validateStreamName(stream);\n        if (cfg.deliver_group && cfg.flow_control) {\n            throw new Error(\"jetstream flow control is not supported with queue groups\");\n        }\n        if (cfg.deliver_group && cfg.idle_heartbeat) {\n            throw new Error(\"jetstream idle heartbeat is not supported with queue groups\");\n        }\n        const cr = {};\n        cr.config = cfg;\n        cr.stream_name = stream;\n        cr.action = action;\n        if (cr.config.durable_name) {\n            validateDurableName(cr.config.durable_name);\n        }\n        const nci = this.nc;\n        let { min, ok: newAPI } = nci.features.get(Feature.JS_NEW_CONSUMER_CREATE_API);\n        const name = cfg.name === \"\" ? undefined : cfg.name;\n        if (name && !newAPI) {\n            throw new Error(`consumer 'name' requires server ${min}`);\n        }\n        if (name) {\n            try {\n                minValidation(\"name\", name);\n            } catch (err) {\n                const m = err.message;\n                const idx = m.indexOf(\"cannot contain\");\n                if (idx !== -1) {\n                    throw new Error(`consumer 'name' ${m.substring(idx)}`);\n                }\n                throw err;\n            }\n        }\n        let subj;\n        let consumerName = \"\";\n        if (Array.isArray(cfg.filter_subjects)) {\n            const { min, ok } = nci.features.get(Feature.JS_MULTIPLE_CONSUMER_FILTER);\n            if (!ok) {\n                throw new Error(`consumer 'filter_subjects' requires server ${min}`);\n            }\n            newAPI = false;\n        }\n        if (cfg.metadata) {\n            const { min, ok } = nci.features.get(Feature.JS_STREAM_CONSUMER_METADATA);\n            if (!ok) {\n                throw new Error(`consumer 'metadata' requires server ${min}`);\n            }\n        }\n        if (newAPI) {\n            consumerName = cfg.name ?? cfg.durable_name ?? \"\";\n        }\n        if (consumerName !== \"\") {\n            let fs = cfg.filter_subject ?? undefined;\n            if (fs === \">\") {\n                fs = undefined;\n            }\n            subj = fs !== undefined ? `${this.prefix}.CONSUMER.CREATE.${stream}.${consumerName}.${fs}` : `${this.prefix}.CONSUMER.CREATE.${stream}.${consumerName}`;\n        } else {\n            subj = cfg.durable_name ? `${this.prefix}.CONSUMER.DURABLE.CREATE.${stream}.${cfg.durable_name}` : `${this.prefix}.CONSUMER.CREATE.${stream}`;\n        }\n        const r = await this._request(subj, cr);\n        return r;\n    }\n    async update(stream, durable, cfg) {\n        const ci = await this.info(stream, durable);\n        const changable = cfg;\n        return this.add(stream, Object.assign(ci.config, changable), ConsumerApiAction.Update);\n    }\n    async info(stream, name) {\n        validateStreamName(stream);\n        validateDurableName(name);\n        const r = await this._request(`${this.prefix}.CONSUMER.INFO.${stream}.${name}`);\n        return r;\n    }\n    async delete(stream, name) {\n        validateStreamName(stream);\n        validateDurableName(name);\n        const r = await this._request(`${this.prefix}.CONSUMER.DELETE.${stream}.${name}`);\n        const cr = r;\n        return cr.success;\n    }\n    list(stream) {\n        validateStreamName(stream);\n        const filter = (v)=>{\n            const clr = v;\n            return clr.consumers;\n        };\n        const subj = `${this.prefix}.CONSUMER.LIST.${stream}`;\n        return new ListerImpl(subj, filter, this);\n    }\n    pause(stream, name, until) {\n        const subj = `${this.prefix}.CONSUMER.PAUSE.${stream}.${name}`;\n        const opts = {\n            pause_until: until.toISOString()\n        };\n        return this._request(subj, opts);\n    }\n    resume(stream, name) {\n        return this.pause(stream, name, new Date(0));\n    }\n}\nfunction checkFn(fn, name, required = false) {\n    if (required === true && !fn) {\n        throw NatsError.errorForCode(ErrorCode.ApiError, new Error(`${name} is not a function`));\n    }\n    if (fn && typeof fn !== \"function\") {\n        throw NatsError.errorForCode(ErrorCode.ApiError, new Error(`${name} is not a function`));\n    }\n}\nclass TypedSubscription extends QueuedIteratorImpl {\n    sub;\n    adapter;\n    subIterDone;\n    constructor(nc, subject, opts){\n        super();\n        checkFn(opts.adapter, \"adapter\", true);\n        this.adapter = opts.adapter;\n        if (opts.callback) {\n            checkFn(opts.callback, \"callback\");\n        }\n        this.noIterator = typeof opts.callback === \"function\";\n        if (opts.ingestionFilterFn) {\n            checkFn(opts.ingestionFilterFn, \"ingestionFilterFn\");\n            this.ingestionFilterFn = opts.ingestionFilterFn;\n        }\n        if (opts.protocolFilterFn) {\n            checkFn(opts.protocolFilterFn, \"protocolFilterFn\");\n            this.protocolFilterFn = opts.protocolFilterFn;\n        }\n        if (opts.dispatchedFn) {\n            checkFn(opts.dispatchedFn, \"dispatchedFn\");\n            this.dispatchedFn = opts.dispatchedFn;\n        }\n        if (opts.cleanupFn) {\n            checkFn(opts.cleanupFn, \"cleanupFn\");\n        }\n        let callback = (err, msg)=>{\n            this.callback(err, msg);\n        };\n        if (opts.callback) {\n            const uh = opts.callback;\n            callback = (err, msg)=>{\n                const [jer, tm] = this.adapter(err, msg);\n                if (jer) {\n                    uh(jer, null);\n                    return;\n                }\n                const { ingest } = this.ingestionFilterFn ? this.ingestionFilterFn(tm, this) : {\n                    ingest: true\n                };\n                if (ingest) {\n                    const ok = this.protocolFilterFn ? this.protocolFilterFn(tm) : true;\n                    if (ok) {\n                        uh(jer, tm);\n                        if (this.dispatchedFn && tm) {\n                            this.dispatchedFn(tm);\n                        }\n                    }\n                }\n            };\n        }\n        const { max, queue, timeout } = opts;\n        const sopts = {\n            queue,\n            timeout,\n            callback\n        };\n        if (max && max > 0) {\n            sopts.max = max;\n        }\n        this.sub = nc.subscribe(subject, sopts);\n        if (opts.cleanupFn) {\n            this.sub.cleanupFn = opts.cleanupFn;\n        }\n        if (!this.noIterator) {\n            this.iterClosed.then(()=>{\n                this.unsubscribe();\n            });\n        }\n        this.subIterDone = deferred();\n        Promise.all([\n            this.sub.closed,\n            this.iterClosed\n        ]).then(()=>{\n            this.subIterDone.resolve();\n        }).catch(()=>{\n            this.subIterDone.resolve();\n        });\n        (async (s)=>{\n            await s.closed;\n            this.stop();\n        })(this.sub).then().catch();\n    }\n    unsubscribe(max) {\n        this.sub.unsubscribe(max);\n    }\n    drain() {\n        return this.sub.drain();\n    }\n    isDraining() {\n        return this.sub.isDraining();\n    }\n    isClosed() {\n        return this.sub.isClosed();\n    }\n    callback(e, msg) {\n        this.sub.cancelTimeout();\n        const [err, tm] = this.adapter(e, msg);\n        if (err) {\n            this.stop(err);\n        }\n        if (tm) {\n            this.push(tm);\n        }\n    }\n    getSubject() {\n        return this.sub.getSubject();\n    }\n    getReceived() {\n        return this.sub.getReceived();\n    }\n    getProcessed() {\n        return this.sub.getProcessed();\n    }\n    getPending() {\n        return this.sub.getPending();\n    }\n    getID() {\n        return this.sub.getID();\n    }\n    getMax() {\n        return this.sub.getMax();\n    }\n    get closed() {\n        return this.sub.closed;\n    }\n}\nlet transportConfig;\nfunction setTransportFactory(config) {\n    transportConfig = config;\n}\nfunction defaultPort() {\n    return transportConfig !== undefined && transportConfig.defaultPort !== undefined ? transportConfig.defaultPort : 4222;\n}\nfunction getUrlParseFn() {\n    return transportConfig !== undefined && transportConfig.urlParseFn ? transportConfig.urlParseFn : undefined;\n}\nfunction newTransport() {\n    if (!transportConfig || typeof transportConfig.factory !== \"function\") {\n        throw new Error(\"transport fn is not set\");\n    }\n    return transportConfig.factory();\n}\nfunction getResolveFn() {\n    return transportConfig !== undefined && transportConfig.dnsResolveFn ? transportConfig.dnsResolveFn : undefined;\n}\nconst CR_LF = \"\\r\\n\";\nCR_LF.length;\nconst CRLF = DataBuffer.fromAscii(CR_LF);\nconst CR = new Uint8Array(CRLF)[0];\nconst LF = new Uint8Array(CRLF)[1];\nfunction protoLen(ba) {\n    for(let i = 0; i < ba.length; i++){\n        const n = i + 1;\n        if (ba.byteLength > n && ba[i] === CR && ba[n] === LF) {\n            return n + 1;\n        }\n    }\n    return 0;\n}\nfunction extractProtocolMessage(a) {\n    const len = protoLen(a);\n    if (len > 0) {\n        const ba = new Uint8Array(a);\n        const out = ba.slice(0, len);\n        return TD.decode(out);\n    }\n    return \"\";\n}\nconst IPv4LEN = 4;\nconst ASCII0 = 48;\nconst ASCIIA = 65;\nconst ASCIIa = 97;\nfunction ipV4(a, b, c, d) {\n    const ip = new Uint8Array(16);\n    const prefix = [\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0xff,\n        0xff\n    ];\n    prefix.forEach((v, idx)=>{\n        ip[idx] = v;\n    });\n    ip[12] = a;\n    ip[13] = b;\n    ip[14] = c;\n    ip[15] = d;\n    return ip;\n}\nfunction isIP(h) {\n    return parseIP(h) !== undefined;\n}\nfunction parseIP(h) {\n    for(let i = 0; i < h.length; i++){\n        switch(h[i]){\n            case \".\":\n                return parseIPv4(h);\n            case \":\":\n                return parseIPv6(h);\n        }\n    }\n    return;\n}\nfunction parseIPv4(s) {\n    const ip = new Uint8Array(4);\n    for(let i = 0; i < 4; i++){\n        if (s.length === 0) {\n            return undefined;\n        }\n        if (i > 0) {\n            if (s[0] !== \".\") {\n                return undefined;\n            }\n            s = s.substring(1);\n        }\n        const { n, c, ok } = dtoi(s);\n        if (!ok || n > 0xFF) {\n            return undefined;\n        }\n        s = s.substring(c);\n        ip[i] = n;\n    }\n    return ipV4(ip[0], ip[1], ip[2], ip[3]);\n}\nfunction parseIPv6(s) {\n    const ip = new Uint8Array(16);\n    let ellipsis = -1;\n    if (s.length >= 2 && s[0] === \":\" && s[1] === \":\") {\n        ellipsis = 0;\n        s = s.substring(2);\n        if (s.length === 0) {\n            return ip;\n        }\n    }\n    let i = 0;\n    while(i < 16){\n        const { n, c, ok } = xtoi(s);\n        if (!ok || n > 0xFFFF) {\n            return undefined;\n        }\n        if (c < s.length && s[c] === \".\") {\n            if (ellipsis < 0 && i != 16 - 4) {\n                return undefined;\n            }\n            if (i + 4 > 16) {\n                return undefined;\n            }\n            const ip4 = parseIPv4(s);\n            if (ip4 === undefined) {\n                return undefined;\n            }\n            ip[i] = ip4[12];\n            ip[i + 1] = ip4[13];\n            ip[i + 2] = ip4[14];\n            ip[i + 3] = ip4[15];\n            s = \"\";\n            i += IPv4LEN;\n            break;\n        }\n        ip[i] = n >> 8;\n        ip[i + 1] = n;\n        i += 2;\n        s = s.substring(c);\n        if (s.length === 0) {\n            break;\n        }\n        if (s[0] !== \":\" || s.length == 1) {\n            return undefined;\n        }\n        s = s.substring(1);\n        if (s[0] === \":\") {\n            if (ellipsis >= 0) {\n                return undefined;\n            }\n            ellipsis = i;\n            s = s.substring(1);\n            if (s.length === 0) {\n                break;\n            }\n        }\n    }\n    if (s.length !== 0) {\n        return undefined;\n    }\n    if (i < 16) {\n        if (ellipsis < 0) {\n            return undefined;\n        }\n        const n = 16 - i;\n        for(let j = i - 1; j >= ellipsis; j--){\n            ip[j + n] = ip[j];\n        }\n        for(let j = ellipsis + n - 1; j >= ellipsis; j--){\n            ip[j] = 0;\n        }\n    } else if (ellipsis >= 0) {\n        return undefined;\n    }\n    return ip;\n}\nfunction dtoi(s) {\n    let i = 0;\n    let n = 0;\n    for(i = 0; i < s.length && 48 <= s.charCodeAt(i) && s.charCodeAt(i) <= 57; i++){\n        n = n * 10 + (s.charCodeAt(i) - ASCII0);\n        if (n >= 0xFFFFFF) {\n            return {\n                n: 0xFFFFFF,\n                c: i,\n                ok: false\n            };\n        }\n    }\n    if (i === 0) {\n        return {\n            n: 0,\n            c: 0,\n            ok: false\n        };\n    }\n    return {\n        n: n,\n        c: i,\n        ok: true\n    };\n}\nfunction xtoi(s) {\n    let n = 0;\n    let i = 0;\n    for(i = 0; i < s.length; i++){\n        if (48 <= s.charCodeAt(i) && s.charCodeAt(i) <= 57) {\n            n *= 16;\n            n += s.charCodeAt(i) - ASCII0;\n        } else if (97 <= s.charCodeAt(i) && s.charCodeAt(i) <= 102) {\n            n *= 16;\n            n += s.charCodeAt(i) - ASCIIa + 10;\n        } else if (65 <= s.charCodeAt(i) && s.charCodeAt(i) <= 70) {\n            n *= 16;\n            n += s.charCodeAt(i) - ASCIIA + 10;\n        } else {\n            break;\n        }\n        if (n >= 0xFFFFFF) {\n            return {\n                n: 0,\n                c: i,\n                ok: false\n            };\n        }\n    }\n    if (i === 0) {\n        return {\n            n: 0,\n            c: i,\n            ok: false\n        };\n    }\n    return {\n        n: n,\n        c: i,\n        ok: true\n    };\n}\nfunction isIPV4OrHostname(hp) {\n    if (hp.indexOf(\"[\") !== -1 || hp.indexOf(\"::\") !== -1) {\n        return false;\n    }\n    if (hp.indexOf(\".\") !== -1) {\n        return true;\n    }\n    if (hp.split(\":\").length <= 2) {\n        return true;\n    }\n    return false;\n}\nfunction isIPV6(hp) {\n    return !isIPV4OrHostname(hp);\n}\nfunction filterIpv6MappedToIpv4(hp) {\n    const prefix = \"::FFFF:\";\n    const idx = hp.toUpperCase().indexOf(prefix);\n    if (idx !== -1 && hp.indexOf(\".\") !== -1) {\n        let ip = hp.substring(idx + prefix.length);\n        ip = ip.replace(\"[\", \"\");\n        return ip.replace(\"]\", \"\");\n    }\n    return hp;\n}\nfunction hostPort(u) {\n    u = u.trim();\n    if (u.match(/^(.*:\\/\\/)(.*)/m)) {\n        u = u.replace(/^(.*:\\/\\/)(.*)/gm, \"$2\");\n    }\n    u = filterIpv6MappedToIpv4(u);\n    if (isIPV6(u) && u.indexOf(\"[\") === -1) {\n        u = `[${u}]`;\n    }\n    const op = isIPV6(u) ? u.match(/(]:)(\\d+)/) : u.match(/(:)(\\d+)/);\n    const port = op && op.length === 3 && op[1] && op[2] ? parseInt(op[2]) : 4222;\n    const protocol = port === 80 ? \"https\" : \"http\";\n    const url = new URL(`${protocol}://${u}`);\n    url.port = `${port}`;\n    let hostname = url.hostname;\n    if (hostname.charAt(0) === \"[\") {\n        hostname = hostname.substring(1, hostname.length - 1);\n    }\n    const listen = url.host;\n    return {\n        listen,\n        hostname,\n        port\n    };\n}\nclass ServerImpl {\n    src;\n    listen;\n    hostname;\n    port;\n    didConnect;\n    reconnects;\n    lastConnect;\n    gossiped;\n    tlsName;\n    resolves;\n    constructor(u, gossiped = false){\n        this.src = u;\n        this.tlsName = \"\";\n        const v = hostPort(u);\n        this.listen = v.listen;\n        this.hostname = v.hostname;\n        this.port = v.port;\n        this.didConnect = false;\n        this.reconnects = 0;\n        this.lastConnect = 0;\n        this.gossiped = gossiped;\n    }\n    toString() {\n        return this.listen;\n    }\n    async resolve(opts) {\n        if (!opts.fn || opts.resolve === false) {\n            return [\n                this\n            ];\n        }\n        const buf = [];\n        if (isIP(this.hostname)) {\n            return [\n                this\n            ];\n        } else {\n            const ips = await opts.fn(this.hostname);\n            if (opts.debug) {\n                console.log(`resolve ${this.hostname} = ${ips.join(\",\")}`);\n            }\n            for (const ip of ips){\n                const proto = this.port === 80 ? \"https\" : \"http\";\n                const url = new URL(`${proto}://${isIPV6(ip) ? \"[\" + ip + \"]\" : ip}`);\n                url.port = `${this.port}`;\n                const ss = new ServerImpl(url.host, false);\n                ss.tlsName = this.hostname;\n                buf.push(ss);\n            }\n        }\n        if (opts.randomize) {\n            shuffle(buf);\n        }\n        this.resolves = buf;\n        return buf;\n    }\n}\nclass Servers {\n    firstSelect;\n    servers;\n    currentServer;\n    tlsName;\n    randomize;\n    constructor(listens = [], opts = {}){\n        this.firstSelect = true;\n        this.servers = [];\n        this.tlsName = \"\";\n        this.randomize = opts.randomize || false;\n        const urlParseFn = getUrlParseFn();\n        if (listens) {\n            listens.forEach((hp)=>{\n                hp = urlParseFn ? urlParseFn(hp) : hp;\n                this.servers.push(new ServerImpl(hp));\n            });\n            if (this.randomize) {\n                this.servers = shuffle(this.servers);\n            }\n        }\n        if (this.servers.length === 0) {\n            this.addServer(`${DEFAULT_HOST}:${defaultPort()}`, false);\n        }\n        this.currentServer = this.servers[0];\n    }\n    clear() {\n        this.servers.length = 0;\n    }\n    updateTLSName() {\n        const cs = this.getCurrentServer();\n        if (!isIP(cs.hostname)) {\n            this.tlsName = cs.hostname;\n            this.servers.forEach((s)=>{\n                if (s.gossiped) {\n                    s.tlsName = this.tlsName;\n                }\n            });\n        }\n    }\n    getCurrentServer() {\n        return this.currentServer;\n    }\n    addServer(u, implicit = false) {\n        const urlParseFn = getUrlParseFn();\n        u = urlParseFn ? urlParseFn(u) : u;\n        const s = new ServerImpl(u, implicit);\n        if (isIP(s.hostname)) {\n            s.tlsName = this.tlsName;\n        }\n        this.servers.push(s);\n    }\n    selectServer() {\n        if (this.firstSelect) {\n            this.firstSelect = false;\n            return this.currentServer;\n        }\n        const t = this.servers.shift();\n        if (t) {\n            this.servers.push(t);\n            this.currentServer = t;\n        }\n        return t;\n    }\n    removeCurrentServer() {\n        this.removeServer(this.currentServer);\n    }\n    removeServer(server) {\n        if (server) {\n            const index = this.servers.indexOf(server);\n            this.servers.splice(index, 1);\n        }\n    }\n    length() {\n        return this.servers.length;\n    }\n    next() {\n        return this.servers.length ? this.servers[0] : undefined;\n    }\n    getServers() {\n        return this.servers;\n    }\n    update(info, encrypted) {\n        const added = [];\n        let deleted = [];\n        const urlParseFn = getUrlParseFn();\n        const discovered = new Map();\n        if (info.connect_urls && info.connect_urls.length > 0) {\n            info.connect_urls.forEach((hp)=>{\n                hp = urlParseFn ? urlParseFn(hp, encrypted) : hp;\n                const s = new ServerImpl(hp, true);\n                discovered.set(hp, s);\n            });\n        }\n        const toDelete = [];\n        this.servers.forEach((s, index)=>{\n            const u = s.listen;\n            if (s.gossiped && this.currentServer.listen !== u && discovered.get(u) === undefined) {\n                toDelete.push(index);\n            }\n            discovered.delete(u);\n        });\n        toDelete.reverse();\n        toDelete.forEach((index)=>{\n            const removed = this.servers.splice(index, 1);\n            deleted = deleted.concat(removed[0].listen);\n        });\n        discovered.forEach((v, k)=>{\n            this.servers.push(v);\n            added.push(k);\n        });\n        return {\n            added,\n            deleted\n        };\n    }\n}\nclass MuxSubscription {\n    baseInbox;\n    reqs;\n    constructor(){\n        this.reqs = new Map();\n    }\n    size() {\n        return this.reqs.size;\n    }\n    init(prefix) {\n        this.baseInbox = `${createInbox(prefix)}.`;\n        return this.baseInbox;\n    }\n    add(r) {\n        if (!isNaN(r.received)) {\n            r.received = 0;\n        }\n        this.reqs.set(r.token, r);\n    }\n    get(token) {\n        return this.reqs.get(token);\n    }\n    cancel(r) {\n        this.reqs.delete(r.token);\n    }\n    getToken(m) {\n        const s = m.subject || \"\";\n        if (s.indexOf(this.baseInbox) === 0) {\n            return s.substring(this.baseInbox.length);\n        }\n        return null;\n    }\n    all() {\n        return Array.from(this.reqs.values());\n    }\n    handleError(isMuxPermissionError, err) {\n        if (err && err.permissionContext) {\n            if (isMuxPermissionError) {\n                this.all().forEach((r)=>{\n                    r.resolver(err, {});\n                });\n                return true;\n            }\n            const ctx = err.permissionContext;\n            if (ctx.operation === \"publish\") {\n                const req = this.all().find((s)=>{\n                    return s.requestSubject === ctx.subject;\n                });\n                if (req) {\n                    req.resolver(err, {});\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    dispatcher() {\n        return (err, m)=>{\n            const token = this.getToken(m);\n            if (token) {\n                const r = this.get(token);\n                if (r) {\n                    if (err === null && m.headers) {\n                        err = isRequestError(m);\n                    }\n                    r.resolver(err, m);\n                }\n            }\n        };\n    }\n    close() {\n        const err = NatsError.errorForCode(ErrorCode.Timeout);\n        this.reqs.forEach((req)=>{\n            req.resolver(err, {});\n        });\n    }\n}\nclass Heartbeat {\n    ph;\n    interval;\n    maxOut;\n    timer;\n    pendings;\n    constructor(ph, interval, maxOut){\n        this.ph = ph;\n        this.interval = interval;\n        this.maxOut = maxOut;\n        this.pendings = [];\n    }\n    start() {\n        this.cancel();\n        this._schedule();\n    }\n    cancel(stale) {\n        if (this.timer) {\n            clearTimeout(this.timer);\n            this.timer = undefined;\n        }\n        this._reset();\n        if (stale) {\n            this.ph.disconnect();\n        }\n    }\n    _schedule() {\n        this.timer = setTimeout(()=>{\n            this.ph.dispatchStatus({\n                type: DebugEvents.PingTimer,\n                data: `${this.pendings.length + 1}`\n            });\n            if (this.pendings.length === this.maxOut) {\n                this.cancel(true);\n                return;\n            }\n            const ping = deferred();\n            this.ph.flush(ping).then(()=>{\n                this._reset();\n            }).catch(()=>{\n                this.cancel();\n            });\n            this.pendings.push(ping);\n            this._schedule();\n        }, this.interval);\n    }\n    _reset() {\n        this.pendings = this.pendings.filter((p)=>{\n            const d = p;\n            d.resolve();\n            return false;\n        });\n    }\n}\nclass AssertionError extends Error {\n    constructor(msg){\n        super(msg);\n        this.name = \"AssertionError\";\n    }\n}\nfunction assert(cond, msg = \"Assertion failed.\") {\n    if (!cond) {\n        throw new AssertionError(msg);\n    }\n}\nconst MIN_READ = 32 * 1024;\nconst MAX_SIZE = 2 ** 32 - 2;\nfunction copy(src, dst, off = 0) {\n    const r = dst.byteLength - off;\n    if (src.byteLength > r) {\n        src = src.subarray(0, r);\n    }\n    dst.set(src, off);\n    return src.byteLength;\n}\nclass DenoBuffer {\n    _buf;\n    _off;\n    constructor(ab){\n        this._off = 0;\n        if (ab == null) {\n            this._buf = new Uint8Array(0);\n            return;\n        }\n        this._buf = new Uint8Array(ab);\n    }\n    bytes(options = {\n        copy: true\n    }) {\n        if (options.copy === false) return this._buf.subarray(this._off);\n        return this._buf.slice(this._off);\n    }\n    empty() {\n        return this._buf.byteLength <= this._off;\n    }\n    get length() {\n        return this._buf.byteLength - this._off;\n    }\n    get capacity() {\n        return this._buf.buffer.byteLength;\n    }\n    truncate(n) {\n        if (n === 0) {\n            this.reset();\n            return;\n        }\n        if (n < 0 || n > this.length) {\n            throw Error(\"bytes.Buffer: truncation out of range\");\n        }\n        this._reslice(this._off + n);\n    }\n    reset() {\n        this._reslice(0);\n        this._off = 0;\n    }\n    _tryGrowByReslice(n) {\n        const l = this._buf.byteLength;\n        if (n <= this.capacity - l) {\n            this._reslice(l + n);\n            return l;\n        }\n        return -1;\n    }\n    _reslice(len) {\n        assert(len <= this._buf.buffer.byteLength);\n        this._buf = new Uint8Array(this._buf.buffer, 0, len);\n    }\n    readByte() {\n        const a = new Uint8Array(1);\n        if (this.read(a)) {\n            return a[0];\n        }\n        return null;\n    }\n    read(p) {\n        if (this.empty()) {\n            this.reset();\n            if (p.byteLength === 0) {\n                return 0;\n            }\n            return null;\n        }\n        const nread = copy(this._buf.subarray(this._off), p);\n        this._off += nread;\n        return nread;\n    }\n    writeByte(n) {\n        return this.write(Uint8Array.of(n));\n    }\n    writeString(s) {\n        return this.write(TE.encode(s));\n    }\n    write(p) {\n        const m = this._grow(p.byteLength);\n        return copy(p, this._buf, m);\n    }\n    _grow(n) {\n        const m = this.length;\n        if (m === 0 && this._off !== 0) {\n            this.reset();\n        }\n        const i = this._tryGrowByReslice(n);\n        if (i >= 0) {\n            return i;\n        }\n        const c = this.capacity;\n        if (n <= Math.floor(c / 2) - m) {\n            copy(this._buf.subarray(this._off), this._buf);\n        } else if (c + n > MAX_SIZE) {\n            throw new Error(\"The buffer cannot be grown beyond the maximum size.\");\n        } else {\n            const buf = new Uint8Array(Math.min(2 * c + n, MAX_SIZE));\n            copy(this._buf.subarray(this._off), buf);\n            this._buf = buf;\n        }\n        this._off = 0;\n        this._reslice(Math.min(m + n, MAX_SIZE));\n        return m;\n    }\n    grow(n) {\n        if (n < 0) {\n            throw Error(\"Buffer._grow: negative count\");\n        }\n        const m = this._grow(n);\n        this._reslice(m);\n    }\n    readFrom(r) {\n        let n = 0;\n        const tmp = new Uint8Array(MIN_READ);\n        while(true){\n            const shouldGrow = this.capacity - this.length < MIN_READ;\n            const buf = shouldGrow ? tmp : new Uint8Array(this._buf.buffer, this.length);\n            const nread = r.read(buf);\n            if (nread === null) {\n                return n;\n            }\n            if (shouldGrow) this.write(buf.subarray(0, nread));\n            else this._reslice(this.length + nread);\n            n += nread;\n        }\n    }\n}\nvar Kind;\n(function(Kind) {\n    Kind[Kind[\"OK\"] = 0] = \"OK\";\n    Kind[Kind[\"ERR\"] = 1] = \"ERR\";\n    Kind[Kind[\"MSG\"] = 2] = \"MSG\";\n    Kind[Kind[\"INFO\"] = 3] = \"INFO\";\n    Kind[Kind[\"PING\"] = 4] = \"PING\";\n    Kind[Kind[\"PONG\"] = 5] = \"PONG\";\n})(Kind || (Kind = {}));\nfunction newMsgArg() {\n    const ma = {};\n    ma.sid = -1;\n    ma.hdr = -1;\n    ma.size = -1;\n    return ma;\n}\nconst ASCII_0 = 48;\nclass Parser {\n    dispatcher;\n    state;\n    as;\n    drop;\n    hdr;\n    ma;\n    argBuf;\n    msgBuf;\n    constructor(dispatcher){\n        this.dispatcher = dispatcher;\n        this.state = State.OP_START;\n        this.as = 0;\n        this.drop = 0;\n        this.hdr = 0;\n    }\n    parse(buf) {\n        let i;\n        for(i = 0; i < buf.length; i++){\n            const b = buf[i];\n            switch(this.state){\n                case State.OP_START:\n                    switch(b){\n                        case cc.M:\n                        case cc.m:\n                            this.state = State.OP_M;\n                            this.hdr = -1;\n                            this.ma = newMsgArg();\n                            break;\n                        case cc.H:\n                        case cc.h:\n                            this.state = State.OP_H;\n                            this.hdr = 0;\n                            this.ma = newMsgArg();\n                            break;\n                        case cc.P:\n                        case cc.p:\n                            this.state = State.OP_P;\n                            break;\n                        case cc.PLUS:\n                            this.state = State.OP_PLUS;\n                            break;\n                        case cc.MINUS:\n                            this.state = State.OP_MINUS;\n                            break;\n                        case cc.I:\n                        case cc.i:\n                            this.state = State.OP_I;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_H:\n                    switch(b){\n                        case cc.M:\n                        case cc.m:\n                            this.state = State.OP_M;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_M:\n                    switch(b){\n                        case cc.S:\n                        case cc.s:\n                            this.state = State.OP_MS;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MS:\n                    switch(b){\n                        case cc.G:\n                        case cc.g:\n                            this.state = State.OP_MSG;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MSG:\n                    switch(b){\n                        case cc.SPACE:\n                        case cc.TAB:\n                            this.state = State.OP_MSG_SPC;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MSG_SPC:\n                    switch(b){\n                        case cc.SPACE:\n                        case cc.TAB:\n                            continue;\n                        default:\n                            this.state = State.MSG_ARG;\n                            this.as = i;\n                    }\n                    break;\n                case State.MSG_ARG:\n                    switch(b){\n                        case cc.CR:\n                            this.drop = 1;\n                            break;\n                        case cc.NL:\n                            {\n                                const arg = this.argBuf ? this.argBuf.bytes() : buf.subarray(this.as, i - this.drop);\n                                this.processMsgArgs(arg);\n                                this.drop = 0;\n                                this.as = i + 1;\n                                this.state = State.MSG_PAYLOAD;\n                                i = this.as + this.ma.size - 1;\n                                break;\n                            }\n                        default:\n                            if (this.argBuf) {\n                                this.argBuf.writeByte(b);\n                            }\n                    }\n                    break;\n                case State.MSG_PAYLOAD:\n                    if (this.msgBuf) {\n                        if (this.msgBuf.length >= this.ma.size) {\n                            const data = this.msgBuf.bytes({\n                                copy: false\n                            });\n                            this.dispatcher.push({\n                                kind: Kind.MSG,\n                                msg: this.ma,\n                                data: data\n                            });\n                            this.argBuf = undefined;\n                            this.msgBuf = undefined;\n                            this.state = State.MSG_END;\n                        } else {\n                            let toCopy = this.ma.size - this.msgBuf.length;\n                            const avail = buf.length - i;\n                            if (avail < toCopy) {\n                                toCopy = avail;\n                            }\n                            if (toCopy > 0) {\n                                this.msgBuf.write(buf.subarray(i, i + toCopy));\n                                i = i + toCopy - 1;\n                            } else {\n                                this.msgBuf.writeByte(b);\n                            }\n                        }\n                    } else if (i - this.as >= this.ma.size) {\n                        this.dispatcher.push({\n                            kind: Kind.MSG,\n                            msg: this.ma,\n                            data: buf.subarray(this.as, i)\n                        });\n                        this.argBuf = undefined;\n                        this.msgBuf = undefined;\n                        this.state = State.MSG_END;\n                    }\n                    break;\n                case State.MSG_END:\n                    switch(b){\n                        case cc.NL:\n                            this.drop = 0;\n                            this.as = i + 1;\n                            this.state = State.OP_START;\n                            break;\n                        default:\n                            continue;\n                    }\n                    break;\n                case State.OP_PLUS:\n                    switch(b){\n                        case cc.O:\n                        case cc.o:\n                            this.state = State.OP_PLUS_O;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PLUS_O:\n                    switch(b){\n                        case cc.K:\n                        case cc.k:\n                            this.state = State.OP_PLUS_OK;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PLUS_OK:\n                    switch(b){\n                        case cc.NL:\n                            this.dispatcher.push({\n                                kind: Kind.OK\n                            });\n                            this.drop = 0;\n                            this.state = State.OP_START;\n                            break;\n                    }\n                    break;\n                case State.OP_MINUS:\n                    switch(b){\n                        case cc.E:\n                        case cc.e:\n                            this.state = State.OP_MINUS_E;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MINUS_E:\n                    switch(b){\n                        case cc.R:\n                        case cc.r:\n                            this.state = State.OP_MINUS_ER;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MINUS_ER:\n                    switch(b){\n                        case cc.R:\n                        case cc.r:\n                            this.state = State.OP_MINUS_ERR;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MINUS_ERR:\n                    switch(b){\n                        case cc.SPACE:\n                        case cc.TAB:\n                            this.state = State.OP_MINUS_ERR_SPC;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MINUS_ERR_SPC:\n                    switch(b){\n                        case cc.SPACE:\n                        case cc.TAB:\n                            continue;\n                        default:\n                            this.state = State.MINUS_ERR_ARG;\n                            this.as = i;\n                    }\n                    break;\n                case State.MINUS_ERR_ARG:\n                    switch(b){\n                        case cc.CR:\n                            this.drop = 1;\n                            break;\n                        case cc.NL:\n                            {\n                                let arg;\n                                if (this.argBuf) {\n                                    arg = this.argBuf.bytes();\n                                    this.argBuf = undefined;\n                                } else {\n                                    arg = buf.subarray(this.as, i - this.drop);\n                                }\n                                this.dispatcher.push({\n                                    kind: Kind.ERR,\n                                    data: arg\n                                });\n                                this.drop = 0;\n                                this.as = i + 1;\n                                this.state = State.OP_START;\n                                break;\n                            }\n                        default:\n                            if (this.argBuf) {\n                                this.argBuf.write(Uint8Array.of(b));\n                            }\n                    }\n                    break;\n                case State.OP_P:\n                    switch(b){\n                        case cc.I:\n                        case cc.i:\n                            this.state = State.OP_PI;\n                            break;\n                        case cc.O:\n                        case cc.o:\n                            this.state = State.OP_PO;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PO:\n                    switch(b){\n                        case cc.N:\n                        case cc.n:\n                            this.state = State.OP_PON;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PON:\n                    switch(b){\n                        case cc.G:\n                        case cc.g:\n                            this.state = State.OP_PONG;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PONG:\n                    switch(b){\n                        case cc.NL:\n                            this.dispatcher.push({\n                                kind: Kind.PONG\n                            });\n                            this.drop = 0;\n                            this.state = State.OP_START;\n                            break;\n                    }\n                    break;\n                case State.OP_PI:\n                    switch(b){\n                        case cc.N:\n                        case cc.n:\n                            this.state = State.OP_PIN;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PIN:\n                    switch(b){\n                        case cc.G:\n                        case cc.g:\n                            this.state = State.OP_PING;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PING:\n                    switch(b){\n                        case cc.NL:\n                            this.dispatcher.push({\n                                kind: Kind.PING\n                            });\n                            this.drop = 0;\n                            this.state = State.OP_START;\n                            break;\n                    }\n                    break;\n                case State.OP_I:\n                    switch(b){\n                        case cc.N:\n                        case cc.n:\n                            this.state = State.OP_IN;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_IN:\n                    switch(b){\n                        case cc.F:\n                        case cc.f:\n                            this.state = State.OP_INF;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_INF:\n                    switch(b){\n                        case cc.O:\n                        case cc.o:\n                            this.state = State.OP_INFO;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_INFO:\n                    switch(b){\n                        case cc.SPACE:\n                        case cc.TAB:\n                            this.state = State.OP_INFO_SPC;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_INFO_SPC:\n                    switch(b){\n                        case cc.SPACE:\n                        case cc.TAB:\n                            continue;\n                        default:\n                            this.state = State.INFO_ARG;\n                            this.as = i;\n                    }\n                    break;\n                case State.INFO_ARG:\n                    switch(b){\n                        case cc.CR:\n                            this.drop = 1;\n                            break;\n                        case cc.NL:\n                            {\n                                let arg;\n                                if (this.argBuf) {\n                                    arg = this.argBuf.bytes();\n                                    this.argBuf = undefined;\n                                } else {\n                                    arg = buf.subarray(this.as, i - this.drop);\n                                }\n                                this.dispatcher.push({\n                                    kind: Kind.INFO,\n                                    data: arg\n                                });\n                                this.drop = 0;\n                                this.as = i + 1;\n                                this.state = State.OP_START;\n                                break;\n                            }\n                        default:\n                            if (this.argBuf) {\n                                this.argBuf.writeByte(b);\n                            }\n                    }\n                    break;\n                default:\n                    throw this.fail(buf.subarray(i));\n            }\n        }\n        if ((this.state === State.MSG_ARG || this.state === State.MINUS_ERR_ARG || this.state === State.INFO_ARG) && !this.argBuf) {\n            this.argBuf = new DenoBuffer(buf.subarray(this.as, i - this.drop));\n        }\n        if (this.state === State.MSG_PAYLOAD && !this.msgBuf) {\n            if (!this.argBuf) {\n                this.cloneMsgArg();\n            }\n            this.msgBuf = new DenoBuffer(buf.subarray(this.as));\n        }\n    }\n    cloneMsgArg() {\n        const s = this.ma.subject.length;\n        const r = this.ma.reply ? this.ma.reply.length : 0;\n        const buf = new Uint8Array(s + r);\n        buf.set(this.ma.subject);\n        if (this.ma.reply) {\n            buf.set(this.ma.reply, s);\n        }\n        this.argBuf = new DenoBuffer(buf);\n        this.ma.subject = buf.subarray(0, s);\n        if (this.ma.reply) {\n            this.ma.reply = buf.subarray(s);\n        }\n    }\n    processMsgArgs(arg) {\n        if (this.hdr >= 0) {\n            return this.processHeaderMsgArgs(arg);\n        }\n        const args = [];\n        let start = -1;\n        for(let i = 0; i < arg.length; i++){\n            const b = arg[i];\n            switch(b){\n                case cc.SPACE:\n                case cc.TAB:\n                case cc.CR:\n                case cc.NL:\n                    if (start >= 0) {\n                        args.push(arg.subarray(start, i));\n                        start = -1;\n                    }\n                    break;\n                default:\n                    if (start < 0) {\n                        start = i;\n                    }\n            }\n        }\n        if (start >= 0) {\n            args.push(arg.subarray(start));\n        }\n        switch(args.length){\n            case 3:\n                this.ma.subject = args[0];\n                this.ma.sid = this.protoParseInt(args[1]);\n                this.ma.reply = undefined;\n                this.ma.size = this.protoParseInt(args[2]);\n                break;\n            case 4:\n                this.ma.subject = args[0];\n                this.ma.sid = this.protoParseInt(args[1]);\n                this.ma.reply = args[2];\n                this.ma.size = this.protoParseInt(args[3]);\n                break;\n            default:\n                throw this.fail(arg, \"processMsgArgs Parse Error\");\n        }\n        if (this.ma.sid < 0) {\n            throw this.fail(arg, \"processMsgArgs Bad or Missing Sid Error\");\n        }\n        if (this.ma.size < 0) {\n            throw this.fail(arg, \"processMsgArgs Bad or Missing Size Error\");\n        }\n    }\n    fail(data, label = \"\") {\n        if (!label) {\n            label = `parse error [${this.state}]`;\n        } else {\n            label = `${label} [${this.state}]`;\n        }\n        return new Error(`${label}: ${TD.decode(data)}`);\n    }\n    processHeaderMsgArgs(arg) {\n        const args = [];\n        let start = -1;\n        for(let i = 0; i < arg.length; i++){\n            const b = arg[i];\n            switch(b){\n                case cc.SPACE:\n                case cc.TAB:\n                case cc.CR:\n                case cc.NL:\n                    if (start >= 0) {\n                        args.push(arg.subarray(start, i));\n                        start = -1;\n                    }\n                    break;\n                default:\n                    if (start < 0) {\n                        start = i;\n                    }\n            }\n        }\n        if (start >= 0) {\n            args.push(arg.subarray(start));\n        }\n        switch(args.length){\n            case 4:\n                this.ma.subject = args[0];\n                this.ma.sid = this.protoParseInt(args[1]);\n                this.ma.reply = undefined;\n                this.ma.hdr = this.protoParseInt(args[2]);\n                this.ma.size = this.protoParseInt(args[3]);\n                break;\n            case 5:\n                this.ma.subject = args[0];\n                this.ma.sid = this.protoParseInt(args[1]);\n                this.ma.reply = args[2];\n                this.ma.hdr = this.protoParseInt(args[3]);\n                this.ma.size = this.protoParseInt(args[4]);\n                break;\n            default:\n                throw this.fail(arg, \"processHeaderMsgArgs Parse Error\");\n        }\n        if (this.ma.sid < 0) {\n            throw this.fail(arg, \"processHeaderMsgArgs Bad or Missing Sid Error\");\n        }\n        if (this.ma.hdr < 0 || this.ma.hdr > this.ma.size) {\n            throw this.fail(arg, \"processHeaderMsgArgs Bad or Missing Header Size Error\");\n        }\n        if (this.ma.size < 0) {\n            throw this.fail(arg, \"processHeaderMsgArgs Bad or Missing Size Error\");\n        }\n    }\n    protoParseInt(a) {\n        if (a.length === 0) {\n            return -1;\n        }\n        let n = 0;\n        for(let i = 0; i < a.length; i++){\n            if (a[i] < 48 || a[i] > 57) {\n                return -1;\n            }\n            n = n * 10 + (a[i] - ASCII_0);\n        }\n        return n;\n    }\n}\nvar State;\n(function(State) {\n    State[State[\"OP_START\"] = 0] = \"OP_START\";\n    State[State[\"OP_PLUS\"] = 1] = \"OP_PLUS\";\n    State[State[\"OP_PLUS_O\"] = 2] = \"OP_PLUS_O\";\n    State[State[\"OP_PLUS_OK\"] = 3] = \"OP_PLUS_OK\";\n    State[State[\"OP_MINUS\"] = 4] = \"OP_MINUS\";\n    State[State[\"OP_MINUS_E\"] = 5] = \"OP_MINUS_E\";\n    State[State[\"OP_MINUS_ER\"] = 6] = \"OP_MINUS_ER\";\n    State[State[\"OP_MINUS_ERR\"] = 7] = \"OP_MINUS_ERR\";\n    State[State[\"OP_MINUS_ERR_SPC\"] = 8] = \"OP_MINUS_ERR_SPC\";\n    State[State[\"MINUS_ERR_ARG\"] = 9] = \"MINUS_ERR_ARG\";\n    State[State[\"OP_M\"] = 10] = \"OP_M\";\n    State[State[\"OP_MS\"] = 11] = \"OP_MS\";\n    State[State[\"OP_MSG\"] = 12] = \"OP_MSG\";\n    State[State[\"OP_MSG_SPC\"] = 13] = \"OP_MSG_SPC\";\n    State[State[\"MSG_ARG\"] = 14] = \"MSG_ARG\";\n    State[State[\"MSG_PAYLOAD\"] = 15] = \"MSG_PAYLOAD\";\n    State[State[\"MSG_END\"] = 16] = \"MSG_END\";\n    State[State[\"OP_H\"] = 17] = \"OP_H\";\n    State[State[\"OP_P\"] = 18] = \"OP_P\";\n    State[State[\"OP_PI\"] = 19] = \"OP_PI\";\n    State[State[\"OP_PIN\"] = 20] = \"OP_PIN\";\n    State[State[\"OP_PING\"] = 21] = \"OP_PING\";\n    State[State[\"OP_PO\"] = 22] = \"OP_PO\";\n    State[State[\"OP_PON\"] = 23] = \"OP_PON\";\n    State[State[\"OP_PONG\"] = 24] = \"OP_PONG\";\n    State[State[\"OP_I\"] = 25] = \"OP_I\";\n    State[State[\"OP_IN\"] = 26] = \"OP_IN\";\n    State[State[\"OP_INF\"] = 27] = \"OP_INF\";\n    State[State[\"OP_INFO\"] = 28] = \"OP_INFO\";\n    State[State[\"OP_INFO_SPC\"] = 29] = \"OP_INFO_SPC\";\n    State[State[\"INFO_ARG\"] = 30] = \"INFO_ARG\";\n})(State || (State = {}));\nvar cc;\n(function(cc) {\n    cc[cc[\"CR\"] = \"\\r\".charCodeAt(0)] = \"CR\";\n    cc[cc[\"E\"] = \"E\".charCodeAt(0)] = \"E\";\n    cc[cc[\"e\"] = \"e\".charCodeAt(0)] = \"e\";\n    cc[cc[\"F\"] = \"F\".charCodeAt(0)] = \"F\";\n    cc[cc[\"f\"] = \"f\".charCodeAt(0)] = \"f\";\n    cc[cc[\"G\"] = \"G\".charCodeAt(0)] = \"G\";\n    cc[cc[\"g\"] = \"g\".charCodeAt(0)] = \"g\";\n    cc[cc[\"H\"] = \"H\".charCodeAt(0)] = \"H\";\n    cc[cc[\"h\"] = \"h\".charCodeAt(0)] = \"h\";\n    cc[cc[\"I\"] = \"I\".charCodeAt(0)] = \"I\";\n    cc[cc[\"i\"] = \"i\".charCodeAt(0)] = \"i\";\n    cc[cc[\"K\"] = \"K\".charCodeAt(0)] = \"K\";\n    cc[cc[\"k\"] = \"k\".charCodeAt(0)] = \"k\";\n    cc[cc[\"M\"] = \"M\".charCodeAt(0)] = \"M\";\n    cc[cc[\"m\"] = \"m\".charCodeAt(0)] = \"m\";\n    cc[cc[\"MINUS\"] = \"-\".charCodeAt(0)] = \"MINUS\";\n    cc[cc[\"N\"] = \"N\".charCodeAt(0)] = \"N\";\n    cc[cc[\"n\"] = \"n\".charCodeAt(0)] = \"n\";\n    cc[cc[\"NL\"] = \"\\n\".charCodeAt(0)] = \"NL\";\n    cc[cc[\"O\"] = \"O\".charCodeAt(0)] = \"O\";\n    cc[cc[\"o\"] = \"o\".charCodeAt(0)] = \"o\";\n    cc[cc[\"P\"] = \"P\".charCodeAt(0)] = \"P\";\n    cc[cc[\"p\"] = \"p\".charCodeAt(0)] = \"p\";\n    cc[cc[\"PLUS\"] = \"+\".charCodeAt(0)] = \"PLUS\";\n    cc[cc[\"R\"] = \"R\".charCodeAt(0)] = \"R\";\n    cc[cc[\"r\"] = \"r\".charCodeAt(0)] = \"r\";\n    cc[cc[\"S\"] = \"S\".charCodeAt(0)] = \"S\";\n    cc[cc[\"s\"] = \"s\".charCodeAt(0)] = \"s\";\n    cc[cc[\"SPACE\"] = \" \".charCodeAt(0)] = \"SPACE\";\n    cc[cc[\"TAB\"] = \"\\t\".charCodeAt(0)] = \"TAB\";\n})(cc || (cc = {}));\n(function(nacl) {\n    'use strict';\n    var u64 = function(h, l) {\n        this.hi = h | 0 >>> 0;\n        this.lo = l | 0 >>> 0;\n    };\n    var gf = function(init) {\n        var i, r = new Float64Array(16);\n        if (init) for(i = 0; i < init.length; i++)r[i] = init[i];\n        return r;\n    };\n    var randombytes = function() {\n        throw new Error('no PRNG');\n    };\n    var _0 = new Uint8Array(16);\n    var _9 = new Uint8Array(32);\n    _9[0] = 9;\n    var gf0 = gf(), gf1 = gf([\n        1\n    ]), _121665 = gf([\n        0xdb41,\n        1\n    ]), D = gf([\n        0x78a3,\n        0x1359,\n        0x4dca,\n        0x75eb,\n        0xd8ab,\n        0x4141,\n        0x0a4d,\n        0x0070,\n        0xe898,\n        0x7779,\n        0x4079,\n        0x8cc7,\n        0xfe73,\n        0x2b6f,\n        0x6cee,\n        0x5203\n    ]), D2 = gf([\n        0xf159,\n        0x26b2,\n        0x9b94,\n        0xebd6,\n        0xb156,\n        0x8283,\n        0x149a,\n        0x00e0,\n        0xd130,\n        0xeef3,\n        0x80f2,\n        0x198e,\n        0xfce7,\n        0x56df,\n        0xd9dc,\n        0x2406\n    ]), X = gf([\n        0xd51a,\n        0x8f25,\n        0x2d60,\n        0xc956,\n        0xa7b2,\n        0x9525,\n        0xc760,\n        0x692c,\n        0xdc5c,\n        0xfdd6,\n        0xe231,\n        0xc0a4,\n        0x53fe,\n        0xcd6e,\n        0x36d3,\n        0x2169\n    ]), Y = gf([\n        0x6658,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666\n    ]), I = gf([\n        0xa0b0,\n        0x4a0e,\n        0x1b27,\n        0xc4ee,\n        0xe478,\n        0xad2f,\n        0x1806,\n        0x2f43,\n        0xd7a7,\n        0x3dfb,\n        0x0099,\n        0x2b4d,\n        0xdf0b,\n        0x4fc1,\n        0x2480,\n        0x2b83\n    ]);\n    function L32(x, c) {\n        return x << c | x >>> 32 - c;\n    }\n    function ld32(x, i) {\n        var u = x[i + 3] & 0xff;\n        u = u << 8 | x[i + 2] & 0xff;\n        u = u << 8 | x[i + 1] & 0xff;\n        return u << 8 | x[i + 0] & 0xff;\n    }\n    function dl64(x, i) {\n        var h = x[i] << 24 | x[i + 1] << 16 | x[i + 2] << 8 | x[i + 3];\n        var l = x[i + 4] << 24 | x[i + 5] << 16 | x[i + 6] << 8 | x[i + 7];\n        return new u64(h, l);\n    }\n    function st32(x, j, u) {\n        var i;\n        for(i = 0; i < 4; i++){\n            x[j + i] = u & 255;\n            u >>>= 8;\n        }\n    }\n    function ts64(x, i, u) {\n        x[i] = u.hi >> 24 & 0xff;\n        x[i + 1] = u.hi >> 16 & 0xff;\n        x[i + 2] = u.hi >> 8 & 0xff;\n        x[i + 3] = u.hi & 0xff;\n        x[i + 4] = u.lo >> 24 & 0xff;\n        x[i + 5] = u.lo >> 16 & 0xff;\n        x[i + 6] = u.lo >> 8 & 0xff;\n        x[i + 7] = u.lo & 0xff;\n    }\n    function vn(x, xi, y, yi, n) {\n        var i, d = 0;\n        for(i = 0; i < n; i++)d |= x[xi + i] ^ y[yi + i];\n        return (1 & d - 1 >>> 8) - 1;\n    }\n    function crypto_verify_16(x, xi, y, yi) {\n        return vn(x, xi, y, yi, 16);\n    }\n    function crypto_verify_32(x, xi, y, yi) {\n        return vn(x, xi, y, yi, 32);\n    }\n    function core(out, inp, k, c, h) {\n        var w = new Uint32Array(16), x = new Uint32Array(16), y = new Uint32Array(16), t = new Uint32Array(4);\n        var i, j, m;\n        for(i = 0; i < 4; i++){\n            x[5 * i] = ld32(c, 4 * i);\n            x[1 + i] = ld32(k, 4 * i);\n            x[6 + i] = ld32(inp, 4 * i);\n            x[11 + i] = ld32(k, 16 + 4 * i);\n        }\n        for(i = 0; i < 16; i++)y[i] = x[i];\n        for(i = 0; i < 20; i++){\n            for(j = 0; j < 4; j++){\n                for(m = 0; m < 4; m++)t[m] = x[(5 * j + 4 * m) % 16];\n                t[1] ^= L32(t[0] + t[3] | 0, 7);\n                t[2] ^= L32(t[1] + t[0] | 0, 9);\n                t[3] ^= L32(t[2] + t[1] | 0, 13);\n                t[0] ^= L32(t[3] + t[2] | 0, 18);\n                for(m = 0; m < 4; m++)w[4 * j + (j + m) % 4] = t[m];\n            }\n            for(m = 0; m < 16; m++)x[m] = w[m];\n        }\n        if (h) {\n            for(i = 0; i < 16; i++)x[i] = x[i] + y[i] | 0;\n            for(i = 0; i < 4; i++){\n                x[5 * i] = x[5 * i] - ld32(c, 4 * i) | 0;\n                x[6 + i] = x[6 + i] - ld32(inp, 4 * i) | 0;\n            }\n            for(i = 0; i < 4; i++){\n                st32(out, 4 * i, x[5 * i]);\n                st32(out, 16 + 4 * i, x[6 + i]);\n            }\n        } else {\n            for(i = 0; i < 16; i++)st32(out, 4 * i, x[i] + y[i] | 0);\n        }\n    }\n    function crypto_core_salsa20(out, inp, k, c) {\n        core(out, inp, k, c, false);\n        return 0;\n    }\n    function crypto_core_hsalsa20(out, inp, k, c) {\n        core(out, inp, k, c, true);\n        return 0;\n    }\n    var sigma = new Uint8Array([\n        101,\n        120,\n        112,\n        97,\n        110,\n        100,\n        32,\n        51,\n        50,\n        45,\n        98,\n        121,\n        116,\n        101,\n        32,\n        107\n    ]);\n    function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {\n        var z = new Uint8Array(16), x = new Uint8Array(64);\n        var u, i;\n        if (!b) return 0;\n        for(i = 0; i < 16; i++)z[i] = 0;\n        for(i = 0; i < 8; i++)z[i] = n[i];\n        while(b >= 64){\n            crypto_core_salsa20(x, z, k, sigma);\n            for(i = 0; i < 64; i++)c[cpos + i] = (m ? m[mpos + i] : 0) ^ x[i];\n            u = 1;\n            for(i = 8; i < 16; i++){\n                u = u + (z[i] & 0xff) | 0;\n                z[i] = u & 0xff;\n                u >>>= 8;\n            }\n            b -= 64;\n            cpos += 64;\n            if (m) mpos += 64;\n        }\n        if (b > 0) {\n            crypto_core_salsa20(x, z, k, sigma);\n            for(i = 0; i < b; i++)c[cpos + i] = (m ? m[mpos + i] : 0) ^ x[i];\n        }\n        return 0;\n    }\n    function crypto_stream_salsa20(c, cpos, d, n, k) {\n        return crypto_stream_salsa20_xor(c, cpos, null, 0, d, n, k);\n    }\n    function crypto_stream(c, cpos, d, n, k) {\n        var s = new Uint8Array(32);\n        crypto_core_hsalsa20(s, n, k, sigma);\n        return crypto_stream_salsa20(c, cpos, d, n.subarray(16), s);\n    }\n    function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {\n        var s = new Uint8Array(32);\n        crypto_core_hsalsa20(s, n, k, sigma);\n        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, n.subarray(16), s);\n    }\n    function add1305(h, c) {\n        var j, u = 0;\n        for(j = 0; j < 17; j++){\n            u = u + (h[j] + c[j] | 0) | 0;\n            h[j] = u & 255;\n            u >>>= 8;\n        }\n    }\n    var minusp = new Uint32Array([\n        5,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        252\n    ]);\n    function crypto_onetimeauth(out, outpos, m, mpos, n, k) {\n        var s, i, j, u;\n        var x = new Uint32Array(17), r = new Uint32Array(17), h = new Uint32Array(17), c = new Uint32Array(17), g = new Uint32Array(17);\n        for(j = 0; j < 17; j++)r[j] = h[j] = 0;\n        for(j = 0; j < 16; j++)r[j] = k[j];\n        r[3] &= 15;\n        r[4] &= 252;\n        r[7] &= 15;\n        r[8] &= 252;\n        r[11] &= 15;\n        r[12] &= 252;\n        r[15] &= 15;\n        while(n > 0){\n            for(j = 0; j < 17; j++)c[j] = 0;\n            for(j = 0; j < 16 && j < n; ++j)c[j] = m[mpos + j];\n            c[j] = 1;\n            mpos += j;\n            n -= j;\n            add1305(h, c);\n            for(i = 0; i < 17; i++){\n                x[i] = 0;\n                for(j = 0; j < 17; j++)x[i] = x[i] + h[j] * (j <= i ? r[i - j] : 320 * r[i + 17 - j] | 0) | 0 | 0;\n            }\n            for(i = 0; i < 17; i++)h[i] = x[i];\n            u = 0;\n            for(j = 0; j < 16; j++){\n                u = u + h[j] | 0;\n                h[j] = u & 255;\n                u >>>= 8;\n            }\n            u = u + h[16] | 0;\n            h[16] = u & 3;\n            u = 5 * (u >>> 2) | 0;\n            for(j = 0; j < 16; j++){\n                u = u + h[j] | 0;\n                h[j] = u & 255;\n                u >>>= 8;\n            }\n            u = u + h[16] | 0;\n            h[16] = u;\n        }\n        for(j = 0; j < 17; j++)g[j] = h[j];\n        add1305(h, minusp);\n        s = -(h[16] >>> 7) | 0;\n        for(j = 0; j < 17; j++)h[j] ^= s & (g[j] ^ h[j]);\n        for(j = 0; j < 16; j++)c[j] = k[j + 16];\n        c[16] = 0;\n        add1305(h, c);\n        for(j = 0; j < 16; j++)out[outpos + j] = h[j];\n        return 0;\n    }\n    function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {\n        var x = new Uint8Array(16);\n        crypto_onetimeauth(x, 0, m, mpos, n, k);\n        return crypto_verify_16(h, hpos, x, 0);\n    }\n    function crypto_secretbox(c, m, d, n, k) {\n        var i;\n        if (d < 32) return -1;\n        crypto_stream_xor(c, 0, m, 0, d, n, k);\n        crypto_onetimeauth(c, 16, c, 32, d - 32, c);\n        for(i = 0; i < 16; i++)c[i] = 0;\n        return 0;\n    }\n    function crypto_secretbox_open(m, c, d, n, k) {\n        var i;\n        var x = new Uint8Array(32);\n        if (d < 32) return -1;\n        crypto_stream(x, 0, 32, n, k);\n        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0) return -1;\n        crypto_stream_xor(m, 0, c, 0, d, n, k);\n        for(i = 0; i < 32; i++)m[i] = 0;\n        return 0;\n    }\n    function set25519(r, a) {\n        var i;\n        for(i = 0; i < 16; i++)r[i] = a[i] | 0;\n    }\n    function car25519(o) {\n        var c;\n        var i;\n        for(i = 0; i < 16; i++){\n            o[i] += 65536;\n            c = Math.floor(o[i] / 65536);\n            o[(i + 1) * (i < 15 ? 1 : 0)] += c - 1 + 37 * (c - 1) * (i === 15 ? 1 : 0);\n            o[i] -= c * 65536;\n        }\n    }\n    function sel25519(p, q, b) {\n        var t, c = ~(b - 1);\n        for(var i = 0; i < 16; i++){\n            t = c & (p[i] ^ q[i]);\n            p[i] ^= t;\n            q[i] ^= t;\n        }\n    }\n    function pack25519(o, n) {\n        var i, j, b;\n        var m = gf(), t = gf();\n        for(i = 0; i < 16; i++)t[i] = n[i];\n        car25519(t);\n        car25519(t);\n        car25519(t);\n        for(j = 0; j < 2; j++){\n            m[0] = t[0] - 0xffed;\n            for(i = 1; i < 15; i++){\n                m[i] = t[i] - 0xffff - (m[i - 1] >> 16 & 1);\n                m[i - 1] &= 0xffff;\n            }\n            m[15] = t[15] - 0x7fff - (m[14] >> 16 & 1);\n            b = m[15] >> 16 & 1;\n            m[14] &= 0xffff;\n            sel25519(t, m, 1 - b);\n        }\n        for(i = 0; i < 16; i++){\n            o[2 * i] = t[i] & 0xff;\n            o[2 * i + 1] = t[i] >> 8;\n        }\n    }\n    function neq25519(a, b) {\n        var c = new Uint8Array(32), d = new Uint8Array(32);\n        pack25519(c, a);\n        pack25519(d, b);\n        return crypto_verify_32(c, 0, d, 0);\n    }\n    function par25519(a) {\n        var d = new Uint8Array(32);\n        pack25519(d, a);\n        return d[0] & 1;\n    }\n    function unpack25519(o, n) {\n        var i;\n        for(i = 0; i < 16; i++)o[i] = n[2 * i] + (n[2 * i + 1] << 8);\n        o[15] &= 0x7fff;\n    }\n    function A(o, a, b) {\n        var i;\n        for(i = 0; i < 16; i++)o[i] = a[i] + b[i] | 0;\n    }\n    function Z(o, a, b) {\n        var i;\n        for(i = 0; i < 16; i++)o[i] = a[i] - b[i] | 0;\n    }\n    function M(o, a, b) {\n        var i, j, t = new Float64Array(31);\n        for(i = 0; i < 31; i++)t[i] = 0;\n        for(i = 0; i < 16; i++){\n            for(j = 0; j < 16; j++){\n                t[i + j] += a[i] * b[j];\n            }\n        }\n        for(i = 0; i < 15; i++){\n            t[i] += 38 * t[i + 16];\n        }\n        for(i = 0; i < 16; i++)o[i] = t[i];\n        car25519(o);\n        car25519(o);\n    }\n    function S(o, a) {\n        M(o, a, a);\n    }\n    function inv25519(o, i) {\n        var c = gf();\n        var a;\n        for(a = 0; a < 16; a++)c[a] = i[a];\n        for(a = 253; a >= 0; a--){\n            S(c, c);\n            if (a !== 2 && a !== 4) M(c, c, i);\n        }\n        for(a = 0; a < 16; a++)o[a] = c[a];\n    }\n    function pow2523(o, i) {\n        var c = gf();\n        var a;\n        for(a = 0; a < 16; a++)c[a] = i[a];\n        for(a = 250; a >= 0; a--){\n            S(c, c);\n            if (a !== 1) M(c, c, i);\n        }\n        for(a = 0; a < 16; a++)o[a] = c[a];\n    }\n    function crypto_scalarmult(q, n, p) {\n        var z = new Uint8Array(32);\n        var x = new Float64Array(80), r, i;\n        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();\n        for(i = 0; i < 31; i++)z[i] = n[i];\n        z[31] = n[31] & 127 | 64;\n        z[0] &= 248;\n        unpack25519(x, p);\n        for(i = 0; i < 16; i++){\n            b[i] = x[i];\n            d[i] = a[i] = c[i] = 0;\n        }\n        a[0] = d[0] = 1;\n        for(i = 254; i >= 0; --i){\n            r = z[i >>> 3] >>> (i & 7) & 1;\n            sel25519(a, b, r);\n            sel25519(c, d, r);\n            A(e, a, c);\n            Z(a, a, c);\n            A(c, b, d);\n            Z(b, b, d);\n            S(d, e);\n            S(f, a);\n            M(a, c, a);\n            M(c, b, e);\n            A(e, a, c);\n            Z(a, a, c);\n            S(b, a);\n            Z(c, d, f);\n            M(a, c, _121665);\n            A(a, a, d);\n            M(c, c, a);\n            M(a, d, f);\n            M(d, b, x);\n            S(b, e);\n            sel25519(a, b, r);\n            sel25519(c, d, r);\n        }\n        for(i = 0; i < 16; i++){\n            x[i + 16] = a[i];\n            x[i + 32] = c[i];\n            x[i + 48] = b[i];\n            x[i + 64] = d[i];\n        }\n        var x32 = x.subarray(32);\n        var x16 = x.subarray(16);\n        inv25519(x32, x32);\n        M(x16, x16, x32);\n        pack25519(q, x16);\n        return 0;\n    }\n    function crypto_scalarmult_base(q, n) {\n        return crypto_scalarmult(q, n, _9);\n    }\n    function crypto_box_keypair(y, x) {\n        randombytes(x, 32);\n        return crypto_scalarmult_base(y, x);\n    }\n    function crypto_box_beforenm(k, y, x) {\n        var s = new Uint8Array(32);\n        crypto_scalarmult(s, x, y);\n        return crypto_core_hsalsa20(k, _0, s, sigma);\n    }\n    var crypto_box_afternm = crypto_secretbox;\n    var crypto_box_open_afternm = crypto_secretbox_open;\n    function crypto_box(c, m, d, n, y, x) {\n        var k = new Uint8Array(32);\n        crypto_box_beforenm(k, y, x);\n        return crypto_box_afternm(c, m, d, n, k);\n    }\n    function crypto_box_open(m, c, d, n, y, x) {\n        var k = new Uint8Array(32);\n        crypto_box_beforenm(k, y, x);\n        return crypto_box_open_afternm(m, c, d, n, k);\n    }\n    function add64() {\n        var a = 0, b = 0, c = 0, d = 0, m16 = 65535, l, h, i;\n        for(i = 0; i < arguments.length; i++){\n            l = arguments[i].lo;\n            h = arguments[i].hi;\n            a += l & m16;\n            b += l >>> 16;\n            c += h & m16;\n            d += h >>> 16;\n        }\n        b += a >>> 16;\n        c += b >>> 16;\n        d += c >>> 16;\n        return new u64(c & m16 | d << 16, a & m16 | b << 16);\n    }\n    function shr64(x, c) {\n        return new u64(x.hi >>> c, x.lo >>> c | x.hi << 32 - c);\n    }\n    function xor64() {\n        var l = 0, h = 0, i;\n        for(i = 0; i < arguments.length; i++){\n            l ^= arguments[i].lo;\n            h ^= arguments[i].hi;\n        }\n        return new u64(h, l);\n    }\n    function R(x, c) {\n        var h, l, c1 = 32 - c;\n        if (c < 32) {\n            h = x.hi >>> c | x.lo << c1;\n            l = x.lo >>> c | x.hi << c1;\n        } else if (c < 64) {\n            h = x.lo >>> c | x.hi << c1;\n            l = x.hi >>> c | x.lo << c1;\n        }\n        return new u64(h, l);\n    }\n    function Ch(x, y, z) {\n        var h = x.hi & y.hi ^ ~x.hi & z.hi, l = x.lo & y.lo ^ ~x.lo & z.lo;\n        return new u64(h, l);\n    }\n    function Maj(x, y, z) {\n        var h = x.hi & y.hi ^ x.hi & z.hi ^ y.hi & z.hi, l = x.lo & y.lo ^ x.lo & z.lo ^ y.lo & z.lo;\n        return new u64(h, l);\n    }\n    function Sigma0(x) {\n        return xor64(R(x, 28), R(x, 34), R(x, 39));\n    }\n    function Sigma1(x) {\n        return xor64(R(x, 14), R(x, 18), R(x, 41));\n    }\n    function sigma0(x) {\n        return xor64(R(x, 1), R(x, 8), shr64(x, 7));\n    }\n    function sigma1(x) {\n        return xor64(R(x, 19), R(x, 61), shr64(x, 6));\n    }\n    var K = [\n        new u64(0x428a2f98, 0xd728ae22),\n        new u64(0x71374491, 0x23ef65cd),\n        new u64(0xb5c0fbcf, 0xec4d3b2f),\n        new u64(0xe9b5dba5, 0x8189dbbc),\n        new u64(0x3956c25b, 0xf348b538),\n        new u64(0x59f111f1, 0xb605d019),\n        new u64(0x923f82a4, 0xaf194f9b),\n        new u64(0xab1c5ed5, 0xda6d8118),\n        new u64(0xd807aa98, 0xa3030242),\n        new u64(0x12835b01, 0x45706fbe),\n        new u64(0x243185be, 0x4ee4b28c),\n        new u64(0x550c7dc3, 0xd5ffb4e2),\n        new u64(0x72be5d74, 0xf27b896f),\n        new u64(0x80deb1fe, 0x3b1696b1),\n        new u64(0x9bdc06a7, 0x25c71235),\n        new u64(0xc19bf174, 0xcf692694),\n        new u64(0xe49b69c1, 0x9ef14ad2),\n        new u64(0xefbe4786, 0x384f25e3),\n        new u64(0x0fc19dc6, 0x8b8cd5b5),\n        new u64(0x240ca1cc, 0x77ac9c65),\n        new u64(0x2de92c6f, 0x592b0275),\n        new u64(0x4a7484aa, 0x6ea6e483),\n        new u64(0x5cb0a9dc, 0xbd41fbd4),\n        new u64(0x76f988da, 0x831153b5),\n        new u64(0x983e5152, 0xee66dfab),\n        new u64(0xa831c66d, 0x2db43210),\n        new u64(0xb00327c8, 0x98fb213f),\n        new u64(0xbf597fc7, 0xbeef0ee4),\n        new u64(0xc6e00bf3, 0x3da88fc2),\n        new u64(0xd5a79147, 0x930aa725),\n        new u64(0x06ca6351, 0xe003826f),\n        new u64(0x14292967, 0x0a0e6e70),\n        new u64(0x27b70a85, 0x46d22ffc),\n        new u64(0x2e1b2138, 0x5c26c926),\n        new u64(0x4d2c6dfc, 0x5ac42aed),\n        new u64(0x53380d13, 0x9d95b3df),\n        new u64(0x650a7354, 0x8baf63de),\n        new u64(0x766a0abb, 0x3c77b2a8),\n        new u64(0x81c2c92e, 0x47edaee6),\n        new u64(0x92722c85, 0x1482353b),\n        new u64(0xa2bfe8a1, 0x4cf10364),\n        new u64(0xa81a664b, 0xbc423001),\n        new u64(0xc24b8b70, 0xd0f89791),\n        new u64(0xc76c51a3, 0x0654be30),\n        new u64(0xd192e819, 0xd6ef5218),\n        new u64(0xd6990624, 0x5565a910),\n        new u64(0xf40e3585, 0x5771202a),\n        new u64(0x106aa070, 0x32bbd1b8),\n        new u64(0x19a4c116, 0xb8d2d0c8),\n        new u64(0x1e376c08, 0x5141ab53),\n        new u64(0x2748774c, 0xdf8eeb99),\n        new u64(0x34b0bcb5, 0xe19b48a8),\n        new u64(0x391c0cb3, 0xc5c95a63),\n        new u64(0x4ed8aa4a, 0xe3418acb),\n        new u64(0x5b9cca4f, 0x7763e373),\n        new u64(0x682e6ff3, 0xd6b2b8a3),\n        new u64(0x748f82ee, 0x5defb2fc),\n        new u64(0x78a5636f, 0x43172f60),\n        new u64(0x84c87814, 0xa1f0ab72),\n        new u64(0x8cc70208, 0x1a6439ec),\n        new u64(0x90befffa, 0x23631e28),\n        new u64(0xa4506ceb, 0xde82bde9),\n        new u64(0xbef9a3f7, 0xb2c67915),\n        new u64(0xc67178f2, 0xe372532b),\n        new u64(0xca273ece, 0xea26619c),\n        new u64(0xd186b8c7, 0x21c0c207),\n        new u64(0xeada7dd6, 0xcde0eb1e),\n        new u64(0xf57d4f7f, 0xee6ed178),\n        new u64(0x06f067aa, 0x72176fba),\n        new u64(0x0a637dc5, 0xa2c898a6),\n        new u64(0x113f9804, 0xbef90dae),\n        new u64(0x1b710b35, 0x131c471b),\n        new u64(0x28db77f5, 0x23047d84),\n        new u64(0x32caab7b, 0x40c72493),\n        new u64(0x3c9ebe0a, 0x15c9bebc),\n        new u64(0x431d67c4, 0x9c100d4c),\n        new u64(0x4cc5d4be, 0xcb3e42b6),\n        new u64(0x597f299c, 0xfc657e2a),\n        new u64(0x5fcb6fab, 0x3ad6faec),\n        new u64(0x6c44198c, 0x4a475817)\n    ];\n    function crypto_hashblocks(x, m, n) {\n        var z = [], b = [], a = [], w = [], t, i, j;\n        for(i = 0; i < 8; i++)z[i] = a[i] = dl64(x, 8 * i);\n        var pos = 0;\n        while(n >= 128){\n            for(i = 0; i < 16; i++)w[i] = dl64(m, 8 * i + pos);\n            for(i = 0; i < 80; i++){\n                for(j = 0; j < 8; j++)b[j] = a[j];\n                t = add64(a[7], Sigma1(a[4]), Ch(a[4], a[5], a[6]), K[i], w[i % 16]);\n                b[7] = add64(t, Sigma0(a[0]), Maj(a[0], a[1], a[2]));\n                b[3] = add64(b[3], t);\n                for(j = 0; j < 8; j++)a[(j + 1) % 8] = b[j];\n                if (i % 16 === 15) {\n                    for(j = 0; j < 16; j++){\n                        w[j] = add64(w[j], w[(j + 9) % 16], sigma0(w[(j + 1) % 16]), sigma1(w[(j + 14) % 16]));\n                    }\n                }\n            }\n            for(i = 0; i < 8; i++){\n                a[i] = add64(a[i], z[i]);\n                z[i] = a[i];\n            }\n            pos += 128;\n            n -= 128;\n        }\n        for(i = 0; i < 8; i++)ts64(x, 8 * i, z[i]);\n        return n;\n    }\n    var iv = new Uint8Array([\n        0x6a,\n        0x09,\n        0xe6,\n        0x67,\n        0xf3,\n        0xbc,\n        0xc9,\n        0x08,\n        0xbb,\n        0x67,\n        0xae,\n        0x85,\n        0x84,\n        0xca,\n        0xa7,\n        0x3b,\n        0x3c,\n        0x6e,\n        0xf3,\n        0x72,\n        0xfe,\n        0x94,\n        0xf8,\n        0x2b,\n        0xa5,\n        0x4f,\n        0xf5,\n        0x3a,\n        0x5f,\n        0x1d,\n        0x36,\n        0xf1,\n        0x51,\n        0x0e,\n        0x52,\n        0x7f,\n        0xad,\n        0xe6,\n        0x82,\n        0xd1,\n        0x9b,\n        0x05,\n        0x68,\n        0x8c,\n        0x2b,\n        0x3e,\n        0x6c,\n        0x1f,\n        0x1f,\n        0x83,\n        0xd9,\n        0xab,\n        0xfb,\n        0x41,\n        0xbd,\n        0x6b,\n        0x5b,\n        0xe0,\n        0xcd,\n        0x19,\n        0x13,\n        0x7e,\n        0x21,\n        0x79\n    ]);\n    function crypto_hash(out, m, n) {\n        var h = new Uint8Array(64), x = new Uint8Array(256);\n        var i, b = n;\n        for(i = 0; i < 64; i++)h[i] = iv[i];\n        crypto_hashblocks(h, m, n);\n        n %= 128;\n        for(i = 0; i < 256; i++)x[i] = 0;\n        for(i = 0; i < n; i++)x[i] = m[b - n + i];\n        x[n] = 128;\n        n = 256 - 128 * (n < 112 ? 1 : 0);\n        x[n - 9] = 0;\n        ts64(x, n - 8, new u64(b / 0x20000000 | 0, b << 3));\n        crypto_hashblocks(h, x, n);\n        for(i = 0; i < 64; i++)out[i] = h[i];\n        return 0;\n    }\n    function add(p, q) {\n        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();\n        Z(a, p[1], p[0]);\n        Z(t, q[1], q[0]);\n        M(a, a, t);\n        A(b, p[0], p[1]);\n        A(t, q[0], q[1]);\n        M(b, b, t);\n        M(c, p[3], q[3]);\n        M(c, c, D2);\n        M(d, p[2], q[2]);\n        A(d, d, d);\n        Z(e, b, a);\n        Z(f, d, c);\n        A(g, d, c);\n        A(h, b, a);\n        M(p[0], e, f);\n        M(p[1], h, g);\n        M(p[2], g, f);\n        M(p[3], e, h);\n    }\n    function cswap(p, q, b) {\n        var i;\n        for(i = 0; i < 4; i++){\n            sel25519(p[i], q[i], b);\n        }\n    }\n    function pack(r, p) {\n        var tx = gf(), ty = gf(), zi = gf();\n        inv25519(zi, p[2]);\n        M(tx, p[0], zi);\n        M(ty, p[1], zi);\n        pack25519(r, ty);\n        r[31] ^= par25519(tx) << 7;\n    }\n    function scalarmult(p, q, s) {\n        var b, i;\n        set25519(p[0], gf0);\n        set25519(p[1], gf1);\n        set25519(p[2], gf1);\n        set25519(p[3], gf0);\n        for(i = 255; i >= 0; --i){\n            b = s[i / 8 | 0] >> (i & 7) & 1;\n            cswap(p, q, b);\n            add(q, p);\n            add(p, p);\n            cswap(p, q, b);\n        }\n    }\n    function scalarbase(p, s) {\n        var q = [\n            gf(),\n            gf(),\n            gf(),\n            gf()\n        ];\n        set25519(q[0], X);\n        set25519(q[1], Y);\n        set25519(q[2], gf1);\n        M(q[3], X, Y);\n        scalarmult(p, q, s);\n    }\n    function crypto_sign_keypair(pk, sk, seeded) {\n        var d = new Uint8Array(64);\n        var p = [\n            gf(),\n            gf(),\n            gf(),\n            gf()\n        ];\n        var i;\n        if (!seeded) randombytes(sk, 32);\n        crypto_hash(d, sk, 32);\n        d[0] &= 248;\n        d[31] &= 127;\n        d[31] |= 64;\n        scalarbase(p, d);\n        pack(pk, p);\n        for(i = 0; i < 32; i++)sk[i + 32] = pk[i];\n        return 0;\n    }\n    var L = new Float64Array([\n        0xed,\n        0xd3,\n        0xf5,\n        0x5c,\n        0x1a,\n        0x63,\n        0x12,\n        0x58,\n        0xd6,\n        0x9c,\n        0xf7,\n        0xa2,\n        0xde,\n        0xf9,\n        0xde,\n        0x14,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0x10\n    ]);\n    function modL(r, x) {\n        var carry, i, j, k;\n        for(i = 63; i >= 32; --i){\n            carry = 0;\n            for(j = i - 32, k = i - 12; j < k; ++j){\n                x[j] += carry - 16 * x[i] * L[j - (i - 32)];\n                carry = Math.floor((x[j] + 128) / 256);\n                x[j] -= carry * 256;\n            }\n            x[j] += carry;\n            x[i] = 0;\n        }\n        carry = 0;\n        for(j = 0; j < 32; j++){\n            x[j] += carry - (x[31] >> 4) * L[j];\n            carry = x[j] >> 8;\n            x[j] &= 255;\n        }\n        for(j = 0; j < 32; j++)x[j] -= carry * L[j];\n        for(i = 0; i < 32; i++){\n            x[i + 1] += x[i] >> 8;\n            r[i] = x[i] & 255;\n        }\n    }\n    function reduce(r) {\n        var x = new Float64Array(64), i;\n        for(i = 0; i < 64; i++)x[i] = r[i];\n        for(i = 0; i < 64; i++)r[i] = 0;\n        modL(r, x);\n    }\n    function crypto_sign(sm, m, n, sk) {\n        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);\n        var i, j, x = new Float64Array(64);\n        var p = [\n            gf(),\n            gf(),\n            gf(),\n            gf()\n        ];\n        crypto_hash(d, sk, 32);\n        d[0] &= 248;\n        d[31] &= 127;\n        d[31] |= 64;\n        var smlen = n + 64;\n        for(i = 0; i < n; i++)sm[64 + i] = m[i];\n        for(i = 0; i < 32; i++)sm[32 + i] = d[32 + i];\n        crypto_hash(r, sm.subarray(32), n + 32);\n        reduce(r);\n        scalarbase(p, r);\n        pack(sm, p);\n        for(i = 32; i < 64; i++)sm[i] = sk[i];\n        crypto_hash(h, sm, n + 64);\n        reduce(h);\n        for(i = 0; i < 64; i++)x[i] = 0;\n        for(i = 0; i < 32; i++)x[i] = r[i];\n        for(i = 0; i < 32; i++){\n            for(j = 0; j < 32; j++){\n                x[i + j] += h[i] * d[j];\n            }\n        }\n        modL(sm.subarray(32), x);\n        return smlen;\n    }\n    function unpackneg(r, p) {\n        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();\n        set25519(r[2], gf1);\n        unpack25519(r[1], p);\n        S(num, r[1]);\n        M(den, num, D);\n        Z(num, num, r[2]);\n        A(den, r[2], den);\n        S(den2, den);\n        S(den4, den2);\n        M(den6, den4, den2);\n        M(t, den6, num);\n        M(t, t, den);\n        pow2523(t, t);\n        M(t, t, num);\n        M(t, t, den);\n        M(t, t, den);\n        M(r[0], t, den);\n        S(chk, r[0]);\n        M(chk, chk, den);\n        if (neq25519(chk, num)) M(r[0], r[0], I);\n        S(chk, r[0]);\n        M(chk, chk, den);\n        if (neq25519(chk, num)) return -1;\n        if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);\n        M(r[3], r[0], r[1]);\n        return 0;\n    }\n    function crypto_sign_open(m, sm, n, pk) {\n        var i;\n        var t = new Uint8Array(32), h = new Uint8Array(64);\n        var p = [\n            gf(),\n            gf(),\n            gf(),\n            gf()\n        ], q = [\n            gf(),\n            gf(),\n            gf(),\n            gf()\n        ];\n        if (n < 64) return -1;\n        if (unpackneg(q, pk)) return -1;\n        for(i = 0; i < n; i++)m[i] = sm[i];\n        for(i = 0; i < 32; i++)m[i + 32] = pk[i];\n        crypto_hash(h, m, n);\n        reduce(h);\n        scalarmult(p, q, h);\n        scalarbase(q, sm.subarray(32));\n        add(p, q);\n        pack(t, p);\n        n -= 64;\n        if (crypto_verify_32(sm, 0, t, 0)) {\n            for(i = 0; i < n; i++)m[i] = 0;\n            return -1;\n        }\n        for(i = 0; i < n; i++)m[i] = sm[i + 64];\n        return n;\n    }\n    var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;\n    nacl.lowlevel = {\n        crypto_core_hsalsa20: crypto_core_hsalsa20,\n        crypto_stream_xor: crypto_stream_xor,\n        crypto_stream: crypto_stream,\n        crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,\n        crypto_stream_salsa20: crypto_stream_salsa20,\n        crypto_onetimeauth: crypto_onetimeauth,\n        crypto_onetimeauth_verify: crypto_onetimeauth_verify,\n        crypto_verify_16: crypto_verify_16,\n        crypto_verify_32: crypto_verify_32,\n        crypto_secretbox: crypto_secretbox,\n        crypto_secretbox_open: crypto_secretbox_open,\n        crypto_scalarmult: crypto_scalarmult,\n        crypto_scalarmult_base: crypto_scalarmult_base,\n        crypto_box_beforenm: crypto_box_beforenm,\n        crypto_box_afternm: crypto_box_afternm,\n        crypto_box: crypto_box,\n        crypto_box_open: crypto_box_open,\n        crypto_box_keypair: crypto_box_keypair,\n        crypto_hash: crypto_hash,\n        crypto_sign: crypto_sign,\n        crypto_sign_keypair: crypto_sign_keypair,\n        crypto_sign_open: crypto_sign_open,\n        crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,\n        crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,\n        crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,\n        crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,\n        crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,\n        crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,\n        crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,\n        crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,\n        crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,\n        crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,\n        crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,\n        crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,\n        crypto_sign_BYTES: crypto_sign_BYTES,\n        crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,\n        crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,\n        crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,\n        crypto_hash_BYTES: crypto_hash_BYTES,\n        gf: gf,\n        D: D,\n        L: L,\n        pack25519: pack25519,\n        unpack25519: unpack25519,\n        M: M,\n        A: A,\n        S: S,\n        Z: Z,\n        pow2523: pow2523,\n        add: add,\n        set25519: set25519,\n        modL: modL,\n        scalarmult: scalarmult,\n        scalarbase: scalarbase\n    };\n    function checkLengths(k, n) {\n        if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');\n        if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');\n    }\n    function checkBoxLengths(pk, sk) {\n        if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');\n        if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');\n    }\n    function checkArrayTypes() {\n        for(var i = 0; i < arguments.length; i++){\n            if (!(arguments[i] instanceof Uint8Array)) throw new TypeError('unexpected type, use Uint8Array');\n        }\n    }\n    function cleanup(arr) {\n        for(var i = 0; i < arr.length; i++)arr[i] = 0;\n    }\n    nacl.randomBytes = function(n) {\n        var b = new Uint8Array(n);\n        randombytes(b, n);\n        return b;\n    };\n    nacl.secretbox = function(msg, nonce, key) {\n        checkArrayTypes(msg, nonce, key);\n        checkLengths(key, nonce);\n        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);\n        var c = new Uint8Array(m.length);\n        for(var i = 0; i < msg.length; i++)m[i + crypto_secretbox_ZEROBYTES] = msg[i];\n        crypto_secretbox(c, m, m.length, nonce, key);\n        return c.subarray(crypto_secretbox_BOXZEROBYTES);\n    };\n    nacl.secretbox.open = function(box, nonce, key) {\n        checkArrayTypes(box, nonce, key);\n        checkLengths(key, nonce);\n        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);\n        var m = new Uint8Array(c.length);\n        for(var i = 0; i < box.length; i++)c[i + crypto_secretbox_BOXZEROBYTES] = box[i];\n        if (c.length < 32) return null;\n        if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;\n        return m.subarray(crypto_secretbox_ZEROBYTES);\n    };\n    nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;\n    nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;\n    nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;\n    nacl.scalarMult = function(n, p) {\n        checkArrayTypes(n, p);\n        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');\n        if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');\n        var q = new Uint8Array(crypto_scalarmult_BYTES);\n        crypto_scalarmult(q, n, p);\n        return q;\n    };\n    nacl.scalarMult.base = function(n) {\n        checkArrayTypes(n);\n        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');\n        var q = new Uint8Array(crypto_scalarmult_BYTES);\n        crypto_scalarmult_base(q, n);\n        return q;\n    };\n    nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;\n    nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;\n    nacl.box = function(msg, nonce, publicKey, secretKey) {\n        var k = nacl.box.before(publicKey, secretKey);\n        return nacl.secretbox(msg, nonce, k);\n    };\n    nacl.box.before = function(publicKey, secretKey) {\n        checkArrayTypes(publicKey, secretKey);\n        checkBoxLengths(publicKey, secretKey);\n        var k = new Uint8Array(crypto_box_BEFORENMBYTES);\n        crypto_box_beforenm(k, publicKey, secretKey);\n        return k;\n    };\n    nacl.box.after = nacl.secretbox;\n    nacl.box.open = function(msg, nonce, publicKey, secretKey) {\n        var k = nacl.box.before(publicKey, secretKey);\n        return nacl.secretbox.open(msg, nonce, k);\n    };\n    nacl.box.open.after = nacl.secretbox.open;\n    nacl.box.keyPair = function() {\n        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);\n        crypto_box_keypair(pk, sk);\n        return {\n            publicKey: pk,\n            secretKey: sk\n        };\n    };\n    nacl.box.keyPair.fromSecretKey = function(secretKey) {\n        checkArrayTypes(secretKey);\n        if (secretKey.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');\n        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n        crypto_scalarmult_base(pk, secretKey);\n        return {\n            publicKey: pk,\n            secretKey: new Uint8Array(secretKey)\n        };\n    };\n    nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;\n    nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;\n    nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;\n    nacl.box.nonceLength = crypto_box_NONCEBYTES;\n    nacl.box.overheadLength = nacl.secretbox.overheadLength;\n    nacl.sign = function(msg, secretKey) {\n        checkArrayTypes(msg, secretKey);\n        if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error('bad secret key size');\n        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);\n        crypto_sign(signedMsg, msg, msg.length, secretKey);\n        return signedMsg;\n    };\n    nacl.sign.open = function(signedMsg, publicKey) {\n        checkArrayTypes(signedMsg, publicKey);\n        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error('bad public key size');\n        var tmp = new Uint8Array(signedMsg.length);\n        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);\n        if (mlen < 0) return null;\n        var m = new Uint8Array(mlen);\n        for(var i = 0; i < m.length; i++)m[i] = tmp[i];\n        return m;\n    };\n    nacl.sign.detached = function(msg, secretKey) {\n        var signedMsg = nacl.sign(msg, secretKey);\n        var sig = new Uint8Array(crypto_sign_BYTES);\n        for(var i = 0; i < sig.length; i++)sig[i] = signedMsg[i];\n        return sig;\n    };\n    nacl.sign.detached.verify = function(msg, sig, publicKey) {\n        checkArrayTypes(msg, sig, publicKey);\n        if (sig.length !== crypto_sign_BYTES) throw new Error('bad signature size');\n        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error('bad public key size');\n        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);\n        var m = new Uint8Array(crypto_sign_BYTES + msg.length);\n        var i;\n        for(i = 0; i < crypto_sign_BYTES; i++)sm[i] = sig[i];\n        for(i = 0; i < msg.length; i++)sm[i + crypto_sign_BYTES] = msg[i];\n        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;\n    };\n    nacl.sign.keyPair = function() {\n        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n        crypto_sign_keypair(pk, sk);\n        return {\n            publicKey: pk,\n            secretKey: sk\n        };\n    };\n    nacl.sign.keyPair.fromSecretKey = function(secretKey) {\n        checkArrayTypes(secretKey);\n        if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error('bad secret key size');\n        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n        for(var i = 0; i < pk.length; i++)pk[i] = secretKey[32 + i];\n        return {\n            publicKey: pk,\n            secretKey: new Uint8Array(secretKey)\n        };\n    };\n    nacl.sign.keyPair.fromSeed = function(seed) {\n        checkArrayTypes(seed);\n        if (seed.length !== crypto_sign_SEEDBYTES) throw new Error('bad seed size');\n        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n        for(var i = 0; i < 32; i++)sk[i] = seed[i];\n        crypto_sign_keypair(pk, sk, true);\n        return {\n            publicKey: pk,\n            secretKey: sk\n        };\n    };\n    nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;\n    nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;\n    nacl.sign.seedLength = crypto_sign_SEEDBYTES;\n    nacl.sign.signatureLength = crypto_sign_BYTES;\n    nacl.hash = function(msg) {\n        checkArrayTypes(msg);\n        var h = new Uint8Array(crypto_hash_BYTES);\n        crypto_hash(h, msg, msg.length);\n        return h;\n    };\n    nacl.hash.hashLength = crypto_hash_BYTES;\n    nacl.verify = function(x, y) {\n        checkArrayTypes(x, y);\n        if (x.length === 0 || y.length === 0) return false;\n        if (x.length !== y.length) return false;\n        return vn(x, 0, y, 0, x.length) === 0 ? true : false;\n    };\n    nacl.setPRNG = function(fn) {\n        randombytes = fn;\n    };\n    (function() {\n        var crypto1 = typeof globalThis !== 'undefined' ? globalThis.crypto || globalThis.msCrypto : null;\n        if (crypto1 && crypto1.getRandomValues) {\n            var QUOTA = 65536;\n            nacl.setPRNG(function(x, n) {\n                var i, v = new Uint8Array(n);\n                for(i = 0; i < n; i += QUOTA){\n                    crypto1.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));\n                }\n                for(i = 0; i < n; i++)x[i] = v[i];\n                cleanup(v);\n            });\n        } else if (typeof require !== 'undefined') {\n            crypto1 = require('crypto');\n            if (crypto1 && crypto1.randomBytes) {\n                nacl.setPRNG(function(x, n) {\n                    var i, v = crypto1.randomBytes(n);\n                    for(i = 0; i < n; i++)x[i] = v[i];\n                    cleanup(v);\n                });\n            }\n        }\n    })();\n})(typeof module !== 'undefined' && module.exports ? module.exports : globalThis.nacl = globalThis.nacl || {});\nconst nacl = typeof module !== 'undefined' && module.exports ? module.exports : globalThis.nacl;\nconst denoHelper = {\n    fromSeed: nacl.sign.keyPair.fromSeed,\n    sign: nacl.sign.detached,\n    verify: nacl.sign.detached.verify,\n    randomBytes: nacl.randomBytes\n};\nlet helper;\nfunction setEd25519Helper(lib) {\n    helper = lib;\n}\nfunction getEd25519Helper() {\n    return helper;\n}\nconst crc16tab = new Uint16Array([\n    0x0000,\n    0x1021,\n    0x2042,\n    0x3063,\n    0x4084,\n    0x50a5,\n    0x60c6,\n    0x70e7,\n    0x8108,\n    0x9129,\n    0xa14a,\n    0xb16b,\n    0xc18c,\n    0xd1ad,\n    0xe1ce,\n    0xf1ef,\n    0x1231,\n    0x0210,\n    0x3273,\n    0x2252,\n    0x52b5,\n    0x4294,\n    0x72f7,\n    0x62d6,\n    0x9339,\n    0x8318,\n    0xb37b,\n    0xa35a,\n    0xd3bd,\n    0xc39c,\n    0xf3ff,\n    0xe3de,\n    0x2462,\n    0x3443,\n    0x0420,\n    0x1401,\n    0x64e6,\n    0x74c7,\n    0x44a4,\n    0x5485,\n    0xa56a,\n    0xb54b,\n    0x8528,\n    0x9509,\n    0xe5ee,\n    0xf5cf,\n    0xc5ac,\n    0xd58d,\n    0x3653,\n    0x2672,\n    0x1611,\n    0x0630,\n    0x76d7,\n    0x66f6,\n    0x5695,\n    0x46b4,\n    0xb75b,\n    0xa77a,\n    0x9719,\n    0x8738,\n    0xf7df,\n    0xe7fe,\n    0xd79d,\n    0xc7bc,\n    0x48c4,\n    0x58e5,\n    0x6886,\n    0x78a7,\n    0x0840,\n    0x1861,\n    0x2802,\n    0x3823,\n    0xc9cc,\n    0xd9ed,\n    0xe98e,\n    0xf9af,\n    0x8948,\n    0x9969,\n    0xa90a,\n    0xb92b,\n    0x5af5,\n    0x4ad4,\n    0x7ab7,\n    0x6a96,\n    0x1a71,\n    0x0a50,\n    0x3a33,\n    0x2a12,\n    0xdbfd,\n    0xcbdc,\n    0xfbbf,\n    0xeb9e,\n    0x9b79,\n    0x8b58,\n    0xbb3b,\n    0xab1a,\n    0x6ca6,\n    0x7c87,\n    0x4ce4,\n    0x5cc5,\n    0x2c22,\n    0x3c03,\n    0x0c60,\n    0x1c41,\n    0xedae,\n    0xfd8f,\n    0xcdec,\n    0xddcd,\n    0xad2a,\n    0xbd0b,\n    0x8d68,\n    0x9d49,\n    0x7e97,\n    0x6eb6,\n    0x5ed5,\n    0x4ef4,\n    0x3e13,\n    0x2e32,\n    0x1e51,\n    0x0e70,\n    0xff9f,\n    0xefbe,\n    0xdfdd,\n    0xcffc,\n    0xbf1b,\n    0xaf3a,\n    0x9f59,\n    0x8f78,\n    0x9188,\n    0x81a9,\n    0xb1ca,\n    0xa1eb,\n    0xd10c,\n    0xc12d,\n    0xf14e,\n    0xe16f,\n    0x1080,\n    0x00a1,\n    0x30c2,\n    0x20e3,\n    0x5004,\n    0x4025,\n    0x7046,\n    0x6067,\n    0x83b9,\n    0x9398,\n    0xa3fb,\n    0xb3da,\n    0xc33d,\n    0xd31c,\n    0xe37f,\n    0xf35e,\n    0x02b1,\n    0x1290,\n    0x22f3,\n    0x32d2,\n    0x4235,\n    0x5214,\n    0x6277,\n    0x7256,\n    0xb5ea,\n    0xa5cb,\n    0x95a8,\n    0x8589,\n    0xf56e,\n    0xe54f,\n    0xd52c,\n    0xc50d,\n    0x34e2,\n    0x24c3,\n    0x14a0,\n    0x0481,\n    0x7466,\n    0x6447,\n    0x5424,\n    0x4405,\n    0xa7db,\n    0xb7fa,\n    0x8799,\n    0x97b8,\n    0xe75f,\n    0xf77e,\n    0xc71d,\n    0xd73c,\n    0x26d3,\n    0x36f2,\n    0x0691,\n    0x16b0,\n    0x6657,\n    0x7676,\n    0x4615,\n    0x5634,\n    0xd94c,\n    0xc96d,\n    0xf90e,\n    0xe92f,\n    0x99c8,\n    0x89e9,\n    0xb98a,\n    0xa9ab,\n    0x5844,\n    0x4865,\n    0x7806,\n    0x6827,\n    0x18c0,\n    0x08e1,\n    0x3882,\n    0x28a3,\n    0xcb7d,\n    0xdb5c,\n    0xeb3f,\n    0xfb1e,\n    0x8bf9,\n    0x9bd8,\n    0xabbb,\n    0xbb9a,\n    0x4a75,\n    0x5a54,\n    0x6a37,\n    0x7a16,\n    0x0af1,\n    0x1ad0,\n    0x2ab3,\n    0x3a92,\n    0xfd2e,\n    0xed0f,\n    0xdd6c,\n    0xcd4d,\n    0xbdaa,\n    0xad8b,\n    0x9de8,\n    0x8dc9,\n    0x7c26,\n    0x6c07,\n    0x5c64,\n    0x4c45,\n    0x3ca2,\n    0x2c83,\n    0x1ce0,\n    0x0cc1,\n    0xef1f,\n    0xff3e,\n    0xcf5d,\n    0xdf7c,\n    0xaf9b,\n    0xbfba,\n    0x8fd9,\n    0x9ff8,\n    0x6e17,\n    0x7e36,\n    0x4e55,\n    0x5e74,\n    0x2e93,\n    0x3eb2,\n    0x0ed1,\n    0x1ef0\n]);\nclass crc16 {\n    static checksum(data) {\n        let crc = 0;\n        for(let i = 0; i < data.byteLength; i++){\n            let b = data[i];\n            crc = crc << 8 & 0xffff ^ crc16tab[(crc >> 8 ^ b) & 0x00FF];\n        }\n        return crc;\n    }\n    static validate(data, expected) {\n        let ba = crc16.checksum(data);\n        return ba == expected;\n    }\n}\nconst b32Alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\";\nclass base32 {\n    static encode(src) {\n        let bits = 0;\n        let value = 0;\n        let a = new Uint8Array(src);\n        let buf = new Uint8Array(src.byteLength * 2);\n        let j = 0;\n        for(let i = 0; i < a.byteLength; i++){\n            value = value << 8 | a[i];\n            bits += 8;\n            while(bits >= 5){\n                let index = value >>> bits - 5 & 31;\n                buf[j++] = b32Alphabet.charAt(index).charCodeAt(0);\n                bits -= 5;\n            }\n        }\n        if (bits > 0) {\n            let index = value << 5 - bits & 31;\n            buf[j++] = b32Alphabet.charAt(index).charCodeAt(0);\n        }\n        return buf.slice(0, j);\n    }\n    static decode(src) {\n        let bits = 0;\n        let __byte = 0;\n        let j = 0;\n        let a = new Uint8Array(src);\n        let out = new Uint8Array(a.byteLength * 5 / 8 | 0);\n        for(let i = 0; i < a.byteLength; i++){\n            let v = String.fromCharCode(a[i]);\n            let vv = b32Alphabet.indexOf(v);\n            if (vv === -1) {\n                throw new Error(\"Illegal Base32 character: \" + a[i]);\n            }\n            __byte = __byte << 5 | vv;\n            bits += 5;\n            if (bits >= 8) {\n                out[j++] = __byte >>> bits - 8 & 255;\n                bits -= 8;\n            }\n        }\n        return out.slice(0, j);\n    }\n}\nclass NKeysError extends Error {\n    name;\n    code;\n    chainedError;\n    constructor(code, chainedError){\n        super(code);\n        this.name = \"NKeysError\";\n        this.code = code;\n        this.chainedError = chainedError;\n    }\n}\nfunction createOperator() {\n    return createPair(Prefix.Operator);\n}\nfunction createAccount() {\n    return createPair(Prefix.Account);\n}\nfunction createUser() {\n    return createPair(Prefix.User);\n}\nvar NKeysErrorCode;\n(function(NKeysErrorCode) {\n    NKeysErrorCode[\"InvalidPrefixByte\"] = \"nkeys: invalid prefix byte\";\n    NKeysErrorCode[\"InvalidKey\"] = \"nkeys: invalid key\";\n    NKeysErrorCode[\"InvalidPublicKey\"] = \"nkeys: invalid public key\";\n    NKeysErrorCode[\"InvalidSeedLen\"] = \"nkeys: invalid seed length\";\n    NKeysErrorCode[\"InvalidSeed\"] = \"nkeys: invalid seed\";\n    NKeysErrorCode[\"InvalidEncoding\"] = \"nkeys: invalid encoded key\";\n    NKeysErrorCode[\"InvalidSignature\"] = \"nkeys: signature verification failed\";\n    NKeysErrorCode[\"CannotSign\"] = \"nkeys: cannot sign, no private key available\";\n    NKeysErrorCode[\"PublicKeyOnly\"] = \"nkeys: no seed or private key available\";\n    NKeysErrorCode[\"InvalidChecksum\"] = \"nkeys: invalid checksum\";\n    NKeysErrorCode[\"SerializationError\"] = \"nkeys: serialization error\";\n    NKeysErrorCode[\"ApiError\"] = \"nkeys: api error\";\n    NKeysErrorCode[\"ClearedPair\"] = \"nkeys: pair is cleared\";\n})(NKeysErrorCode || (NKeysErrorCode = {}));\nvar Prefix;\n(function(Prefix) {\n    Prefix[Prefix[\"Seed\"] = 144] = \"Seed\";\n    Prefix[Prefix[\"Private\"] = 120] = \"Private\";\n    Prefix[Prefix[\"Operator\"] = 112] = \"Operator\";\n    Prefix[Prefix[\"Server\"] = 104] = \"Server\";\n    Prefix[Prefix[\"Cluster\"] = 16] = \"Cluster\";\n    Prefix[Prefix[\"Account\"] = 0] = \"Account\";\n    Prefix[Prefix[\"User\"] = 160] = \"User\";\n})(Prefix || (Prefix = {}));\nclass Prefixes {\n    static isValidPublicPrefix(prefix) {\n        return prefix == Prefix.Server || prefix == Prefix.Operator || prefix == Prefix.Cluster || prefix == Prefix.Account || prefix == Prefix.User;\n    }\n    static startsWithValidPrefix(s) {\n        let c = s[0];\n        return c == \"S\" || c == \"P\" || c == \"O\" || c == \"N\" || c == \"C\" || c == \"A\" || c == \"U\";\n    }\n    static isValidPrefix(prefix) {\n        let v = this.parsePrefix(prefix);\n        return v != -1;\n    }\n    static parsePrefix(v) {\n        switch(v){\n            case Prefix.Seed:\n                return Prefix.Seed;\n            case Prefix.Private:\n                return Prefix.Private;\n            case Prefix.Operator:\n                return Prefix.Operator;\n            case Prefix.Server:\n                return Prefix.Server;\n            case Prefix.Cluster:\n                return Prefix.Cluster;\n            case Prefix.Account:\n                return Prefix.Account;\n            case Prefix.User:\n                return Prefix.User;\n            default:\n                return -1;\n        }\n    }\n}\nclass Codec {\n    static encode(prefix, src) {\n        if (!src || !(src instanceof Uint8Array)) {\n            throw new NKeysError(NKeysErrorCode.SerializationError);\n        }\n        if (!Prefixes.isValidPrefix(prefix)) {\n            throw new NKeysError(NKeysErrorCode.InvalidPrefixByte);\n        }\n        return Codec._encode(false, prefix, src);\n    }\n    static encodeSeed(role, src) {\n        if (!src) {\n            throw new NKeysError(NKeysErrorCode.ApiError);\n        }\n        if (!Prefixes.isValidPublicPrefix(role)) {\n            throw new NKeysError(NKeysErrorCode.InvalidPrefixByte);\n        }\n        if (src.byteLength !== 32) {\n            throw new NKeysError(NKeysErrorCode.InvalidSeedLen);\n        }\n        return Codec._encode(true, role, src);\n    }\n    static decode(expected, src) {\n        if (!Prefixes.isValidPrefix(expected)) {\n            throw new NKeysError(NKeysErrorCode.InvalidPrefixByte);\n        }\n        const raw = Codec._decode(src);\n        if (raw[0] !== expected) {\n            throw new NKeysError(NKeysErrorCode.InvalidPrefixByte);\n        }\n        return raw.slice(1);\n    }\n    static decodeSeed(src) {\n        const raw = Codec._decode(src);\n        const prefix = Codec._decodePrefix(raw);\n        if (prefix[0] != Prefix.Seed) {\n            throw new NKeysError(NKeysErrorCode.InvalidSeed);\n        }\n        if (!Prefixes.isValidPublicPrefix(prefix[1])) {\n            throw new NKeysError(NKeysErrorCode.InvalidPrefixByte);\n        }\n        return {\n            buf: raw.slice(2),\n            prefix: prefix[1]\n        };\n    }\n    static _encode(seed, role, payload) {\n        const payloadOffset = seed ? 2 : 1;\n        const payloadLen = payload.byteLength;\n        const cap = payloadOffset + payloadLen + 2;\n        const checkOffset = payloadOffset + payloadLen;\n        const raw = new Uint8Array(cap);\n        if (seed) {\n            const encodedPrefix = Codec._encodePrefix(Prefix.Seed, role);\n            raw.set(encodedPrefix);\n        } else {\n            raw[0] = role;\n        }\n        raw.set(payload, payloadOffset);\n        const checksum = crc16.checksum(raw.slice(0, checkOffset));\n        const dv = new DataView(raw.buffer);\n        dv.setUint16(checkOffset, checksum, true);\n        return base32.encode(raw);\n    }\n    static _decode(src) {\n        if (src.byteLength < 4) {\n            throw new NKeysError(NKeysErrorCode.InvalidEncoding);\n        }\n        let raw;\n        try {\n            raw = base32.decode(src);\n        } catch (ex) {\n            throw new NKeysError(NKeysErrorCode.InvalidEncoding, ex);\n        }\n        const checkOffset = raw.byteLength - 2;\n        const dv = new DataView(raw.buffer);\n        const checksum = dv.getUint16(checkOffset, true);\n        const payload = raw.slice(0, checkOffset);\n        if (!crc16.validate(payload, checksum)) {\n            throw new NKeysError(NKeysErrorCode.InvalidChecksum);\n        }\n        return payload;\n    }\n    static _encodePrefix(kind, role) {\n        const b1 = kind | role >> 5;\n        const b2 = (role & 31) << 3;\n        return new Uint8Array([\n            b1,\n            b2\n        ]);\n    }\n    static _decodePrefix(raw) {\n        const b1 = raw[0] & 248;\n        const b2 = (raw[0] & 7) << 5 | (raw[1] & 248) >> 3;\n        return new Uint8Array([\n            b1,\n            b2\n        ]);\n    }\n}\nclass KP {\n    seed;\n    constructor(seed){\n        this.seed = seed;\n    }\n    getRawSeed() {\n        if (!this.seed) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        let sd = Codec.decodeSeed(this.seed);\n        return sd.buf;\n    }\n    getSeed() {\n        if (!this.seed) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        return this.seed;\n    }\n    getPublicKey() {\n        if (!this.seed) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        const sd = Codec.decodeSeed(this.seed);\n        const kp = getEd25519Helper().fromSeed(this.getRawSeed());\n        const buf = Codec.encode(sd.prefix, kp.publicKey);\n        return new TextDecoder().decode(buf);\n    }\n    getPrivateKey() {\n        if (!this.seed) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        const kp = getEd25519Helper().fromSeed(this.getRawSeed());\n        return Codec.encode(Prefix.Private, kp.secretKey);\n    }\n    sign(input) {\n        if (!this.seed) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        const kp = getEd25519Helper().fromSeed(this.getRawSeed());\n        return getEd25519Helper().sign(input, kp.secretKey);\n    }\n    verify(input, sig) {\n        if (!this.seed) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        const kp = getEd25519Helper().fromSeed(this.getRawSeed());\n        return getEd25519Helper().verify(input, sig, kp.publicKey);\n    }\n    clear() {\n        if (!this.seed) {\n            return;\n        }\n        this.seed.fill(0);\n        this.seed = undefined;\n    }\n}\nfunction createPair(prefix) {\n    const rawSeed = getEd25519Helper().randomBytes(32);\n    let str = Codec.encodeSeed(prefix, new Uint8Array(rawSeed));\n    return new KP(str);\n}\nclass PublicKey {\n    publicKey;\n    constructor(publicKey){\n        this.publicKey = publicKey;\n    }\n    getPublicKey() {\n        if (!this.publicKey) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        return new TextDecoder().decode(this.publicKey);\n    }\n    getPrivateKey() {\n        if (!this.publicKey) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        throw new NKeysError(NKeysErrorCode.PublicKeyOnly);\n    }\n    getSeed() {\n        if (!this.publicKey) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        throw new NKeysError(NKeysErrorCode.PublicKeyOnly);\n    }\n    sign(_) {\n        if (!this.publicKey) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        throw new NKeysError(NKeysErrorCode.CannotSign);\n    }\n    verify(input, sig) {\n        if (!this.publicKey) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        let buf = Codec._decode(this.publicKey);\n        return getEd25519Helper().verify(input, sig, buf.slice(1));\n    }\n    clear() {\n        if (!this.publicKey) {\n            return;\n        }\n        this.publicKey.fill(0);\n        this.publicKey = undefined;\n    }\n}\nfunction fromPublic(src) {\n    const ba = new TextEncoder().encode(src);\n    const raw = Codec._decode(ba);\n    const prefix = Prefixes.parsePrefix(raw[0]);\n    if (Prefixes.isValidPublicPrefix(prefix)) {\n        return new PublicKey(ba);\n    }\n    throw new NKeysError(NKeysErrorCode.InvalidPublicKey);\n}\nfunction fromSeed(src) {\n    Codec.decodeSeed(src);\n    return new KP(src);\n}\nfunction encode1(bytes) {\n    return btoa(String.fromCharCode(...bytes));\n}\nfunction decode1(b64str) {\n    const bin = atob(b64str);\n    const bytes = new Uint8Array(bin.length);\n    for(let i = 0; i < bin.length; i++){\n        bytes[i] = bin.charCodeAt(i);\n    }\n    return bytes;\n}\nsetEd25519Helper(denoHelper);\nconst mod = {\n    createAccount,\n    createOperator,\n    createPair,\n    createUser,\n    fromPublic,\n    fromSeed,\n    NKeysError,\n    NKeysErrorCode,\n    Prefix,\n    decode: decode1,\n    encode: encode1\n};\nfunction multiAuthenticator(authenticators) {\n    return (nonce)=>{\n        let auth = {};\n        authenticators.forEach((a)=>{\n            const args = a(nonce) || {};\n            auth = Object.assign(auth, args);\n        });\n        return auth;\n    };\n}\nfunction noAuthFn() {\n    return ()=>{\n        return;\n    };\n}\nfunction usernamePasswordAuthenticator(user, pass) {\n    return ()=>{\n        const u = typeof user === \"function\" ? user() : user;\n        const p = typeof pass === \"function\" ? pass() : pass;\n        return {\n            user: u,\n            pass: p\n        };\n    };\n}\nfunction tokenAuthenticator(token) {\n    return ()=>{\n        const auth_token = typeof token === \"function\" ? token() : token;\n        return {\n            auth_token\n        };\n    };\n}\nfunction nkeyAuthenticator(seed) {\n    return (nonce)=>{\n        const s = typeof seed === \"function\" ? seed() : seed;\n        const kp = s ? mod.fromSeed(s) : undefined;\n        const nkey = kp ? kp.getPublicKey() : \"\";\n        const challenge = TE.encode(nonce || \"\");\n        const sigBytes = kp !== undefined && nonce ? kp.sign(challenge) : undefined;\n        const sig = sigBytes ? mod.encode(sigBytes) : \"\";\n        return {\n            nkey,\n            sig\n        };\n    };\n}\nfunction jwtAuthenticator(ajwt, seed) {\n    return (nonce)=>{\n        const jwt = typeof ajwt === \"function\" ? ajwt() : ajwt;\n        const fn = nkeyAuthenticator(seed);\n        const { nkey, sig } = fn(nonce);\n        return {\n            jwt,\n            nkey,\n            sig\n        };\n    };\n}\nfunction credsAuthenticator(creds) {\n    const fn = typeof creds !== \"function\" ? ()=>creds : creds;\n    const parse = ()=>{\n        const CREDS = /\\s*(?:(?:[-]{3,}[^\\n]*[-]{3,}\\n)(.+)(?:\\n\\s*[-]{3,}[^\\n]*[-]{3,}\\n))/ig;\n        const s = TD.decode(fn());\n        let m = CREDS.exec(s);\n        if (!m) {\n            throw NatsError.errorForCode(ErrorCode.BadCreds);\n        }\n        const jwt = m[1].trim();\n        m = CREDS.exec(s);\n        if (!m) {\n            throw NatsError.errorForCode(ErrorCode.BadCreds);\n        }\n        if (!m) {\n            throw NatsError.errorForCode(ErrorCode.BadCreds);\n        }\n        const seed = TE.encode(m[1].trim());\n        return {\n            jwt,\n            seed\n        };\n    };\n    const jwtFn = ()=>{\n        const { jwt } = parse();\n        return jwt;\n    };\n    const nkeyFn = ()=>{\n        const { seed } = parse();\n        return seed;\n    };\n    return jwtAuthenticator(jwtFn, nkeyFn);\n}\nconst DEFAULT_PING_INTERVAL = 2 * 60 * 1000;\nconst DEFAULT_MAX_PING_OUT = 2;\nconst DEFAULT_RECONNECT_TIME_WAIT = 2 * 1000;\nfunction defaultOptions() {\n    return {\n        maxPingOut: 2,\n        maxReconnectAttempts: 10,\n        noRandomize: false,\n        pedantic: false,\n        pingInterval: DEFAULT_PING_INTERVAL,\n        reconnect: true,\n        reconnectJitter: 100,\n        reconnectJitterTLS: 1000,\n        reconnectTimeWait: DEFAULT_RECONNECT_TIME_WAIT,\n        tls: undefined,\n        verbose: false,\n        waitOnFirstConnect: false,\n        ignoreAuthErrorAbort: false\n    };\n}\nfunction buildAuthenticator(opts) {\n    const buf = [];\n    if (typeof opts.authenticator === \"function\") {\n        buf.push(opts.authenticator);\n    }\n    if (Array.isArray(opts.authenticator)) {\n        buf.push(...opts.authenticator);\n    }\n    if (opts.token) {\n        buf.push(tokenAuthenticator(opts.token));\n    }\n    if (opts.user) {\n        buf.push(usernamePasswordAuthenticator(opts.user, opts.pass));\n    }\n    return buf.length === 0 ? noAuthFn() : multiAuthenticator(buf);\n}\nfunction parseOptions(opts) {\n    const dhp = `${DEFAULT_HOST}:${defaultPort()}`;\n    opts = opts || {\n        servers: [\n            dhp\n        ]\n    };\n    opts.servers = opts.servers || [];\n    if (typeof opts.servers === \"string\") {\n        opts.servers = [\n            opts.servers\n        ];\n    }\n    if (opts.servers.length > 0 && opts.port) {\n        throw new NatsError(\"port and servers options are mutually exclusive\", ErrorCode.InvalidOption);\n    }\n    if (opts.servers.length === 0 && opts.port) {\n        opts.servers = [\n            `${DEFAULT_HOST}:${opts.port}`\n        ];\n    }\n    if (opts.servers && opts.servers.length === 0) {\n        opts.servers = [\n            dhp\n        ];\n    }\n    const options = extend(defaultOptions(), opts);\n    options.authenticator = buildAuthenticator(options);\n    [\n        \"reconnectDelayHandler\",\n        \"authenticator\"\n    ].forEach((n)=>{\n        if (options[n] && typeof options[n] !== \"function\") {\n            throw new NatsError(`${n} option should be a function`, ErrorCode.NotFunction);\n        }\n    });\n    if (!options.reconnectDelayHandler) {\n        options.reconnectDelayHandler = ()=>{\n            let extra = options.tls ? options.reconnectJitterTLS : options.reconnectJitter;\n            if (extra) {\n                extra++;\n                extra = Math.floor(Math.random() * extra);\n            }\n            return options.reconnectTimeWait + extra;\n        };\n    }\n    if (options.inboxPrefix) {\n        try {\n            createInbox(options.inboxPrefix);\n        } catch (err) {\n            throw new NatsError(err.message, ErrorCode.ApiError);\n        }\n    }\n    if (options.resolve === undefined) {\n        options.resolve = typeof getResolveFn() === \"function\";\n    }\n    if (options.resolve) {\n        if (typeof getResolveFn() !== \"function\") {\n            throw new NatsError(`'resolve' is not supported on this client`, ErrorCode.InvalidOption);\n        }\n    }\n    return options;\n}\nfunction checkOptions(info, options) {\n    const { proto, tls_required: tlsRequired, tls_available: tlsAvailable } = info;\n    if ((proto === undefined || proto < 1) && options.noEcho) {\n        throw new NatsError(\"noEcho\", ErrorCode.ServerOptionNotAvailable);\n    }\n    const tls = tlsRequired || tlsAvailable || false;\n    if (options.tls && !tls) {\n        throw new NatsError(\"tls\", ErrorCode.ServerOptionNotAvailable);\n    }\n}\nconst FLUSH_THRESHOLD = 1024 * 32;\nconst INFO = /^INFO\\s+([^\\r\\n]+)\\r\\n/i;\nconst PONG_CMD = encode(\"PONG\\r\\n\");\nconst PING_CMD = encode(\"PING\\r\\n\");\nclass Connect {\n    echo;\n    no_responders;\n    protocol;\n    verbose;\n    pedantic;\n    jwt;\n    nkey;\n    sig;\n    user;\n    pass;\n    auth_token;\n    tls_required;\n    name;\n    lang;\n    version;\n    headers;\n    constructor(transport, opts, nonce){\n        this.protocol = 1;\n        this.version = transport.version;\n        this.lang = transport.lang;\n        this.echo = opts.noEcho ? false : undefined;\n        this.verbose = opts.verbose;\n        this.pedantic = opts.pedantic;\n        this.tls_required = opts.tls ? true : undefined;\n        this.name = opts.name;\n        const creds = (opts && typeof opts.authenticator === \"function\" ? opts.authenticator(nonce) : {}) || {};\n        extend(this, creds);\n    }\n}\nclass SubscriptionImpl extends QueuedIteratorImpl {\n    sid;\n    queue;\n    draining;\n    max;\n    subject;\n    drained;\n    protocol;\n    timer;\n    info;\n    cleanupFn;\n    closed;\n    requestSubject;\n    constructor(protocol, subject, opts = {}){\n        super();\n        extend(this, opts);\n        this.protocol = protocol;\n        this.subject = subject;\n        this.draining = false;\n        this.noIterator = typeof opts.callback === \"function\";\n        this.closed = deferred();\n        const asyncTraces = !(protocol.options?.noAsyncTraces || false);\n        if (opts.timeout) {\n            this.timer = timeout(opts.timeout, asyncTraces);\n            this.timer.then(()=>{\n                this.timer = undefined;\n            }).catch((err)=>{\n                this.stop(err);\n                if (this.noIterator) {\n                    this.callback(err, {});\n                }\n            });\n        }\n        if (!this.noIterator) {\n            this.iterClosed.then(()=>{\n                this.closed.resolve();\n                this.unsubscribe();\n            });\n        }\n    }\n    setPrePostHandlers(opts) {\n        if (this.noIterator) {\n            const uc = this.callback;\n            const ingestion = opts.ingestionFilterFn ? opts.ingestionFilterFn : ()=>{\n                return {\n                    ingest: true,\n                    protocol: false\n                };\n            };\n            const filter = opts.protocolFilterFn ? opts.protocolFilterFn : ()=>{\n                return true;\n            };\n            const dispatched = opts.dispatchedFn ? opts.dispatchedFn : ()=>{};\n            this.callback = (err, msg)=>{\n                const { ingest } = ingestion(msg);\n                if (!ingest) {\n                    return;\n                }\n                if (filter(msg)) {\n                    uc(err, msg);\n                    dispatched(msg);\n                }\n            };\n        } else {\n            this.protocolFilterFn = opts.protocolFilterFn;\n            this.dispatchedFn = opts.dispatchedFn;\n        }\n    }\n    callback(err, msg) {\n        this.cancelTimeout();\n        err ? this.stop(err) : this.push(msg);\n    }\n    close() {\n        if (!this.isClosed()) {\n            this.cancelTimeout();\n            const fn = ()=>{\n                this.stop();\n                if (this.cleanupFn) {\n                    try {\n                        this.cleanupFn(this, this.info);\n                    } catch (_err) {}\n                }\n                this.closed.resolve();\n            };\n            if (this.noIterator) {\n                fn();\n            } else {\n                this.push(fn);\n            }\n        }\n    }\n    unsubscribe(max) {\n        this.protocol.unsubscribe(this, max);\n    }\n    cancelTimeout() {\n        if (this.timer) {\n            this.timer.cancel();\n            this.timer = undefined;\n        }\n    }\n    drain() {\n        if (this.protocol.isClosed()) {\n            return Promise.reject(NatsError.errorForCode(ErrorCode.ConnectionClosed));\n        }\n        if (this.isClosed()) {\n            return Promise.reject(NatsError.errorForCode(ErrorCode.SubClosed));\n        }\n        if (!this.drained) {\n            this.draining = true;\n            this.protocol.unsub(this);\n            this.drained = this.protocol.flush(deferred()).then(()=>{\n                this.protocol.subscriptions.cancel(this);\n            }).catch(()=>{\n                this.protocol.subscriptions.cancel(this);\n            });\n        }\n        return this.drained;\n    }\n    isDraining() {\n        return this.draining;\n    }\n    isClosed() {\n        return this.done;\n    }\n    getSubject() {\n        return this.subject;\n    }\n    getMax() {\n        return this.max;\n    }\n    getID() {\n        return this.sid;\n    }\n}\nclass Subscriptions {\n    mux;\n    subs;\n    sidCounter;\n    constructor(){\n        this.sidCounter = 0;\n        this.mux = null;\n        this.subs = new Map();\n    }\n    size() {\n        return this.subs.size;\n    }\n    add(s) {\n        this.sidCounter++;\n        s.sid = this.sidCounter;\n        this.subs.set(s.sid, s);\n        return s;\n    }\n    setMux(s) {\n        this.mux = s;\n        return s;\n    }\n    getMux() {\n        return this.mux;\n    }\n    get(sid) {\n        return this.subs.get(sid);\n    }\n    resub(s) {\n        this.sidCounter++;\n        this.subs.delete(s.sid);\n        s.sid = this.sidCounter;\n        this.subs.set(s.sid, s);\n        return s;\n    }\n    all() {\n        return Array.from(this.subs.values());\n    }\n    cancel(s) {\n        if (s) {\n            s.close();\n            this.subs.delete(s.sid);\n        }\n    }\n    handleError(err) {\n        if (err && err.permissionContext) {\n            const ctx = err.permissionContext;\n            const subs = this.all();\n            let sub;\n            if (ctx.operation === \"subscription\") {\n                sub = subs.find((s)=>{\n                    return s.subject === ctx.subject && s.queue === ctx.queue;\n                });\n            }\n            if (ctx.operation === \"publish\") {\n                sub = subs.find((s)=>{\n                    return s.requestSubject === ctx.subject;\n                });\n            }\n            if (sub) {\n                sub.callback(err, {});\n                sub.close();\n                this.subs.delete(sub.sid);\n                return sub !== this.mux;\n            }\n        }\n        return false;\n    }\n    close() {\n        this.subs.forEach((sub)=>{\n            sub.close();\n        });\n    }\n}\nclass ProtocolHandler {\n    connected;\n    connectedOnce;\n    infoReceived;\n    info;\n    muxSubscriptions;\n    options;\n    outbound;\n    pongs;\n    subscriptions;\n    transport;\n    noMorePublishing;\n    connectError;\n    publisher;\n    _closed;\n    closed;\n    listeners;\n    heartbeats;\n    parser;\n    outMsgs;\n    inMsgs;\n    outBytes;\n    inBytes;\n    pendingLimit;\n    lastError;\n    abortReconnect;\n    whyClosed;\n    servers;\n    server;\n    features;\n    connectPromise;\n    constructor(options, publisher){\n        this._closed = false;\n        this.connected = false;\n        this.connectedOnce = false;\n        this.infoReceived = false;\n        this.noMorePublishing = false;\n        this.abortReconnect = false;\n        this.listeners = [];\n        this.pendingLimit = FLUSH_THRESHOLD;\n        this.outMsgs = 0;\n        this.inMsgs = 0;\n        this.outBytes = 0;\n        this.inBytes = 0;\n        this.options = options;\n        this.publisher = publisher;\n        this.subscriptions = new Subscriptions();\n        this.muxSubscriptions = new MuxSubscription();\n        this.outbound = new DataBuffer();\n        this.pongs = [];\n        this.whyClosed = \"\";\n        this.pendingLimit = options.pendingLimit || this.pendingLimit;\n        this.features = new Features({\n            major: 0,\n            minor: 0,\n            micro: 0\n        });\n        this.connectPromise = null;\n        const servers = typeof options.servers === \"string\" ? [\n            options.servers\n        ] : options.servers;\n        this.servers = new Servers(servers, {\n            randomize: !options.noRandomize\n        });\n        this.closed = deferred();\n        this.parser = new Parser(this);\n        this.heartbeats = new Heartbeat(this, this.options.pingInterval || DEFAULT_PING_INTERVAL, this.options.maxPingOut || DEFAULT_MAX_PING_OUT);\n    }\n    resetOutbound() {\n        this.outbound.reset();\n        const pongs = this.pongs;\n        this.pongs = [];\n        const err = NatsError.errorForCode(ErrorCode.Disconnect);\n        err.stack = \"\";\n        pongs.forEach((p)=>{\n            p.reject(err);\n        });\n        this.parser = new Parser(this);\n        this.infoReceived = false;\n    }\n    dispatchStatus(status) {\n        this.listeners.forEach((q)=>{\n            q.push(status);\n        });\n    }\n    status() {\n        const iter = new QueuedIteratorImpl();\n        this.listeners.push(iter);\n        return iter;\n    }\n    prepare() {\n        if (this.transport) {\n            this.transport.discard();\n        }\n        this.info = undefined;\n        this.resetOutbound();\n        const pong = deferred();\n        pong.catch(()=>{});\n        this.pongs.unshift(pong);\n        this.connectError = (err)=>{\n            pong.reject(err);\n        };\n        this.transport = newTransport();\n        this.transport.closed().then(async (_err)=>{\n            this.connected = false;\n            if (!this.isClosed()) {\n                await this.disconnected(this.transport.closeError || this.lastError);\n                return;\n            }\n        });\n        return pong;\n    }\n    disconnect() {\n        this.dispatchStatus({\n            type: DebugEvents.StaleConnection,\n            data: \"\"\n        });\n        this.transport.disconnect();\n    }\n    reconnect() {\n        if (this.connected) {\n            this.dispatchStatus({\n                type: DebugEvents.ClientInitiatedReconnect,\n                data: \"\"\n            });\n            this.transport.disconnect();\n        }\n        return Promise.resolve();\n    }\n    async disconnected(err) {\n        this.dispatchStatus({\n            type: Events.Disconnect,\n            data: this.servers.getCurrentServer().toString()\n        });\n        if (this.options.reconnect) {\n            await this.dialLoop().then(()=>{\n                this.dispatchStatus({\n                    type: Events.Reconnect,\n                    data: this.servers.getCurrentServer().toString()\n                });\n                if (this.lastError?.code === ErrorCode.AuthenticationExpired) {\n                    this.lastError = undefined;\n                }\n            }).catch((err)=>{\n                this._close(err);\n            });\n        } else {\n            await this._close(err);\n        }\n    }\n    async dial(srv) {\n        const pong = this.prepare();\n        let timer;\n        try {\n            timer = timeout(this.options.timeout || 20000);\n            const cp = this.transport.connect(srv, this.options);\n            await Promise.race([\n                cp,\n                timer\n            ]);\n            (async ()=>{\n                try {\n                    for await (const b of this.transport){\n                        this.parser.parse(b);\n                    }\n                } catch (err) {\n                    console.log(\"reader closed\", err);\n                }\n            })().then();\n        } catch (err) {\n            pong.reject(err);\n        }\n        try {\n            await Promise.race([\n                timer,\n                pong\n            ]);\n            if (timer) {\n                timer.cancel();\n            }\n            this.connected = true;\n            this.connectError = undefined;\n            this.sendSubscriptions();\n            this.connectedOnce = true;\n            this.server.didConnect = true;\n            this.server.reconnects = 0;\n            this.flushPending();\n            this.heartbeats.start();\n        } catch (err) {\n            if (timer) {\n                timer.cancel();\n            }\n            await this.transport.close(err);\n            throw err;\n        }\n    }\n    async _doDial(srv) {\n        const { resolve } = this.options;\n        const alts = await srv.resolve({\n            fn: getResolveFn(),\n            debug: this.options.debug,\n            randomize: !this.options.noRandomize,\n            resolve\n        });\n        let lastErr = null;\n        for (const a of alts){\n            try {\n                lastErr = null;\n                this.dispatchStatus({\n                    type: DebugEvents.Reconnecting,\n                    data: a.toString()\n                });\n                await this.dial(a);\n                return;\n            } catch (err) {\n                lastErr = err;\n            }\n        }\n        throw lastErr;\n    }\n    dialLoop() {\n        if (this.connectPromise === null) {\n            this.connectPromise = this.dodialLoop();\n            this.connectPromise.then(()=>{}).catch(()=>{}).finally(()=>{\n                this.connectPromise = null;\n            });\n        }\n        return this.connectPromise;\n    }\n    async dodialLoop() {\n        let lastError;\n        while(true){\n            if (this._closed) {\n                this.servers.clear();\n            }\n            const wait = this.options.reconnectDelayHandler ? this.options.reconnectDelayHandler() : DEFAULT_RECONNECT_TIME_WAIT;\n            let maxWait = wait;\n            const srv = this.selectServer();\n            if (!srv || this.abortReconnect) {\n                if (lastError) {\n                    throw lastError;\n                } else if (this.lastError) {\n                    throw this.lastError;\n                } else {\n                    throw NatsError.errorForCode(ErrorCode.ConnectionRefused);\n                }\n            }\n            const now = Date.now();\n            if (srv.lastConnect === 0 || srv.lastConnect + wait <= now) {\n                srv.lastConnect = Date.now();\n                try {\n                    await this._doDial(srv);\n                    break;\n                } catch (err) {\n                    lastError = err;\n                    if (!this.connectedOnce) {\n                        if (this.options.waitOnFirstConnect) {\n                            continue;\n                        }\n                        this.servers.removeCurrentServer();\n                    }\n                    srv.reconnects++;\n                    const mra = this.options.maxReconnectAttempts || 0;\n                    if (mra !== -1 && srv.reconnects >= mra) {\n                        this.servers.removeCurrentServer();\n                    }\n                }\n            } else {\n                maxWait = Math.min(maxWait, srv.lastConnect + wait - now);\n                await delay(maxWait);\n            }\n        }\n    }\n    static async connect(options, publisher) {\n        const h = new ProtocolHandler(options, publisher);\n        await h.dialLoop();\n        return h;\n    }\n    static toError(s) {\n        const t = s ? s.toLowerCase() : \"\";\n        if (t.indexOf(\"permissions violation\") !== -1) {\n            const err = new NatsError(s, ErrorCode.PermissionsViolation);\n            const m = s.match(/(Publish|Subscription) to \"(\\S+)\"/);\n            if (m) {\n                err.permissionContext = {\n                    operation: m[1].toLowerCase(),\n                    subject: m[2],\n                    queue: undefined\n                };\n                const qm = s.match(/using queue \"(\\S+)\"/);\n                if (qm) {\n                    err.permissionContext.queue = qm[1];\n                }\n            }\n            return err;\n        } else if (t.indexOf(\"authorization violation\") !== -1) {\n            return new NatsError(s, ErrorCode.AuthorizationViolation);\n        } else if (t.indexOf(\"user authentication expired\") !== -1) {\n            return new NatsError(s, ErrorCode.AuthenticationExpired);\n        } else if (t.indexOf(\"account authentication expired\") != -1) {\n            return new NatsError(s, ErrorCode.AccountExpired);\n        } else if (t.indexOf(\"authentication timeout\") !== -1) {\n            return new NatsError(s, ErrorCode.AuthenticationTimeout);\n        } else {\n            return new NatsError(s, ErrorCode.ProtocolError);\n        }\n    }\n    processMsg(msg, data) {\n        this.inMsgs++;\n        this.inBytes += data.length;\n        if (!this.subscriptions.sidCounter) {\n            return;\n        }\n        const sub = this.subscriptions.get(msg.sid);\n        if (!sub) {\n            return;\n        }\n        sub.received += 1;\n        if (sub.callback) {\n            sub.callback(null, new MsgImpl(msg, data, this));\n        }\n        if (sub.max !== undefined && sub.received >= sub.max) {\n            sub.unsubscribe();\n        }\n    }\n    processError(m) {\n        const s = decode(m);\n        const err = ProtocolHandler.toError(s);\n        const status = {\n            type: Events.Error,\n            data: err.code\n        };\n        if (err.isPermissionError()) {\n            let isMuxPermissionError = false;\n            if (err.permissionContext) {\n                status.permissionContext = err.permissionContext;\n                const mux = this.subscriptions.getMux();\n                isMuxPermissionError = mux?.subject === err.permissionContext.subject;\n            }\n            this.subscriptions.handleError(err);\n            this.muxSubscriptions.handleError(isMuxPermissionError, err);\n            if (isMuxPermissionError) {\n                this.subscriptions.setMux(null);\n            }\n        }\n        this.dispatchStatus(status);\n        this.handleError(err);\n    }\n    handleError(err) {\n        if (err.isAuthError()) {\n            this.handleAuthError(err);\n        } else if (err.isProtocolError()) {\n            this.lastError = err;\n        } else if (err.isAuthTimeout()) {\n            this.lastError = err;\n        }\n        if (!err.isPermissionError()) {\n            this.lastError = err;\n        }\n    }\n    handleAuthError(err) {\n        if (this.lastError && err.code === this.lastError.code && this.options.ignoreAuthErrorAbort === false) {\n            this.abortReconnect = true;\n        }\n        if (this.connectError) {\n            this.connectError(err);\n        } else {\n            this.disconnect();\n        }\n    }\n    processPing() {\n        this.transport.send(PONG_CMD);\n    }\n    processPong() {\n        const cb = this.pongs.shift();\n        if (cb) {\n            cb.resolve();\n        }\n    }\n    processInfo(m) {\n        const info = JSON.parse(decode(m));\n        this.info = info;\n        const updates = this.options && this.options.ignoreClusterUpdates ? undefined : this.servers.update(info, this.transport.isEncrypted());\n        if (!this.infoReceived) {\n            this.features.update(parseSemVer(info.version));\n            this.infoReceived = true;\n            if (this.transport.isEncrypted()) {\n                this.servers.updateTLSName();\n            }\n            const { version, lang } = this.transport;\n            try {\n                const c = new Connect({\n                    version,\n                    lang\n                }, this.options, info.nonce);\n                if (info.headers) {\n                    c.headers = true;\n                    c.no_responders = true;\n                }\n                const cs = JSON.stringify(c);\n                this.transport.send(encode(`CONNECT ${cs}${CR_LF}`));\n                this.transport.send(PING_CMD);\n            } catch (err) {\n                this._close(err);\n            }\n        }\n        if (updates) {\n            this.dispatchStatus({\n                type: Events.Update,\n                data: updates\n            });\n        }\n        const ldm = info.ldm !== undefined ? info.ldm : false;\n        if (ldm) {\n            this.dispatchStatus({\n                type: Events.LDM,\n                data: this.servers.getCurrentServer().toString()\n            });\n        }\n    }\n    push(e) {\n        switch(e.kind){\n            case Kind.MSG:\n                {\n                    const { msg, data } = e;\n                    this.processMsg(msg, data);\n                    break;\n                }\n            case Kind.OK:\n                break;\n            case Kind.ERR:\n                this.processError(e.data);\n                break;\n            case Kind.PING:\n                this.processPing();\n                break;\n            case Kind.PONG:\n                this.processPong();\n                break;\n            case Kind.INFO:\n                this.processInfo(e.data);\n                break;\n        }\n    }\n    sendCommand(cmd, ...payloads) {\n        const len = this.outbound.length();\n        let buf;\n        if (typeof cmd === \"string\") {\n            buf = encode(cmd);\n        } else {\n            buf = cmd;\n        }\n        this.outbound.fill(buf, ...payloads);\n        if (len === 0) {\n            queueMicrotask(()=>{\n                this.flushPending();\n            });\n        } else if (this.outbound.size() >= this.pendingLimit) {\n            this.flushPending();\n        }\n    }\n    publish(subject, payload = Empty, options) {\n        let data;\n        if (payload instanceof Uint8Array) {\n            data = payload;\n        } else if (typeof payload === \"string\") {\n            data = TE.encode(payload);\n        } else {\n            throw NatsError.errorForCode(ErrorCode.BadPayload);\n        }\n        let len = data.length;\n        options = options || {};\n        options.reply = options.reply || \"\";\n        let headers = Empty;\n        let hlen = 0;\n        if (options.headers) {\n            if (this.info && !this.info.headers) {\n                throw new NatsError(\"headers\", ErrorCode.ServerOptionNotAvailable);\n            }\n            const hdrs = options.headers;\n            headers = hdrs.encode();\n            hlen = headers.length;\n            len = data.length + hlen;\n        }\n        if (this.info && len > this.info.max_payload) {\n            throw NatsError.errorForCode(ErrorCode.MaxPayloadExceeded);\n        }\n        this.outBytes += len;\n        this.outMsgs++;\n        let proto;\n        if (options.headers) {\n            if (options.reply) {\n                proto = `HPUB ${subject} ${options.reply} ${hlen} ${len}\\r\\n`;\n            } else {\n                proto = `HPUB ${subject} ${hlen} ${len}\\r\\n`;\n            }\n            this.sendCommand(proto, headers, data, CRLF);\n        } else {\n            if (options.reply) {\n                proto = `PUB ${subject} ${options.reply} ${len}\\r\\n`;\n            } else {\n                proto = `PUB ${subject} ${len}\\r\\n`;\n            }\n            this.sendCommand(proto, data, CRLF);\n        }\n    }\n    request(r) {\n        this.initMux();\n        this.muxSubscriptions.add(r);\n        return r;\n    }\n    subscribe(s) {\n        this.subscriptions.add(s);\n        this._subunsub(s);\n        return s;\n    }\n    _sub(s) {\n        if (s.queue) {\n            this.sendCommand(`SUB ${s.subject} ${s.queue} ${s.sid}\\r\\n`);\n        } else {\n            this.sendCommand(`SUB ${s.subject} ${s.sid}\\r\\n`);\n        }\n    }\n    _subunsub(s) {\n        this._sub(s);\n        if (s.max) {\n            this.unsubscribe(s, s.max);\n        }\n        return s;\n    }\n    unsubscribe(s, max) {\n        this.unsub(s, max);\n        if (s.max === undefined || s.received >= s.max) {\n            this.subscriptions.cancel(s);\n        }\n    }\n    unsub(s, max) {\n        if (!s || this.isClosed()) {\n            return;\n        }\n        if (max) {\n            this.sendCommand(`UNSUB ${s.sid} ${max}\\r\\n`);\n        } else {\n            this.sendCommand(`UNSUB ${s.sid}\\r\\n`);\n        }\n        s.max = max;\n    }\n    resub(s, subject) {\n        if (!s || this.isClosed()) {\n            return;\n        }\n        this.unsub(s);\n        s.subject = subject;\n        this.subscriptions.resub(s);\n        this._sub(s);\n    }\n    flush(p) {\n        if (!p) {\n            p = deferred();\n        }\n        this.pongs.push(p);\n        this.outbound.fill(PING_CMD);\n        this.flushPending();\n        return p;\n    }\n    sendSubscriptions() {\n        const cmds = [];\n        this.subscriptions.all().forEach((s)=>{\n            const sub = s;\n            if (sub.queue) {\n                cmds.push(`SUB ${sub.subject} ${sub.queue} ${sub.sid}${CR_LF}`);\n            } else {\n                cmds.push(`SUB ${sub.subject} ${sub.sid}${CR_LF}`);\n            }\n        });\n        if (cmds.length) {\n            this.transport.send(encode(cmds.join(\"\")));\n        }\n    }\n    async _close(err) {\n        if (this._closed) {\n            return;\n        }\n        this.whyClosed = new Error(\"close trace\").stack || \"\";\n        this.heartbeats.cancel();\n        if (this.connectError) {\n            this.connectError(err);\n            this.connectError = undefined;\n        }\n        this.muxSubscriptions.close();\n        this.subscriptions.close();\n        this.listeners.forEach((l)=>{\n            l.stop();\n        });\n        this._closed = true;\n        await this.transport.close(err);\n        await this.closed.resolve(err);\n    }\n    close() {\n        return this._close();\n    }\n    isClosed() {\n        return this._closed;\n    }\n    drain() {\n        const subs = this.subscriptions.all();\n        const promises = [];\n        subs.forEach((sub)=>{\n            promises.push(sub.drain());\n        });\n        return Promise.all(promises).then(async ()=>{\n            this.noMorePublishing = true;\n            await this.flush();\n            return this.close();\n        }).catch(()=>{});\n    }\n    flushPending() {\n        if (!this.infoReceived || !this.connected) {\n            return;\n        }\n        if (this.outbound.size()) {\n            const d = this.outbound.drain();\n            this.transport.send(d);\n        }\n    }\n    initMux() {\n        const mux = this.subscriptions.getMux();\n        if (!mux) {\n            const inbox = this.muxSubscriptions.init(this.options.inboxPrefix);\n            const sub = new SubscriptionImpl(this, `${inbox}*`);\n            sub.callback = this.muxSubscriptions.dispatcher();\n            this.subscriptions.setMux(sub);\n            this.subscribe(sub);\n        }\n    }\n    selectServer() {\n        const server = this.servers.selectServer();\n        if (server === undefined) {\n            return undefined;\n        }\n        this.server = server;\n        return this.server;\n    }\n    getServer() {\n        return this.server;\n    }\n}\nconst ServiceApiPrefix = \"$SRV\";\nclass ServiceMsgImpl {\n    msg;\n    constructor(msg){\n        this.msg = msg;\n    }\n    get data() {\n        return this.msg.data;\n    }\n    get sid() {\n        return this.msg.sid;\n    }\n    get subject() {\n        return this.msg.subject;\n    }\n    get reply() {\n        return this.msg.reply || \"\";\n    }\n    get headers() {\n        return this.msg.headers;\n    }\n    respond(data, opts) {\n        return this.msg.respond(data, opts);\n    }\n    respondError(code, description, data, opts) {\n        opts = opts || {};\n        opts.headers = opts.headers || headers();\n        opts.headers?.set(ServiceErrorCodeHeader, `${code}`);\n        opts.headers?.set(ServiceErrorHeader, description);\n        return this.msg.respond(data, opts);\n    }\n    json(reviver) {\n        return this.msg.json(reviver);\n    }\n    string() {\n        return this.msg.string();\n    }\n}\nclass ServiceGroupImpl {\n    subject;\n    queue;\n    srv;\n    constructor(parent, name = \"\", queue = \"\"){\n        if (name !== \"\") {\n            validInternalToken(\"service group\", name);\n        }\n        let root = \"\";\n        if (parent instanceof ServiceImpl) {\n            this.srv = parent;\n            root = \"\";\n        } else if (parent instanceof ServiceGroupImpl) {\n            const sg = parent;\n            this.srv = sg.srv;\n            if (queue === \"\" && sg.queue !== \"\") {\n                queue = sg.queue;\n            }\n            root = sg.subject;\n        } else {\n            throw new Error(\"unknown ServiceGroup type\");\n        }\n        this.subject = this.calcSubject(root, name);\n        this.queue = queue;\n    }\n    calcSubject(root, name = \"\") {\n        if (name === \"\") {\n            return root;\n        }\n        return root !== \"\" ? `${root}.${name}` : name;\n    }\n    addEndpoint(name = \"\", opts) {\n        opts = opts || {\n            subject: name\n        };\n        const args = typeof opts === \"function\" ? {\n            handler: opts,\n            subject: name\n        } : opts;\n        validateName(\"endpoint\", name);\n        let { subject, handler, metadata, queue } = args;\n        subject = subject || name;\n        queue = queue || this.queue;\n        validSubjectName(\"endpoint subject\", subject);\n        subject = this.calcSubject(this.subject, subject);\n        const ne = {\n            name,\n            subject,\n            queue,\n            handler,\n            metadata\n        };\n        return this.srv._addEndpoint(ne);\n    }\n    addGroup(name = \"\", queue = \"\") {\n        return new ServiceGroupImpl(this, name, queue);\n    }\n}\nfunction validSubjectName(context, subj) {\n    if (subj === \"\") {\n        throw new Error(`${context} cannot be empty`);\n    }\n    if (subj.indexOf(\" \") !== -1) {\n        throw new Error(`${context} cannot contain spaces: '${subj}'`);\n    }\n    const tokens = subj.split(\".\");\n    tokens.forEach((v, idx)=>{\n        if (v === \">\" && idx !== tokens.length - 1) {\n            throw new Error(`${context} cannot have internal '>': '${subj}'`);\n        }\n    });\n}\nfunction validInternalToken(context, subj) {\n    if (subj.indexOf(\" \") !== -1) {\n        throw new Error(`${context} cannot contain spaces: '${subj}'`);\n    }\n    const tokens = subj.split(\".\");\n    tokens.forEach((v)=>{\n        if (v === \">\") {\n            throw new Error(`${context} name cannot contain internal '>': '${subj}'`);\n        }\n    });\n}\nclass ServiceImpl {\n    nc;\n    _id;\n    config;\n    handlers;\n    internal;\n    _stopped;\n    _done;\n    started;\n    static controlSubject(verb, name = \"\", id = \"\", prefix) {\n        const pre = prefix ?? ServiceApiPrefix;\n        if (name === \"\" && id === \"\") {\n            return `${pre}.${verb}`;\n        }\n        validateName(\"control subject name\", name);\n        if (id !== \"\") {\n            validateName(\"control subject id\", id);\n            return `${pre}.${verb}.${name}.${id}`;\n        }\n        return `${pre}.${verb}.${name}`;\n    }\n    constructor(nc, config = {\n        name: \"\",\n        version: \"\"\n    }){\n        this.nc = nc;\n        this.config = Object.assign({}, config);\n        if (!this.config.queue) {\n            this.config.queue = \"q\";\n        }\n        validateName(\"name\", this.config.name);\n        validateName(\"queue\", this.config.queue);\n        parseSemVer(this.config.version);\n        this._id = nuid.next();\n        this.internal = [];\n        this._done = deferred();\n        this._stopped = false;\n        this.handlers = [];\n        this.started = new Date().toISOString();\n        this.reset();\n        this.nc.closed().then(()=>{\n            this.close().catch();\n        }).catch((err)=>{\n            this.close(err).catch();\n        });\n    }\n    get subjects() {\n        return this.handlers.filter((s)=>{\n            return s.internal === false;\n        }).map((s)=>{\n            return s.subject;\n        });\n    }\n    get id() {\n        return this._id;\n    }\n    get name() {\n        return this.config.name;\n    }\n    get description() {\n        return this.config.description ?? \"\";\n    }\n    get version() {\n        return this.config.version;\n    }\n    get metadata() {\n        return this.config.metadata;\n    }\n    errorToHeader(err) {\n        const h = headers();\n        if (err instanceof ServiceError) {\n            const se = err;\n            h.set(ServiceErrorHeader, se.message);\n            h.set(ServiceErrorCodeHeader, `${se.code}`);\n        } else {\n            h.set(ServiceErrorHeader, err.message);\n            h.set(ServiceErrorCodeHeader, \"500\");\n        }\n        return h;\n    }\n    setupHandler(h, internal = false) {\n        const queue = internal ? \"\" : h.queue ? h.queue : this.config.queue;\n        const { name, subject, handler } = h;\n        const sv = h;\n        sv.internal = internal;\n        if (internal) {\n            this.internal.push(sv);\n        }\n        sv.stats = new NamedEndpointStatsImpl(name, subject, queue);\n        sv.queue = queue;\n        const callback = handler ? (err, msg)=>{\n            if (err) {\n                this.close(err);\n                return;\n            }\n            const start = Date.now();\n            try {\n                handler(err, new ServiceMsgImpl(msg));\n            } catch (err) {\n                sv.stats.countError(err);\n                msg?.respond(Empty, {\n                    headers: this.errorToHeader(err)\n                });\n            } finally{\n                sv.stats.countLatency(start);\n            }\n        } : undefined;\n        sv.sub = this.nc.subscribe(subject, {\n            callback,\n            queue\n        });\n        sv.sub.closed.then(()=>{\n            if (!this._stopped) {\n                this.close(new Error(`required subscription ${h.subject} stopped`)).catch();\n            }\n        }).catch((err)=>{\n            if (!this._stopped) {\n                const ne = new Error(`required subscription ${h.subject} errored: ${err.message}`);\n                ne.stack = err.stack;\n                this.close(ne).catch();\n            }\n        });\n        return sv;\n    }\n    info() {\n        return {\n            type: ServiceResponseType.INFO,\n            name: this.name,\n            id: this.id,\n            version: this.version,\n            description: this.description,\n            metadata: this.metadata,\n            endpoints: this.endpoints()\n        };\n    }\n    endpoints() {\n        return this.handlers.map((v)=>{\n            const { subject, metadata, name, queue } = v;\n            return {\n                subject,\n                metadata,\n                name,\n                queue_group: queue\n            };\n        });\n    }\n    async stats() {\n        const endpoints = [];\n        for (const h of this.handlers){\n            if (typeof this.config.statsHandler === \"function\") {\n                try {\n                    h.stats.data = await this.config.statsHandler(h);\n                } catch (err) {\n                    h.stats.countError(err);\n                }\n            }\n            endpoints.push(h.stats.stats(h.qi));\n        }\n        return {\n            type: ServiceResponseType.STATS,\n            name: this.name,\n            id: this.id,\n            version: this.version,\n            started: this.started,\n            metadata: this.metadata,\n            endpoints\n        };\n    }\n    addInternalHandler(verb, handler) {\n        const v = `${verb}`.toUpperCase();\n        this._doAddInternalHandler(`${v}-all`, verb, handler);\n        this._doAddInternalHandler(`${v}-kind`, verb, handler, this.name);\n        this._doAddInternalHandler(`${v}`, verb, handler, this.name, this.id);\n    }\n    _doAddInternalHandler(name, verb, handler, kind = \"\", id = \"\") {\n        const endpoint = {};\n        endpoint.name = name;\n        endpoint.subject = ServiceImpl.controlSubject(verb, kind, id);\n        endpoint.handler = handler;\n        this.setupHandler(endpoint, true);\n    }\n    start() {\n        const jc = JSONCodec();\n        const statsHandler = (err, msg)=>{\n            if (err) {\n                this.close(err);\n                return Promise.reject(err);\n            }\n            return this.stats().then((s)=>{\n                msg?.respond(jc.encode(s));\n                return Promise.resolve();\n            });\n        };\n        const infoHandler = (err, msg)=>{\n            if (err) {\n                this.close(err);\n                return Promise.reject(err);\n            }\n            msg?.respond(jc.encode(this.info()));\n            return Promise.resolve();\n        };\n        const ping = jc.encode(this.ping());\n        const pingHandler = (err, msg)=>{\n            if (err) {\n                this.close(err).then().catch();\n                return Promise.reject(err);\n            }\n            msg.respond(ping);\n            return Promise.resolve();\n        };\n        this.addInternalHandler(ServiceVerb.PING, pingHandler);\n        this.addInternalHandler(ServiceVerb.STATS, statsHandler);\n        this.addInternalHandler(ServiceVerb.INFO, infoHandler);\n        this.handlers.forEach((h)=>{\n            const { subject } = h;\n            if (typeof subject !== \"string\") {\n                return;\n            }\n            if (h.handler === null) {\n                return;\n            }\n            this.setupHandler(h);\n        });\n        return Promise.resolve(this);\n    }\n    close(err) {\n        if (this._stopped) {\n            return this._done;\n        }\n        this._stopped = true;\n        let buf = [];\n        if (!this.nc.isClosed()) {\n            buf = this.handlers.concat(this.internal).map((h)=>{\n                return h.sub.drain();\n            });\n        }\n        Promise.allSettled(buf).then(()=>{\n            this._done.resolve(err ? err : null);\n        });\n        return this._done;\n    }\n    get stopped() {\n        return this._done;\n    }\n    get isStopped() {\n        return this._stopped;\n    }\n    stop(err) {\n        return this.close(err);\n    }\n    ping() {\n        return {\n            type: ServiceResponseType.PING,\n            name: this.name,\n            id: this.id,\n            version: this.version,\n            metadata: this.metadata\n        };\n    }\n    reset() {\n        this.started = new Date().toISOString();\n        if (this.handlers) {\n            for (const h of this.handlers){\n                h.stats.reset(h.qi);\n            }\n        }\n    }\n    addGroup(name, queue) {\n        return new ServiceGroupImpl(this, name, queue);\n    }\n    addEndpoint(name, handler) {\n        const sg = new ServiceGroupImpl(this);\n        return sg.addEndpoint(name, handler);\n    }\n    _addEndpoint(e) {\n        const qi = new QueuedIteratorImpl();\n        qi.noIterator = typeof e.handler === \"function\";\n        if (!qi.noIterator) {\n            e.handler = (err, msg)=>{\n                err ? this.stop(err).catch() : qi.push(new ServiceMsgImpl(msg));\n            };\n            qi.iterClosed.then(()=>{\n                this.close().catch();\n            });\n        }\n        const ss = this.setupHandler(e, false);\n        ss.qi = qi;\n        this.handlers.push(ss);\n        return qi;\n    }\n}\nclass NamedEndpointStatsImpl {\n    name;\n    subject;\n    average_processing_time;\n    num_requests;\n    processing_time;\n    num_errors;\n    last_error;\n    data;\n    metadata;\n    queue;\n    constructor(name, subject, queue = \"\"){\n        this.name = name;\n        this.subject = subject;\n        this.average_processing_time = 0;\n        this.num_errors = 0;\n        this.num_requests = 0;\n        this.processing_time = 0;\n        this.queue = queue;\n    }\n    reset(qi) {\n        this.num_requests = 0;\n        this.processing_time = 0;\n        this.average_processing_time = 0;\n        this.num_errors = 0;\n        this.last_error = undefined;\n        this.data = undefined;\n        const qii = qi;\n        if (qii) {\n            qii.time = 0;\n            qii.processed = 0;\n        }\n    }\n    countLatency(start) {\n        this.num_requests++;\n        this.processing_time += nanos(Date.now() - start);\n        this.average_processing_time = Math.round(this.processing_time / this.num_requests);\n    }\n    countError(err) {\n        this.num_errors++;\n        this.last_error = err.message;\n    }\n    _stats() {\n        const { name, subject, average_processing_time, num_errors, num_requests, processing_time, last_error, data, queue } = this;\n        return {\n            name,\n            subject,\n            average_processing_time,\n            num_errors,\n            num_requests,\n            processing_time,\n            last_error,\n            data,\n            queue_group: queue\n        };\n    }\n    stats(qi) {\n        const qii = qi;\n        if (qii?.noIterator === false) {\n            this.processing_time = nanos(qii.time);\n            this.num_requests = qii.processed;\n            this.average_processing_time = this.processing_time > 0 && this.num_requests > 0 ? this.processing_time / this.num_requests : 0;\n        }\n        return this._stats();\n    }\n}\nclass ServiceClientImpl {\n    nc;\n    prefix;\n    opts;\n    constructor(nc, opts = {\n        strategy: RequestStrategy.JitterTimer,\n        maxWait: 2000\n    }, prefix){\n        this.nc = nc;\n        this.prefix = prefix;\n        this.opts = opts;\n    }\n    ping(name = \"\", id = \"\") {\n        return this.q(ServiceVerb.PING, name, id);\n    }\n    stats(name = \"\", id = \"\") {\n        return this.q(ServiceVerb.STATS, name, id);\n    }\n    info(name = \"\", id = \"\") {\n        return this.q(ServiceVerb.INFO, name, id);\n    }\n    async q(v, name = \"\", id = \"\") {\n        const iter = new QueuedIteratorImpl();\n        const jc = JSONCodec();\n        const subj = ServiceImpl.controlSubject(v, name, id, this.prefix);\n        const responses = await this.nc.requestMany(subj, Empty, this.opts);\n        (async ()=>{\n            for await (const m of responses){\n                try {\n                    const s = jc.decode(m.data);\n                    iter.push(s);\n                } catch (err) {\n                    iter.push(()=>{\n                        iter.stop(err);\n                    });\n                }\n            }\n            iter.push(()=>{\n                iter.stop();\n            });\n        })().catch((err)=>{\n            iter.stop(err);\n        });\n        return iter;\n    }\n}\nclass Metric {\n    name;\n    duration;\n    date;\n    payload;\n    msgs;\n    lang;\n    version;\n    bytes;\n    asyncRequests;\n    min;\n    max;\n    constructor(name, duration){\n        this.name = name;\n        this.duration = duration;\n        this.date = Date.now();\n        this.payload = 0;\n        this.msgs = 0;\n        this.bytes = 0;\n    }\n    toString() {\n        const sec = this.duration / 1000;\n        const mps = Math.round(this.msgs / sec);\n        const label = this.asyncRequests ? \"asyncRequests\" : \"\";\n        let minmax = \"\";\n        if (this.max) {\n            minmax = `${this.min}/${this.max}`;\n        }\n        return `${this.name}${label ? \" [asyncRequests]\" : \"\"} ${humanizeNumber(mps)} msgs/sec - [${sec.toFixed(2)} secs] ~ ${throughput(this.bytes, sec)} ${minmax}`;\n    }\n    toCsv() {\n        return `\"${this.name}\",${new Date(this.date).toISOString()},${this.lang},${this.version},${this.msgs},${this.payload},${this.bytes},${this.duration},${this.asyncRequests ? this.asyncRequests : false}\\n`;\n    }\n    static header() {\n        return `Test,Date,Lang,Version,Count,MsgPayload,Bytes,Millis,Async\\n`;\n    }\n}\nclass Bench {\n    nc;\n    callbacks;\n    msgs;\n    size;\n    subject;\n    asyncRequests;\n    pub;\n    sub;\n    req;\n    rep;\n    perf;\n    payload;\n    constructor(nc, opts = {\n        msgs: 100000,\n        size: 128,\n        subject: \"\",\n        asyncRequests: false,\n        pub: false,\n        sub: false,\n        req: false,\n        rep: false\n    }){\n        this.nc = nc;\n        this.callbacks = opts.callbacks || false;\n        this.msgs = opts.msgs || 0;\n        this.size = opts.size || 0;\n        this.subject = opts.subject || nuid.next();\n        this.asyncRequests = opts.asyncRequests || false;\n        this.pub = opts.pub || false;\n        this.sub = opts.sub || false;\n        this.req = opts.req || false;\n        this.rep = opts.rep || false;\n        this.perf = new Perf();\n        this.payload = this.size ? new Uint8Array(this.size) : Empty;\n        if (!this.pub && !this.sub && !this.req && !this.rep) {\n            throw new Error(\"no bench option selected\");\n        }\n    }\n    async run() {\n        this.nc.closed().then((err)=>{\n            if (err) {\n                throw new NatsError(`bench closed with an error: ${err.message}`, ErrorCode.Unknown, err);\n            }\n        });\n        if (this.callbacks) {\n            await this.runCallbacks();\n        } else {\n            await this.runAsync();\n        }\n        return this.processMetrics();\n    }\n    processMetrics() {\n        const nc = this.nc;\n        const { lang, version } = nc.protocol.transport;\n        if (this.pub && this.sub) {\n            this.perf.measure(\"pubsub\", \"pubStart\", \"subStop\");\n        }\n        if (this.req && this.rep) {\n            this.perf.measure(\"reqrep\", \"reqStart\", \"reqStop\");\n        }\n        const measures = this.perf.getEntries();\n        const pubsub = measures.find((m)=>m.name === \"pubsub\");\n        const reqrep = measures.find((m)=>m.name === \"reqrep\");\n        const req = measures.find((m)=>m.name === \"req\");\n        const rep = measures.find((m)=>m.name === \"rep\");\n        const pub = measures.find((m)=>m.name === \"pub\");\n        const sub = measures.find((m)=>m.name === \"sub\");\n        const stats = this.nc.stats();\n        const metrics = [];\n        if (pubsub) {\n            const { name, duration } = pubsub;\n            const m = new Metric(name, duration);\n            m.msgs = this.msgs * 2;\n            m.bytes = stats.inBytes + stats.outBytes;\n            m.lang = lang;\n            m.version = version;\n            m.payload = this.payload.length;\n            metrics.push(m);\n        }\n        if (reqrep) {\n            const { name, duration } = reqrep;\n            const m = new Metric(name, duration);\n            m.msgs = this.msgs * 2;\n            m.bytes = stats.inBytes + stats.outBytes;\n            m.lang = lang;\n            m.version = version;\n            m.payload = this.payload.length;\n            metrics.push(m);\n        }\n        if (pub) {\n            const { name, duration } = pub;\n            const m = new Metric(name, duration);\n            m.msgs = this.msgs;\n            m.bytes = stats.outBytes;\n            m.lang = lang;\n            m.version = version;\n            m.payload = this.payload.length;\n            metrics.push(m);\n        }\n        if (sub) {\n            const { name, duration } = sub;\n            const m = new Metric(name, duration);\n            m.msgs = this.msgs;\n            m.bytes = stats.inBytes;\n            m.lang = lang;\n            m.version = version;\n            m.payload = this.payload.length;\n            metrics.push(m);\n        }\n        if (rep) {\n            const { name, duration } = rep;\n            const m = new Metric(name, duration);\n            m.msgs = this.msgs;\n            m.bytes = stats.inBytes + stats.outBytes;\n            m.lang = lang;\n            m.version = version;\n            m.payload = this.payload.length;\n            metrics.push(m);\n        }\n        if (req) {\n            const { name, duration } = req;\n            const m = new Metric(name, duration);\n            m.msgs = this.msgs;\n            m.bytes = stats.inBytes + stats.outBytes;\n            m.lang = lang;\n            m.version = version;\n            m.payload = this.payload.length;\n            metrics.push(m);\n        }\n        return metrics;\n    }\n    async runCallbacks() {\n        const jobs = [];\n        if (this.sub) {\n            const d = deferred();\n            jobs.push(d);\n            let i = 0;\n            this.nc.subscribe(this.subject, {\n                max: this.msgs,\n                callback: ()=>{\n                    i++;\n                    if (i === 1) {\n                        this.perf.mark(\"subStart\");\n                    }\n                    if (i === this.msgs) {\n                        this.perf.mark(\"subStop\");\n                        this.perf.measure(\"sub\", \"subStart\", \"subStop\");\n                        d.resolve();\n                    }\n                }\n            });\n        }\n        if (this.rep) {\n            const d = deferred();\n            jobs.push(d);\n            let i = 0;\n            this.nc.subscribe(this.subject, {\n                max: this.msgs,\n                callback: (_, m)=>{\n                    m.respond(this.payload);\n                    i++;\n                    if (i === 1) {\n                        this.perf.mark(\"repStart\");\n                    }\n                    if (i === this.msgs) {\n                        this.perf.mark(\"repStop\");\n                        this.perf.measure(\"rep\", \"repStart\", \"repStop\");\n                        d.resolve();\n                    }\n                }\n            });\n        }\n        if (this.pub) {\n            const job = (async ()=>{\n                this.perf.mark(\"pubStart\");\n                for(let i = 0; i < this.msgs; i++){\n                    this.nc.publish(this.subject, this.payload);\n                }\n                await this.nc.flush();\n                this.perf.mark(\"pubStop\");\n                this.perf.measure(\"pub\", \"pubStart\", \"pubStop\");\n            })();\n            jobs.push(job);\n        }\n        if (this.req) {\n            const job = (async ()=>{\n                if (this.asyncRequests) {\n                    this.perf.mark(\"reqStart\");\n                    const a = [];\n                    for(let i = 0; i < this.msgs; i++){\n                        a.push(this.nc.request(this.subject, this.payload, {\n                            timeout: 20000\n                        }));\n                    }\n                    await Promise.all(a);\n                    this.perf.mark(\"reqStop\");\n                    this.perf.measure(\"req\", \"reqStart\", \"reqStop\");\n                } else {\n                    this.perf.mark(\"reqStart\");\n                    for(let i = 0; i < this.msgs; i++){\n                        await this.nc.request(this.subject);\n                    }\n                    this.perf.mark(\"reqStop\");\n                    this.perf.measure(\"req\", \"reqStart\", \"reqStop\");\n                }\n            })();\n            jobs.push(job);\n        }\n        await Promise.all(jobs);\n    }\n    async runAsync() {\n        const jobs = [];\n        if (this.rep) {\n            let first = false;\n            const sub = this.nc.subscribe(this.subject, {\n                max: this.msgs\n            });\n            const job = (async ()=>{\n                for await (const m of sub){\n                    if (!first) {\n                        this.perf.mark(\"repStart\");\n                        first = true;\n                    }\n                    m.respond(this.payload);\n                }\n                await this.nc.flush();\n                this.perf.mark(\"repStop\");\n                this.perf.measure(\"rep\", \"repStart\", \"repStop\");\n            })();\n            jobs.push(job);\n        }\n        if (this.sub) {\n            let first = false;\n            const sub = this.nc.subscribe(this.subject, {\n                max: this.msgs\n            });\n            const job = (async ()=>{\n                for await (const _m of sub){\n                    if (!first) {\n                        this.perf.mark(\"subStart\");\n                        first = true;\n                    }\n                }\n                this.perf.mark(\"subStop\");\n                this.perf.measure(\"sub\", \"subStart\", \"subStop\");\n            })();\n            jobs.push(job);\n        }\n        if (this.pub) {\n            const job = (async ()=>{\n                this.perf.mark(\"pubStart\");\n                for(let i = 0; i < this.msgs; i++){\n                    this.nc.publish(this.subject, this.payload);\n                }\n                await this.nc.flush();\n                this.perf.mark(\"pubStop\");\n                this.perf.measure(\"pub\", \"pubStart\", \"pubStop\");\n            })();\n            jobs.push(job);\n        }\n        if (this.req) {\n            const job = (async ()=>{\n                if (this.asyncRequests) {\n                    this.perf.mark(\"reqStart\");\n                    const a = [];\n                    for(let i = 0; i < this.msgs; i++){\n                        a.push(this.nc.request(this.subject, this.payload, {\n                            timeout: 20000\n                        }));\n                    }\n                    await Promise.all(a);\n                    this.perf.mark(\"reqStop\");\n                    this.perf.measure(\"req\", \"reqStart\", \"reqStop\");\n                } else {\n                    this.perf.mark(\"reqStart\");\n                    for(let i = 0; i < this.msgs; i++){\n                        await this.nc.request(this.subject);\n                    }\n                    this.perf.mark(\"reqStop\");\n                    this.perf.measure(\"req\", \"reqStart\", \"reqStop\");\n                }\n            })();\n            jobs.push(job);\n        }\n        await Promise.all(jobs);\n    }\n}\nfunction throughput(bytes, seconds) {\n    return `${humanizeBytes(bytes / seconds)}/sec`;\n}\nfunction humanizeBytes(bytes, si = false) {\n    const base = si ? 1000 : 1024;\n    const pre = si ? [\n        \"k\",\n        \"M\",\n        \"G\",\n        \"T\",\n        \"P\",\n        \"E\"\n    ] : [\n        \"K\",\n        \"M\",\n        \"G\",\n        \"T\",\n        \"P\",\n        \"E\"\n    ];\n    const post = si ? \"iB\" : \"B\";\n    if (bytes < base) {\n        return `${bytes.toFixed(2)} ${post}`;\n    }\n    const exp = parseInt(Math.log(bytes) / Math.log(base) + \"\");\n    const index = parseInt(exp - 1 + \"\");\n    return `${(bytes / Math.pow(base, exp)).toFixed(2)} ${pre[index]}${post}`;\n}\nfunction humanizeNumber(n) {\n    return n.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n}\n\nfunction NoopKvCodecs() {\n    return {\n        key: {\n            encode (k) {\n                return k;\n            },\n            decode (k) {\n                return k;\n            }\n        },\n        value: {\n            encode (v) {\n                return v;\n            },\n            decode (v) {\n                return v;\n            }\n        }\n    };\n}\nfunction defaultBucketOpts() {\n    return {\n        replicas: 1,\n        history: 1,\n        timeout: 2000,\n        max_bytes: -1,\n        maxValueSize: -1,\n        codec: NoopKvCodecs(),\n        storage: StorageType.File\n    };\n}\nconst kvOperationHdr = \"KV-Operation\";\nconst kvSubjectPrefix = \"$KV\";\nconst validKeyRe = /^[-/=.\\w]+$/;\nconst validSearchKey = /^[-/=.>*\\w]+$/;\nconst validBucketRe = /^[-\\w]+$/;\nfunction validateKey(k) {\n    if (k.startsWith(\".\") || k.endsWith(\".\") || !validKeyRe.test(k)) {\n        throw new Error(`invalid key: ${k}`);\n    }\n}\nfunction validateSearchKey(k) {\n    if (k.startsWith(\".\") || k.endsWith(\".\") || !validSearchKey.test(k)) {\n        throw new Error(`invalid key: ${k}`);\n    }\n}\nfunction hasWildcards(k) {\n    if (k.startsWith(\".\") || k.endsWith(\".\")) {\n        throw new Error(`invalid key: ${k}`);\n    }\n    const chunks = k.split(\".\");\n    let hasWildcards = false;\n    for(let i = 0; i < chunks.length; i++){\n        switch(chunks[i]){\n            case \"*\":\n                hasWildcards = true;\n                break;\n            case \">\":\n                if (i !== chunks.length - 1) {\n                    throw new Error(`invalid key: ${k}`);\n                }\n                hasWildcards = true;\n                break;\n            default:\n        }\n    }\n    return hasWildcards;\n}\nfunction validateBucket(name) {\n    if (!validBucketRe.test(name)) {\n        throw new Error(`invalid bucket name: ${name}`);\n    }\n}\nvar PubHeaders;\n(function(PubHeaders) {\n    PubHeaders[\"MsgIdHdr\"] = \"Nats-Msg-Id\";\n    PubHeaders[\"ExpectedStreamHdr\"] = \"Nats-Expected-Stream\";\n    PubHeaders[\"ExpectedLastSeqHdr\"] = \"Nats-Expected-Last-Sequence\";\n    PubHeaders[\"ExpectedLastMsgIdHdr\"] = \"Nats-Expected-Last-Msg-Id\";\n    PubHeaders[\"ExpectedLastSubjectSequenceHdr\"] = \"Nats-Expected-Last-Subject-Sequence\";\n})(PubHeaders || (PubHeaders = {}));\nclass Bucket {\n    js;\n    jsm;\n    stream;\n    bucket;\n    direct;\n    codec;\n    prefix;\n    editPrefix;\n    useJsPrefix;\n    _prefixLen;\n    constructor(bucket, js, jsm){\n        validateBucket(bucket);\n        this.js = js;\n        this.jsm = jsm;\n        this.bucket = bucket;\n        this.prefix = kvSubjectPrefix;\n        this.editPrefix = \"\";\n        this.useJsPrefix = false;\n        this._prefixLen = 0;\n    }\n    static async create(js, name, opts = {}) {\n        validateBucket(name);\n        const jsm = await js.jetstreamManager();\n        const bucket = new Bucket(name, js, jsm);\n        await bucket.init(opts);\n        return bucket;\n    }\n    static async bind(js, name, opts = {}) {\n        const jsm = await js.jetstreamManager();\n        const info = {\n            config: {\n                allow_direct: opts.allow_direct\n            }\n        };\n        validateBucket(name);\n        const bucket = new Bucket(name, js, jsm);\n        info.config.name = opts.streamName ?? bucket.bucketName();\n        Object.assign(bucket, info);\n        bucket.stream = info.config.name;\n        bucket.codec = opts.codec || NoopKvCodecs();\n        bucket.direct = info.config.allow_direct ?? false;\n        bucket.initializePrefixes(info);\n        return bucket;\n    }\n    async init(opts = {}) {\n        const bo = Object.assign(defaultBucketOpts(), opts);\n        this.codec = bo.codec;\n        const sc = {};\n        this.stream = sc.name = opts.streamName ?? this.bucketName();\n        sc.retention = RetentionPolicy.Limits;\n        sc.max_msgs_per_subject = bo.history;\n        if (bo.maxBucketSize) {\n            bo.max_bytes = bo.maxBucketSize;\n        }\n        if (bo.max_bytes) {\n            sc.max_bytes = bo.max_bytes;\n        }\n        sc.max_msg_size = bo.maxValueSize;\n        sc.storage = bo.storage;\n        const location = opts.placementCluster ?? \"\";\n        if (location) {\n            opts.placement = {};\n            opts.placement.cluster = location;\n            opts.placement.tags = [];\n        }\n        if (opts.placement) {\n            sc.placement = opts.placement;\n        }\n        if (opts.republish) {\n            sc.republish = opts.republish;\n        }\n        if (opts.description) {\n            sc.description = opts.description;\n        }\n        if (opts.mirror) {\n            const mirror = Object.assign({}, opts.mirror);\n            if (!mirror.name.startsWith(kvPrefix)) {\n                mirror.name = `${kvPrefix}${mirror.name}`;\n            }\n            sc.mirror = mirror;\n            sc.mirror_direct = true;\n        } else if (opts.sources) {\n            const sources = opts.sources.map((s)=>{\n                const c = Object.assign({}, s);\n                const srcBucketName = c.name.startsWith(kvPrefix) ? c.name.substring(kvPrefix.length) : c.name;\n                if (!c.name.startsWith(kvPrefix)) {\n                    c.name = `${kvPrefix}${c.name}`;\n                }\n                if (!s.external && srcBucketName !== this.bucket) {\n                    c.subject_transforms = [\n                        {\n                            src: `$KV.${srcBucketName}.>`,\n                            dest: `$KV.${this.bucket}.>`\n                        }\n                    ];\n                }\n                return c;\n            });\n            sc.sources = sources;\n            sc.subjects = [\n                this.subjectForBucket()\n            ];\n        } else {\n            sc.subjects = [\n                this.subjectForBucket()\n            ];\n        }\n        if (opts.metadata) {\n            sc.metadata = opts.metadata;\n        }\n        if (typeof opts.compression === \"boolean\") {\n            sc.compression = opts.compression ? StoreCompression.S2 : StoreCompression.None;\n        }\n        const nci = this.js.nc;\n        const have = nci.getServerVersion();\n        const discardNew = have ? compare(have, parseSemVer(\"2.7.2\")) >= 0 : false;\n        sc.discard = discardNew ? DiscardPolicy.New : DiscardPolicy.Old;\n        const { ok: direct, min } = nci.features.get(Feature.JS_ALLOW_DIRECT);\n        if (!direct && opts.allow_direct === true) {\n            const v = have ? `${have.major}.${have.minor}.${have.micro}` : \"unknown\";\n            return Promise.reject(new Error(`allow_direct is not available on server version ${v} - requires ${min}`));\n        }\n        opts.allow_direct = typeof opts.allow_direct === \"boolean\" ? opts.allow_direct : direct;\n        sc.allow_direct = opts.allow_direct;\n        this.direct = sc.allow_direct;\n        sc.num_replicas = bo.replicas;\n        if (bo.ttl) {\n            sc.max_age = nanos(bo.ttl);\n        }\n        sc.allow_rollup_hdrs = true;\n        let info;\n        try {\n            info = await this.jsm.streams.info(sc.name);\n            if (!info.config.allow_direct && this.direct === true) {\n                this.direct = false;\n            }\n        } catch (err) {\n            if (err.message === \"stream not found\") {\n                info = await this.jsm.streams.add(sc);\n            } else {\n                throw err;\n            }\n        }\n        this.initializePrefixes(info);\n    }\n    initializePrefixes(info) {\n        this._prefixLen = 0;\n        this.prefix = `$KV.${this.bucket}`;\n        this.useJsPrefix = this.js.apiPrefix !== \"$JS.API\";\n        const { mirror } = info.config;\n        if (mirror) {\n            let n = mirror.name;\n            if (n.startsWith(kvPrefix)) {\n                n = n.substring(kvPrefix.length);\n            }\n            if (mirror.external && mirror.external.api !== \"\") {\n                const mb = mirror.name.substring(kvPrefix.length);\n                this.useJsPrefix = false;\n                this.prefix = `$KV.${mb}`;\n                this.editPrefix = `${mirror.external.api}.$KV.${n}`;\n            } else {\n                this.editPrefix = this.prefix;\n            }\n        }\n    }\n    bucketName() {\n        return this.stream ?? `${kvPrefix}${this.bucket}`;\n    }\n    subjectForBucket() {\n        return `${this.prefix}.${this.bucket}.>`;\n    }\n    subjectForKey(k, edit = false) {\n        const builder = [];\n        if (edit) {\n            if (this.useJsPrefix) {\n                builder.push(this.js.apiPrefix);\n            }\n            if (this.editPrefix !== \"\") {\n                builder.push(this.editPrefix);\n            } else {\n                builder.push(this.prefix);\n            }\n        } else {\n            if (this.prefix) {\n                builder.push(this.prefix);\n            }\n        }\n        builder.push(k);\n        return builder.join(\".\");\n    }\n    fullKeyName(k) {\n        if (this.prefix !== \"\") {\n            return `${this.prefix}.${k}`;\n        }\n        return `${kvSubjectPrefix}.${this.bucket}.${k}`;\n    }\n    get prefixLen() {\n        if (this._prefixLen === 0) {\n            this._prefixLen = this.prefix.length + 1;\n        }\n        return this._prefixLen;\n    }\n    encodeKey(key) {\n        const chunks = [];\n        for (const t of key.split(\".\")){\n            switch(t){\n                case \">\":\n                case \"*\":\n                    chunks.push(t);\n                    break;\n                default:\n                    chunks.push(this.codec.key.encode(t));\n                    break;\n            }\n        }\n        return chunks.join(\".\");\n    }\n    decodeKey(ekey) {\n        const chunks = [];\n        for (const t of ekey.split(\".\")){\n            switch(t){\n                case \">\":\n                case \"*\":\n                    chunks.push(t);\n                    break;\n                default:\n                    chunks.push(this.codec.key.decode(t));\n                    break;\n            }\n        }\n        return chunks.join(\".\");\n    }\n    validateKey = validateKey;\n    validateSearchKey = validateSearchKey;\n    hasWildcards = hasWildcards;\n    close() {\n        return Promise.resolve();\n    }\n    dataLen(data, h) {\n        const slen = h ? h.get(JsHeaders.MessageSizeHdr) || \"\" : \"\";\n        if (slen !== \"\") {\n            return parseInt(slen, 10);\n        }\n        return data.length;\n    }\n    smToEntry(sm) {\n        return new KvStoredEntryImpl(this.bucket, this.prefixLen, sm);\n    }\n    jmToEntry(jm) {\n        const key = this.decodeKey(jm.subject.substring(this.prefixLen));\n        return new KvJsMsgEntryImpl(this.bucket, key, jm);\n    }\n    async create(k, data) {\n        let firstErr;\n        try {\n            const n = await this.put(k, data, {\n                previousSeq: 0\n            });\n            return Promise.resolve(n);\n        } catch (err) {\n            firstErr = err;\n            if (err?.api_error?.err_code !== 10071) {\n                return Promise.reject(err);\n            }\n        }\n        let rev = 0;\n        try {\n            const e = await this.get(k);\n            if (e?.operation === \"DEL\" || e?.operation === \"PURGE\") {\n                rev = e !== null ? e.revision : 0;\n                return this.update(k, data, rev);\n            } else {\n                return Promise.reject(firstErr);\n            }\n        } catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    update(k, data, version) {\n        if (version <= 0) {\n            throw new Error(\"version must be greater than 0\");\n        }\n        return this.put(k, data, {\n            previousSeq: version\n        });\n    }\n    async put(k, data, opts = {}) {\n        const ek = this.encodeKey(k);\n        this.validateKey(ek);\n        const o = {};\n        if (opts.previousSeq !== undefined) {\n            const h = headers();\n            o.headers = h;\n            h.set(PubHeaders.ExpectedLastSubjectSequenceHdr, `${opts.previousSeq}`);\n        }\n        try {\n            const pa = await this.js.publish(this.subjectForKey(ek, true), data, o);\n            return pa.seq;\n        } catch (err) {\n            const ne = err;\n            if (ne.isJetStreamError()) {\n                ne.message = ne.api_error?.description;\n                ne.code = `${ne.api_error?.code}`;\n                return Promise.reject(ne);\n            }\n            return Promise.reject(err);\n        }\n    }\n    async get(k, opts) {\n        const ek = this.encodeKey(k);\n        this.validateKey(ek);\n        let arg = {\n            last_by_subj: this.subjectForKey(ek)\n        };\n        if (opts && opts.revision > 0) {\n            arg = {\n                seq: opts.revision\n            };\n        }\n        let sm;\n        try {\n            if (this.direct) {\n                const direct = this.jsm.direct;\n                sm = await direct.getMessage(this.bucketName(), arg);\n            } else {\n                sm = await this.jsm.streams.getMessage(this.bucketName(), arg);\n            }\n            const ke = this.smToEntry(sm);\n            if (ke.key !== ek) {\n                return null;\n            }\n            return ke;\n        } catch (err) {\n            if (err.code === ErrorCode.JetStream404NoMessages) {\n                return null;\n            }\n            throw err;\n        }\n    }\n    purge(k, opts) {\n        return this._deleteOrPurge(k, \"PURGE\", opts);\n    }\n    delete(k, opts) {\n        return this._deleteOrPurge(k, \"DEL\", opts);\n    }\n    async purgeDeletes(olderMillis = 30 * 60 * 1000) {\n        const done = deferred();\n        const buf = [];\n        const i = await this.watch({\n            key: \">\",\n            initializedFn: ()=>{\n                done.resolve();\n            }\n        });\n        (async ()=>{\n            for await (const e of i){\n                if (e.operation === \"DEL\" || e.operation === \"PURGE\") {\n                    buf.push(e);\n                }\n            }\n        })().then();\n        await done;\n        i.stop();\n        const min = Date.now() - olderMillis;\n        const proms = buf.map((e)=>{\n            const subj = this.subjectForKey(e.key);\n            if (e.created.getTime() >= min) {\n                return this.jsm.streams.purge(this.stream, {\n                    filter: subj,\n                    keep: 1\n                });\n            } else {\n                return this.jsm.streams.purge(this.stream, {\n                    filter: subj,\n                    keep: 0\n                });\n            }\n        });\n        const purged = await Promise.all(proms);\n        purged.unshift({\n            success: true,\n            purged: 0\n        });\n        return purged.reduce((pv, cv)=>{\n            pv.purged += cv.purged;\n            return pv;\n        });\n    }\n    async _deleteOrPurge(k, op, opts) {\n        if (!this.hasWildcards(k)) {\n            return this._doDeleteOrPurge(k, op, opts);\n        }\n        const iter = await this.keys(k);\n        const buf = [];\n        for await (const k of iter){\n            buf.push(this._doDeleteOrPurge(k, op));\n            if (buf.length === 100) {\n                await Promise.all(buf);\n                buf.length = 0;\n            }\n        }\n        if (buf.length > 0) {\n            await Promise.all(buf);\n        }\n    }\n    async _doDeleteOrPurge(k, op, opts) {\n        const ek = this.encodeKey(k);\n        this.validateKey(ek);\n        const h = headers();\n        h.set(kvOperationHdr, op);\n        if (op === \"PURGE\") {\n            h.set(JsHeaders.RollupHdr, JsHeaders.RollupValueSubject);\n        }\n        if (opts?.previousSeq) {\n            h.set(PubHeaders.ExpectedLastSubjectSequenceHdr, `${opts.previousSeq}`);\n        }\n        await this.js.publish(this.subjectForKey(ek, true), Empty, {\n            headers: h\n        });\n    }\n    _buildCC(k, content, opts = {}) {\n        const a = !Array.isArray(k) ? [\n            k\n        ] : k;\n        let filter_subjects = a.map((k)=>{\n            const ek = this.encodeKey(k);\n            this.validateSearchKey(k);\n            return this.fullKeyName(ek);\n        });\n        let deliver_policy = DeliverPolicy.LastPerSubject;\n        if (content === KvWatchInclude.AllHistory) {\n            deliver_policy = DeliverPolicy.All;\n        }\n        if (content === KvWatchInclude.UpdatesOnly) {\n            deliver_policy = DeliverPolicy.New;\n        }\n        let filter_subject = undefined;\n        if (filter_subjects.length === 1) {\n            filter_subject = filter_subjects[0];\n            filter_subjects = undefined;\n        }\n        return Object.assign({\n            deliver_policy,\n            \"ack_policy\": AckPolicy.None,\n            filter_subjects,\n            filter_subject,\n            \"flow_control\": true,\n            \"idle_heartbeat\": nanos(5 * 1000)\n        }, opts);\n    }\n    remove(k) {\n        return this.purge(k);\n    }\n    async history(opts = {}) {\n        const k = opts.key ?? \">\";\n        const qi = new QueuedIteratorImpl();\n        const co = {};\n        co.headers_only = opts.headers_only || false;\n        let fn;\n        fn = ()=>{\n            qi.stop();\n        };\n        let count = 0;\n        const cc = this._buildCC(k, KvWatchInclude.AllHistory, co);\n        const subj = cc.filter_subject;\n        const copts = consumerOpts(cc);\n        copts.bindStream(this.stream);\n        copts.orderedConsumer();\n        copts.callback((err, jm)=>{\n            if (err) {\n                qi.stop(err);\n                return;\n            }\n            if (jm) {\n                const e = this.jmToEntry(jm);\n                qi.push(e);\n                qi.received++;\n                if (fn && count > 0 && qi.received >= count || jm.info.pending === 0) {\n                    qi.push(fn);\n                    fn = undefined;\n                }\n            }\n        });\n        const sub = await this.js.subscribe(subj, copts);\n        if (fn) {\n            const { info: { last } } = sub;\n            const expect = last.num_pending + last.delivered.consumer_seq;\n            if (expect === 0 || qi.received >= expect) {\n                try {\n                    fn();\n                } catch (err) {\n                    qi.stop(err);\n                } finally{\n                    fn = undefined;\n                }\n            } else {\n                count = expect;\n            }\n        }\n        qi._data = sub;\n        qi.iterClosed.then(()=>{\n            sub.unsubscribe();\n        });\n        sub.closed.then(()=>{\n            qi.stop();\n        }).catch((err)=>{\n            qi.stop(err);\n        });\n        return qi;\n    }\n    canSetWatcherName() {\n        const jsi = this.js;\n        const nci = jsi.nc;\n        const { ok } = nci.features.get(Feature.JS_NEW_CONSUMER_CREATE_API);\n        return ok;\n    }\n    async watch(opts = {}) {\n        const k = opts.key ?? \">\";\n        const qi = new QueuedIteratorImpl();\n        const co = {};\n        co.headers_only = opts.headers_only || false;\n        let content = KvWatchInclude.LastValue;\n        if (opts.include === KvWatchInclude.AllHistory) {\n            content = KvWatchInclude.AllHistory;\n        } else if (opts.include === KvWatchInclude.UpdatesOnly) {\n            content = KvWatchInclude.UpdatesOnly;\n        }\n        const ignoreDeletes = opts.ignoreDeletes === true;\n        let fn = opts.initializedFn;\n        let count = 0;\n        const cc = this._buildCC(k, content, co);\n        const subj = cc.filter_subject;\n        const copts = consumerOpts(cc);\n        if (this.canSetWatcherName()) {\n            copts.consumerName(nuid.next());\n        }\n        copts.bindStream(this.stream);\n        if (opts.resumeFromRevision && opts.resumeFromRevision > 0) {\n            copts.startSequence(opts.resumeFromRevision);\n        }\n        copts.orderedConsumer();\n        copts.callback((err, jm)=>{\n            if (err) {\n                qi.stop(err);\n                return;\n            }\n            if (jm) {\n                const e = this.jmToEntry(jm);\n                if (ignoreDeletes && e.operation === \"DEL\") {\n                    return;\n                }\n                qi.push(e);\n                qi.received++;\n                if (fn && (count > 0 && qi.received >= count || jm.info.pending === 0)) {\n                    qi.push(fn);\n                    fn = undefined;\n                }\n            }\n        });\n        const sub = await this.js.subscribe(subj, copts);\n        if (fn) {\n            const { info: { last } } = sub;\n            const expect = last.num_pending + last.delivered.consumer_seq;\n            if (expect === 0 || qi.received >= expect) {\n                try {\n                    fn();\n                } catch (err) {\n                    qi.stop(err);\n                } finally{\n                    fn = undefined;\n                }\n            } else {\n                count = expect;\n            }\n        }\n        qi._data = sub;\n        qi.iterClosed.then(()=>{\n            sub.unsubscribe();\n        });\n        sub.closed.then(()=>{\n            qi.stop();\n        }).catch((err)=>{\n            qi.stop(err);\n        });\n        return qi;\n    }\n    async keys(k = \">\") {\n        const keys = new QueuedIteratorImpl();\n        const cc = this._buildCC(k, KvWatchInclude.LastValue, {\n            headers_only: true\n        });\n        const subj = Array.isArray(k) ? \">\" : cc.filter_subject;\n        const copts = consumerOpts(cc);\n        copts.bindStream(this.stream);\n        copts.orderedConsumer();\n        const sub = await this.js.subscribe(subj, copts);\n        (async ()=>{\n            for await (const jm of sub){\n                const op = jm.headers?.get(kvOperationHdr);\n                if (op !== \"DEL\" && op !== \"PURGE\") {\n                    const key = this.decodeKey(jm.subject.substring(this.prefixLen));\n                    keys.push(key);\n                }\n                if (jm.info.pending === 0) {\n                    sub.unsubscribe();\n                }\n            }\n        })().then(()=>{\n            keys.stop();\n        }).catch((err)=>{\n            keys.stop(err);\n        });\n        const si = sub;\n        if (si.info.last.num_pending === 0) {\n            sub.unsubscribe();\n        }\n        return keys;\n    }\n    purgeBucket(opts) {\n        return this.jsm.streams.purge(this.bucketName(), opts);\n    }\n    destroy() {\n        return this.jsm.streams.delete(this.bucketName());\n    }\n    async status() {\n        const nc = this.js.nc;\n        const cluster = nc.info?.cluster ?? \"\";\n        const bn = this.bucketName();\n        const si = await this.jsm.streams.info(bn);\n        return new KvStatusImpl(si, cluster);\n    }\n}\nclass KvStatusImpl {\n    si;\n    cluster;\n    constructor(si, cluster = \"\"){\n        this.si = si;\n        this.cluster = cluster;\n    }\n    get bucket() {\n        return this.si.config.name.startsWith(kvPrefix) ? this.si.config.name.substring(kvPrefix.length) : this.si.config.name;\n    }\n    get values() {\n        return this.si.state.messages;\n    }\n    get history() {\n        return this.si.config.max_msgs_per_subject;\n    }\n    get ttl() {\n        return millis(this.si.config.max_age);\n    }\n    get bucket_location() {\n        return this.cluster;\n    }\n    get backingStore() {\n        return this.si.config.storage;\n    }\n    get storage() {\n        return this.si.config.storage;\n    }\n    get replicas() {\n        return this.si.config.num_replicas;\n    }\n    get description() {\n        return this.si.config.description ?? \"\";\n    }\n    get maxBucketSize() {\n        return this.si.config.max_bytes;\n    }\n    get maxValueSize() {\n        return this.si.config.max_msg_size;\n    }\n    get max_bytes() {\n        return this.si.config.max_bytes;\n    }\n    get placement() {\n        return this.si.config.placement || {\n            cluster: \"\",\n            tags: []\n        };\n    }\n    get placementCluster() {\n        return this.si.config.placement?.cluster ?? \"\";\n    }\n    get republish() {\n        return this.si.config.republish ?? {\n            src: \"\",\n            dest: \"\"\n        };\n    }\n    get streamInfo() {\n        return this.si;\n    }\n    get size() {\n        return this.si.state.bytes;\n    }\n    get metadata() {\n        return this.si.config.metadata ?? {};\n    }\n    get compression() {\n        if (this.si.config.compression) {\n            return this.si.config.compression !== StoreCompression.None;\n        }\n        return false;\n    }\n}\nconst osPrefix = \"OBJ_\";\nconst digestType = \"SHA-256=\";\nfunction objectStoreStreamName(bucket) {\n    validateBucket(bucket);\n    return `${osPrefix}${bucket}`;\n}\nfunction objectStoreBucketName(stream) {\n    if (stream.startsWith(osPrefix)) {\n        return stream.substring(4);\n    }\n    return stream;\n}\nclass ObjectStoreStatusImpl {\n    si;\n    backingStore;\n    constructor(si){\n        this.si = si;\n        this.backingStore = \"JetStream\";\n    }\n    get bucket() {\n        return objectStoreBucketName(this.si.config.name);\n    }\n    get description() {\n        return this.si.config.description ?? \"\";\n    }\n    get ttl() {\n        return this.si.config.max_age;\n    }\n    get storage() {\n        return this.si.config.storage;\n    }\n    get replicas() {\n        return this.si.config.num_replicas;\n    }\n    get sealed() {\n        return this.si.config.sealed;\n    }\n    get size() {\n        return this.si.state.bytes;\n    }\n    get streamInfo() {\n        return this.si;\n    }\n    get metadata() {\n        return this.si.config.metadata;\n    }\n    get compression() {\n        if (this.si.config.compression) {\n            return this.si.config.compression !== StoreCompression.None;\n        }\n        return false;\n    }\n}\nfunction convertStreamSourceDomain(s) {\n    if (s === undefined) {\n        return undefined;\n    }\n    const { domain } = s;\n    if (domain === undefined) {\n        return s;\n    }\n    const copy = Object.assign({}, s);\n    delete copy.domain;\n    if (domain === \"\") {\n        return copy;\n    }\n    if (copy.external) {\n        throw new Error(\"domain and external are both set\");\n    }\n    copy.external = {\n        api: `$JS.${domain}.API`\n    };\n    return copy;\n}\nvar PullConsumerType;\n(function(PullConsumerType) {\n    PullConsumerType[PullConsumerType[\"Unset\"] = -1] = \"Unset\";\n    PullConsumerType[PullConsumerType[\"Consume\"] = 0] = \"Consume\";\n    PullConsumerType[PullConsumerType[\"Fetch\"] = 1] = \"Fetch\";\n})(PullConsumerType || (PullConsumerType = {}));\nvar ConsumerEvents;\n(function(ConsumerEvents) {\n    ConsumerEvents[\"HeartbeatsMissed\"] = \"heartbeats_missed\";\n    ConsumerEvents[\"ConsumerNotFound\"] = \"consumer_not_found\";\n    ConsumerEvents[\"StreamNotFound\"] = \"stream_not_found\";\n    ConsumerEvents[\"ConsumerDeleted\"] = \"consumer_deleted\";\n    ConsumerEvents[\"OrderedConsumerRecreated\"] = \"ordered_consumer_recreated\";\n    ConsumerEvents[\"NoResponders\"] = \"no_responders\";\n})(ConsumerEvents || (ConsumerEvents = {}));\nvar ConsumerDebugEvents;\n(function(ConsumerDebugEvents) {\n    ConsumerDebugEvents[\"DebugEvent\"] = \"debug\";\n    ConsumerDebugEvents[\"Discard\"] = \"discard\";\n    ConsumerDebugEvents[\"Reset\"] = \"reset\";\n    ConsumerDebugEvents[\"Next\"] = \"next\";\n})(ConsumerDebugEvents || (ConsumerDebugEvents = {}));\nconst ACK = Uint8Array.of(43, 65, 67, 75);\nconst NAK = Uint8Array.of(45, 78, 65, 75);\nconst WPI = Uint8Array.of(43, 87, 80, 73);\nconst NXT = Uint8Array.of(43, 78, 88, 84);\nconst TERM = Uint8Array.of(43, 84, 69, 82, 77);\nconst SPACE = Uint8Array.of(32);\nfunction toJsMsg(m, ackTimeout = 5000) {\n    return new JsMsgImpl(m, ackTimeout);\n}\nclass PullConsumerMessagesImpl extends QueuedIteratorImpl {\n    consumer;\n    opts;\n    sub;\n    monitor;\n    pending;\n    inbox;\n    refilling;\n    pong;\n    callback;\n    timeout;\n    cleanupHandler;\n    listeners;\n    statusIterator;\n    forOrderedConsumer;\n    resetHandler;\n    abortOnMissingResource;\n    bind;\n    inBackOff;\n    constructor(c, opts, refilling = false){\n        super();\n        this.consumer = c;\n        const copts = opts;\n        this.opts = this.parseOptions(opts, refilling);\n        this.callback = copts.callback || null;\n        this.noIterator = typeof this.callback === \"function\";\n        this.monitor = null;\n        this.pong = null;\n        this.pending = {\n            msgs: 0,\n            bytes: 0,\n            requests: 0\n        };\n        this.refilling = refilling;\n        this.timeout = null;\n        this.inbox = createInbox(c.api.nc.options.inboxPrefix);\n        this.listeners = [];\n        this.forOrderedConsumer = false;\n        this.abortOnMissingResource = copts.abort_on_missing_resource === true;\n        this.bind = copts.bind === true;\n        this.inBackOff = false;\n        this.start();\n    }\n    start() {\n        const { max_messages, max_bytes, idle_heartbeat, threshold_bytes, threshold_messages } = this.opts;\n        this.closed().then((err)=>{\n            if (this.cleanupHandler) {\n                try {\n                    this.cleanupHandler(err);\n                } catch (_err) {}\n            }\n        });\n        const { sub } = this;\n        if (sub) {\n            sub.unsubscribe();\n        }\n        this.sub = this.consumer.api.nc.subscribe(this.inbox, {\n            callback: (err, msg)=>{\n                if (err) {\n                    this.stop(err);\n                    return;\n                }\n                this.monitor?.work();\n                const isProtocol = msg.subject === this.inbox;\n                if (isProtocol) {\n                    if (isHeartbeatMsg(msg)) {\n                        return;\n                    }\n                    const code = msg.headers?.code;\n                    const description = msg.headers?.description?.toLowerCase() || \"unknown\";\n                    const { msgsLeft, bytesLeft } = this.parseDiscard(msg.headers);\n                    if (msgsLeft > 0 || bytesLeft > 0) {\n                        this.pending.msgs -= msgsLeft;\n                        this.pending.bytes -= bytesLeft;\n                        this.pending.requests--;\n                        this.notify(ConsumerDebugEvents.Discard, {\n                            msgsLeft,\n                            bytesLeft\n                        });\n                    } else {\n                        if (code === 400) {\n                            this.stop(new NatsError(description, `${code}`));\n                            return;\n                        } else if (code === 409 && description === \"consumer deleted\") {\n                            this.notify(ConsumerEvents.ConsumerDeleted, `${code} ${description}`);\n                            if (!this.refilling || this.abortOnMissingResource) {\n                                const error = new NatsError(description, `${code}`);\n                                this.stop(error);\n                                return;\n                            }\n                        } else if (code === 503) {\n                            this.notify(ConsumerEvents.NoResponders, `${code} No Responders`);\n                            if (!this.refilling || this.abortOnMissingResource) {\n                                const error = new NatsError(\"no responders\", `${code}`);\n                                this.stop(error);\n                                return;\n                            }\n                        } else {\n                            this.notify(ConsumerDebugEvents.DebugEvent, `${code} ${description}`);\n                        }\n                    }\n                } else {\n                    this._push(toJsMsg(msg, this.consumer.api.timeout));\n                    this.received++;\n                    if (this.pending.msgs) {\n                        this.pending.msgs--;\n                    }\n                    if (this.pending.bytes) {\n                        this.pending.bytes -= msg.size();\n                    }\n                }\n                if (this.pending.msgs === 0 && this.pending.bytes === 0) {\n                    this.pending.requests = 0;\n                }\n                if (this.refilling) {\n                    if (max_messages && this.pending.msgs <= threshold_messages || max_bytes && this.pending.bytes <= threshold_bytes) {\n                        const batch = this.pullOptions();\n                        this.pull(batch);\n                    }\n                } else if (this.pending.requests === 0) {\n                    this._push(()=>{\n                        this.stop();\n                    });\n                }\n            }\n        });\n        this.sub.closed.then(()=>{\n            if (this.sub.draining) {\n                this._push(()=>{\n                    this.stop();\n                });\n            }\n        });\n        if (idle_heartbeat) {\n            this.monitor = new IdleHeartbeatMonitor(idle_heartbeat, (data)=>{\n                this.notify(ConsumerEvents.HeartbeatsMissed, data);\n                this.resetPending().then(()=>{}).catch(()=>{});\n                return false;\n            }, {\n                maxOut: 2\n            });\n        }\n        (async ()=>{\n            const status = this.consumer.api.nc.status();\n            this.statusIterator = status;\n            for await (const s of status){\n                switch(s.type){\n                    case Events.Disconnect:\n                        this.monitor?.cancel();\n                        break;\n                    case Events.Reconnect:\n                        this.resetPending().then((ok)=>{\n                            if (ok) {\n                                this.monitor?.restart();\n                            }\n                        }).catch(()=>{});\n                        break;\n                    default:\n                }\n            }\n        })();\n        this.pull(this.pullOptions());\n    }\n    _push(r) {\n        if (!this.callback) {\n            super.push(r);\n        } else {\n            const fn = typeof r === \"function\" ? r : null;\n            try {\n                if (!fn) {\n                    this.callback(r);\n                } else {\n                    fn();\n                }\n            } catch (err) {\n                this.stop(err);\n            }\n        }\n    }\n    notify(type, data) {\n        if (this.listeners.length > 0) {\n            (()=>{\n                this.listeners.forEach((l)=>{\n                    if (!l.done) {\n                        l.push({\n                            type,\n                            data\n                        });\n                    }\n                });\n            })();\n        }\n    }\n    resetPending() {\n        return this.bind ? this.resetPendingNoInfo() : this.resetPendingWithInfo();\n    }\n    resetPendingNoInfo() {\n        this.pending.msgs = 0;\n        this.pending.bytes = 0;\n        this.pending.requests = 0;\n        this.pull(this.pullOptions());\n        return Promise.resolve(true);\n    }\n    async resetPendingWithInfo() {\n        if (this.inBackOff) {\n            return false;\n        }\n        let notFound = 0;\n        let streamNotFound = 0;\n        const bo = backoff([\n            this.opts.expires\n        ]);\n        let attempt = 0;\n        while(true){\n            if (this.done) {\n                return false;\n            }\n            if (this.consumer.api.nc.isClosed()) {\n                console.error(\"aborting resetPending - connection is closed\");\n                return false;\n            }\n            try {\n                await this.consumer.info();\n                this.inBackOff = false;\n                notFound = 0;\n                this.pending.msgs = 0;\n                this.pending.bytes = 0;\n                this.pending.requests = 0;\n                this.pull(this.pullOptions());\n                return true;\n            } catch (err) {\n                if (err.message === \"stream not found\") {\n                    streamNotFound++;\n                    this.notify(ConsumerEvents.StreamNotFound, streamNotFound);\n                    if (!this.refilling || this.abortOnMissingResource) {\n                        this.stop(err);\n                        return false;\n                    }\n                } else if (err.message === \"consumer not found\") {\n                    notFound++;\n                    this.notify(ConsumerEvents.ConsumerNotFound, notFound);\n                    if (this.resetHandler) {\n                        try {\n                            this.resetHandler();\n                        } catch (_) {}\n                    }\n                    if (!this.refilling || this.abortOnMissingResource) {\n                        this.stop(err);\n                        return false;\n                    }\n                    if (this.forOrderedConsumer) {\n                        return false;\n                    }\n                } else {\n                    notFound = 0;\n                    streamNotFound = 0;\n                }\n                this.inBackOff = true;\n                const to = bo.backoff(attempt);\n                const de = delay(to);\n                await Promise.race([\n                    de,\n                    this.consumer.api.nc.closed()\n                ]);\n                de.cancel();\n                attempt++;\n            }\n        }\n    }\n    pull(opts) {\n        this.pending.bytes += opts.max_bytes ?? 0;\n        this.pending.msgs += opts.batch ?? 0;\n        this.pending.requests++;\n        const nc = this.consumer.api.nc;\n        this._push(()=>{\n            nc.publish(`${this.consumer.api.prefix}.CONSUMER.MSG.NEXT.${this.consumer.stream}.${this.consumer.name}`, this.consumer.api.jc.encode(opts), {\n                reply: this.inbox\n            });\n            this.notify(ConsumerDebugEvents.Next, opts);\n        });\n    }\n    pullOptions() {\n        const batch = this.opts.max_messages - this.pending.msgs;\n        const max_bytes = this.opts.max_bytes - this.pending.bytes;\n        const idle_heartbeat = nanos(this.opts.idle_heartbeat);\n        const expires = nanos(this.opts.expires);\n        return {\n            batch,\n            max_bytes,\n            idle_heartbeat,\n            expires\n        };\n    }\n    parseDiscard(headers) {\n        const discard = {\n            msgsLeft: 0,\n            bytesLeft: 0\n        };\n        const msgsLeft = headers?.get(JsHeaders.PendingMessagesHdr);\n        if (msgsLeft) {\n            discard.msgsLeft = parseInt(msgsLeft);\n        }\n        const bytesLeft = headers?.get(JsHeaders.PendingBytesHdr);\n        if (bytesLeft) {\n            discard.bytesLeft = parseInt(bytesLeft);\n        }\n        return discard;\n    }\n    trackTimeout(t) {\n        this.timeout = t;\n    }\n    close() {\n        this.stop();\n        return this.iterClosed;\n    }\n    closed() {\n        return this.iterClosed;\n    }\n    clearTimers() {\n        this.monitor?.cancel();\n        this.monitor = null;\n        this.timeout?.cancel();\n        this.timeout = null;\n    }\n    setCleanupHandler(fn) {\n        this.cleanupHandler = fn;\n    }\n    stop(err) {\n        if (this.done) {\n            return;\n        }\n        this.sub?.unsubscribe();\n        this.clearTimers();\n        this.statusIterator?.stop();\n        this._push(()=>{\n            super.stop(err);\n            this.listeners.forEach((n)=>{\n                n.stop();\n            });\n        });\n    }\n    parseOptions(opts, refilling = false) {\n        const args = opts || {};\n        args.max_messages = args.max_messages || 0;\n        args.max_bytes = args.max_bytes || 0;\n        if (args.max_messages !== 0 && args.max_bytes !== 0) {\n            throw new Error(`only specify one of max_messages or max_bytes`);\n        }\n        if (args.max_messages === 0) {\n            args.max_messages = 100;\n        }\n        args.expires = args.expires || 30_000;\n        if (args.expires < 1000) {\n            throw new Error(\"expires should be at least 1000ms\");\n        }\n        args.idle_heartbeat = args.idle_heartbeat || args.expires / 2;\n        args.idle_heartbeat = args.idle_heartbeat > 30_000 ? 30_000 : args.idle_heartbeat;\n        if (refilling) {\n            const minMsgs = Math.round(args.max_messages * .75) || 1;\n            args.threshold_messages = args.threshold_messages || minMsgs;\n            const minBytes = Math.round(args.max_bytes * .75) || 1;\n            args.threshold_bytes = args.threshold_bytes || minBytes;\n        }\n        return args;\n    }\n    status() {\n        const iter = new QueuedIteratorImpl();\n        this.listeners.push(iter);\n        return Promise.resolve(iter);\n    }\n}\nclass OrderedConsumerMessages extends QueuedIteratorImpl {\n    src;\n    listeners;\n    constructor(){\n        super();\n        this.listeners = [];\n    }\n    setSource(src) {\n        if (this.src) {\n            this.src.resetHandler = undefined;\n            this.src.setCleanupHandler();\n            this.src.stop();\n        }\n        this.src = src;\n        this.src.setCleanupHandler((err)=>{\n            this.stop(err || undefined);\n        });\n        (async ()=>{\n            const status = await this.src.status();\n            for await (const s of status){\n                this.notify(s.type, s.data);\n            }\n        })().catch(()=>{});\n    }\n    notify(type, data) {\n        if (this.listeners.length > 0) {\n            (()=>{\n                this.listeners.forEach((l)=>{\n                    if (!l.done) {\n                        l.push({\n                            type,\n                            data\n                        });\n                    }\n                });\n            })();\n        }\n    }\n    stop(err) {\n        if (this.done) {\n            return;\n        }\n        this.src?.stop(err);\n        super.stop(err);\n        this.listeners.forEach((n)=>{\n            n.stop();\n        });\n    }\n    close() {\n        this.stop();\n        return this.iterClosed;\n    }\n    closed() {\n        return this.iterClosed;\n    }\n    status() {\n        const iter = new QueuedIteratorImpl();\n        this.listeners.push(iter);\n        return Promise.resolve(iter);\n    }\n}\nclass PullConsumerImpl {\n    api;\n    _info;\n    stream;\n    name;\n    constructor(api, info){\n        this.api = api;\n        this._info = info;\n        this.stream = info.stream_name;\n        this.name = info.name;\n    }\n    consume(opts = {\n        max_messages: 100,\n        expires: 30_000\n    }) {\n        return Promise.resolve(new PullConsumerMessagesImpl(this, opts, true));\n    }\n    fetch(opts = {\n        max_messages: 100,\n        expires: 30_000\n    }) {\n        const m = new PullConsumerMessagesImpl(this, opts, false);\n        const to = Math.round(m.opts.expires * 1.05);\n        const timer = timeout(to);\n        m.closed().catch(()=>{}).finally(()=>{\n            timer.cancel();\n        });\n        timer.catch(()=>{\n            m.close().catch();\n        });\n        m.trackTimeout(timer);\n        return Promise.resolve(m);\n    }\n    next(opts = {\n        expires: 30_000\n    }) {\n        const d = deferred();\n        const fopts = opts;\n        fopts.max_messages = 1;\n        const iter = new PullConsumerMessagesImpl(this, fopts, false);\n        const to = Math.round(iter.opts.expires * 1.05);\n        if (to >= 60_000) {\n            (async ()=>{\n                for await (const s of (await iter.status())){\n                    if (s.type === ConsumerEvents.HeartbeatsMissed && s.data >= 2) {\n                        d.reject(new Error(\"consumer missed heartbeats\"));\n                        break;\n                    }\n                }\n            })().catch();\n        }\n        (async ()=>{\n            for await (const m of iter){\n                d.resolve(m);\n                break;\n            }\n        })().catch(()=>{});\n        const timer = timeout(to);\n        iter.closed().then((err)=>{\n            err ? d.reject(err) : d.resolve(null);\n        }).catch((err)=>{\n            d.reject(err);\n        }).finally(()=>{\n            timer.cancel();\n        });\n        timer.catch((_err)=>{\n            d.resolve(null);\n            iter.close().catch();\n        });\n        iter.trackTimeout(timer);\n        return d;\n    }\n    delete() {\n        const { stream_name, name } = this._info;\n        return this.api.delete(stream_name, name);\n    }\n    info(cached = false) {\n        if (cached) {\n            return Promise.resolve(this._info);\n        }\n        const { stream_name, name } = this._info;\n        return this.api.info(stream_name, name).then((ci)=>{\n            this._info = ci;\n            return this._info;\n        });\n    }\n}\nclass OrderedPullConsumerImpl {\n    api;\n    consumerOpts;\n    consumer;\n    opts;\n    cursor;\n    stream;\n    namePrefix;\n    serial;\n    currentConsumer;\n    userCallback;\n    iter;\n    type;\n    startSeq;\n    maxInitialReset;\n    constructor(api, stream, opts = {}){\n        this.api = api;\n        this.stream = stream;\n        this.cursor = {\n            stream_seq: 1,\n            deliver_seq: 0\n        };\n        this.namePrefix = nuid.next();\n        if (typeof opts.name_prefix === \"string\") {\n            minValidation(\"name_prefix\", opts.name_prefix);\n            this.namePrefix = opts.name_prefix + this.namePrefix;\n        }\n        this.serial = 0;\n        this.currentConsumer = null;\n        this.userCallback = null;\n        this.iter = null;\n        this.type = PullConsumerType.Unset;\n        this.consumerOpts = opts;\n        this.maxInitialReset = 30;\n        this.startSeq = this.consumerOpts.opt_start_seq || 0;\n        this.cursor.stream_seq = this.startSeq > 0 ? this.startSeq - 1 : 0;\n    }\n    getConsumerOpts(seq) {\n        this.serial++;\n        const name = `${this.namePrefix}_${this.serial}`;\n        seq = seq === 0 ? 1 : seq;\n        const config = {\n            name,\n            deliver_policy: DeliverPolicy.StartSequence,\n            opt_start_seq: seq,\n            ack_policy: AckPolicy.None,\n            inactive_threshold: nanos(5 * 60 * 1000),\n            num_replicas: 1\n        };\n        if (this.consumerOpts.headers_only === true) {\n            config.headers_only = true;\n        }\n        if (Array.isArray(this.consumerOpts.filterSubjects)) {\n            config.filter_subjects = this.consumerOpts.filterSubjects;\n        }\n        if (typeof this.consumerOpts.filterSubjects === \"string\") {\n            config.filter_subject = this.consumerOpts.filterSubjects;\n        }\n        if (this.consumerOpts.replay_policy) {\n            config.replay_policy = this.consumerOpts.replay_policy;\n        }\n        if (seq === this.startSeq + 1) {\n            config.deliver_policy = this.consumerOpts.deliver_policy || DeliverPolicy.StartSequence;\n            if (this.consumerOpts.deliver_policy === DeliverPolicy.LastPerSubject || this.consumerOpts.deliver_policy === DeliverPolicy.New || this.consumerOpts.deliver_policy === DeliverPolicy.Last) {\n                delete config.opt_start_seq;\n                config.deliver_policy = this.consumerOpts.deliver_policy;\n            }\n            if (config.deliver_policy === DeliverPolicy.LastPerSubject) {\n                if (typeof config.filter_subjects === \"undefined\" && typeof config.filter_subject === \"undefined\") {\n                    config.filter_subject = \">\";\n                }\n            }\n            if (this.consumerOpts.opt_start_time) {\n                delete config.opt_start_seq;\n                config.deliver_policy = DeliverPolicy.StartTime;\n                config.opt_start_time = this.consumerOpts.opt_start_time;\n            }\n            if (this.consumerOpts.inactive_threshold) {\n                config.inactive_threshold = nanos(this.consumerOpts.inactive_threshold);\n            }\n        }\n        return config;\n    }\n    async resetConsumer(seq = 0) {\n        nuid.next();\n        const isNew = this.serial === 0;\n        this.consumer?.delete().catch(()=>{});\n        seq = seq === 0 ? 1 : seq;\n        this.cursor.deliver_seq = 0;\n        const config = this.getConsumerOpts(seq);\n        config.max_deliver = 1;\n        config.mem_storage = true;\n        const bo = backoff([\n            this.opts?.expires || 30_000\n        ]);\n        let ci;\n        for(let i = 0;; i++){\n            try {\n                ci = await this.api.add(this.stream, config);\n                this.iter?.notify(ConsumerEvents.OrderedConsumerRecreated, ci.name);\n                break;\n            } catch (err) {\n                if (err.message === \"stream not found\") {\n                    this.iter?.notify(ConsumerEvents.StreamNotFound, i);\n                    if (this.type === PullConsumerType.Fetch || this.opts.abort_on_missing_resource === true) {\n                        this.iter?.stop(err);\n                        return Promise.reject(err);\n                    }\n                }\n                if (isNew && i >= this.maxInitialReset) {\n                    throw err;\n                } else {\n                    await delay(bo.backoff(i + 1));\n                }\n            }\n        }\n        return ci;\n    }\n    internalHandler(serial) {\n        return (m)=>{\n            if (this.serial !== serial) {\n                return;\n            }\n            const dseq = m.info.deliverySequence;\n            if (dseq !== this.cursor.deliver_seq + 1) {\n                this.notifyOrderedResetAndReset();\n                return;\n            }\n            this.cursor.deliver_seq = dseq;\n            this.cursor.stream_seq = m.info.streamSequence;\n            if (this.userCallback) {\n                this.userCallback(m);\n            } else {\n                this.iter?.push(m);\n            }\n        };\n    }\n    async reset(opts = {\n        max_messages: 100,\n        expires: 30_000\n    }, info) {\n        info = info || {};\n        const fromFetch = info.fromFetch || false;\n        const orderedReset = info.orderedReset || false;\n        if (this.type === PullConsumerType.Fetch && orderedReset) {\n            this.iter?.src.stop();\n            await this.iter?.closed();\n            this.currentConsumer = null;\n            return;\n        }\n        if (this.currentConsumer === null || orderedReset) {\n            this.currentConsumer = await this.resetConsumer(this.cursor.stream_seq + 1);\n        }\n        if (this.iter === null || fromFetch) {\n            this.iter = new OrderedConsumerMessages();\n        }\n        this.consumer = new PullConsumerImpl(this.api, this.currentConsumer);\n        const copts = opts;\n        copts.callback = this.internalHandler(this.serial);\n        let msgs = null;\n        if (this.type === PullConsumerType.Fetch && fromFetch) {\n            msgs = await this.consumer.fetch(opts);\n        } else if (this.type === PullConsumerType.Consume) {\n            msgs = await this.consumer.consume(opts);\n        }\n        const msgsImpl = msgs;\n        msgsImpl.forOrderedConsumer = true;\n        msgsImpl.resetHandler = ()=>{\n            this.notifyOrderedResetAndReset();\n        };\n        this.iter.setSource(msgsImpl);\n    }\n    notifyOrderedResetAndReset() {\n        this.iter?.notify(ConsumerDebugEvents.Reset, \"\");\n        this.reset(this.opts, {\n            orderedReset: true\n        });\n    }\n    async consume(opts = {\n        max_messages: 100,\n        expires: 30_000\n    }) {\n        const copts = opts;\n        if (copts.bind) {\n            return Promise.reject(new Error(\"bind is not supported\"));\n        }\n        if (this.type === PullConsumerType.Fetch) {\n            return Promise.reject(new Error(\"ordered consumer initialized as fetch\"));\n        }\n        if (this.type === PullConsumerType.Consume) {\n            return Promise.reject(new Error(\"ordered consumer doesn't support concurrent consume\"));\n        }\n        const { callback } = opts;\n        if (callback) {\n            this.userCallback = callback;\n        }\n        this.type = PullConsumerType.Consume;\n        this.opts = opts;\n        await this.reset(opts);\n        return this.iter;\n    }\n    async fetch(opts = {\n        max_messages: 100,\n        expires: 30_000\n    }) {\n        const copts = opts;\n        if (copts.bind) {\n            return Promise.reject(new Error(\"bind is not supported\"));\n        }\n        if (this.type === PullConsumerType.Consume) {\n            return Promise.reject(new Error(\"ordered consumer already initialized as consume\"));\n        }\n        if (this.iter?.done === false) {\n            return Promise.reject(new Error(\"ordered consumer doesn't support concurrent fetch\"));\n        }\n        const { callback } = opts;\n        if (callback) {\n            this.userCallback = callback;\n        }\n        this.type = PullConsumerType.Fetch;\n        this.opts = opts;\n        await this.reset(opts, {\n            fromFetch: true\n        });\n        return this.iter;\n    }\n    async next(opts = {\n        expires: 30_000\n    }) {\n        const copts = opts;\n        if (copts.bind) {\n            return Promise.reject(new Error(\"bind is not supported\"));\n        }\n        copts.max_messages = 1;\n        const d = deferred();\n        copts.callback = (m)=>{\n            this.userCallback = null;\n            d.resolve(m);\n        };\n        const iter = await this.fetch(copts);\n        iter.iterClosed.then((err)=>{\n            if (err) {\n                d.reject(err);\n            }\n            d.resolve(null);\n        }).catch((err)=>{\n            d.reject(err);\n        });\n        return d;\n    }\n    delete() {\n        if (!this.currentConsumer) {\n            return Promise.resolve(false);\n        }\n        return this.api.delete(this.stream, this.currentConsumer.name).then((tf)=>{\n            return Promise.resolve(tf);\n        }).catch((err)=>{\n            return Promise.reject(err);\n        }).finally(()=>{\n            this.currentConsumer = null;\n        });\n    }\n    async info(cached) {\n        if (this.currentConsumer == null) {\n            this.currentConsumer = await this.resetConsumer(this.startSeq);\n            return Promise.resolve(this.currentConsumer);\n        }\n        if (cached && this.currentConsumer) {\n            return Promise.resolve(this.currentConsumer);\n        }\n        return this.api.info(this.stream, this.currentConsumer.name);\n    }\n}\nclass ConsumersImpl {\n    api;\n    notified;\n    constructor(api){\n        this.api = api;\n        this.notified = false;\n    }\n    checkVersion() {\n        const fv = this.api.nc.features.get(Feature.JS_SIMPLIFICATION);\n        if (!fv.ok) {\n            return Promise.reject(new Error(`consumers framework is only supported on servers ${fv.min} or better`));\n        }\n        return Promise.resolve();\n    }\n    getPullConsumerFor(ci) {\n        if (ci.config.deliver_subject !== undefined) {\n            throw new Error(\"push consumer not supported\");\n        }\n        return new PullConsumerImpl(this.api, ci);\n    }\n    async get(stream, name = {}) {\n        if (typeof name === \"object\") {\n            return this.ordered(stream, name);\n        }\n        await this.checkVersion();\n        return this.api.info(stream, name).then((ci)=>{\n            if (ci.config.deliver_subject !== undefined) {\n                return Promise.reject(new Error(\"push consumer not supported\"));\n            }\n            return new PullConsumerImpl(this.api, ci);\n        }).catch((err)=>{\n            return Promise.reject(err);\n        });\n    }\n    async ordered(stream, opts) {\n        await this.checkVersion();\n        const impl = this.api;\n        const sapi = new StreamAPIImpl(impl.nc, impl.opts);\n        return sapi.info(stream).then((_si)=>{\n            return Promise.resolve(new OrderedPullConsumerImpl(this.api, stream, opts));\n        }).catch((err)=>{\n            return Promise.reject(err);\n        });\n    }\n}\nclass StreamImpl {\n    api;\n    _info;\n    constructor(api, info){\n        this.api = api;\n        this._info = info;\n    }\n    get name() {\n        return this._info.config.name;\n    }\n    alternates() {\n        return this.info().then((si)=>{\n            return si.alternates ? si.alternates : [];\n        });\n    }\n    async best() {\n        await this.info();\n        if (this._info.alternates) {\n            const asi = await this.api.info(this._info.alternates[0].name);\n            return new StreamImpl(this.api, asi);\n        } else {\n            return this;\n        }\n    }\n    info(cached = false, opts) {\n        if (cached) {\n            return Promise.resolve(this._info);\n        }\n        return this.api.info(this.name, opts).then((si)=>{\n            this._info = si;\n            return this._info;\n        });\n    }\n    getConsumerFromInfo(ci) {\n        return new ConsumersImpl(new ConsumerAPIImpl(this.api.nc, this.api.opts)).getPullConsumerFor(ci);\n    }\n    getConsumer(name) {\n        return new ConsumersImpl(new ConsumerAPIImpl(this.api.nc, this.api.opts)).get(this.name, name);\n    }\n    getMessage(query) {\n        return this.api.getMessage(this.name, query);\n    }\n    deleteMessage(seq, erase) {\n        return this.api.deleteMessage(this.name, seq, erase);\n    }\n}\nclass StreamAPIImpl extends BaseApiClient {\n    constructor(nc, opts){\n        super(nc, opts);\n    }\n    checkStreamConfigVersions(cfg) {\n        const nci = this.nc;\n        if (cfg.metadata) {\n            const { min, ok } = nci.features.get(Feature.JS_STREAM_CONSUMER_METADATA);\n            if (!ok) {\n                throw new Error(`stream 'metadata' requires server ${min}`);\n            }\n        }\n        if (cfg.first_seq) {\n            const { min, ok } = nci.features.get(Feature.JS_STREAM_FIRST_SEQ);\n            if (!ok) {\n                throw new Error(`stream 'first_seq' requires server ${min}`);\n            }\n        }\n        if (cfg.subject_transform) {\n            const { min, ok } = nci.features.get(Feature.JS_STREAM_SUBJECT_TRANSFORM);\n            if (!ok) {\n                throw new Error(`stream 'subject_transform' requires server ${min}`);\n            }\n        }\n        if (cfg.compression) {\n            const { min, ok } = nci.features.get(Feature.JS_STREAM_COMPRESSION);\n            if (!ok) {\n                throw new Error(`stream 'compression' requires server ${min}`);\n            }\n        }\n        if (cfg.consumer_limits) {\n            const { min, ok } = nci.features.get(Feature.JS_DEFAULT_CONSUMER_LIMITS);\n            if (!ok) {\n                throw new Error(`stream 'consumer_limits' requires server ${min}`);\n            }\n        }\n        function validateStreamSource(context, src) {\n            const count = src?.subject_transforms?.length || 0;\n            if (count > 0) {\n                const { min, ok } = nci.features.get(Feature.JS_STREAM_SOURCE_SUBJECT_TRANSFORM);\n                if (!ok) {\n                    throw new Error(`${context} 'subject_transforms' requires server ${min}`);\n                }\n            }\n        }\n        if (cfg.sources) {\n            cfg.sources.forEach((src)=>{\n                validateStreamSource(\"stream sources\", src);\n            });\n        }\n        if (cfg.mirror) {\n            validateStreamSource(\"stream mirror\", cfg.mirror);\n        }\n    }\n    async add(cfg = {}) {\n        this.checkStreamConfigVersions(cfg);\n        validateStreamName(cfg.name);\n        cfg.mirror = convertStreamSourceDomain(cfg.mirror);\n        cfg.sources = cfg.sources?.map(convertStreamSourceDomain);\n        const r = await this._request(`${this.prefix}.STREAM.CREATE.${cfg.name}`, cfg);\n        const si = r;\n        this._fixInfo(si);\n        return si;\n    }\n    async delete(stream) {\n        validateStreamName(stream);\n        const r = await this._request(`${this.prefix}.STREAM.DELETE.${stream}`);\n        const cr = r;\n        return cr.success;\n    }\n    async update(name, cfg = {}) {\n        if (typeof name === \"object\") {\n            const sc = name;\n            name = sc.name;\n            cfg = sc;\n            console.trace(`\\u001B[33m >> streams.update(config: StreamConfig) api changed to streams.update(name: string, config: StreamUpdateConfig) - this shim will be removed - update your code.  \\u001B[0m`);\n        }\n        this.checkStreamConfigVersions(cfg);\n        validateStreamName(name);\n        const old = await this.info(name);\n        const update = Object.assign(old.config, cfg);\n        update.mirror = convertStreamSourceDomain(update.mirror);\n        update.sources = update.sources?.map(convertStreamSourceDomain);\n        const r = await this._request(`${this.prefix}.STREAM.UPDATE.${name}`, update);\n        const si = r;\n        this._fixInfo(si);\n        return si;\n    }\n    async info(name, data) {\n        validateStreamName(name);\n        const subj = `${this.prefix}.STREAM.INFO.${name}`;\n        const r = await this._request(subj, data);\n        let si = r;\n        let { total, limit } = si;\n        let have = si.state.subjects ? Object.getOwnPropertyNames(si.state.subjects).length : 1;\n        if (total && total > have) {\n            const infos = [\n                si\n            ];\n            const paged = data || {};\n            let i = 0;\n            while(total > have){\n                i++;\n                paged.offset = limit * i;\n                const r = await this._request(subj, paged);\n                total = r.total;\n                infos.push(r);\n                const count = Object.getOwnPropertyNames(r.state.subjects).length;\n                have += count;\n                if (count < limit) {\n                    break;\n                }\n            }\n            let subjects = {};\n            for(let i = 0; i < infos.length; i++){\n                si = infos[i];\n                if (si.state.subjects) {\n                    subjects = Object.assign(subjects, si.state.subjects);\n                }\n            }\n            si.offset = 0;\n            si.total = 0;\n            si.limit = 0;\n            si.state.subjects = subjects;\n        }\n        this._fixInfo(si);\n        return si;\n    }\n    list(subject = \"\") {\n        const payload = subject?.length ? {\n            subject\n        } : {};\n        const listerFilter = (v)=>{\n            const slr = v;\n            slr.streams.forEach((si)=>{\n                this._fixInfo(si);\n            });\n            return slr.streams;\n        };\n        const subj = `${this.prefix}.STREAM.LIST`;\n        return new ListerImpl(subj, listerFilter, this, payload);\n    }\n    _fixInfo(si) {\n        si.config.sealed = si.config.sealed || false;\n        si.config.deny_delete = si.config.deny_delete || false;\n        si.config.deny_purge = si.config.deny_purge || false;\n        si.config.allow_rollup_hdrs = si.config.allow_rollup_hdrs || false;\n    }\n    async purge(name, opts) {\n        if (opts) {\n            const { keep, seq } = opts;\n            if (typeof keep === \"number\" && typeof seq === \"number\") {\n                throw new Error(\"can specify one of keep or seq\");\n            }\n        }\n        validateStreamName(name);\n        const v = await this._request(`${this.prefix}.STREAM.PURGE.${name}`, opts);\n        return v;\n    }\n    async deleteMessage(stream, seq, erase = true) {\n        validateStreamName(stream);\n        const dr = {\n            seq\n        };\n        if (!erase) {\n            dr.no_erase = true;\n        }\n        const r = await this._request(`${this.prefix}.STREAM.MSG.DELETE.${stream}`, dr);\n        const cr = r;\n        return cr.success;\n    }\n    async getMessage(stream, query) {\n        validateStreamName(stream);\n        const r = await this._request(`${this.prefix}.STREAM.MSG.GET.${stream}`, query);\n        const sm = r;\n        return new StoredMsgImpl(sm);\n    }\n    find(subject) {\n        return this.findStream(subject);\n    }\n    listKvs() {\n        const filter = (v)=>{\n            const slr = v;\n            const kvStreams = slr.streams.filter((v)=>{\n                return v.config.name.startsWith(kvPrefix);\n            });\n            kvStreams.forEach((si)=>{\n                this._fixInfo(si);\n            });\n            let cluster = \"\";\n            if (kvStreams.length) {\n                cluster = this.nc.info?.cluster ?? \"\";\n            }\n            const status = kvStreams.map((si)=>{\n                return new KvStatusImpl(si, cluster);\n            });\n            return status;\n        };\n        const subj = `${this.prefix}.STREAM.LIST`;\n        return new ListerImpl(subj, filter, this);\n    }\n    listObjectStores() {\n        const filter = (v)=>{\n            const slr = v;\n            const objStreams = slr.streams.filter((v)=>{\n                return v.config.name.startsWith(osPrefix);\n            });\n            objStreams.forEach((si)=>{\n                this._fixInfo(si);\n            });\n            const status = objStreams.map((si)=>{\n                return new ObjectStoreStatusImpl(si);\n            });\n            return status;\n        };\n        const subj = `${this.prefix}.STREAM.LIST`;\n        return new ListerImpl(subj, filter, this);\n    }\n    names(subject = \"\") {\n        const payload = subject?.length ? {\n            subject\n        } : {};\n        const listerFilter = (v)=>{\n            const sr = v;\n            return sr.streams;\n        };\n        const subj = `${this.prefix}.STREAM.NAMES`;\n        return new ListerImpl(subj, listerFilter, this, payload);\n    }\n    async get(name) {\n        const si = await this.info(name);\n        return Promise.resolve(new StreamImpl(this, si));\n    }\n}\nclass DirectStreamAPIImpl extends BaseApiClient {\n    constructor(nc, opts){\n        super(nc, opts);\n    }\n    async getMessage(stream, query) {\n        validateStreamName(stream);\n        let qq = query;\n        const { last_by_subj } = qq;\n        if (last_by_subj) {\n            qq = null;\n        }\n        const payload = qq ? this.jc.encode(qq) : Empty;\n        const pre = this.opts.apiPrefix || \"$JS.API\";\n        const subj = last_by_subj ? `${pre}.DIRECT.GET.${stream}.${last_by_subj}` : `${pre}.DIRECT.GET.${stream}`;\n        const r = await this.nc.request(subj, payload, {\n            timeout: this.timeout\n        });\n        const err = checkJsError(r);\n        if (err) {\n            return Promise.reject(err);\n        }\n        const dm = new DirectMsgImpl(r);\n        return Promise.resolve(dm);\n    }\n    async getBatch(stream, opts) {\n        validateStreamName(stream);\n        const pre = this.opts.apiPrefix || \"$JS.API\";\n        const subj = `${pre}.DIRECT.GET.${stream}`;\n        if (!Array.isArray(opts.multi_last) || opts.multi_last.length === 0) {\n            return Promise.reject(\"multi_last is required\");\n        }\n        const payload = JSON.stringify(opts, (key, value)=>{\n            if (key === \"up_to_time\" && value instanceof Date) {\n                return value.toISOString();\n            }\n            return value;\n        });\n        const iter = new QueuedIteratorImpl();\n        const raw = await this.nc.requestMany(subj, payload, {\n            strategy: RequestStrategy.SentinelMsg\n        });\n        (async ()=>{\n            let gotFirst = false;\n            let badServer = false;\n            let badRequest;\n            for await (const m of raw){\n                if (!gotFirst) {\n                    gotFirst = true;\n                    const code = m.headers?.code || 0;\n                    if (code !== 0 && code < 200 || code > 299) {\n                        badRequest = m.headers?.description.toLowerCase();\n                        break;\n                    }\n                    const v = m.headers?.get(\"Nats-Num-Pending\");\n                    if (v === \"\") {\n                        badServer = true;\n                        break;\n                    }\n                }\n                if (m.data.length === 0) {\n                    break;\n                }\n                iter.push(new DirectMsgImpl(m));\n            }\n            iter.push(()=>{\n                if (badServer) {\n                    throw new Error(\"batch direct get not supported by the server\");\n                }\n                if (badRequest) {\n                    throw new Error(`bad request: ${badRequest}`);\n                }\n                iter.stop();\n            });\n        })();\n        return Promise.resolve(iter);\n    }\n}\nclass DirectMsgImpl {\n    data;\n    header;\n    static jc;\n    constructor(m){\n        if (!m.headers) {\n            throw new Error(\"headers expected\");\n        }\n        this.data = m.data;\n        this.header = m.headers;\n    }\n    get subject() {\n        return this.header.last(DirectMsgHeaders.Subject);\n    }\n    get seq() {\n        const v = this.header.last(DirectMsgHeaders.Sequence);\n        return typeof v === \"string\" ? parseInt(v) : 0;\n    }\n    get time() {\n        return new Date(Date.parse(this.timestamp));\n    }\n    get timestamp() {\n        return this.header.last(DirectMsgHeaders.TimeStamp);\n    }\n    get stream() {\n        return this.header.last(DirectMsgHeaders.Stream);\n    }\n    json(reviver) {\n        return JSONCodec(reviver).decode(this.data);\n    }\n    string() {\n        return TD.decode(this.data);\n    }\n}\nclass JetStreamManagerImpl extends BaseApiClient {\n    streams;\n    consumers;\n    direct;\n    constructor(nc, opts){\n        super(nc, opts);\n        this.streams = new StreamAPIImpl(nc, opts);\n        this.consumers = new ConsumerAPIImpl(nc, opts);\n        this.direct = new DirectStreamAPIImpl(nc, opts);\n    }\n    async getAccountInfo() {\n        const r = await this._request(`${this.prefix}.INFO`);\n        return r;\n    }\n    jetstream() {\n        return this.nc.jetstream(this.getOptions());\n    }\n    advisories() {\n        const iter = new QueuedIteratorImpl();\n        this.nc.subscribe(`$JS.EVENT.ADVISORY.>`, {\n            callback: (err, msg)=>{\n                if (err) {\n                    throw err;\n                }\n                try {\n                    const d = this.parseJsResponse(msg);\n                    const chunks = d.type.split(\".\");\n                    const kind = chunks[chunks.length - 1];\n                    iter.push({\n                        kind: kind,\n                        data: d\n                    });\n                } catch (err) {\n                    iter.stop(err);\n                }\n            }\n        });\n        return iter;\n    }\n}\nclass StoredMsgImpl {\n    _header;\n    smr;\n    static jc;\n    constructor(smr){\n        this.smr = smr;\n    }\n    get subject() {\n        return this.smr.message.subject;\n    }\n    get seq() {\n        return this.smr.message.seq;\n    }\n    get timestamp() {\n        return this.smr.message.time;\n    }\n    get time() {\n        return new Date(Date.parse(this.timestamp));\n    }\n    get data() {\n        return this.smr.message.data ? this._parse(this.smr.message.data) : Empty;\n    }\n    get header() {\n        if (!this._header) {\n            if (this.smr.message.hdrs) {\n                const hd = this._parse(this.smr.message.hdrs);\n                this._header = MsgHdrsImpl.decode(hd);\n            } else {\n                this._header = headers();\n            }\n        }\n        return this._header;\n    }\n    _parse(s) {\n        const bs = atob(s);\n        const len = bs.length;\n        const bytes = new Uint8Array(len);\n        for(let i = 0; i < len; i++){\n            bytes[i] = bs.charCodeAt(i);\n        }\n        return bytes;\n    }\n    json(reviver) {\n        return JSONCodec(reviver).decode(this.data);\n    }\n    string() {\n        return TD.decode(this.data);\n    }\n}\nclass StreamsImpl {\n    api;\n    constructor(api){\n        this.api = api;\n    }\n    get(stream) {\n        return this.api.info(stream).then((si)=>{\n            return new StreamImpl(this.api, si);\n        });\n    }\n}\nclass ObjectInfoImpl {\n    info;\n    hdrs;\n    constructor(oi){\n        this.info = oi;\n    }\n    get name() {\n        return this.info.name;\n    }\n    get description() {\n        return this.info.description ?? \"\";\n    }\n    get headers() {\n        if (!this.hdrs) {\n            this.hdrs = MsgHdrsImpl.fromRecord(this.info.headers || {});\n        }\n        return this.hdrs;\n    }\n    get options() {\n        return this.info.options;\n    }\n    get bucket() {\n        return this.info.bucket;\n    }\n    get chunks() {\n        return this.info.chunks;\n    }\n    get deleted() {\n        return this.info.deleted ?? false;\n    }\n    get digest() {\n        return this.info.digest;\n    }\n    get mtime() {\n        return this.info.mtime;\n    }\n    get nuid() {\n        return this.info.nuid;\n    }\n    get size() {\n        return this.info.size;\n    }\n    get revision() {\n        return this.info.revision;\n    }\n    get metadata() {\n        return this.info.metadata || {};\n    }\n    isLink() {\n        return this.info.options?.link !== undefined && this.info.options?.link !== null;\n    }\n}\nfunction toServerObjectStoreMeta(meta) {\n    const v = {\n        name: meta.name,\n        description: meta.description ?? \"\",\n        options: meta.options,\n        metadata: meta.metadata\n    };\n    if (meta.headers) {\n        const mhi = meta.headers;\n        v.headers = mhi.toRecord();\n    }\n    return v;\n}\nfunction emptyReadableStream() {\n    return new ReadableStream({\n        pull (c) {\n            c.enqueue(new Uint8Array(0));\n            c.close();\n        }\n    });\n}\nclass ObjectStoreImpl {\n    jsm;\n    js;\n    stream;\n    name;\n    constructor(name, jsm, js){\n        this.name = name;\n        this.jsm = jsm;\n        this.js = js;\n    }\n    _checkNotEmpty(name) {\n        if (!name || name.length === 0) {\n            return {\n                name,\n                error: new Error(\"name cannot be empty\")\n            };\n        }\n        return {\n            name\n        };\n    }\n    async info(name) {\n        const info = await this.rawInfo(name);\n        return info ? new ObjectInfoImpl(info) : null;\n    }\n    async list() {\n        const buf = [];\n        const iter = await this.watch({\n            ignoreDeletes: true,\n            includeHistory: true\n        });\n        for await (const info of iter){\n            if (info === null) {\n                break;\n            }\n            buf.push(info);\n        }\n        return Promise.resolve(buf);\n    }\n    async rawInfo(name) {\n        const { name: obj, error } = this._checkNotEmpty(name);\n        if (error) {\n            return Promise.reject(error);\n        }\n        const meta = this._metaSubject(obj);\n        try {\n            const m = await this.jsm.streams.getMessage(this.stream, {\n                last_by_subj: meta\n            });\n            const jc = JSONCodec();\n            const soi = jc.decode(m.data);\n            soi.revision = m.seq;\n            return soi;\n        } catch (err) {\n            if (err.code === \"404\") {\n                return null;\n            }\n            return Promise.reject(err);\n        }\n    }\n    async _si(opts) {\n        try {\n            return await this.jsm.streams.info(this.stream, opts);\n        } catch (err) {\n            const nerr = err;\n            if (nerr.code === \"404\") {\n                return null;\n            }\n            return Promise.reject(err);\n        }\n    }\n    async seal() {\n        let info = await this._si();\n        if (info === null) {\n            return Promise.reject(new Error(\"object store not found\"));\n        }\n        info.config.sealed = true;\n        info = await this.jsm.streams.update(this.stream, info.config);\n        return Promise.resolve(new ObjectStoreStatusImpl(info));\n    }\n    async status(opts) {\n        const info = await this._si(opts);\n        if (info === null) {\n            return Promise.reject(new Error(\"object store not found\"));\n        }\n        return Promise.resolve(new ObjectStoreStatusImpl(info));\n    }\n    destroy() {\n        return this.jsm.streams.delete(this.stream);\n    }\n    async _put(meta, rs, opts) {\n        const jsopts = this.js.getOptions();\n        opts = opts || {\n            timeout: jsopts.timeout\n        };\n        opts.timeout = opts.timeout || jsopts.timeout;\n        opts.previousRevision = opts.previousRevision ?? undefined;\n        const { timeout, previousRevision } = opts;\n        const si = this.js.nc.info;\n        const maxPayload = si?.max_payload || 1024;\n        meta = meta || {};\n        meta.options = meta.options || {};\n        let maxChunk = meta.options?.max_chunk_size || 128 * 1024;\n        maxChunk = maxChunk > maxPayload ? maxPayload : maxChunk;\n        meta.options.max_chunk_size = maxChunk;\n        const old = await this.info(meta.name);\n        const { name: n, error } = this._checkNotEmpty(meta.name);\n        if (error) {\n            return Promise.reject(error);\n        }\n        const id = nuid.next();\n        const chunkSubj = this._chunkSubject(id);\n        const metaSubj = this._metaSubject(n);\n        const info = Object.assign({\n            bucket: this.name,\n            nuid: id,\n            size: 0,\n            chunks: 0\n        }, toServerObjectStoreMeta(meta));\n        const d = deferred();\n        const proms = [];\n        const db = new DataBuffer();\n        try {\n            const reader = rs ? rs.getReader() : null;\n            const sha = J.create();\n            while(true){\n                const { done, value } = reader ? await reader.read() : {\n                    done: true,\n                    value: undefined\n                };\n                if (done) {\n                    if (db.size() > 0) {\n                        const payload = db.drain();\n                        sha.update(payload);\n                        info.chunks++;\n                        info.size += payload.length;\n                        proms.push(this.js.publish(chunkSubj, payload, {\n                            timeout\n                        }));\n                    }\n                    await Promise.all(proms);\n                    proms.length = 0;\n                    info.mtime = new Date().toISOString();\n                    const digest = Base64UrlPaddedCodec.encode(sha.digest());\n                    info.digest = `${digestType}${digest}`;\n                    info.deleted = false;\n                    const h = headers();\n                    if (typeof previousRevision === \"number\") {\n                        h.set(PubHeaders.ExpectedLastSubjectSequenceHdr, `${previousRevision}`);\n                    }\n                    h.set(JsHeaders.RollupHdr, JsHeaders.RollupValueSubject);\n                    const pa = await this.js.publish(metaSubj, JSONCodec().encode(info), {\n                        headers: h,\n                        timeout\n                    });\n                    info.revision = pa.seq;\n                    if (old) {\n                        try {\n                            await this.jsm.streams.purge(this.stream, {\n                                filter: `$O.${this.name}.C.${old.nuid}`\n                            });\n                        } catch (_err) {}\n                    }\n                    d.resolve(new ObjectInfoImpl(info));\n                    break;\n                }\n                if (value) {\n                    db.fill(value);\n                    while(db.size() > maxChunk){\n                        info.chunks++;\n                        info.size += maxChunk;\n                        const payload = db.drain(meta.options.max_chunk_size);\n                        sha.update(payload);\n                        proms.push(this.js.publish(chunkSubj, payload, {\n                            timeout\n                        }));\n                    }\n                }\n            }\n        } catch (err) {\n            await this.jsm.streams.purge(this.stream, {\n                filter: chunkSubj\n            });\n            d.reject(err);\n        }\n        return d;\n    }\n    putBlob(meta, data, opts) {\n        function readableStreamFrom(data) {\n            return new ReadableStream({\n                pull (controller) {\n                    controller.enqueue(data);\n                    controller.close();\n                }\n            });\n        }\n        if (data === null) {\n            data = new Uint8Array(0);\n        }\n        return this.put(meta, readableStreamFrom(data), opts);\n    }\n    put(meta, rs, opts) {\n        if (meta?.options?.link) {\n            return Promise.reject(new Error(\"link cannot be set when putting the object in bucket\"));\n        }\n        return this._put(meta, rs, opts);\n    }\n    async getBlob(name) {\n        async function fromReadableStream(rs) {\n            const buf = new DataBuffer();\n            const reader = rs.getReader();\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) {\n                    return buf.drain();\n                }\n                if (value && value.length) {\n                    buf.fill(value);\n                }\n            }\n        }\n        const r = await this.get(name);\n        if (r === null) {\n            return Promise.resolve(null);\n        }\n        const vs = await Promise.all([\n            r.error,\n            fromReadableStream(r.data)\n        ]);\n        if (vs[0]) {\n            return Promise.reject(vs[0]);\n        } else {\n            return Promise.resolve(vs[1]);\n        }\n    }\n    async get(name) {\n        const info = await this.rawInfo(name);\n        if (info === null) {\n            return Promise.resolve(null);\n        }\n        if (info.deleted) {\n            return Promise.resolve(null);\n        }\n        if (info.options && info.options.link) {\n            const ln = info.options.link.name || \"\";\n            if (ln === \"\") {\n                throw new Error(\"link is a bucket\");\n            }\n            const os = info.options.link.bucket !== this.name ? await ObjectStoreImpl.create(this.js, info.options.link.bucket) : this;\n            return os.get(ln);\n        }\n        if (!info.digest.startsWith(digestType)) {\n            return Promise.reject(new Error(`unknown digest type: ${info.digest}`));\n        }\n        const digest = parseSha256(info.digest.substring(8));\n        if (digest === null) {\n            return Promise.reject(new Error(`unable to parse digest: ${info.digest}`));\n        }\n        const d = deferred();\n        const r = {\n            info: new ObjectInfoImpl(info),\n            error: d\n        };\n        if (info.size === 0) {\n            r.data = emptyReadableStream();\n            d.resolve(null);\n            return Promise.resolve(r);\n        }\n        let controller;\n        const oc = consumerOpts();\n        oc.orderedConsumer();\n        const sha = J.create();\n        const subj = `$O.${this.name}.C.${info.nuid}`;\n        const sub = await this.js.subscribe(subj, oc);\n        (async ()=>{\n            for await (const jm of sub){\n                if (jm.data.length > 0) {\n                    sha.update(jm.data);\n                    controller.enqueue(jm.data);\n                }\n                if (jm.info.pending === 0) {\n                    if (!checkSha256(digest, sha.digest())) {\n                        controller.error(new Error(`received a corrupt object, digests do not match received: ${info.digest} calculated ${digest}`));\n                    } else {\n                        controller.close();\n                    }\n                    sub.unsubscribe();\n                }\n            }\n        })().then(()=>{\n            d.resolve();\n        }).catch((err)=>{\n            controller.error(err);\n            d.reject(err);\n        });\n        r.data = new ReadableStream({\n            start (c) {\n                controller = c;\n            },\n            cancel () {\n                sub.unsubscribe();\n            }\n        });\n        return r;\n    }\n    linkStore(name, bucket) {\n        if (!(bucket instanceof ObjectStoreImpl)) {\n            return Promise.reject(\"bucket required\");\n        }\n        const osi = bucket;\n        const { name: n, error } = this._checkNotEmpty(name);\n        if (error) {\n            return Promise.reject(error);\n        }\n        const meta = {\n            name: n,\n            options: {\n                link: {\n                    bucket: osi.name\n                }\n            }\n        };\n        return this._put(meta, null);\n    }\n    async link(name, info) {\n        const { name: n, error } = this._checkNotEmpty(name);\n        if (error) {\n            return Promise.reject(error);\n        }\n        if (info.deleted) {\n            return Promise.reject(new Error(\"src object is deleted\"));\n        }\n        if (info.isLink()) {\n            return Promise.reject(new Error(\"src object is a link\"));\n        }\n        const dest = await this.rawInfo(name);\n        if (dest !== null && !dest.deleted) {\n            return Promise.reject(new Error(\"an object already exists with that name\"));\n        }\n        const link = {\n            bucket: info.bucket,\n            name: info.name\n        };\n        const mm = {\n            name: n,\n            bucket: info.bucket,\n            options: {\n                link: link\n            }\n        };\n        await this.js.publish(this._metaSubject(name), JSON.stringify(mm));\n        const i = await this.info(name);\n        return Promise.resolve(i);\n    }\n    async delete(name) {\n        const info = await this.rawInfo(name);\n        if (info === null) {\n            return Promise.resolve({\n                purged: 0,\n                success: false\n            });\n        }\n        info.deleted = true;\n        info.size = 0;\n        info.chunks = 0;\n        info.digest = \"\";\n        const jc = JSONCodec();\n        const h = headers();\n        h.set(JsHeaders.RollupHdr, JsHeaders.RollupValueSubject);\n        await this.js.publish(this._metaSubject(info.name), jc.encode(info), {\n            headers: h\n        });\n        return this.jsm.streams.purge(this.stream, {\n            filter: this._chunkSubject(info.nuid)\n        });\n    }\n    async update(name, meta = {}) {\n        const info = await this.rawInfo(name);\n        if (info === null) {\n            return Promise.reject(new Error(\"object not found\"));\n        }\n        if (info.deleted) {\n            return Promise.reject(new Error(\"cannot update meta for a deleted object\"));\n        }\n        meta.name = meta.name ?? info.name;\n        const { name: n, error } = this._checkNotEmpty(meta.name);\n        if (error) {\n            return Promise.reject(error);\n        }\n        if (name !== meta.name) {\n            const i = await this.info(meta.name);\n            if (i && !i.deleted) {\n                return Promise.reject(new Error(\"an object already exists with that name\"));\n            }\n        }\n        meta.name = n;\n        const ii = Object.assign({}, info, toServerObjectStoreMeta(meta));\n        const ack = await this.js.publish(this._metaSubject(ii.name), JSON.stringify(ii));\n        if (name !== meta.name) {\n            await this.jsm.streams.purge(this.stream, {\n                filter: this._metaSubject(name)\n            });\n        }\n        return Promise.resolve(ack);\n    }\n    async watch(opts = {}) {\n        opts.includeHistory = opts.includeHistory ?? false;\n        opts.ignoreDeletes = opts.ignoreDeletes ?? false;\n        let initialized = false;\n        const qi = new QueuedIteratorImpl();\n        const subj = this._metaSubjectAll();\n        try {\n            await this.jsm.streams.getMessage(this.stream, {\n                last_by_subj: subj\n            });\n        } catch (err) {\n            if (err.code === \"404\") {\n                qi.push(null);\n                initialized = true;\n            } else {\n                qi.stop(err);\n            }\n        }\n        const jc = JSONCodec();\n        const copts = consumerOpts();\n        copts.orderedConsumer();\n        if (opts.includeHistory) {\n            copts.deliverLastPerSubject();\n        } else {\n            initialized = true;\n            copts.deliverNew();\n        }\n        copts.callback((err, jm)=>{\n            if (err) {\n                qi.stop(err);\n                return;\n            }\n            if (jm !== null) {\n                const oi = jc.decode(jm.data);\n                if (oi.deleted && opts.ignoreDeletes === true) {} else {\n                    qi.push(oi);\n                }\n                if (jm.info?.pending === 0 && !initialized) {\n                    initialized = true;\n                    qi.push(null);\n                }\n            }\n        });\n        const sub = await this.js.subscribe(subj, copts);\n        qi._data = sub;\n        qi.iterClosed.then(()=>{\n            sub.unsubscribe();\n        });\n        sub.closed.then(()=>{\n            qi.stop();\n        }).catch((err)=>{\n            qi.stop(err);\n        });\n        return qi;\n    }\n    _chunkSubject(id) {\n        return `$O.${this.name}.C.${id}`;\n    }\n    _metaSubject(n) {\n        return `$O.${this.name}.M.${Base64UrlPaddedCodec.encode(n)}`;\n    }\n    _metaSubjectAll() {\n        return `$O.${this.name}.M.>`;\n    }\n    async init(opts = {}) {\n        try {\n            this.stream = objectStoreStreamName(this.name);\n        } catch (err) {\n            return Promise.reject(err);\n        }\n        const max_age = opts?.ttl || 0;\n        delete opts.ttl;\n        const sc = Object.assign({\n            max_age\n        }, opts);\n        sc.name = this.stream;\n        sc.num_replicas = opts.replicas ?? 1;\n        sc.allow_direct = true;\n        sc.allow_rollup_hdrs = true;\n        sc.discard = DiscardPolicy.New;\n        sc.subjects = [\n            `$O.${this.name}.C.>`,\n            `$O.${this.name}.M.>`\n        ];\n        if (opts.placement) {\n            sc.placement = opts.placement;\n        }\n        if (opts.metadata) {\n            sc.metadata = opts.metadata;\n        }\n        if (typeof opts.compression === \"boolean\") {\n            sc.compression = opts.compression ? StoreCompression.S2 : StoreCompression.None;\n        }\n        try {\n            await this.jsm.streams.info(sc.name);\n        } catch (err) {\n            if (err.message === \"stream not found\") {\n                await this.jsm.streams.add(sc);\n            }\n        }\n    }\n    static async create(js, name, opts = {}) {\n        const jsm = await js.jetstreamManager();\n        const os = new ObjectStoreImpl(name, jsm, js);\n        await os.init(opts);\n        return Promise.resolve(os);\n    }\n}\nclass ViewsImpl {\n    js;\n    constructor(js){\n        this.js = js;\n    }\n    kv(name, opts = {}) {\n        const jsi = this.js;\n        const { ok, min } = jsi.nc.features.get(Feature.JS_KV);\n        if (!ok) {\n            return Promise.reject(new Error(`kv is only supported on servers ${min} or better`));\n        }\n        if (opts.bindOnly) {\n            return Bucket.bind(this.js, name, opts);\n        }\n        return Bucket.create(this.js, name, opts);\n    }\n    os(name, opts = {}) {\n        if (typeof crypto?.subtle?.digest !== \"function\") {\n            return Promise.reject(new Error(\"objectstore: unable to calculate hashes - crypto.subtle.digest with sha256 support is required\"));\n        }\n        const jsi = this.js;\n        const { ok, min } = jsi.nc.features.get(Feature.JS_OBJECTSTORE);\n        if (!ok) {\n            return Promise.reject(new Error(`objectstore is only supported on servers ${min} or better`));\n        }\n        return ObjectStoreImpl.create(this.js, name, opts);\n    }\n}\nclass JetStreamClientImpl extends BaseApiClient {\n    consumers;\n    streams;\n    consumerAPI;\n    streamAPI;\n    constructor(nc, opts){\n        super(nc, opts);\n        this.consumerAPI = new ConsumerAPIImpl(nc, opts);\n        this.streamAPI = new StreamAPIImpl(nc, opts);\n        this.consumers = new ConsumersImpl(this.consumerAPI);\n        this.streams = new StreamsImpl(this.streamAPI);\n    }\n    jetstreamManager(checkAPI) {\n        if (checkAPI === undefined) {\n            checkAPI = this.opts.checkAPI;\n        }\n        const opts = Object.assign({}, this.opts, {\n            checkAPI\n        });\n        return this.nc.jetstreamManager(opts);\n    }\n    get apiPrefix() {\n        return this.prefix;\n    }\n    get views() {\n        return new ViewsImpl(this);\n    }\n    async publish(subj, data = Empty, opts) {\n        opts = opts || {};\n        opts.expect = opts.expect || {};\n        const mh = opts?.headers || headers();\n        if (opts) {\n            if (opts.msgID) {\n                mh.set(PubHeaders.MsgIdHdr, opts.msgID);\n            }\n            if (opts.expect.lastMsgID) {\n                mh.set(PubHeaders.ExpectedLastMsgIdHdr, opts.expect.lastMsgID);\n            }\n            if (opts.expect.streamName) {\n                mh.set(PubHeaders.ExpectedStreamHdr, opts.expect.streamName);\n            }\n            if (typeof opts.expect.lastSequence === \"number\") {\n                mh.set(PubHeaders.ExpectedLastSeqHdr, `${opts.expect.lastSequence}`);\n            }\n            if (typeof opts.expect.lastSubjectSequence === \"number\") {\n                mh.set(PubHeaders.ExpectedLastSubjectSequenceHdr, `${opts.expect.lastSubjectSequence}`);\n            }\n        }\n        const to = opts.timeout || this.timeout;\n        const ro = {};\n        if (to) {\n            ro.timeout = to;\n        }\n        if (opts) {\n            ro.headers = mh;\n        }\n        let { retries, retry_delay } = opts;\n        retries = retries || 1;\n        retry_delay = retry_delay || 250;\n        let r;\n        for(let i = 0; i < retries; i++){\n            try {\n                r = await this.nc.request(subj, data, ro);\n                break;\n            } catch (err) {\n                const ne = err;\n                if (ne.code === \"503\" && i + 1 < retries) {\n                    await delay(retry_delay);\n                } else {\n                    throw err;\n                }\n            }\n        }\n        const pa = this.parseJsResponse(r);\n        if (pa.stream === \"\") {\n            throw NatsError.errorForCode(ErrorCode.JetStreamInvalidAck);\n        }\n        pa.duplicate = pa.duplicate ? pa.duplicate : false;\n        return pa;\n    }\n    async pull(stream, durable, expires = 0) {\n        validateStreamName(stream);\n        validateDurableName(durable);\n        let timeout = this.timeout;\n        if (expires > timeout) {\n            timeout = expires;\n        }\n        expires = expires < 0 ? 0 : nanos(expires);\n        const pullOpts = {\n            batch: 1,\n            no_wait: expires === 0,\n            expires\n        };\n        const msg = await this.nc.request(`${this.prefix}.CONSUMER.MSG.NEXT.${stream}.${durable}`, this.jc.encode(pullOpts), {\n            noMux: true,\n            timeout\n        });\n        const err = checkJsError(msg);\n        if (err) {\n            throw err;\n        }\n        return toJsMsg(msg, this.timeout);\n    }\n    fetch(stream, durable, opts = {}) {\n        validateStreamName(stream);\n        validateDurableName(durable);\n        let timer = null;\n        const trackBytes = (opts.max_bytes ?? 0) > 0;\n        let receivedBytes = 0;\n        const max_bytes = trackBytes ? opts.max_bytes : 0;\n        let monitor = null;\n        const args = {};\n        args.batch = opts.batch || 1;\n        if (max_bytes) {\n            const fv = this.nc.features.get(Feature.JS_PULL_MAX_BYTES);\n            if (!fv.ok) {\n                throw new Error(`max_bytes is only supported on servers ${fv.min} or better`);\n            }\n            args.max_bytes = max_bytes;\n        }\n        args.no_wait = opts.no_wait || false;\n        if (args.no_wait && args.expires) {\n            args.expires = 0;\n        }\n        const expires = opts.expires || 0;\n        if (expires) {\n            args.expires = nanos(expires);\n        }\n        if (expires === 0 && args.no_wait === false) {\n            throw new Error(\"expires or no_wait is required\");\n        }\n        const hb = opts.idle_heartbeat || 0;\n        if (hb) {\n            args.idle_heartbeat = nanos(hb);\n            if (opts.delay_heartbeat === true) {\n                args.idle_heartbeat = nanos(hb * 4);\n            }\n        }\n        const qi = new QueuedIteratorImpl();\n        const wants = args.batch;\n        let received = 0;\n        qi.protocolFilterFn = (jm, _ingest = false)=>{\n            const jsmi = jm;\n            if (isHeartbeatMsg(jsmi.msg)) {\n                monitor?.work();\n                return false;\n            }\n            return true;\n        };\n        qi.dispatchedFn = (m)=>{\n            if (m) {\n                if (trackBytes) {\n                    receivedBytes += m.data.length;\n                }\n                received++;\n                if (timer && m.info.pending === 0) {\n                    return;\n                }\n                if (qi.getPending() === 1 && m.info.pending === 0 || wants === received || max_bytes > 0 && receivedBytes >= max_bytes) {\n                    qi.stop();\n                }\n            }\n        };\n        const inbox = createInbox(this.nc.options.inboxPrefix);\n        const sub = this.nc.subscribe(inbox, {\n            max: opts.batch,\n            callback: (err, msg)=>{\n                if (err === null) {\n                    err = checkJsError(msg);\n                }\n                if (err !== null) {\n                    if (timer) {\n                        timer.cancel();\n                        timer = null;\n                    }\n                    if (isNatsError(err)) {\n                        qi.stop(hideNonTerminalJsErrors(err) === null ? undefined : err);\n                    } else {\n                        qi.stop(err);\n                    }\n                } else {\n                    monitor?.work();\n                    qi.received++;\n                    qi.push(toJsMsg(msg, this.timeout));\n                }\n            }\n        });\n        if (expires) {\n            timer = timeout(expires);\n            timer.catch(()=>{\n                if (!sub.isClosed()) {\n                    sub.drain().catch(()=>{});\n                    timer = null;\n                }\n                if (monitor) {\n                    monitor.cancel();\n                }\n            });\n        }\n        (async ()=>{\n            try {\n                if (hb) {\n                    monitor = new IdleHeartbeatMonitor(hb, (v)=>{\n                        qi.push(()=>{\n                            qi.err = new NatsError(`${Js409Errors.IdleHeartbeatMissed}: ${v}`, ErrorCode.JetStreamIdleHeartBeat);\n                        });\n                        return true;\n                    });\n                }\n            } catch (_err) {}\n            await sub.closed;\n            if (timer !== null) {\n                timer.cancel();\n                timer = null;\n            }\n            if (monitor) {\n                monitor.cancel();\n            }\n            qi.stop();\n        })().catch();\n        this.nc.publish(`${this.prefix}.CONSUMER.MSG.NEXT.${stream}.${durable}`, this.jc.encode(args), {\n            reply: inbox\n        });\n        return qi;\n    }\n    async pullSubscribe(subject, opts = consumerOpts()) {\n        const cso = await this._processOptions(subject, opts);\n        if (cso.ordered) {\n            throw new Error(\"pull subscribers cannot be be ordered\");\n        }\n        if (cso.config.deliver_subject) {\n            throw new Error(\"consumer info specifies deliver_subject - pull consumers cannot have deliver_subject set\");\n        }\n        const ackPolicy = cso.config.ack_policy;\n        if (ackPolicy === AckPolicy.None || ackPolicy === AckPolicy.All) {\n            throw new Error(\"ack policy for pull consumers must be explicit\");\n        }\n        const so = this._buildTypedSubscriptionOpts(cso);\n        const sub = new JetStreamPullSubscriptionImpl(this, cso.deliver, so);\n        sub.info = cso;\n        try {\n            await this._maybeCreateConsumer(cso);\n        } catch (err) {\n            sub.unsubscribe();\n            throw err;\n        }\n        return sub;\n    }\n    async subscribe(subject, opts = consumerOpts()) {\n        const cso = await this._processOptions(subject, opts);\n        if (!cso.isBind && !cso.config.deliver_subject) {\n            throw new Error(\"push consumer requires deliver_subject\");\n        }\n        const so = this._buildTypedSubscriptionOpts(cso);\n        const sub = new JetStreamSubscriptionImpl(this, cso.deliver, so);\n        sub.info = cso;\n        try {\n            await this._maybeCreateConsumer(cso);\n        } catch (err) {\n            sub.unsubscribe();\n            throw err;\n        }\n        sub._maybeSetupHbMonitoring();\n        return sub;\n    }\n    async _processOptions(subject, opts = consumerOpts()) {\n        const jsi = isConsumerOptsBuilder(opts) ? opts.getOpts() : opts;\n        jsi.isBind = isConsumerOptsBuilder(opts) ? opts.isBind : false;\n        jsi.flow_control = {\n            heartbeat_count: 0,\n            fc_count: 0,\n            consumer_restarts: 0\n        };\n        if (jsi.ordered) {\n            jsi.ordered_consumer_sequence = {\n                stream_seq: 0,\n                delivery_seq: 0\n            };\n            if (jsi.config.ack_policy !== AckPolicy.NotSet && jsi.config.ack_policy !== AckPolicy.None) {\n                throw new NatsError(\"ordered consumer: ack_policy can only be set to 'none'\", ErrorCode.ApiError);\n            }\n            if (jsi.config.durable_name && jsi.config.durable_name.length > 0) {\n                throw new NatsError(\"ordered consumer: durable_name cannot be set\", ErrorCode.ApiError);\n            }\n            if (jsi.config.deliver_subject && jsi.config.deliver_subject.length > 0) {\n                throw new NatsError(\"ordered consumer: deliver_subject cannot be set\", ErrorCode.ApiError);\n            }\n            if (jsi.config.max_deliver !== undefined && jsi.config.max_deliver > 1) {\n                throw new NatsError(\"ordered consumer: max_deliver cannot be set\", ErrorCode.ApiError);\n            }\n            if (jsi.config.deliver_group && jsi.config.deliver_group.length > 0) {\n                throw new NatsError(\"ordered consumer: deliver_group cannot be set\", ErrorCode.ApiError);\n            }\n            jsi.config.deliver_subject = createInbox(this.nc.options.inboxPrefix);\n            jsi.config.ack_policy = AckPolicy.None;\n            jsi.config.max_deliver = 1;\n            jsi.config.flow_control = true;\n            jsi.config.idle_heartbeat = jsi.config.idle_heartbeat || nanos(5000);\n            jsi.config.ack_wait = nanos(22 * 60 * 60 * 1000);\n            jsi.config.mem_storage = true;\n            jsi.config.num_replicas = 1;\n        }\n        if (jsi.config.ack_policy === AckPolicy.NotSet) {\n            jsi.config.ack_policy = AckPolicy.All;\n        }\n        jsi.api = this;\n        jsi.config = jsi.config || {};\n        jsi.stream = jsi.stream ? jsi.stream : await this.findStream(subject);\n        jsi.attached = false;\n        if (jsi.config.durable_name) {\n            try {\n                const info = await this.consumerAPI.info(jsi.stream, jsi.config.durable_name);\n                if (info) {\n                    if (info.config.filter_subject && info.config.filter_subject !== subject) {\n                        throw new Error(\"subject does not match consumer\");\n                    }\n                    const qn = jsi.config.deliver_group ?? \"\";\n                    if (qn === \"\" && info.push_bound === true) {\n                        throw new Error(`duplicate subscription`);\n                    }\n                    const rqn = info.config.deliver_group ?? \"\";\n                    if (qn !== rqn) {\n                        if (rqn === \"\") {\n                            throw new Error(`durable requires no queue group`);\n                        } else {\n                            throw new Error(`durable requires queue group '${rqn}'`);\n                        }\n                    }\n                    jsi.last = info;\n                    jsi.config = info.config;\n                    jsi.attached = true;\n                    if (!jsi.config.durable_name) {\n                        jsi.name = info.name;\n                    }\n                }\n            } catch (err) {\n                if (err.code !== \"404\") {\n                    throw err;\n                }\n            }\n        }\n        if (!jsi.attached && jsi.config.filter_subject === undefined && jsi.config.filter_subjects === undefined) {\n            jsi.config.filter_subject = subject;\n        }\n        jsi.deliver = jsi.config.deliver_subject || createInbox(this.nc.options.inboxPrefix);\n        return jsi;\n    }\n    _buildTypedSubscriptionOpts(jsi) {\n        const so = {};\n        so.adapter = msgAdapter(jsi.callbackFn === undefined, this.timeout);\n        so.ingestionFilterFn = JetStreamClientImpl.ingestionFn(jsi.ordered);\n        so.protocolFilterFn = (jm, ingest = false)=>{\n            const jsmi = jm;\n            if (isFlowControlMsg(jsmi.msg)) {\n                if (!ingest) {\n                    jsmi.msg.respond();\n                }\n                return false;\n            }\n            return true;\n        };\n        if (!jsi.mack && jsi.config.ack_policy !== AckPolicy.None) {\n            so.dispatchedFn = autoAckJsMsg;\n        }\n        if (jsi.callbackFn) {\n            so.callback = jsi.callbackFn;\n        }\n        so.max = jsi.max || 0;\n        so.queue = jsi.queue;\n        return so;\n    }\n    async _maybeCreateConsumer(jsi) {\n        if (jsi.attached) {\n            return;\n        }\n        if (jsi.isBind) {\n            throw new Error(`unable to bind - durable consumer ${jsi.config.durable_name} doesn't exist in ${jsi.stream}`);\n        }\n        jsi.config = Object.assign({\n            deliver_policy: DeliverPolicy.All,\n            ack_policy: AckPolicy.Explicit,\n            ack_wait: nanos(30 * 1000),\n            replay_policy: ReplayPolicy.Instant\n        }, jsi.config);\n        const ci = await this.consumerAPI.add(jsi.stream, jsi.config);\n        if (Array.isArray(jsi.config.filter_subjects && !Array.isArray(ci.config.filter_subjects))) {\n            throw new Error(`jetstream server doesn't support consumers with multiple filter subjects`);\n        }\n        jsi.name = ci.name;\n        jsi.config = ci.config;\n        jsi.last = ci;\n    }\n    static ingestionFn(ordered) {\n        return (jm, ctx)=>{\n            const jsub = ctx;\n            if (!jm) return {\n                ingest: false,\n                protocol: false\n            };\n            const jmi = jm;\n            if (!checkJsError(jmi.msg)) {\n                jsub.monitor?.work();\n            }\n            if (isHeartbeatMsg(jmi.msg)) {\n                const ingest = ordered ? jsub._checkHbOrderConsumer(jmi.msg) : true;\n                if (!ordered) {\n                    jsub.info.flow_control.heartbeat_count++;\n                }\n                return {\n                    ingest,\n                    protocol: true\n                };\n            } else if (isFlowControlMsg(jmi.msg)) {\n                jsub.info.flow_control.fc_count++;\n                return {\n                    ingest: true,\n                    protocol: true\n                };\n            }\n            const ingest = ordered ? jsub._checkOrderedConsumer(jm) : true;\n            return {\n                ingest,\n                protocol: false\n            };\n        };\n    }\n}\nclass NatsConnectionImpl {\n    options;\n    protocol;\n    draining;\n    listeners;\n    _services;\n    constructor(opts){\n        this.draining = false;\n        this.options = parseOptions(opts);\n        this.listeners = [];\n    }\n    static connect(opts = {}) {\n        return new Promise((resolve, reject)=>{\n            const nc = new NatsConnectionImpl(opts);\n            ProtocolHandler.connect(nc.options, nc).then((ph)=>{\n                nc.protocol = ph;\n                (async function() {\n                    for await (const s of ph.status()){\n                        nc.listeners.forEach((l)=>{\n                            l.push(s);\n                        });\n                    }\n                })();\n                resolve(nc);\n            }).catch((err)=>{\n                reject(err);\n            });\n        });\n    }\n    closed() {\n        return this.protocol.closed;\n    }\n    async close() {\n        await this.protocol.close();\n    }\n    _check(subject, sub, pub) {\n        if (this.isClosed()) {\n            throw NatsError.errorForCode(ErrorCode.ConnectionClosed);\n        }\n        if (sub && this.isDraining()) {\n            throw NatsError.errorForCode(ErrorCode.ConnectionDraining);\n        }\n        if (pub && this.protocol.noMorePublishing) {\n            throw NatsError.errorForCode(ErrorCode.ConnectionDraining);\n        }\n        subject = subject || \"\";\n        if (subject.length === 0) {\n            throw NatsError.errorForCode(ErrorCode.BadSubject);\n        }\n    }\n    publish(subject, data, options) {\n        this._check(subject, false, true);\n        this.protocol.publish(subject, data, options);\n    }\n    publishMessage(msg) {\n        return this.publish(msg.subject, msg.data, {\n            reply: msg.reply,\n            headers: msg.headers\n        });\n    }\n    respondMessage(msg) {\n        if (msg.reply) {\n            this.publish(msg.reply, msg.data, {\n                reply: msg.reply,\n                headers: msg.headers\n            });\n            return true;\n        }\n        return false;\n    }\n    subscribe(subject, opts = {}) {\n        this._check(subject, true, false);\n        const sub = new SubscriptionImpl(this.protocol, subject, opts);\n        this.protocol.subscribe(sub);\n        return sub;\n    }\n    _resub(s, subject, max) {\n        this._check(subject, true, false);\n        const si = s;\n        si.max = max;\n        if (max) {\n            si.max = max + si.received;\n        }\n        this.protocol.resub(si, subject);\n    }\n    requestMany(subject, data = Empty, opts = {\n        maxWait: 1000,\n        maxMessages: -1\n    }) {\n        const asyncTraces = !(this.protocol.options.noAsyncTraces || false);\n        try {\n            this._check(subject, true, true);\n        } catch (err) {\n            return Promise.reject(err);\n        }\n        opts.strategy = opts.strategy || RequestStrategy.Timer;\n        opts.maxWait = opts.maxWait || 1000;\n        if (opts.maxWait < 1) {\n            return Promise.reject(new NatsError(\"timeout\", ErrorCode.InvalidOption));\n        }\n        const qi = new QueuedIteratorImpl();\n        function stop(err) {\n            qi.push(()=>{\n                qi.stop(err);\n            });\n        }\n        function callback(err, msg) {\n            if (err || msg === null) {\n                stop(err === null ? undefined : err);\n            } else {\n                qi.push(msg);\n            }\n        }\n        if (opts.noMux) {\n            const stack = asyncTraces ? new Error().stack : null;\n            let max = typeof opts.maxMessages === \"number\" && opts.maxMessages > 0 ? opts.maxMessages : -1;\n            const sub = this.subscribe(createInbox(this.options.inboxPrefix), {\n                callback: (err, msg)=>{\n                    if (msg?.data?.length === 0 && msg?.headers?.status === ErrorCode.NoResponders) {\n                        err = NatsError.errorForCode(ErrorCode.NoResponders);\n                    }\n                    if (err) {\n                        if (stack) {\n                            err.stack += `\\n\\n${stack}`;\n                        }\n                        cancel(err);\n                        return;\n                    }\n                    callback(null, msg);\n                    if (opts.strategy === RequestStrategy.Count) {\n                        max--;\n                        if (max === 0) {\n                            cancel();\n                        }\n                    }\n                    if (opts.strategy === RequestStrategy.JitterTimer) {\n                        clearTimers();\n                        timer = setTimeout(()=>{\n                            cancel();\n                        }, 300);\n                    }\n                    if (opts.strategy === RequestStrategy.SentinelMsg) {\n                        if (msg && msg.data.length === 0) {\n                            cancel();\n                        }\n                    }\n                }\n            });\n            sub.requestSubject = subject;\n            sub.closed.then(()=>{\n                stop();\n            }).catch((err)=>{\n                qi.stop(err);\n            });\n            const cancel = (err)=>{\n                if (err) {\n                    qi.push(()=>{\n                        throw err;\n                    });\n                }\n                clearTimers();\n                sub.drain().then(()=>{\n                    stop();\n                }).catch((_err)=>{\n                    stop();\n                });\n            };\n            qi.iterClosed.then(()=>{\n                clearTimers();\n                sub?.unsubscribe();\n            }).catch((_err)=>{\n                clearTimers();\n                sub?.unsubscribe();\n            });\n            try {\n                this.publish(subject, data, {\n                    reply: sub.getSubject()\n                });\n            } catch (err) {\n                cancel(err);\n            }\n            let timer = setTimeout(()=>{\n                cancel();\n            }, opts.maxWait);\n            const clearTimers = ()=>{\n                if (timer) {\n                    clearTimeout(timer);\n                }\n            };\n        } else {\n            const rmo = opts;\n            rmo.callback = callback;\n            qi.iterClosed.then(()=>{\n                r.cancel();\n            }).catch((err)=>{\n                r.cancel(err);\n            });\n            const r = new RequestMany(this.protocol.muxSubscriptions, subject, rmo);\n            this.protocol.request(r);\n            try {\n                this.publish(subject, data, {\n                    reply: `${this.protocol.muxSubscriptions.baseInbox}${r.token}`,\n                    headers: opts.headers\n                });\n            } catch (err) {\n                r.cancel(err);\n            }\n        }\n        return Promise.resolve(qi);\n    }\n    request(subject, data, opts = {\n        timeout: 1000,\n        noMux: false\n    }) {\n        try {\n            this._check(subject, true, true);\n        } catch (err) {\n            return Promise.reject(err);\n        }\n        const asyncTraces = !(this.protocol.options.noAsyncTraces || false);\n        opts.timeout = opts.timeout || 1000;\n        if (opts.timeout < 1) {\n            return Promise.reject(new NatsError(\"timeout\", ErrorCode.InvalidOption));\n        }\n        if (!opts.noMux && opts.reply) {\n            return Promise.reject(new NatsError(\"reply can only be used with noMux\", ErrorCode.InvalidOption));\n        }\n        if (opts.noMux) {\n            const inbox = opts.reply ? opts.reply : createInbox(this.options.inboxPrefix);\n            const d = deferred();\n            const errCtx = asyncTraces ? new Error() : null;\n            const sub = this.subscribe(inbox, {\n                max: 1,\n                timeout: opts.timeout,\n                callback: (err, msg)=>{\n                    if (err) {\n                        if (errCtx && err.code !== ErrorCode.Timeout) {\n                            err.stack += `\\n\\n${errCtx.stack}`;\n                        }\n                        sub.unsubscribe();\n                        d.reject(err);\n                    } else {\n                        err = isRequestError(msg);\n                        if (err) {\n                            if (errCtx) {\n                                err.stack += `\\n\\n${errCtx.stack}`;\n                            }\n                            d.reject(err);\n                        } else {\n                            d.resolve(msg);\n                        }\n                    }\n                }\n            });\n            sub.requestSubject = subject;\n            this.protocol.publish(subject, data, {\n                reply: inbox,\n                headers: opts.headers\n            });\n            return d;\n        } else {\n            const r = new RequestOne(this.protocol.muxSubscriptions, subject, opts, asyncTraces);\n            this.protocol.request(r);\n            try {\n                this.publish(subject, data, {\n                    reply: `${this.protocol.muxSubscriptions.baseInbox}${r.token}`,\n                    headers: opts.headers\n                });\n            } catch (err) {\n                r.cancel(err);\n            }\n            const p = Promise.race([\n                r.timer,\n                r.deferred\n            ]);\n            p.catch(()=>{\n                r.cancel();\n            });\n            return p;\n        }\n    }\n    flush() {\n        if (this.isClosed()) {\n            return Promise.reject(NatsError.errorForCode(ErrorCode.ConnectionClosed));\n        }\n        return this.protocol.flush();\n    }\n    drain() {\n        if (this.isClosed()) {\n            return Promise.reject(NatsError.errorForCode(ErrorCode.ConnectionClosed));\n        }\n        if (this.isDraining()) {\n            return Promise.reject(NatsError.errorForCode(ErrorCode.ConnectionDraining));\n        }\n        this.draining = true;\n        return this.protocol.drain();\n    }\n    isClosed() {\n        return this.protocol.isClosed();\n    }\n    isDraining() {\n        return this.draining;\n    }\n    getServer() {\n        const srv = this.protocol.getServer();\n        return srv ? srv.listen : \"\";\n    }\n    status() {\n        const iter = new QueuedIteratorImpl();\n        iter.iterClosed.then(()=>{\n            const idx = this.listeners.indexOf(iter);\n            this.listeners.splice(idx, 1);\n        });\n        this.listeners.push(iter);\n        return iter;\n    }\n    get info() {\n        return this.protocol.isClosed() ? undefined : this.protocol.info;\n    }\n    async context() {\n        const r = await this.request(`$SYS.REQ.USER.INFO`);\n        return r.json((key, value)=>{\n            if (key === \"time\") {\n                return new Date(Date.parse(value));\n            }\n            return value;\n        });\n    }\n    stats() {\n        return {\n            inBytes: this.protocol.inBytes,\n            outBytes: this.protocol.outBytes,\n            inMsgs: this.protocol.inMsgs,\n            outMsgs: this.protocol.outMsgs\n        };\n    }\n    async jetstreamManager(opts = {}) {\n        const adm = new JetStreamManagerImpl(this, opts);\n        if (opts.checkAPI !== false) {\n            try {\n                await adm.getAccountInfo();\n            } catch (err) {\n                const ne = err;\n                if (ne.code === ErrorCode.NoResponders) {\n                    ne.code = ErrorCode.JetStreamNotEnabled;\n                }\n                throw ne;\n            }\n        }\n        return adm;\n    }\n    jetstream(opts = {}) {\n        return new JetStreamClientImpl(this, opts);\n    }\n    getServerVersion() {\n        const info = this.info;\n        return info ? parseSemVer(info.version) : undefined;\n    }\n    async rtt() {\n        if (!this.protocol._closed && !this.protocol.connected) {\n            throw NatsError.errorForCode(ErrorCode.Disconnect);\n        }\n        const start = Date.now();\n        await this.flush();\n        return Date.now() - start;\n    }\n    get features() {\n        return this.protocol.features;\n    }\n    get services() {\n        if (!this._services) {\n            this._services = new ServicesFactory(this);\n        }\n        return this._services;\n    }\n    reconnect() {\n        if (this.isClosed()) {\n            return Promise.reject(NatsError.errorForCode(ErrorCode.ConnectionClosed));\n        }\n        if (this.isDraining()) {\n            return Promise.reject(NatsError.errorForCode(ErrorCode.ConnectionDraining));\n        }\n        return this.protocol.reconnect();\n    }\n}\nclass ServicesFactory {\n    nc;\n    constructor(nc){\n        this.nc = nc;\n    }\n    add(config) {\n        try {\n            const s = new ServiceImpl(this.nc, config);\n            return s.start();\n        } catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    client(opts, prefix) {\n        return new ServiceClientImpl(this.nc, opts, prefix);\n    }\n}\nclass KvStoredEntryImpl {\n    bucket;\n    sm;\n    prefixLen;\n    constructor(bucket, prefixLen, sm){\n        this.bucket = bucket;\n        this.prefixLen = prefixLen;\n        this.sm = sm;\n    }\n    get key() {\n        return this.sm.subject.substring(this.prefixLen);\n    }\n    get value() {\n        return this.sm.data;\n    }\n    get delta() {\n        return 0;\n    }\n    get created() {\n        return this.sm.time;\n    }\n    get revision() {\n        return this.sm.seq;\n    }\n    get operation() {\n        return this.sm.header.get(kvOperationHdr) || \"PUT\";\n    }\n    get length() {\n        const slen = this.sm.header.get(JsHeaders.MessageSizeHdr) || \"\";\n        if (slen !== \"\") {\n            return parseInt(slen, 10);\n        }\n        return this.sm.data.length;\n    }\n    json() {\n        return this.sm.json();\n    }\n    string() {\n        return this.sm.string();\n    }\n}\nclass KvJsMsgEntryImpl {\n    bucket;\n    key;\n    sm;\n    constructor(bucket, key, sm){\n        this.bucket = bucket;\n        this.key = key;\n        this.sm = sm;\n    }\n    get value() {\n        return this.sm.data;\n    }\n    get created() {\n        return new Date(millis(this.sm.info.timestampNanos));\n    }\n    get revision() {\n        return this.sm.seq;\n    }\n    get operation() {\n        return this.sm.headers?.get(kvOperationHdr) || \"PUT\";\n    }\n    get delta() {\n        return this.sm.info.pending;\n    }\n    get length() {\n        const slen = this.sm.headers?.get(JsHeaders.MessageSizeHdr) || \"\";\n        if (slen !== \"\") {\n            return parseInt(slen, 10);\n        }\n        return this.sm.data.length;\n    }\n    json() {\n        return this.sm.json();\n    }\n    string() {\n        return this.sm.string();\n    }\n}\nclass JetStreamSubscriptionImpl extends TypedSubscription {\n    js;\n    monitor;\n    constructor(js, subject, opts){\n        super(js.nc, subject, opts);\n        this.js = js;\n        this.monitor = null;\n        this.sub.closed.then(()=>{\n            if (this.monitor) {\n                this.monitor.cancel();\n            }\n        });\n    }\n    set info(info) {\n        this.sub.info = info;\n    }\n    get info() {\n        return this.sub.info;\n    }\n    _resetOrderedConsumer(sseq) {\n        if (this.info === null || this.sub.isClosed()) {\n            return;\n        }\n        const newDeliver = createInbox(this.js.nc.options.inboxPrefix);\n        const nci = this.js.nc;\n        nci._resub(this.sub, newDeliver);\n        const info = this.info;\n        info.config.name = nuid.next();\n        info.ordered_consumer_sequence.delivery_seq = 0;\n        info.flow_control.heartbeat_count = 0;\n        info.flow_control.fc_count = 0;\n        info.flow_control.consumer_restarts++;\n        info.deliver = newDeliver;\n        info.config.deliver_subject = newDeliver;\n        info.config.deliver_policy = DeliverPolicy.StartSequence;\n        info.config.opt_start_seq = sseq;\n        const req = {};\n        req.stream_name = this.info.stream;\n        req.config = info.config;\n        const subj = `${info.api.prefix}.CONSUMER.CREATE.${info.stream}`;\n        this.js._request(subj, req, {\n            retries: -1\n        }).then((v)=>{\n            const ci = v;\n            const jinfo = this.sub.info;\n            jinfo.last = ci;\n            this.info.config = ci.config;\n            this.info.name = ci.name;\n        }).catch((err)=>{\n            const nerr = new NatsError(`unable to recreate ordered consumer ${info.stream} at seq ${sseq}`, ErrorCode.RequestError, err);\n            this.sub.callback(nerr, {});\n        });\n    }\n    _maybeSetupHbMonitoring() {\n        const ns = this.info?.config?.idle_heartbeat || 0;\n        if (ns) {\n            this._setupHbMonitoring(millis(ns));\n        }\n    }\n    _setupHbMonitoring(millis, cancelAfter = 0) {\n        const opts = {\n            cancelAfter: 0,\n            maxOut: 2\n        };\n        if (cancelAfter) {\n            opts.cancelAfter = cancelAfter;\n        }\n        const sub = this.sub;\n        const handler = (v)=>{\n            const msg = newJsErrorMsg(409, `${Js409Errors.IdleHeartbeatMissed}: ${v}`, this.sub.subject);\n            const ordered = this.info?.ordered;\n            if (!ordered) {\n                this.sub.callback(null, msg);\n            } else {\n                if (!this.js.nc.protocol.connected) {\n                    return false;\n                }\n                const seq = this.info?.ordered_consumer_sequence?.stream_seq || 0;\n                this._resetOrderedConsumer(seq + 1);\n                this.monitor?.restart();\n                return false;\n            }\n            return !sub.noIterator;\n        };\n        this.monitor = new IdleHeartbeatMonitor(millis, handler, opts);\n    }\n    _checkHbOrderConsumer(msg) {\n        const rm = msg.headers.get(JsHeaders.ConsumerStalledHdr);\n        if (rm !== \"\") {\n            const nci = this.js.nc;\n            nci.publish(rm);\n        }\n        const lastDelivered = parseInt(msg.headers.get(JsHeaders.LastConsumerSeqHdr), 10);\n        const ordered = this.info.ordered_consumer_sequence;\n        this.info.flow_control.heartbeat_count++;\n        if (lastDelivered !== ordered.delivery_seq) {\n            this._resetOrderedConsumer(ordered.stream_seq + 1);\n        }\n        return false;\n    }\n    _checkOrderedConsumer(jm) {\n        const ordered = this.info.ordered_consumer_sequence;\n        const sseq = jm.info.streamSequence;\n        const dseq = jm.info.deliverySequence;\n        if (dseq != ordered.delivery_seq + 1) {\n            this._resetOrderedConsumer(ordered.stream_seq + 1);\n            return false;\n        }\n        ordered.delivery_seq = dseq;\n        ordered.stream_seq = sseq;\n        return true;\n    }\n    async destroy() {\n        if (!this.isClosed()) {\n            await this.drain();\n        }\n        const jinfo = this.sub.info;\n        const name = jinfo.config.durable_name || jinfo.name;\n        const subj = `${jinfo.api.prefix}.CONSUMER.DELETE.${jinfo.stream}.${name}`;\n        await jinfo.api._request(subj);\n    }\n    async consumerInfo() {\n        const jinfo = this.sub.info;\n        const name = jinfo.config.durable_name || jinfo.name;\n        const subj = `${jinfo.api.prefix}.CONSUMER.INFO.${jinfo.stream}.${name}`;\n        const ci = await jinfo.api._request(subj);\n        jinfo.last = ci;\n        return ci;\n    }\n}\nclass JetStreamPullSubscriptionImpl extends JetStreamSubscriptionImpl {\n    constructor(js, subject, opts){\n        super(js, subject, opts);\n    }\n    pull(opts = {\n        batch: 1\n    }) {\n        const { stream, config, name } = this.sub.info;\n        const consumer = config.durable_name ?? name;\n        const args = {};\n        args.batch = opts.batch || 1;\n        args.no_wait = opts.no_wait || false;\n        if ((opts.max_bytes ?? 0) > 0) {\n            const fv = this.js.nc.features.get(Feature.JS_PULL_MAX_BYTES);\n            if (!fv.ok) {\n                throw new Error(`max_bytes is only supported on servers ${fv.min} or better`);\n            }\n            args.max_bytes = opts.max_bytes;\n        }\n        let expires = 0;\n        if (opts.expires && opts.expires > 0) {\n            expires = opts.expires;\n            args.expires = nanos(expires);\n        }\n        let hb = 0;\n        if (opts.idle_heartbeat && opts.idle_heartbeat > 0) {\n            hb = opts.idle_heartbeat;\n            args.idle_heartbeat = nanos(hb);\n        }\n        if (hb && expires === 0) {\n            throw new Error(\"idle_heartbeat requires expires\");\n        }\n        if (hb > expires) {\n            throw new Error(\"expires must be greater than idle_heartbeat\");\n        }\n        if (this.info) {\n            if (this.monitor) {\n                this.monitor.cancel();\n            }\n            if (expires && hb) {\n                if (!this.monitor) {\n                    this._setupHbMonitoring(hb, expires);\n                } else {\n                    this.monitor._change(hb, expires);\n                }\n            }\n            const api = this.info.api;\n            const subj = `${api.prefix}.CONSUMER.MSG.NEXT.${stream}.${consumer}`;\n            const reply = this.sub.subject;\n            api.nc.publish(subj, api.jc.encode(args), {\n                reply: reply\n            });\n        }\n    }\n}\nfunction msgAdapter(iterator, ackTimeout) {\n    if (iterator) {\n        return iterMsgAdapter(ackTimeout);\n    } else {\n        return cbMsgAdapter(ackTimeout);\n    }\n}\nfunction cbMsgAdapter(ackTimeout) {\n    return (err, msg)=>{\n        if (err) {\n            return [\n                err,\n                null\n            ];\n        }\n        err = checkJsError(msg);\n        if (err) {\n            return [\n                err,\n                null\n            ];\n        }\n        return [\n            null,\n            toJsMsg(msg, ackTimeout)\n        ];\n    };\n}\nfunction iterMsgAdapter(ackTimeout) {\n    return (err, msg)=>{\n        if (err) {\n            return [\n                err,\n                null\n            ];\n        }\n        const ne = checkJsError(msg);\n        if (ne !== null) {\n            return [\n                hideNonTerminalJsErrors(ne),\n                null\n            ];\n        }\n        return [\n            null,\n            toJsMsg(msg, ackTimeout)\n        ];\n    };\n}\nfunction hideNonTerminalJsErrors(ne) {\n    if (ne !== null) {\n        switch(ne.code){\n            case ErrorCode.JetStream404NoMessages:\n            case ErrorCode.JetStream408RequestTimeout:\n                return null;\n            case ErrorCode.JetStream409:\n                if (isTerminal409(ne)) {\n                    return ne;\n                }\n                return null;\n            default:\n                return ne;\n        }\n    }\n    return null;\n}\nfunction autoAckJsMsg(data) {\n    if (data) {\n        data.ack();\n    }\n}\nfunction parseInfo(s) {\n    const tokens = s.split(\".\");\n    if (tokens.length === 9) {\n        tokens.splice(2, 0, \"_\", \"\");\n    }\n    if (tokens.length < 11 || tokens[0] !== \"$JS\" || tokens[1] !== \"ACK\") {\n        throw new Error(`not js message`);\n    }\n    const di = {};\n    di.domain = tokens[2] === \"_\" ? \"\" : tokens[2];\n    di.account_hash = tokens[3];\n    di.stream = tokens[4];\n    di.consumer = tokens[5];\n    di.deliveryCount = parseInt(tokens[6], 10);\n    di.redeliveryCount = di.deliveryCount;\n    di.redelivered = di.deliveryCount > 1;\n    di.streamSequence = parseInt(tokens[7], 10);\n    di.deliverySequence = parseInt(tokens[8], 10);\n    di.timestampNanos = parseInt(tokens[9], 10);\n    di.pending = parseInt(tokens[10], 10);\n    return di;\n}\nclass JsMsgImpl {\n    msg;\n    di;\n    didAck;\n    timeout;\n    constructor(msg, timeout){\n        this.msg = msg;\n        this.didAck = false;\n        this.timeout = timeout;\n    }\n    get subject() {\n        return this.msg.subject;\n    }\n    get sid() {\n        return this.msg.sid;\n    }\n    get data() {\n        return this.msg.data;\n    }\n    get headers() {\n        return this.msg.headers;\n    }\n    get info() {\n        if (!this.di) {\n            this.di = parseInfo(this.reply);\n        }\n        return this.di;\n    }\n    get redelivered() {\n        return this.info.deliveryCount > 1;\n    }\n    get reply() {\n        return this.msg.reply || \"\";\n    }\n    get seq() {\n        return this.info.streamSequence;\n    }\n    doAck(payload) {\n        if (!this.didAck) {\n            this.didAck = !this.isWIP(payload);\n            this.msg.respond(payload);\n        }\n    }\n    isWIP(p) {\n        return p.length === 4 && p[0] === WPI[0] && p[1] === WPI[1] && p[2] === WPI[2] && p[3] === WPI[3];\n    }\n    async ackAck(opts) {\n        opts = opts || {};\n        opts.timeout = opts.timeout || this.timeout;\n        const d = deferred();\n        if (!this.didAck) {\n            this.didAck = true;\n            if (this.msg.reply) {\n                const mi = this.msg;\n                const proto = mi.publisher;\n                const trace = !(proto.options?.noAsyncTraces || false);\n                const r = new RequestOne(proto.muxSubscriptions, this.msg.reply, {\n                    timeout: opts.timeout\n                }, trace);\n                proto.request(r);\n                try {\n                    proto.publish(this.msg.reply, ACK, {\n                        reply: `${proto.muxSubscriptions.baseInbox}${r.token}`\n                    });\n                } catch (err) {\n                    r.cancel(err);\n                }\n                try {\n                    await Promise.race([\n                        r.timer,\n                        r.deferred\n                    ]);\n                    d.resolve(true);\n                } catch (err) {\n                    r.cancel(err);\n                    d.reject(err);\n                }\n            } else {\n                d.resolve(false);\n            }\n        } else {\n            d.resolve(false);\n        }\n        return d;\n    }\n    ack() {\n        this.doAck(ACK);\n    }\n    nak(millis) {\n        let payload = NAK;\n        if (millis) {\n            payload = StringCodec().encode(`-NAK ${JSON.stringify({\n                delay: nanos(millis)\n            })}`);\n        }\n        this.doAck(payload);\n    }\n    working() {\n        this.doAck(WPI);\n    }\n    next(subj, opts = {\n        batch: 1\n    }) {\n        const args = {};\n        args.batch = opts.batch || 1;\n        args.no_wait = opts.no_wait || false;\n        if (opts.expires && opts.expires > 0) {\n            args.expires = nanos(opts.expires);\n        }\n        const data = JSONCodec().encode(args);\n        const payload = DataBuffer.concat(NXT, SPACE, data);\n        const reqOpts = subj ? {\n            reply: subj\n        } : undefined;\n        this.msg.respond(payload, reqOpts);\n    }\n    term(reason = \"\") {\n        let term = TERM;\n        if (reason?.length > 0) {\n            term = StringCodec().encode(`+TERM ${reason}`);\n        }\n        this.doAck(term);\n    }\n    json() {\n        return this.msg.json();\n    }\n    string() {\n        return this.msg.string();\n    }\n}\n\n\n\nconst VERSION = \"1.30.3\";\nconst LANG = \"nats.ws\";\nclass WsTransport {\n    version;\n    lang;\n    closeError;\n    connected;\n    done;\n    socket;\n    options;\n    socketClosed;\n    encrypted;\n    peeked;\n    yields;\n    signal;\n    closedNotification;\n    constructor(){\n        this.version = VERSION;\n        this.lang = LANG;\n        this.connected = false;\n        this.done = false;\n        this.socketClosed = false;\n        this.encrypted = false;\n        this.peeked = false;\n        this.yields = [];\n        this.signal = deferred();\n        this.closedNotification = deferred();\n    }\n    async connect(server, options) {\n        const connected = false;\n        const connLock = deferred();\n        if (options.tls) {\n            connLock.reject(new NatsError(\"tls\", ErrorCode.InvalidOption));\n            return connLock;\n        }\n        this.options = options;\n        const u = server.src;\n        if (options.wsFactory) {\n            const { socket, encrypted } = await options.wsFactory(server.src, options);\n            this.socket = socket;\n            this.encrypted = encrypted;\n        } else {\n            this.encrypted = u.indexOf(\"wss://\") === 0;\n            this.socket = new WebSocket(u);\n        }\n        this.socket.binaryType = \"arraybuffer\";\n        this.socket.onopen = ()=>{\n            if (this.isDiscarded()) {\n                return;\n            }\n        };\n        this.socket.onmessage = (me)=>{\n            if (this.isDiscarded()) {\n                return;\n            }\n            this.yields.push(new Uint8Array(me.data));\n            if (this.peeked) {\n                this.signal.resolve();\n                return;\n            }\n            const t = DataBuffer.concat(...this.yields);\n            const pm = extractProtocolMessage(t);\n            if (pm !== \"\") {\n                const m = INFO.exec(pm);\n                if (!m) {\n                    if (options.debug) {\n                        console.error(\"!!!\", render(t));\n                    }\n                    connLock.reject(new Error(\"unexpected response from server\"));\n                    return;\n                }\n                try {\n                    const info = JSON.parse(m[1]);\n                    checkOptions(info, this.options);\n                    this.peeked = true;\n                    this.connected = true;\n                    this.signal.resolve();\n                    connLock.resolve();\n                } catch (err) {\n                    connLock.reject(err);\n                    return;\n                }\n            }\n        };\n        this.socket.onclose = (evt)=>{\n            if (this.isDiscarded()) {\n                return;\n            }\n            this.socketClosed = true;\n            let reason;\n            if (this.done) return;\n            if (!evt.wasClean) {\n                reason = new Error(evt.reason);\n            }\n            this._closed(reason);\n        };\n        this.socket.onerror = (e)=>{\n            if (this.isDiscarded()) {\n                return;\n            }\n            const evt = e;\n            const err = new NatsError(evt.message, ErrorCode.Unknown, new Error(evt.error));\n            if (!connected) {\n                connLock.reject(err);\n            } else {\n                this._closed(err);\n            }\n        };\n        return connLock;\n    }\n    disconnect() {\n        this._closed(undefined, true);\n    }\n    async _closed(err, internal = true) {\n        if (this.isDiscarded()) {\n            return;\n        }\n        if (!this.connected) return;\n        if (this.done) return;\n        this.closeError = err;\n        if (!err) {\n            while(!this.socketClosed && this.socket.bufferedAmount > 0){\n                await delay(100);\n            }\n        }\n        this.done = true;\n        try {\n            this.socket.close(err ? 1002 : 1000, err ? err.message : undefined);\n        } catch (err) {}\n        if (internal) {\n            this.closedNotification.resolve(err);\n        }\n    }\n    get isClosed() {\n        return this.done;\n    }\n    [Symbol.asyncIterator]() {\n        return this.iterate();\n    }\n    async *iterate() {\n        while(true){\n            if (this.isDiscarded()) {\n                return;\n            }\n            if (this.yields.length === 0) {\n                await this.signal;\n            }\n            const yields = this.yields;\n            this.yields = [];\n            for(let i = 0; i < yields.length; i++){\n                if (this.options.debug) {\n                    console.info(`> ${render(yields[i])}`);\n                }\n                yield yields[i];\n            }\n            if (this.done) {\n                break;\n            } else if (this.yields.length === 0) {\n                yields.length = 0;\n                this.yields = yields;\n                this.signal = deferred();\n            }\n        }\n    }\n    isEncrypted() {\n        return this.connected && this.encrypted;\n    }\n    send(frame) {\n        if (this.isDiscarded()) {\n            return;\n        }\n        try {\n            this.socket.send(frame.buffer);\n            if (this.options.debug) {\n                console.info(`< ${render(frame)}`);\n            }\n            return;\n        } catch (err) {\n            if (this.options.debug) {\n                console.error(`!!! ${render(frame)}: ${err}`);\n            }\n        }\n    }\n    close(err) {\n        return this._closed(err, false);\n    }\n    closed() {\n        return this.closedNotification;\n    }\n    isDiscarded() {\n        if (this.done) {\n            this.discard();\n            return true;\n        }\n        return false;\n    }\n    discard() {\n        this.done = true;\n        try {\n            this.socket?.close();\n        } catch (_err) {}\n    }\n}\nfunction wsUrlParseFn(u, encrypted) {\n    const ut = /^(.*:\\/\\/)(.*)/;\n    if (!ut.test(u)) {\n        if (typeof encrypted === \"boolean\") {\n            u = `${encrypted === true ? \"https\" : \"http\"}://${u}`;\n        } else {\n            u = `https://${u}`;\n        }\n    }\n    let url = new URL(u);\n    const srcProto = url.protocol.toLowerCase();\n    if (srcProto === \"ws:\") {\n        encrypted = false;\n    }\n    if (srcProto === \"wss:\") {\n        encrypted = true;\n    }\n    if (srcProto !== \"https:\" && srcProto !== \"http\") {\n        u = u.replace(/^(.*:\\/\\/)(.*)/gm, \"$2\");\n        url = new URL(`http://${u}`);\n    }\n    let protocol;\n    let port;\n    const host = url.hostname;\n    const path = url.pathname;\n    const search = url.search || \"\";\n    switch(srcProto){\n        case \"http:\":\n        case \"ws:\":\n        case \"nats:\":\n            port = url.port || \"80\";\n            protocol = \"ws:\";\n            break;\n        case \"https:\":\n        case \"wss:\":\n        case \"tls:\":\n            port = url.port || \"443\";\n            protocol = \"wss:\";\n            break;\n        default:\n            port = url.port || encrypted === true ? \"443\" : \"80\";\n            protocol = encrypted === true ? \"wss:\" : \"ws:\";\n            break;\n    }\n    return `${protocol}//${host}:${port}${path}${search}`;\n}\nfunction connect(opts = {}) {\n    setTransportFactory({\n        defaultPort: 443,\n        urlParseFn: wsUrlParseFn,\n        factory: ()=>{\n            return new WsTransport();\n        }\n    });\n    return NatsConnectionImpl.connect(opts);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uYXRzLndzL2VzbS9uYXRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNCQUFzQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrREFBa0Q7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsT0FBTztBQUM1RTtBQUNBLEtBQUs7QUFDTCxjQUFjLE9BQU8sR0FBRyxZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVksRUFBRSxrQkFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxRQUFRO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx1QkFBdUIsY0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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LFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHlCQUF5QjtBQUNsRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0JBQW9CO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsV0FBVztBQUMvQyxVQUFVO0FBQ1YsdUJBQXVCLE9BQU8sR0FBRyxXQUFXO0FBQzVDO0FBQ0EsNEJBQTRCLE1BQU0sSUFBSSxnQkFBZ0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsY0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQkFBc0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0JBQWdCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0IsdUJBQXVCLFFBQVE7QUFDL0IsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQyxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUMsNEdBQTRHO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0NBQXdDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtB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QUFxQixLQUFLO0FBQzFCLHNDQUFzQyxFQUFFO0FBQ3hDLHNDQUFzQyxFQUFFO0FBQ3hDLHNDQUFzQyxFQUFFO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxpQkFBaUI7QUFDakY7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUSxTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUSxTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVMsRUFBRSxPQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtE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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0csUUFBUTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQSxxRUFBcUUsSUFBSTtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBLHNFQUFzRSxJQUFJO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0EsOEVBQThFLElBQUk7QUFDbEY7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQSx3RUFBd0UsSUFBSTtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBLDRFQUE0RSxJQUFJO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBLHVDQUF1QyxTQUFTLHVDQUF1QyxJQUFJO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFlBQVksaUJBQWlCLFNBQVM7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFlBQVksaUJBQWlCLE9BQU87QUFDN0U7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxZQUFZLGlCQUFpQixLQUFLO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZLGVBQWUsS0FBSztBQUN4RDtBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWSxnQkFBZ0IsS0FBSztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxZQUFZLHFCQUFxQixPQUFPO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWSxrQkFBa0IsT0FBTztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxJQUFJLGNBQWMsT0FBTyxHQUFHLGFBQWEsT0FBTyxJQUFJLGNBQWMsT0FBTztBQUNoSDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLElBQUksY0FBYyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFdBQVc7QUFDL0Q7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFlBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsNkVBQTZFLElBQUk7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHlCQUF5QixtQkFBbUIsV0FBVztBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQixtQkFBbUIsWUFBWTtBQUN2RTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsOEVBQThFLGFBQWEsU0FBUyxLQUFLO0FBQ3pHLHNDQUFzQztBQUN0QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnQ0FBZ0MsSUFBSSxFQUFFO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQixtQkFBbUIsYUFBYSxHQUFHLEtBQUs7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUIsaUJBQWlCLGFBQWEsR0FBRyxLQUFLO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxRQUFRO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVyxxQkFBcUIsT0FBTyxHQUFHLFNBQVM7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQSxtQkFBbUIsc0NBQXNDLEtBQUssRUFBRTtBQUNoRSxVQUFVO0FBQ1YsMkJBQTJCLEVBQUU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEVBQUU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTLElBQUksS0FBSyxHQUFHLEtBQUssRUFBRSxLQUFLLEVBQUUsT0FBTztBQUN4RDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUM4QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmF0cy53cy9lc20vbmF0cy5qcz9hMmIxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGRlbm8tZm10LWlnbm9yZS1maWxlXG4vLyBkZW5vLWxpbnQtaWdub3JlLWZpbGVcbi8vIFRoaXMgY29kZSB3YXMgYnVuZGxlZCB1c2luZyBgZGVubyBidW5kbGVgIGFuZCBpdCdzIG5vdCByZWNvbW1lbmRlZCB0byBlZGl0IGl0IG1hbnVhbGx5XG5cbmNvbnN0IEVtcHR5ID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG5jb25zdCBURSA9IG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgVEQgPSBuZXcgVGV4dERlY29kZXIoKTtcbmZ1bmN0aW9uIGNvbmNhdCguLi5idWZzKSB7XG4gICAgbGV0IG1heCA9IDA7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGJ1ZnMubGVuZ3RoOyBpKyspe1xuICAgICAgICBtYXggKz0gYnVmc1tpXS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KG1heCk7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgYnVmcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIG91dC5zZXQoYnVmc1tpXSwgaW5kZXgpO1xuICAgICAgICBpbmRleCArPSBidWZzW2ldLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIGVuY29kZSguLi5hKSB7XG4gICAgY29uc3QgYnVmcyA9IFtdO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgYnVmcy5wdXNoKFRFLmVuY29kZShhW2ldKSk7XG4gICAgfVxuICAgIGlmIChidWZzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gRW1wdHk7XG4gICAgfVxuICAgIGlmIChidWZzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gYnVmc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmNhdCguLi5idWZzKTtcbn1cbmZ1bmN0aW9uIGRlY29kZShhKSB7XG4gICAgaWYgKCFhIHx8IGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gVEQuZGVjb2RlKGEpO1xufVxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBkaWdpdHMgPSBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlwiO1xuY29uc3QgYmFzZSA9IDM2O1xuY29uc3QgbWF4U2VxID0gMzY1NjE1ODQ0MDA2Mjk3NjtcbmNvbnN0IG1pbkluYyA9IDMzO1xuY29uc3QgbWF4SW5jID0gMzMzO1xuY29uc3QgdG90YWxMZW4gPSAxMiArIDEwO1xuZnVuY3Rpb24gX2dldFJhbmRvbVZhbHVlcyhhKSB7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspe1xuICAgICAgICBhW2ldID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU1KTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaWxsUmFuZG9tKGEpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcz8uY3J5cHRvPy5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgICAgZ2xvYmFsVGhpcy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXRSYW5kb21WYWx1ZXMoYSk7XG4gICAgfVxufVxuY2xhc3MgTnVpZCB7XG4gICAgYnVmO1xuICAgIHNlcTtcbiAgICBpbmM7XG4gICAgaW5pdGVkO1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuYnVmID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW4pO1xuICAgICAgICB0aGlzLmluaXRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICB0aGlzLmluaXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2V0UHJlKCk7XG4gICAgICAgIHRoaXMuaW5pdFNlcUFuZEluYygpO1xuICAgICAgICB0aGlzLmZpbGxTZXEoKTtcbiAgICB9XG4gICAgaW5pdFNlcUFuZEluYygpIHtcbiAgICAgICAgdGhpcy5zZXEgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtYXhTZXEpO1xuICAgICAgICB0aGlzLmluYyA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXhJbmMgLSBtaW5JbmMpICsgbWluSW5jKTtcbiAgICB9XG4gICAgc2V0UHJlKCkge1xuICAgICAgICBjb25zdCBjYnVmID0gbmV3IFVpbnQ4QXJyYXkoMTIpO1xuICAgICAgICBmaWxsUmFuZG9tKGNidWYpO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgMTI7IGkrKyl7XG4gICAgICAgICAgICBjb25zdCBkaSA9IGNidWZbaV0gJSAzNjtcbiAgICAgICAgICAgIHRoaXMuYnVmW2ldID0gZGlnaXRzLmNoYXJDb2RlQXQoZGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbGxTZXEoKSB7XG4gICAgICAgIGxldCBuID0gdGhpcy5zZXE7XG4gICAgICAgIGZvcihsZXQgaSA9IHRvdGFsTGVuIC0gMTsgaSA+PSAxMjsgaS0tKXtcbiAgICAgICAgICAgIHRoaXMuYnVmW2ldID0gZGlnaXRzLmNoYXJDb2RlQXQobiAlIGJhc2UpO1xuICAgICAgICAgICAgbiA9IE1hdGguZmxvb3IobiAvIGJhc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGlmICghdGhpcy5pbml0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VxICs9IHRoaXMuaW5jO1xuICAgICAgICBpZiAodGhpcy5zZXEgPiAzNjU2MTU4NDQwMDYyOTc2KSB7XG4gICAgICAgICAgICB0aGlzLnNldFByZSgpO1xuICAgICAgICAgICAgdGhpcy5pbml0U2VxQW5kSW5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maWxsU2VxKCk7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgdGhpcy5idWYpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgfVxufVxuY29uc3QgbnVpZCA9IG5ldyBOdWlkKCk7XG52YXIgRXZlbnRzO1xuKGZ1bmN0aW9uKEV2ZW50cykge1xuICAgIEV2ZW50c1tcIkRpc2Nvbm5lY3RcIl0gPSBcImRpc2Nvbm5lY3RcIjtcbiAgICBFdmVudHNbXCJSZWNvbm5lY3RcIl0gPSBcInJlY29ubmVjdFwiO1xuICAgIEV2ZW50c1tcIlVwZGF0ZVwiXSA9IFwidXBkYXRlXCI7XG4gICAgRXZlbnRzW1wiTERNXCJdID0gXCJsZG1cIjtcbiAgICBFdmVudHNbXCJFcnJvclwiXSA9IFwiZXJyb3JcIjtcbn0pKEV2ZW50cyB8fCAoRXZlbnRzID0ge30pKTtcbnZhciBEZWJ1Z0V2ZW50cztcbihmdW5jdGlvbihEZWJ1Z0V2ZW50cykge1xuICAgIERlYnVnRXZlbnRzW1wiUmVjb25uZWN0aW5nXCJdID0gXCJyZWNvbm5lY3RpbmdcIjtcbiAgICBEZWJ1Z0V2ZW50c1tcIlBpbmdUaW1lclwiXSA9IFwicGluZ1RpbWVyXCI7XG4gICAgRGVidWdFdmVudHNbXCJTdGFsZUNvbm5lY3Rpb25cIl0gPSBcInN0YWxlQ29ubmVjdGlvblwiO1xuICAgIERlYnVnRXZlbnRzW1wiQ2xpZW50SW5pdGlhdGVkUmVjb25uZWN0XCJdID0gXCJjbGllbnQgaW5pdGlhdGVkIHJlY29ubmVjdFwiO1xufSkoRGVidWdFdmVudHMgfHwgKERlYnVnRXZlbnRzID0ge30pKTtcbnZhciBFcnJvckNvZGU7XG4oZnVuY3Rpb24oRXJyb3JDb2RlKSB7XG4gICAgRXJyb3JDb2RlW1wiQXBpRXJyb3JcIl0gPSBcIkJBRCBBUElcIjtcbiAgICBFcnJvckNvZGVbXCJCYWRBdXRoZW50aWNhdGlvblwiXSA9IFwiQkFEX0FVVEhFTlRJQ0FUSU9OXCI7XG4gICAgRXJyb3JDb2RlW1wiQmFkQ3JlZHNcIl0gPSBcIkJBRF9DUkVEU1wiO1xuICAgIEVycm9yQ29kZVtcIkJhZEhlYWRlclwiXSA9IFwiQkFEX0hFQURFUlwiO1xuICAgIEVycm9yQ29kZVtcIkJhZEpzb25cIl0gPSBcIkJBRF9KU09OXCI7XG4gICAgRXJyb3JDb2RlW1wiQmFkUGF5bG9hZFwiXSA9IFwiQkFEX1BBWUxPQURcIjtcbiAgICBFcnJvckNvZGVbXCJCYWRTdWJqZWN0XCJdID0gXCJCQURfU1VCSkVDVFwiO1xuICAgIEVycm9yQ29kZVtcIkNhbmNlbGxlZFwiXSA9IFwiQ0FOQ0VMTEVEXCI7XG4gICAgRXJyb3JDb2RlW1wiQ29ubmVjdGlvbkNsb3NlZFwiXSA9IFwiQ09OTkVDVElPTl9DTE9TRURcIjtcbiAgICBFcnJvckNvZGVbXCJDb25uZWN0aW9uRHJhaW5pbmdcIl0gPSBcIkNPTk5FQ1RJT05fRFJBSU5JTkdcIjtcbiAgICBFcnJvckNvZGVbXCJDb25uZWN0aW9uUmVmdXNlZFwiXSA9IFwiQ09OTkVDVElPTl9SRUZVU0VEXCI7XG4gICAgRXJyb3JDb2RlW1wiQ29ubmVjdGlvblRpbWVvdXRcIl0gPSBcIkNPTk5FQ1RJT05fVElNRU9VVFwiO1xuICAgIEVycm9yQ29kZVtcIkRpc2Nvbm5lY3RcIl0gPSBcIkRJU0NPTk5FQ1RcIjtcbiAgICBFcnJvckNvZGVbXCJJbnZhbGlkT3B0aW9uXCJdID0gXCJJTlZBTElEX09QVElPTlwiO1xuICAgIEVycm9yQ29kZVtcIkludmFsaWRQYXlsb2FkXCJdID0gXCJJTlZBTElEX1BBWUxPQURcIjtcbiAgICBFcnJvckNvZGVbXCJNYXhQYXlsb2FkRXhjZWVkZWRcIl0gPSBcIk1BWF9QQVlMT0FEX0VYQ0VFREVEXCI7XG4gICAgRXJyb3JDb2RlW1wiTm9SZXNwb25kZXJzXCJdID0gXCI1MDNcIjtcbiAgICBFcnJvckNvZGVbXCJOb3RGdW5jdGlvblwiXSA9IFwiTk9UX0ZVTkNcIjtcbiAgICBFcnJvckNvZGVbXCJSZXF1ZXN0RXJyb3JcIl0gPSBcIlJFUVVFU1RfRVJST1JcIjtcbiAgICBFcnJvckNvZGVbXCJTZXJ2ZXJPcHRpb25Ob3RBdmFpbGFibGVcIl0gPSBcIlNFUlZFUl9PUFRfTkFcIjtcbiAgICBFcnJvckNvZGVbXCJTdWJDbG9zZWRcIl0gPSBcIlNVQl9DTE9TRURcIjtcbiAgICBFcnJvckNvZGVbXCJTdWJEcmFpbmluZ1wiXSA9IFwiU1VCX0RSQUlOSU5HXCI7XG4gICAgRXJyb3JDb2RlW1wiVGltZW91dFwiXSA9IFwiVElNRU9VVFwiO1xuICAgIEVycm9yQ29kZVtcIlRsc1wiXSA9IFwiVExTXCI7XG4gICAgRXJyb3JDb2RlW1wiVW5rbm93blwiXSA9IFwiVU5LTk9XTl9FUlJPUlwiO1xuICAgIEVycm9yQ29kZVtcIldzc1JlcXVpcmVkXCJdID0gXCJXU1NfUkVRVUlSRURcIjtcbiAgICBFcnJvckNvZGVbXCJKZXRTdHJlYW1JbnZhbGlkQWNrXCJdID0gXCJKRVNUUkVBTV9JTlZBTElEX0FDS1wiO1xuICAgIEVycm9yQ29kZVtcIkpldFN0cmVhbTQwNE5vTWVzc2FnZXNcIl0gPSBcIjQwNFwiO1xuICAgIEVycm9yQ29kZVtcIkpldFN0cmVhbTQwOFJlcXVlc3RUaW1lb3V0XCJdID0gXCI0MDhcIjtcbiAgICBFcnJvckNvZGVbXCJKZXRTdHJlYW00MDlNYXhBY2tQZW5kaW5nRXhjZWVkZWRcIl0gPSBcIjQwOVwiO1xuICAgIEVycm9yQ29kZVtcIkpldFN0cmVhbTQwOVwiXSA9IFwiNDA5XCI7XG4gICAgRXJyb3JDb2RlW1wiSmV0U3RyZWFtTm90RW5hYmxlZFwiXSA9IFwiNTAzXCI7XG4gICAgRXJyb3JDb2RlW1wiSmV0U3RyZWFtSWRsZUhlYXJ0QmVhdFwiXSA9IFwiSURMRV9IRUFSVEJFQVRcIjtcbiAgICBFcnJvckNvZGVbXCJBdXRob3JpemF0aW9uVmlvbGF0aW9uXCJdID0gXCJBVVRIT1JJWkFUSU9OX1ZJT0xBVElPTlwiO1xuICAgIEVycm9yQ29kZVtcIkF1dGhlbnRpY2F0aW9uRXhwaXJlZFwiXSA9IFwiQVVUSEVOVElDQVRJT05fRVhQSVJFRFwiO1xuICAgIEVycm9yQ29kZVtcIlByb3RvY29sRXJyb3JcIl0gPSBcIk5BVFNfUFJPVE9DT0xfRVJSXCI7XG4gICAgRXJyb3JDb2RlW1wiUGVybWlzc2lvbnNWaW9sYXRpb25cIl0gPSBcIlBFUk1JU1NJT05TX1ZJT0xBVElPTlwiO1xuICAgIEVycm9yQ29kZVtcIkF1dGhlbnRpY2F0aW9uVGltZW91dFwiXSA9IFwiQVVUSEVOVElDQVRJT05fVElNRU9VVFwiO1xuICAgIEVycm9yQ29kZVtcIkFjY291bnRFeHBpcmVkXCJdID0gXCJBQ0NPVU5UX0VYUElSRURcIjtcbn0pKEVycm9yQ29kZSB8fCAoRXJyb3JDb2RlID0ge30pKTtcbmZ1bmN0aW9uIGlzTmF0c0Vycm9yKGVycikge1xuICAgIHJldHVybiB0eXBlb2YgZXJyLmNvZGUgPT09IFwic3RyaW5nXCI7XG59XG5jbGFzcyBNZXNzYWdlcyB7XG4gICAgbWVzc2FnZXM7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5tZXNzYWdlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlcy5zZXQoRXJyb3JDb2RlLkludmFsaWRQYXlsb2FkLCBcIkludmFsaWQgcGF5bG9hZCB0eXBlIC0gcGF5bG9hZHMgY2FuIGJlICdiaW5hcnknLCAnc3RyaW5nJywgb3IgJ2pzb24nXCIpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzLnNldChFcnJvckNvZGUuQmFkSnNvbiwgXCJCYWQgSlNPTlwiKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlcy5zZXQoRXJyb3JDb2RlLldzc1JlcXVpcmVkLCBcIlRMUyBpcyByZXF1aXJlZCwgdGhlcmVmb3JlIGEgc2VjdXJlIHdlYnNvY2tldCBjb25uZWN0aW9uIGlzIGFsc28gcmVxdWlyZWRcIik7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRNZXNzYWdlKHMpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VzLmdldE1lc3NhZ2Uocyk7XG4gICAgfVxuICAgIGdldE1lc3NhZ2Uocykge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlcy5nZXQocykgfHwgcztcbiAgICB9XG59XG5jb25zdCBtZXNzYWdlcyA9IG5ldyBNZXNzYWdlcygpO1xuY2xhc3MgTmF0c0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIG5hbWU7XG4gICAgbWVzc2FnZTtcbiAgICBjb2RlO1xuICAgIHBlcm1pc3Npb25Db250ZXh0O1xuICAgIGNoYWluZWRFcnJvcjtcbiAgICBhcGlfZXJyb3I7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgY29kZSwgY2hhaW5lZEVycm9yKXtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiTmF0c0Vycm9yXCI7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMuY2hhaW5lZEVycm9yID0gY2hhaW5lZEVycm9yO1xuICAgIH1cbiAgICBzdGF0aWMgZXJyb3JGb3JDb2RlKGNvZGUsIGNoYWluZWRFcnJvcikge1xuICAgICAgICBjb25zdCBtID0gTWVzc2FnZXMuZ2V0TWVzc2FnZShjb2RlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOYXRzRXJyb3IobSwgY29kZSwgY2hhaW5lZEVycm9yKTtcbiAgICB9XG4gICAgaXNBdXRoRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGUgPT09IEVycm9yQ29kZS5BdXRoZW50aWNhdGlvbkV4cGlyZWQgfHwgdGhpcy5jb2RlID09PSBFcnJvckNvZGUuQXV0aG9yaXphdGlvblZpb2xhdGlvbiB8fCB0aGlzLmNvZGUgPT09IEVycm9yQ29kZS5BY2NvdW50RXhwaXJlZDtcbiAgICB9XG4gICAgaXNBdXRoVGltZW91dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZSA9PT0gRXJyb3JDb2RlLkF1dGhlbnRpY2F0aW9uVGltZW91dDtcbiAgICB9XG4gICAgaXNQZXJtaXNzaW9uRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGUgPT09IEVycm9yQ29kZS5QZXJtaXNzaW9uc1Zpb2xhdGlvbjtcbiAgICB9XG4gICAgaXNQcm90b2NvbEVycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2RlID09PSBFcnJvckNvZGUuUHJvdG9jb2xFcnJvcjtcbiAgICB9XG4gICAgaXNKZXRTdHJlYW1FcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpX2Vycm9yICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGpzRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwaV9lcnJvciA/IHRoaXMuYXBpX2Vycm9yIDogbnVsbDtcbiAgICB9XG59XG52YXIgTWF0Y2g7XG4oZnVuY3Rpb24oTWF0Y2gpIHtcbiAgICBNYXRjaFtNYXRjaFtcIkV4YWN0XCJdID0gMF0gPSBcIkV4YWN0XCI7XG4gICAgTWF0Y2hbTWF0Y2hbXCJDYW5vbmljYWxNSU1FXCJdID0gMV0gPSBcIkNhbm9uaWNhbE1JTUVcIjtcbiAgICBNYXRjaFtNYXRjaFtcIklnbm9yZUNhc2VcIl0gPSAyXSA9IFwiSWdub3JlQ2FzZVwiO1xufSkoTWF0Y2ggfHwgKE1hdGNoID0ge30pKTtcbnZhciBSZXF1ZXN0U3RyYXRlZ3k7XG4oZnVuY3Rpb24oUmVxdWVzdFN0cmF0ZWd5KSB7XG4gICAgUmVxdWVzdFN0cmF0ZWd5W1wiVGltZXJcIl0gPSBcInRpbWVyXCI7XG4gICAgUmVxdWVzdFN0cmF0ZWd5W1wiQ291bnRcIl0gPSBcImNvdW50XCI7XG4gICAgUmVxdWVzdFN0cmF0ZWd5W1wiSml0dGVyVGltZXJcIl0gPSBcImppdHRlclRpbWVyXCI7XG4gICAgUmVxdWVzdFN0cmF0ZWd5W1wiU2VudGluZWxNc2dcIl0gPSBcInNlbnRpbmVsTXNnXCI7XG59KShSZXF1ZXN0U3RyYXRlZ3kgfHwgKFJlcXVlc3RTdHJhdGVneSA9IHt9KSk7XG5mdW5jdGlvbiBzeW5jSXRlcmF0b3Ioc3JjKSB7XG4gICAgY29uc3QgaXRlciA9IHNyY1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhc3luYyBuZXh0ICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBhd2FpdCBpdGVyLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChtLmRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG59XG52YXIgU2VydmljZVJlc3BvbnNlVHlwZTtcbihmdW5jdGlvbihTZXJ2aWNlUmVzcG9uc2VUeXBlKSB7XG4gICAgU2VydmljZVJlc3BvbnNlVHlwZVtcIlNUQVRTXCJdID0gXCJpby5uYXRzLm1pY3JvLnYxLnN0YXRzX3Jlc3BvbnNlXCI7XG4gICAgU2VydmljZVJlc3BvbnNlVHlwZVtcIklORk9cIl0gPSBcImlvLm5hdHMubWljcm8udjEuaW5mb19yZXNwb25zZVwiO1xuICAgIFNlcnZpY2VSZXNwb25zZVR5cGVbXCJQSU5HXCJdID0gXCJpby5uYXRzLm1pY3JvLnYxLnBpbmdfcmVzcG9uc2VcIjtcbn0pKFNlcnZpY2VSZXNwb25zZVR5cGUgfHwgKFNlcnZpY2VSZXNwb25zZVR5cGUgPSB7fSkpO1xuY29uc3QgU2VydmljZUVycm9ySGVhZGVyID0gXCJOYXRzLVNlcnZpY2UtRXJyb3JcIjtcbmNvbnN0IFNlcnZpY2VFcnJvckNvZGVIZWFkZXIgPSBcIk5hdHMtU2VydmljZS1FcnJvci1Db2RlXCI7XG5jbGFzcyBTZXJ2aWNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29kZTtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlKXtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxuICAgIHN0YXRpYyBpc1NlcnZpY2VFcnJvcihtc2cpIHtcbiAgICAgICAgcmV0dXJuIFNlcnZpY2VFcnJvci50b1NlcnZpY2VFcnJvcihtc2cpICE9PSBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgdG9TZXJ2aWNlRXJyb3IobXNnKSB7XG4gICAgICAgIGNvbnN0IHNjb2RlID0gbXNnPy5oZWFkZXJzPy5nZXQoU2VydmljZUVycm9yQ29kZUhlYWRlcikgfHwgXCJcIjtcbiAgICAgICAgaWYgKHNjb2RlICE9PSBcIlwiKSB7XG4gICAgICAgICAgICBjb25zdCBjb2RlID0gcGFyc2VJbnQoc2NvZGUpIHx8IDQwMDtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gbXNnPy5oZWFkZXJzPy5nZXQoU2VydmljZUVycm9ySGVhZGVyKSB8fCBcIlwiO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXJ2aWNlRXJyb3IoY29kZSwgZGVzY3JpcHRpb24ubGVuZ3RoID8gZGVzY3JpcHRpb24gOiBzY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlSW5ib3gocHJlZml4ID0gXCJcIikge1xuICAgIHByZWZpeCA9IHByZWZpeCB8fCBcIl9JTkJPWFwiO1xuICAgIGlmICh0eXBlb2YgcHJlZml4ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInByZWZpeCBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgIH1cbiAgICBwcmVmaXguc3BsaXQoXCIuXCIpLmZvckVhY2goKHYpPT57XG4gICAgICAgIGlmICh2ID09PSBcIipcIiB8fCB2ID09PSBcIj5cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbmJveCBwcmVmaXhlcyBjYW5ub3QgaGF2ZSB3aWxkY2FyZHMgJyR7cHJlZml4fSdgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBgJHtwcmVmaXh9LiR7bnVpZC5uZXh0KCl9YDtcbn1cbmNvbnN0IERFRkFVTFRfSE9TVCA9IFwiMTI3LjAuMC4xXCI7XG52YXIgU2VydmljZVZlcmI7XG4oZnVuY3Rpb24oU2VydmljZVZlcmIpIHtcbiAgICBTZXJ2aWNlVmVyYltcIlBJTkdcIl0gPSBcIlBJTkdcIjtcbiAgICBTZXJ2aWNlVmVyYltcIlNUQVRTXCJdID0gXCJTVEFUU1wiO1xuICAgIFNlcnZpY2VWZXJiW1wiSU5GT1wiXSA9IFwiSU5GT1wiO1xufSkoU2VydmljZVZlcmIgfHwgKFNlcnZpY2VWZXJiID0ge30pKTtcbmZ1bmN0aW9uIGV4dGVuZChhLCAuLi5iKSB7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspe1xuICAgICAgICBjb25zdCBvID0gYltpXTtcbiAgICAgICAgT2JqZWN0LmtleXMobykuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICAgICAgICBhW2tdID0gb1trXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhO1xufVxuZnVuY3Rpb24gcmVuZGVyKGZyYW1lKSB7XG4gICAgY29uc3QgY3IgPSBcIuKQjVwiO1xuICAgIGNvbnN0IGxmID0gXCLikIpcIjtcbiAgICByZXR1cm4gVEQuZGVjb2RlKGZyYW1lKS5yZXBsYWNlKC9cXG4vZywgbGYpLnJlcGxhY2UoL1xcci9nLCBjcik7XG59XG5mdW5jdGlvbiB0aW1lb3V0KG1zLCBhc3luY1RyYWNlcyA9IHRydWUpIHtcbiAgICBjb25zdCBlcnIgPSBhc3luY1RyYWNlcyA/IE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLlRpbWVvdXQpIDogbnVsbDtcbiAgICBsZXQgbWV0aG9kcztcbiAgICBsZXQgdGltZXI7XG4gICAgY29uc3QgcCA9IG5ldyBQcm9taXNlKChfcmVzb2x2ZSwgcmVqZWN0KT0+e1xuICAgICAgICBjb25zdCBjYW5jZWwgPSAoKT0+e1xuICAgICAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbWV0aG9kcyA9IHtcbiAgICAgICAgICAgIGNhbmNlbFxuICAgICAgICB9O1xuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgIGlmIChlcnIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoTmF0c0Vycm9yLmVycm9yRm9yQ29kZShFcnJvckNvZGUuVGltZW91dCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgbXMpO1xuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHAsIG1ldGhvZHMpO1xufVxuZnVuY3Rpb24gZGVsYXkobXMgPSAwKSB7XG4gICAgbGV0IG1ldGhvZHM7XG4gICAgY29uc3QgcCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKT0+e1xuICAgICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSwgbXMpO1xuICAgICAgICBjb25zdCBjYW5jZWwgPSAoKT0+e1xuICAgICAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbWV0aG9kcyA9IHtcbiAgICAgICAgICAgIGNhbmNlbFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHAsIG1ldGhvZHMpO1xufVxuZnVuY3Rpb24gZGVhZGxpbmUocCwgbWlsbGlzID0gMTAwMCkge1xuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgZGVhZGxpbmUgZXhjZWVkZWRgKTtcbiAgICBjb25zdCBkID0gZGVmZXJyZWQoKTtcbiAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCk9PmQucmVqZWN0KGVyciksIG1pbGxpcyk7XG4gICAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgICAgIHAsXG4gICAgICAgIGRcbiAgICBdKS5maW5hbGx5KCgpPT5jbGVhclRpbWVvdXQodGltZXIpKTtcbn1cbmZ1bmN0aW9uIGRlZmVycmVkKCkge1xuICAgIGxldCBtZXRob2RzID0ge307XG4gICAgY29uc3QgcCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIG1ldGhvZHMgPSB7XG4gICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgcmVqZWN0XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocCwgbWV0aG9kcyk7XG59XG5mdW5jdGlvbiBzaHVmZmxlKGEpIHtcbiAgICBmb3IobGV0IGkgPSBhLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pe1xuICAgICAgICBjb25zdCBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGkgKyAxKSk7XG4gICAgICAgIFthW2ldLCBhW2pdXSA9IFtcbiAgICAgICAgICAgIGFbal0sXG4gICAgICAgICAgICBhW2ldXG4gICAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBhO1xufVxuY2xhc3MgUGVyZiB7XG4gICAgdGltZXJzO1xuICAgIG1lYXN1cmVzO1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMudGltZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm1lYXN1cmVzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBtYXJrKGtleSkge1xuICAgICAgICB0aGlzLnRpbWVycy5zZXQoa2V5LCBwZXJmb3JtYW5jZS5ub3coKSk7XG4gICAgfVxuICAgIG1lYXN1cmUoa2V5LCBzdGFydEtleSwgZW5kS2V5KSB7XG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLnRpbWVycy5nZXQoc3RhcnRLZXkpO1xuICAgICAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c3RhcnRLZXl9IGlzIG5vdCBkZWZpbmVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZSA9IHRoaXMudGltZXJzLmdldChlbmRLZXkpO1xuICAgICAgICBpZiAoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZW5kS2V5fSBpcyBub3QgZGVmaW5lZGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVhc3VyZXMuc2V0KGtleSwgZSAtIHMpO1xuICAgIH1cbiAgICBnZXRFbnRyaWVzKCkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5tZWFzdXJlcy5mb3JFYWNoKCh2LCBrKT0+e1xuICAgICAgICAgICAgdmFsdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IGssXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG59XG5mdW5jdGlvbiBqaXR0ZXIobikge1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5mbG9vcihuIC8gMiArIE1hdGgucmFuZG9tKCkgKiBuKTtcbn1cbmZ1bmN0aW9uIGJhY2tvZmYocG9saWN5ID0gW1xuICAgIDAsXG4gICAgMjUwLFxuICAgIDI1MCxcbiAgICA1MDAsXG4gICAgNTAwLFxuICAgIDMwMDAsXG4gICAgNTAwMFxuXSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwb2xpY3kpKSB7XG4gICAgICAgIHBvbGljeSA9IFtcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAyNTAsXG4gICAgICAgICAgICAyNTAsXG4gICAgICAgICAgICA1MDAsXG4gICAgICAgICAgICA1MDAsXG4gICAgICAgICAgICAzMDAwLFxuICAgICAgICAgICAgNTAwMFxuICAgICAgICBdO1xuICAgIH1cbiAgICBjb25zdCBtYXggPSBwb2xpY3kubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4ge1xuICAgICAgICBiYWNrb2ZmIChhdHRlbXB0KSB7XG4gICAgICAgICAgICByZXR1cm4gaml0dGVyKGF0dGVtcHQgPiBtYXggPyBwb2xpY3lbbWF4XSA6IHBvbGljeVthdHRlbXB0XSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gbmFub3MobWlsbGlzKSB7XG4gICAgcmV0dXJuIG1pbGxpcyAqIDEwMDAwMDA7XG59XG5mdW5jdGlvbiBtaWxsaXMobnMpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihucyAvIDEwMDAwMDApO1xufVxuZnVuY3Rpb24gY2Fub25pY2FsTUlNRUhlYWRlcktleShrKSB7XG4gICAgY29uc3QgZGFzaCA9IDQ1O1xuICAgIGNvbnN0IHRvTG93ZXIgPSA5NyAtIDY1O1xuICAgIGxldCB1cHBlciA9IHRydWU7XG4gICAgY29uc3QgYnVmID0gbmV3IEFycmF5KGsubGVuZ3RoKTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGxldCBjID0gay5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA9PT0gNTggfHwgYyA8IDMzIHx8IGMgPiAxMjYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOYXRzRXJyb3IoYCcke2tbaV19JyBpcyBub3QgYSB2YWxpZCBjaGFyYWN0ZXIgZm9yIGEgaGVhZGVyIGtleWAsIEVycm9yQ29kZS5CYWRIZWFkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cHBlciAmJiA5NyA8PSBjICYmIGMgPD0gMTIyKSB7XG4gICAgICAgICAgICBjIC09IHRvTG93ZXI7XG4gICAgICAgIH0gZWxzZSBpZiAoIXVwcGVyICYmIDY1IDw9IGMgJiYgYyA8PSA5MCkge1xuICAgICAgICAgICAgYyArPSB0b0xvd2VyO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZltpXSA9IGM7XG4gICAgICAgIHVwcGVyID0gYyA9PSBkYXNoO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSguLi5idWYpO1xufVxuZnVuY3Rpb24gaGVhZGVycyhjb2RlID0gMCwgZGVzY3JpcHRpb24gPSBcIlwiKSB7XG4gICAgaWYgKGNvZGUgPT09IDAgJiYgZGVzY3JpcHRpb24gIT09IFwiXCIgfHwgY29kZSA+IDAgJiYgZGVzY3JpcHRpb24gPT09IFwiXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2V0dGluZyBzdGF0dXMgcmVxdWlyZXMgYm90aCBjb2RlIGFuZCBkZXNjcmlwdGlvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBNc2dIZHJzSW1wbChjb2RlLCBkZXNjcmlwdGlvbik7XG59XG5jb25zdCBIRUFERVIgPSBcIk5BVFMvMS4wXCI7XG5jbGFzcyBNc2dIZHJzSW1wbCB7XG4gICAgX2NvZGU7XG4gICAgaGVhZGVycztcbiAgICBfZGVzY3JpcHRpb247XG4gICAgY29uc3RydWN0b3IoY29kZSA9IDAsIGRlc2NyaXB0aW9uID0gXCJcIil7XG4gICAgICAgIHRoaXMuX2NvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLl9kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJzLmVudHJpZXMoKTtcbiAgICB9XG4gICAgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVycy5zaXplO1xuICAgIH1cbiAgICBlcXVhbHMobWgpIHtcbiAgICAgICAgaWYgKG1oICYmIHRoaXMuaGVhZGVycy5zaXplID09PSBtaC5oZWFkZXJzLnNpemUgJiYgdGhpcy5fY29kZSA9PT0gbWguX2NvZGUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIHRoaXMuaGVhZGVycyl7XG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IG1oLnZhbHVlcyhrKTtcbiAgICAgICAgICAgICAgICBpZiAodi5sZW5ndGggIT09IGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdnYgPSBbXG4gICAgICAgICAgICAgICAgICAgIC4uLnZcbiAgICAgICAgICAgICAgICBdLnNvcnQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhYSA9IFtcbiAgICAgICAgICAgICAgICAgICAgLi4uYVxuICAgICAgICAgICAgICAgIF0uc29ydCgpO1xuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB2di5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2dltpXSAhPT0gYWFbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3RhdGljIGRlY29kZShhKSB7XG4gICAgICAgIGNvbnN0IG1oID0gbmV3IE1zZ0hkcnNJbXBsKCk7XG4gICAgICAgIGNvbnN0IHMgPSBURC5kZWNvZGUoYSk7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gcy5zcGxpdChcIlxcclxcblwiKTtcbiAgICAgICAgY29uc3QgaCA9IGxpbmVzWzBdO1xuICAgICAgICBpZiAoaCAhPT0gSEVBREVSKSB7XG4gICAgICAgICAgICBsZXQgc3RyID0gaC5yZXBsYWNlKEhFQURFUiwgXCJcIikudHJpbSgpO1xuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbWguX2NvZGUgPSBwYXJzZUludChzdHIsIDEwKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4obWguX2NvZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1oLl9jb2RlID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NvZGUgPSBtaC5fY29kZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKHNjb2RlLCBcIlwiKTtcbiAgICAgICAgICAgICAgICBtaC5fZGVzY3JpcHRpb24gPSBzdHIudHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPj0gMSkge1xuICAgICAgICAgICAgbGluZXMuc2xpY2UoMSkubWFwKChzKT0+e1xuICAgICAgICAgICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9IHMuaW5kZXhPZihcIjpcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgayA9IHMuc2xpY2UoMCwgaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzLnNsaWNlKGlkeCArIDEpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1oLmFwcGVuZChrLCB2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYWRlcnMuc2l6ZSA9PT0gMCAmJiB0aGlzLl9jb2RlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcyA9IEhFQURFUjtcbiAgICAgICAgaWYgKHRoaXMuX2NvZGUgPiAwICYmIHRoaXMuX2Rlc2NyaXB0aW9uICE9PSBcIlwiKSB7XG4gICAgICAgICAgICBzICs9IGAgJHt0aGlzLl9jb2RlfSAke3RoaXMuX2Rlc2NyaXB0aW9ufWA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgdGhpcy5oZWFkZXJzKXtcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICBzID0gYCR7c31cXHJcXG4ke2t9OiAke3ZbaV19YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7c31cXHJcXG5cXHJcXG5gO1xuICAgIH1cbiAgICBlbmNvZGUoKSB7XG4gICAgICAgIHJldHVybiBURS5lbmNvZGUodGhpcy50b1N0cmluZygpKTtcbiAgICB9XG4gICAgc3RhdGljIHZhbGlkSGVhZGVyVmFsdWUoaykge1xuICAgICAgICBjb25zdCBpbnYgPSAvW1xcclxcbl0vO1xuICAgICAgICBpZiAoaW52LnRlc3QoaykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOYXRzRXJyb3IoXCJpbnZhbGlkIGhlYWRlciB2YWx1ZSAtIFxcXFxyIGFuZCBcXFxcbiBhcmUgbm90IGFsbG93ZWQuXCIsIEVycm9yQ29kZS5CYWRIZWFkZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrLnRyaW0oKTtcbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHNrIG9mIHRoaXMuaGVhZGVycy5rZXlzKCkpe1xuICAgICAgICAgICAga2V5cy5wdXNoKHNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9XG4gICAgZmluZEtleXMoaywgbWF0Y2ggPSBNYXRjaC5FeGFjdCkge1xuICAgICAgICBjb25zdCBrZXlzID0gdGhpcy5rZXlzKCk7XG4gICAgICAgIHN3aXRjaChtYXRjaCl7XG4gICAgICAgICAgICBjYXNlIE1hdGNoLkV4YWN0OlxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzLmZpbHRlcigodik9PntcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYgPT09IGs7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIE1hdGNoLkNhbm9uaWNhbE1JTUU6XG4gICAgICAgICAgICAgICAgayA9IGNhbm9uaWNhbE1JTUVIZWFkZXJLZXkoayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXMuZmlsdGVyKCh2KT0+e1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdiA9PT0gaztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsY2kgPSBrLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlzLmZpbHRlcigodik9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsY2kgPT09IHYudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldChrLCBtYXRjaCA9IE1hdGNoLkV4YWN0KSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSB0aGlzLmZpbmRLZXlzKGssIG1hdGNoKTtcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy5oZWFkZXJzLmdldChrZXlzWzBdKTtcbiAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodikgPyB2WzBdIDogdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgbGFzdChrLCBtYXRjaCA9IE1hdGNoLkV4YWN0KSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSB0aGlzLmZpbmRLZXlzKGssIG1hdGNoKTtcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy5oZWFkZXJzLmdldChrZXlzWzBdKTtcbiAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodikgPyB2W3YubGVuZ3RoIC0gMV0gOiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBoYXMoaywgbWF0Y2ggPSBNYXRjaC5FeGFjdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kS2V5cyhrLCBtYXRjaCkubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgc2V0KGssIHYsIG1hdGNoID0gTWF0Y2guRXhhY3QpIHtcbiAgICAgICAgdGhpcy5kZWxldGUoaywgbWF0Y2gpO1xuICAgICAgICB0aGlzLmFwcGVuZChrLCB2LCBtYXRjaCk7XG4gICAgfVxuICAgIGFwcGVuZChrLCB2LCBtYXRjaCA9IE1hdGNoLkV4YWN0KSB7XG4gICAgICAgIGNvbnN0IGNrID0gY2Fub25pY2FsTUlNRUhlYWRlcktleShrKTtcbiAgICAgICAgaWYgKG1hdGNoID09PSBNYXRjaC5DYW5vbmljYWxNSU1FKSB7XG4gICAgICAgICAgICBrID0gY2s7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5cyA9IHRoaXMuZmluZEtleXMoaywgbWF0Y2gpO1xuICAgICAgICBrID0ga2V5cy5sZW5ndGggPiAwID8ga2V5c1swXSA6IGs7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gTXNnSGRyc0ltcGwudmFsaWRIZWFkZXJWYWx1ZSh2KTtcbiAgICAgICAgbGV0IGEgPSB0aGlzLmhlYWRlcnMuZ2V0KGspO1xuICAgICAgICBpZiAoIWEpIHtcbiAgICAgICAgICAgIGEgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoaywgYSk7XG4gICAgICAgIH1cbiAgICAgICAgYS5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgdmFsdWVzKGssIG1hdGNoID0gTWF0Y2guRXhhY3QpIHtcbiAgICAgICAgY29uc3QgYnVmID0gW107XG4gICAgICAgIGNvbnN0IGtleXMgPSB0aGlzLmZpbmRLZXlzKGssIG1hdGNoKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKCh2KT0+e1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy5oZWFkZXJzLmdldCh2KTtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBidWYucHVzaCguLi52YWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgZGVsZXRlKGssIG1hdGNoID0gTWF0Y2guRXhhY3QpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IHRoaXMuZmluZEtleXMoaywgbWF0Y2gpO1xuICAgICAgICBrZXlzLmZvckVhY2goKHYpPT57XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMuZGVsZXRlKHYpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGhhc0Vycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29kZSA+PSAzMDA7XG4gICAgfVxuICAgIGdldCBzdGF0dXMoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLl9jb2RlfSAke3RoaXMuX2Rlc2NyaXB0aW9ufWAudHJpbSgpO1xuICAgIH1cbiAgICB0b1JlY29yZCgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHt9O1xuICAgICAgICB0aGlzLmtleXMoKS5mb3JFYWNoKCh2KT0+e1xuICAgICAgICAgICAgZGF0YVt2XSA9IHRoaXMudmFsdWVzKHYpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGdldCBjb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29kZTtcbiAgICB9XG4gICAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVzY3JpcHRpb247XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUmVjb3JkKHIpIHtcbiAgICAgICAgY29uc3QgaCA9IG5ldyBNc2dIZHJzSW1wbCgpO1xuICAgICAgICBmb3IoY29uc3QgayBpbiByKXtcbiAgICAgICAgICAgIGguaGVhZGVycy5zZXQoaywgcltrXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGg7XG4gICAgfVxufVxuZnVuY3Rpb24gU3RyaW5nQ29kZWMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gVEUuZW5jb2RlKGQpO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUgKGEpIHtcbiAgICAgICAgICAgIHJldHVybiBURC5kZWNvZGUoYSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gSlNPTkNvZGVjKHJldml2ZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUgKGQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRFLmVuY29kZShKU09OLnN0cmluZ2lmeShkKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBOYXRzRXJyb3IuZXJyb3JGb3JDb2RlKEVycm9yQ29kZS5CYWRKc29uLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUgKGEpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoVEQuZGVjb2RlKGEpLCByZXZpdmVyKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRocm93IE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLkJhZEpzb24sIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gaXNSZXF1ZXN0RXJyb3IobXNnKSB7XG4gICAgaWYgKG1zZyAmJiBtc2cuZGF0YS5sZW5ndGggPT09IDAgJiYgbXNnLmhlYWRlcnM/LmNvZGUgPT09IDUwMykge1xuICAgICAgICByZXR1cm4gTmF0c0Vycm9yLmVycm9yRm9yQ29kZShFcnJvckNvZGUuTm9SZXNwb25kZXJzKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5jbGFzcyBNc2dJbXBsIHtcbiAgICBfaGVhZGVycztcbiAgICBfbXNnO1xuICAgIF9yZGF0YTtcbiAgICBfcmVwbHk7XG4gICAgX3N1YmplY3Q7XG4gICAgcHVibGlzaGVyO1xuICAgIHN0YXRpYyBqYztcbiAgICBjb25zdHJ1Y3Rvcihtc2csIGRhdGEsIHB1Ymxpc2hlcil7XG4gICAgICAgIHRoaXMuX21zZyA9IG1zZztcbiAgICAgICAgdGhpcy5fcmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLnB1Ymxpc2hlciA9IHB1Ymxpc2hlcjtcbiAgICB9XG4gICAgZ2V0IHN1YmplY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdWJqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3ViamVjdDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdWJqZWN0ID0gVEQuZGVjb2RlKHRoaXMuX21zZy5zdWJqZWN0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1YmplY3Q7XG4gICAgfVxuICAgIGdldCByZXBseSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlcGx5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVwbHk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVwbHkgPSBURC5kZWNvZGUodGhpcy5fbXNnLnJlcGx5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcGx5O1xuICAgIH1cbiAgICBnZXQgc2lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbXNnLnNpZDtcbiAgICB9XG4gICAgZ2V0IGhlYWRlcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9tc2cuaGRyID4gLTEgJiYgIXRoaXMuX2hlYWRlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMuX3JkYXRhLnN1YmFycmF5KDAsIHRoaXMuX21zZy5oZHIpO1xuICAgICAgICAgICAgdGhpcy5faGVhZGVycyA9IE1zZ0hkcnNJbXBsLmRlY29kZShidWYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXJzO1xuICAgIH1cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9tc2cuaGRyID4gLTEgPyB0aGlzLl9yZGF0YS5zdWJhcnJheSh0aGlzLl9tc2cuaGRyKSA6IHRoaXMuX3JkYXRhO1xuICAgIH1cbiAgICByZXNwb25kKGRhdGEgPSBFbXB0eSwgb3B0cykge1xuICAgICAgICBpZiAodGhpcy5yZXBseSkge1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoZXIucHVibGlzaCh0aGlzLnJlcGx5LCBkYXRhLCBvcHRzKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2l6ZSgpIHtcbiAgICAgICAgY29uc3Qgc3ViaiA9IHRoaXMuX21zZy5zdWJqZWN0Lmxlbmd0aDtcbiAgICAgICAgY29uc3QgcmVwbHkgPSB0aGlzLl9tc2cucmVwbHk/Lmxlbmd0aCB8fCAwO1xuICAgICAgICBjb25zdCBwYXlsb2FkQW5kSGVhZGVycyA9IHRoaXMuX21zZy5zaXplID09PSAtMSA/IDAgOiB0aGlzLl9tc2cuc2l6ZTtcbiAgICAgICAgcmV0dXJuIHN1YmogKyByZXBseSArIHBheWxvYWRBbmRIZWFkZXJzO1xuICAgIH1cbiAgICBqc29uKHJldml2ZXIpIHtcbiAgICAgICAgcmV0dXJuIEpTT05Db2RlYyhyZXZpdmVyKS5kZWNvZGUodGhpcy5kYXRhKTtcbiAgICB9XG4gICAgc3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gVEQuZGVjb2RlKHRoaXMuZGF0YSk7XG4gICAgfVxuICAgIHJlcXVlc3RJbmZvKCkge1xuICAgICAgICBjb25zdCB2ID0gdGhpcy5oZWFkZXJzPy5nZXQoXCJOYXRzLVJlcXVlc3QtSW5mb1wiKTtcbiAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHYsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGtleSA9PT0gXCJzdGFydFwiIHx8IGtleSA9PT0gXCJzdG9wXCIpICYmIHZhbHVlICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLnBhcnNlKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRHVyYWJsZU5hbWUobmFtZSkge1xuICAgIHJldHVybiBtaW5WYWxpZGF0aW9uKFwiZHVyYWJsZVwiLCBuYW1lKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlU3RyZWFtTmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG1pblZhbGlkYXRpb24oXCJzdHJlYW1cIiwgbmFtZSk7XG59XG5mdW5jdGlvbiBtaW5WYWxpZGF0aW9uKGNvbnRleHQsIG5hbWUgPSBcIlwiKSB7XG4gICAgaWYgKG5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYCR7Y29udGV4dH0gbmFtZSByZXF1aXJlZGApO1xuICAgIH1cbiAgICBjb25zdCBiYWQgPSBbXG4gICAgICAgIFwiLlwiLFxuICAgICAgICBcIipcIixcbiAgICAgICAgXCI+XCIsXG4gICAgICAgIFwiL1wiLFxuICAgICAgICBcIlxcXFxcIixcbiAgICAgICAgXCIgXCIsXG4gICAgICAgIFwiXFx0XCIsXG4gICAgICAgIFwiXFxuXCIsXG4gICAgICAgIFwiXFxyXCJcbiAgICBdO1xuICAgIGJhZC5mb3JFYWNoKCh2KT0+e1xuICAgICAgICBpZiAobmFtZS5pbmRleE9mKHYpICE9PSAtMSkge1xuICAgICAgICAgICAgc3dpdGNoKHYpe1xuICAgICAgICAgICAgICAgIGNhc2UgXCJcXG5cIjpcbiAgICAgICAgICAgICAgICAgICAgdiA9IFwiXFxcXG5cIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcclwiOlxuICAgICAgICAgICAgICAgICAgICB2ID0gXCJcXFxcclwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFx0XCI6XG4gICAgICAgICAgICAgICAgICAgIHYgPSBcIlxcXFx0XCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgaW52YWxpZCAke2NvbnRleHR9IG5hbWUgLSAke2NvbnRleHR9IG5hbWUgY2Fubm90IGNvbnRhaW4gJyR7dn0nYCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gXCJcIjtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTmFtZShjb250ZXh0LCBuYW1lID0gXCJcIikge1xuICAgIGlmIChuYW1lID09PSBcIlwiKSB7XG4gICAgICAgIHRocm93IEVycm9yKGAke2NvbnRleHR9IG5hbWUgcmVxdWlyZWRgKTtcbiAgICB9XG4gICAgY29uc3QgbSA9IHZhbGlkTmFtZShuYW1lKTtcbiAgICBpZiAobS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkICR7Y29udGV4dH0gbmFtZSAtICR7Y29udGV4dH0gbmFtZSAke219YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWROYW1lKG5hbWUgPSBcIlwiKSB7XG4gICAgaWYgKG5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYG5hbWUgcmVxdWlyZWRgKTtcbiAgICB9XG4gICAgY29uc3QgUkUgPSAvXlstXFx3XSskL2c7XG4gICAgY29uc3QgbSA9IG5hbWUubWF0Y2goUkUpO1xuICAgIGlmIChtID09PSBudWxsKSB7XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBuYW1lLnNwbGl0KFwiXCIpKXtcbiAgICAgICAgICAgIGNvbnN0IG1tID0gYy5tYXRjaChSRSk7XG4gICAgICAgICAgICBpZiAobW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYGNhbm5vdCBjb250YWluICcke2N9J2A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiXCI7XG59XG5mdW5jdGlvbiBpc0Zsb3dDb250cm9sTXNnKG1zZykge1xuICAgIGlmIChtc2cuZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgaCA9IG1zZy5oZWFkZXJzO1xuICAgIGlmICghaCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBoLmNvZGUgPj0gMTAwICYmIGguY29kZSA8IDIwMDtcbn1cbmZ1bmN0aW9uIGlzSGVhcnRiZWF0TXNnKG1zZykge1xuICAgIHJldHVybiBpc0Zsb3dDb250cm9sTXNnKG1zZykgJiYgbXNnLmhlYWRlcnM/LmRlc2NyaXB0aW9uID09PSBcIklkbGUgSGVhcnRiZWF0XCI7XG59XG5mdW5jdGlvbiBuZXdKc0Vycm9yTXNnKGNvZGUsIGRlc2NyaXB0aW9uLCBzdWJqZWN0KSB7XG4gICAgY29uc3QgaCA9IGhlYWRlcnMoY29kZSwgZGVzY3JpcHRpb24pO1xuICAgIGNvbnN0IGFyZyA9IHtcbiAgICAgICAgaGRyOiAxLFxuICAgICAgICBzaWQ6IDAsXG4gICAgICAgIHNpemU6IDBcbiAgICB9O1xuICAgIGNvbnN0IG1zZyA9IG5ldyBNc2dJbXBsKGFyZywgRW1wdHksIHt9KTtcbiAgICBtc2cuX2hlYWRlcnMgPSBoO1xuICAgIG1zZy5fc3ViamVjdCA9IHN1YmplY3Q7XG4gICAgcmV0dXJuIG1zZztcbn1cbmZ1bmN0aW9uIGNoZWNrSnNFcnJvcihtc2cpIHtcbiAgICBpZiAobXNnLmRhdGEubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBoID0gbXNnLmhlYWRlcnM7XG4gICAgaWYgKCFoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY2hlY2tKc0Vycm9yQ29kZShoLmNvZGUsIGguZGVzY3JpcHRpb24pO1xufVxudmFyIEpzNDA5RXJyb3JzO1xuKGZ1bmN0aW9uKEpzNDA5RXJyb3JzKSB7XG4gICAgSnM0MDlFcnJvcnNbXCJNYXhCYXRjaEV4Y2VlZGVkXCJdID0gXCJleGNlZWRlZCBtYXhyZXF1ZXN0YmF0Y2ggb2ZcIjtcbiAgICBKczQwOUVycm9yc1tcIk1heEV4cGlyZXNFeGNlZWRlZFwiXSA9IFwiZXhjZWVkZWQgbWF4cmVxdWVzdGV4cGlyZXMgb2ZcIjtcbiAgICBKczQwOUVycm9yc1tcIk1heEJ5dGVzRXhjZWVkZWRcIl0gPSBcImV4Y2VlZGVkIG1heHJlcXVlc3RtYXhieXRlcyBvZlwiO1xuICAgIEpzNDA5RXJyb3JzW1wiTWF4TWVzc2FnZVNpemVFeGNlZWRlZFwiXSA9IFwibWVzc2FnZSBzaXplIGV4Y2VlZHMgbWF4Ynl0ZXNcIjtcbiAgICBKczQwOUVycm9yc1tcIlB1c2hDb25zdW1lclwiXSA9IFwiY29uc3VtZXIgaXMgcHVzaCBiYXNlZFwiO1xuICAgIEpzNDA5RXJyb3JzW1wiTWF4V2FpdGluZ0V4Y2VlZGVkXCJdID0gXCJleGNlZWRlZCBtYXh3YWl0aW5nXCI7XG4gICAgSnM0MDlFcnJvcnNbXCJJZGxlSGVhcnRiZWF0TWlzc2VkXCJdID0gXCJpZGxlIGhlYXJ0YmVhdHMgbWlzc2VkXCI7XG4gICAgSnM0MDlFcnJvcnNbXCJDb25zdW1lckRlbGV0ZWRcIl0gPSBcImNvbnN1bWVyIGRlbGV0ZWRcIjtcbn0pKEpzNDA5RXJyb3JzIHx8IChKczQwOUVycm9ycyA9IHt9KSk7XG5sZXQgTUFYX1dBSVRJTkdfRkFJTCA9IGZhbHNlO1xuZnVuY3Rpb24gaXNUZXJtaW5hbDQwOShlcnIpIHtcbiAgICBpZiAoZXJyLmNvZGUgIT09IEVycm9yQ29kZS5KZXRTdHJlYW00MDkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBmYXRhbCA9IFtcbiAgICAgICAgSnM0MDlFcnJvcnMuTWF4QmF0Y2hFeGNlZWRlZCxcbiAgICAgICAgSnM0MDlFcnJvcnMuTWF4RXhwaXJlc0V4Y2VlZGVkLFxuICAgICAgICBKczQwOUVycm9ycy5NYXhCeXRlc0V4Y2VlZGVkLFxuICAgICAgICBKczQwOUVycm9ycy5NYXhNZXNzYWdlU2l6ZUV4Y2VlZGVkLFxuICAgICAgICBKczQwOUVycm9ycy5QdXNoQ29uc3VtZXIsXG4gICAgICAgIEpzNDA5RXJyb3JzLklkbGVIZWFydGJlYXRNaXNzZWQsXG4gICAgICAgIEpzNDA5RXJyb3JzLkNvbnN1bWVyRGVsZXRlZFxuICAgIF07XG4gICAgaWYgKE1BWF9XQUlUSU5HX0ZBSUwpIHtcbiAgICAgICAgZmF0YWwucHVzaChKczQwOUVycm9ycy5NYXhXYWl0aW5nRXhjZWVkZWQpO1xuICAgIH1cbiAgICByZXR1cm4gZmF0YWwuZmluZCgocyk9PntcbiAgICAgICAgcmV0dXJuIGVyci5tZXNzYWdlLmluZGV4T2YocykgIT09IC0xO1xuICAgIH0pICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBjaGVja0pzRXJyb3JDb2RlKGNvZGUsIGRlc2NyaXB0aW9uID0gXCJcIikge1xuICAgIGlmIChjb2RlIDwgMzAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBkZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgc3dpdGNoKGNvZGUpe1xuICAgICAgICBjYXNlIDQwNDpcbiAgICAgICAgICAgIHJldHVybiBuZXcgTmF0c0Vycm9yKGRlc2NyaXB0aW9uLCBFcnJvckNvZGUuSmV0U3RyZWFtNDA0Tm9NZXNzYWdlcyk7XG4gICAgICAgIGNhc2UgNDA4OlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOYXRzRXJyb3IoZGVzY3JpcHRpb24sIEVycm9yQ29kZS5KZXRTdHJlYW00MDhSZXF1ZXN0VGltZW91dCk7XG4gICAgICAgIGNhc2UgNDA5OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVjID0gZGVzY3JpcHRpb24uc3RhcnRzV2l0aChKczQwOUVycm9ycy5JZGxlSGVhcnRiZWF0TWlzc2VkKSA/IEVycm9yQ29kZS5KZXRTdHJlYW1JZGxlSGVhcnRCZWF0IDogRXJyb3JDb2RlLkpldFN0cmVhbTQwOTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE5hdHNFcnJvcihkZXNjcmlwdGlvbiwgZWMpO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIDUwMzpcbiAgICAgICAgICAgIHJldHVybiBOYXRzRXJyb3IuZXJyb3JGb3JDb2RlKEVycm9yQ29kZS5KZXRTdHJlYW1Ob3RFbmFibGVkLCBuZXcgRXJyb3IoZGVzY3JpcHRpb24pKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdGlvbiA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gRXJyb3JDb2RlLlVua25vd247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5hdHNFcnJvcihkZXNjcmlwdGlvbiwgYCR7Y29kZX1gKTtcbiAgICB9XG59XG5jbGFzcyBRdWV1ZWRJdGVyYXRvckltcGwge1xuICAgIGluZmxpZ2h0O1xuICAgIHByb2Nlc3NlZDtcbiAgICByZWNlaXZlZDtcbiAgICBub0l0ZXJhdG9yO1xuICAgIGl0ZXJDbG9zZWQ7XG4gICAgZG9uZTtcbiAgICBzaWduYWw7XG4gICAgeWllbGRzO1xuICAgIGZpbHRlcmVkO1xuICAgIHBlbmRpbmdGaWx0ZXJlZDtcbiAgICBpbmdlc3Rpb25GaWx0ZXJGbjtcbiAgICBwcm90b2NvbEZpbHRlckZuO1xuICAgIGRpc3BhdGNoZWRGbjtcbiAgICBjdHg7XG4gICAgX2RhdGE7XG4gICAgZXJyO1xuICAgIHRpbWU7XG4gICAgeWllbGRpbmc7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5pbmZsaWdodCA9IDA7XG4gICAgICAgIHRoaXMuZmlsdGVyZWQgPSAwO1xuICAgICAgICB0aGlzLnBlbmRpbmdGaWx0ZXJlZCA9IDA7XG4gICAgICAgIHRoaXMucHJvY2Vzc2VkID0gMDtcbiAgICAgICAgdGhpcy5yZWNlaXZlZCA9IDA7XG4gICAgICAgIHRoaXMubm9JdGVyYXRvciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaWduYWwgPSBkZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLnlpZWxkcyA9IFtdO1xuICAgICAgICB0aGlzLml0ZXJDbG9zZWQgPSBkZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLnRpbWUgPSAwO1xuICAgICAgICB0aGlzLnlpZWxkaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZXJhdGUoKTtcbiAgICB9XG4gICAgcHVzaCh2KSB7XG4gICAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy55aWVsZHMucHVzaCh2KTtcbiAgICAgICAgICAgIHRoaXMuc2lnbmFsLnJlc29sdmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGluZ2VzdCwgcHJvdG9jb2wgfSA9IHRoaXMuaW5nZXN0aW9uRmlsdGVyRm4gPyB0aGlzLmluZ2VzdGlvbkZpbHRlckZuKHYsIHRoaXMuY3R4IHx8IHRoaXMpIDoge1xuICAgICAgICAgICAgaW5nZXN0OiB0cnVlLFxuICAgICAgICAgICAgcHJvdG9jb2w6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpbmdlc3QpIHtcbiAgICAgICAgICAgIGlmIChwcm90b2NvbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyZWQrKztcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdGaWx0ZXJlZCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy55aWVsZHMucHVzaCh2KTtcbiAgICAgICAgICAgIHRoaXMuc2lnbmFsLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAqaXRlcmF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9JdGVyYXRvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5hdHNFcnJvcihcInVuc3VwcG9ydGVkIGl0ZXJhdG9yXCIsIEVycm9yQ29kZS5BcGlFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMueWllbGRpbmcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOYXRzRXJyb3IoXCJhbHJlYWR5IHlpZWxkaW5nXCIsIEVycm9yQ29kZS5BcGlFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy55aWVsZGluZyA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aGlsZSh0cnVlKXtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy55aWVsZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2lnbmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5lcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHlpZWxkcyA9IHRoaXMueWllbGRzO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mbGlnaHQgPSB5aWVsZHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMueWllbGRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHlpZWxkcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgeWllbGRzW2ldID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZuID0geWllbGRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5lcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvayA9IHRoaXMucHJvdG9jb2xGaWx0ZXJGbiA/IHRoaXMucHJvdG9jb2xGaWx0ZXJGbih5aWVsZHNbaV0pIDogdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NlZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlzcGF0Y2hlZEZuICYmIHlpZWxkc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hlZEZuKHlpZWxkc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdGaWx0ZXJlZC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5mbGlnaHQtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMueWllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55aWVsZHMgPSB5aWVsZHM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2lnbmFsID0gZGVmZXJyZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0b3AoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVyciA9IGVycjtcbiAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zaWduYWwucmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLml0ZXJDbG9zZWQucmVzb2x2ZShlcnIpO1xuICAgIH1cbiAgICBnZXRQcm9jZXNzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vSXRlcmF0b3IgPyB0aGlzLnJlY2VpdmVkIDogdGhpcy5wcm9jZXNzZWQ7XG4gICAgfVxuICAgIGdldFBlbmRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkcy5sZW5ndGggKyB0aGlzLmluZmxpZ2h0IC0gdGhpcy5wZW5kaW5nRmlsdGVyZWQ7XG4gICAgfVxuICAgIGdldFJlY2VpdmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWNlaXZlZCAtIHRoaXMuZmlsdGVyZWQ7XG4gICAgfVxufVxuY2xhc3MgSWRsZUhlYXJ0YmVhdE1vbml0b3Ige1xuICAgIGludGVydmFsO1xuICAgIG1heE91dDtcbiAgICBjYW5jZWxBZnRlcjtcbiAgICB0aW1lcjtcbiAgICBhdXRvQ2FuY2VsVGltZXI7XG4gICAgbGFzdDtcbiAgICBtaXNzZWQ7XG4gICAgY291bnQ7XG4gICAgY2FsbGJhY2s7XG4gICAgY29uc3RydWN0b3IoaW50ZXJ2YWwsIGNiLCBvcHRzID0ge1xuICAgICAgICBtYXhPdXQ6IDJcbiAgICB9KXtcbiAgICAgICAgdGhpcy5pbnRlcnZhbCA9IGludGVydmFsO1xuICAgICAgICB0aGlzLm1heE91dCA9IG9wdHM/Lm1heE91dCB8fCAyO1xuICAgICAgICB0aGlzLmNhbmNlbEFmdGVyID0gb3B0cz8uY2FuY2VsQWZ0ZXIgfHwgMDtcbiAgICAgICAgdGhpcy5sYXN0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5taXNzZWQgPSAwO1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICAgICAgICB0aGlzLl9zY2hlZHVsZSgpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIGlmICh0aGlzLmF1dG9DYW5jZWxUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuYXV0b0NhbmNlbFRpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWVyID0gMDtcbiAgICAgICAgdGhpcy5hdXRvQ2FuY2VsVGltZXIgPSAwO1xuICAgICAgICB0aGlzLm1pc3NlZCA9IDA7XG4gICAgfVxuICAgIHdvcmsoKSB7XG4gICAgICAgIHRoaXMubGFzdCA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMubWlzc2VkID0gMDtcbiAgICB9XG4gICAgX2NoYW5nZShpbnRlcnZhbCwgY2FuY2VsQWZ0ZXIgPSAwLCBtYXhPdXQgPSAyKSB7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBpbnRlcnZhbDtcbiAgICAgICAgdGhpcy5tYXhPdXQgPSBtYXhPdXQ7XG4gICAgICAgIHRoaXMuY2FuY2VsQWZ0ZXIgPSBjYW5jZWxBZnRlcjtcbiAgICAgICAgdGhpcy5yZXN0YXJ0KCk7XG4gICAgfVxuICAgIHJlc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlKCk7XG4gICAgfVxuICAgIF9zY2hlZHVsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsQWZ0ZXIgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmF1dG9DYW5jZWxUaW1lciA9IHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICAgICAgfSwgdGhpcy5jYW5jZWxBZnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKCgpPT57XG4gICAgICAgICAgICB0aGlzLmNvdW50Kys7XG4gICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIHRoaXMubGFzdCA+IHRoaXMuaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1pc3NlZCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubWlzc2VkID49IHRoaXMubWF4T3V0KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2sodGhpcy5taXNzZWQpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLmludGVydmFsKTtcbiAgICB9XG59XG52YXIgUmV0ZW50aW9uUG9saWN5O1xuKGZ1bmN0aW9uKFJldGVudGlvblBvbGljeSkge1xuICAgIFJldGVudGlvblBvbGljeVtcIkxpbWl0c1wiXSA9IFwibGltaXRzXCI7XG4gICAgUmV0ZW50aW9uUG9saWN5W1wiSW50ZXJlc3RcIl0gPSBcImludGVyZXN0XCI7XG4gICAgUmV0ZW50aW9uUG9saWN5W1wiV29ya3F1ZXVlXCJdID0gXCJ3b3JrcXVldWVcIjtcbn0pKFJldGVudGlvblBvbGljeSB8fCAoUmV0ZW50aW9uUG9saWN5ID0ge30pKTtcbnZhciBEaXNjYXJkUG9saWN5O1xuKGZ1bmN0aW9uKERpc2NhcmRQb2xpY3kpIHtcbiAgICBEaXNjYXJkUG9saWN5W1wiT2xkXCJdID0gXCJvbGRcIjtcbiAgICBEaXNjYXJkUG9saWN5W1wiTmV3XCJdID0gXCJuZXdcIjtcbn0pKERpc2NhcmRQb2xpY3kgfHwgKERpc2NhcmRQb2xpY3kgPSB7fSkpO1xudmFyIFN0b3JhZ2VUeXBlO1xuKGZ1bmN0aW9uKFN0b3JhZ2VUeXBlKSB7XG4gICAgU3RvcmFnZVR5cGVbXCJGaWxlXCJdID0gXCJmaWxlXCI7XG4gICAgU3RvcmFnZVR5cGVbXCJNZW1vcnlcIl0gPSBcIm1lbW9yeVwiO1xufSkoU3RvcmFnZVR5cGUgfHwgKFN0b3JhZ2VUeXBlID0ge30pKTtcbnZhciBEZWxpdmVyUG9saWN5O1xuKGZ1bmN0aW9uKERlbGl2ZXJQb2xpY3kpIHtcbiAgICBEZWxpdmVyUG9saWN5W1wiQWxsXCJdID0gXCJhbGxcIjtcbiAgICBEZWxpdmVyUG9saWN5W1wiTGFzdFwiXSA9IFwibGFzdFwiO1xuICAgIERlbGl2ZXJQb2xpY3lbXCJOZXdcIl0gPSBcIm5ld1wiO1xuICAgIERlbGl2ZXJQb2xpY3lbXCJTdGFydFNlcXVlbmNlXCJdID0gXCJieV9zdGFydF9zZXF1ZW5jZVwiO1xuICAgIERlbGl2ZXJQb2xpY3lbXCJTdGFydFRpbWVcIl0gPSBcImJ5X3N0YXJ0X3RpbWVcIjtcbiAgICBEZWxpdmVyUG9saWN5W1wiTGFzdFBlclN1YmplY3RcIl0gPSBcImxhc3RfcGVyX3N1YmplY3RcIjtcbn0pKERlbGl2ZXJQb2xpY3kgfHwgKERlbGl2ZXJQb2xpY3kgPSB7fSkpO1xudmFyIEFja1BvbGljeTtcbihmdW5jdGlvbihBY2tQb2xpY3kpIHtcbiAgICBBY2tQb2xpY3lbXCJOb25lXCJdID0gXCJub25lXCI7XG4gICAgQWNrUG9saWN5W1wiQWxsXCJdID0gXCJhbGxcIjtcbiAgICBBY2tQb2xpY3lbXCJFeHBsaWNpdFwiXSA9IFwiZXhwbGljaXRcIjtcbiAgICBBY2tQb2xpY3lbXCJOb3RTZXRcIl0gPSBcIlwiO1xufSkoQWNrUG9saWN5IHx8IChBY2tQb2xpY3kgPSB7fSkpO1xudmFyIFJlcGxheVBvbGljeTtcbihmdW5jdGlvbihSZXBsYXlQb2xpY3kpIHtcbiAgICBSZXBsYXlQb2xpY3lbXCJJbnN0YW50XCJdID0gXCJpbnN0YW50XCI7XG4gICAgUmVwbGF5UG9saWN5W1wiT3JpZ2luYWxcIl0gPSBcIm9yaWdpbmFsXCI7XG59KShSZXBsYXlQb2xpY3kgfHwgKFJlcGxheVBvbGljeSA9IHt9KSk7XG52YXIgU3RvcmVDb21wcmVzc2lvbjtcbihmdW5jdGlvbihTdG9yZUNvbXByZXNzaW9uKSB7XG4gICAgU3RvcmVDb21wcmVzc2lvbltcIk5vbmVcIl0gPSBcIm5vbmVcIjtcbiAgICBTdG9yZUNvbXByZXNzaW9uW1wiUzJcIl0gPSBcInMyXCI7XG59KShTdG9yZUNvbXByZXNzaW9uIHx8IChTdG9yZUNvbXByZXNzaW9uID0ge30pKTtcbnZhciBDb25zdW1lckFwaUFjdGlvbjtcbihmdW5jdGlvbihDb25zdW1lckFwaUFjdGlvbikge1xuICAgIENvbnN1bWVyQXBpQWN0aW9uW1wiQ3JlYXRlT3JVcGRhdGVcIl0gPSBcIlwiO1xuICAgIENvbnN1bWVyQXBpQWN0aW9uW1wiVXBkYXRlXCJdID0gXCJ1cGRhdGVcIjtcbiAgICBDb25zdW1lckFwaUFjdGlvbltcIkNyZWF0ZVwiXSA9IFwiY3JlYXRlXCI7XG59KShDb25zdW1lckFwaUFjdGlvbiB8fCAoQ29uc3VtZXJBcGlBY3Rpb24gPSB7fSkpO1xuZnVuY3Rpb24gZGVmYXVsdENvbnN1bWVyKG5hbWUsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgZGVsaXZlcl9wb2xpY3k6IERlbGl2ZXJQb2xpY3kuQWxsLFxuICAgICAgICBhY2tfcG9saWN5OiBBY2tQb2xpY3kuRXhwbGljaXQsXG4gICAgICAgIGFja193YWl0OiBuYW5vcygzMCAqIDEwMDApLFxuICAgICAgICByZXBsYXlfcG9saWN5OiBSZXBsYXlQb2xpY3kuSW5zdGFudFxuICAgIH0sIG9wdHMpO1xufVxudmFyIEFkdmlzb3J5S2luZDtcbihmdW5jdGlvbihBZHZpc29yeUtpbmQpIHtcbiAgICBBZHZpc29yeUtpbmRbXCJBUElcIl0gPSBcImFwaV9hdWRpdFwiO1xuICAgIEFkdmlzb3J5S2luZFtcIlN0cmVhbUFjdGlvblwiXSA9IFwic3RyZWFtX2FjdGlvblwiO1xuICAgIEFkdmlzb3J5S2luZFtcIkNvbnN1bWVyQWN0aW9uXCJdID0gXCJjb25zdW1lcl9hY3Rpb25cIjtcbiAgICBBZHZpc29yeUtpbmRbXCJTbmFwc2hvdENyZWF0ZVwiXSA9IFwic25hcHNob3RfY3JlYXRlXCI7XG4gICAgQWR2aXNvcnlLaW5kW1wiU25hcHNob3RDb21wbGV0ZVwiXSA9IFwic25hcHNob3RfY29tcGxldGVcIjtcbiAgICBBZHZpc29yeUtpbmRbXCJSZXN0b3JlQ3JlYXRlXCJdID0gXCJyZXN0b3JlX2NyZWF0ZVwiO1xuICAgIEFkdmlzb3J5S2luZFtcIlJlc3RvcmVDb21wbGV0ZVwiXSA9IFwicmVzdG9yZV9jb21wbGV0ZVwiO1xuICAgIEFkdmlzb3J5S2luZFtcIk1heERlbGl2ZXJcIl0gPSBcIm1heF9kZWxpdmVyXCI7XG4gICAgQWR2aXNvcnlLaW5kW1wiVGVybWluYXRlZFwiXSA9IFwidGVybWluYXRlZFwiO1xuICAgIEFkdmlzb3J5S2luZFtcIkFja1wiXSA9IFwiY29uc3VtZXJfYWNrXCI7XG4gICAgQWR2aXNvcnlLaW5kW1wiU3RyZWFtTGVhZGVyRWxlY3RlZFwiXSA9IFwic3RyZWFtX2xlYWRlcl9lbGVjdGVkXCI7XG4gICAgQWR2aXNvcnlLaW5kW1wiU3RyZWFtUXVvcnVtTG9zdFwiXSA9IFwic3RyZWFtX3F1b3J1bV9sb3N0XCI7XG4gICAgQWR2aXNvcnlLaW5kW1wiQ29uc3VtZXJMZWFkZXJFbGVjdGVkXCJdID0gXCJjb25zdW1lcl9sZWFkZXJfZWxlY3RlZFwiO1xuICAgIEFkdmlzb3J5S2luZFtcIkNvbnN1bWVyUXVvcnVtTG9zdFwiXSA9IFwiY29uc3VtZXJfcXVvcnVtX2xvc3RcIjtcbn0pKEFkdmlzb3J5S2luZCB8fCAoQWR2aXNvcnlLaW5kID0ge30pKTtcbnZhciBKc0hlYWRlcnM7XG4oZnVuY3Rpb24oSnNIZWFkZXJzKSB7XG4gICAgSnNIZWFkZXJzW1wiU3RyZWFtU291cmNlSGRyXCJdID0gXCJOYXRzLVN0cmVhbS1Tb3VyY2VcIjtcbiAgICBKc0hlYWRlcnNbXCJMYXN0Q29uc3VtZXJTZXFIZHJcIl0gPSBcIk5hdHMtTGFzdC1Db25zdW1lclwiO1xuICAgIEpzSGVhZGVyc1tcIkxhc3RTdHJlYW1TZXFIZHJcIl0gPSBcIk5hdHMtTGFzdC1TdHJlYW1cIjtcbiAgICBKc0hlYWRlcnNbXCJDb25zdW1lclN0YWxsZWRIZHJcIl0gPSBcIk5hdHMtQ29uc3VtZXItU3RhbGxlZFwiO1xuICAgIEpzSGVhZGVyc1tcIk1lc3NhZ2VTaXplSGRyXCJdID0gXCJOYXRzLU1zZy1TaXplXCI7XG4gICAgSnNIZWFkZXJzW1wiUm9sbHVwSGRyXCJdID0gXCJOYXRzLVJvbGx1cFwiO1xuICAgIEpzSGVhZGVyc1tcIlJvbGx1cFZhbHVlU3ViamVjdFwiXSA9IFwic3ViXCI7XG4gICAgSnNIZWFkZXJzW1wiUm9sbHVwVmFsdWVBbGxcIl0gPSBcImFsbFwiO1xuICAgIEpzSGVhZGVyc1tcIlBlbmRpbmdNZXNzYWdlc0hkclwiXSA9IFwiTmF0cy1QZW5kaW5nLU1lc3NhZ2VzXCI7XG4gICAgSnNIZWFkZXJzW1wiUGVuZGluZ0J5dGVzSGRyXCJdID0gXCJOYXRzLVBlbmRpbmctQnl0ZXNcIjtcbn0pKEpzSGVhZGVycyB8fCAoSnNIZWFkZXJzID0ge30pKTtcbnZhciBLdldhdGNoSW5jbHVkZTtcbihmdW5jdGlvbihLdldhdGNoSW5jbHVkZSkge1xuICAgIEt2V2F0Y2hJbmNsdWRlW1wiTGFzdFZhbHVlXCJdID0gXCJcIjtcbiAgICBLdldhdGNoSW5jbHVkZVtcIkFsbEhpc3RvcnlcIl0gPSBcImhpc3RvcnlcIjtcbiAgICBLdldhdGNoSW5jbHVkZVtcIlVwZGF0ZXNPbmx5XCJdID0gXCJ1cGRhdGVzXCI7XG59KShLdldhdGNoSW5jbHVkZSB8fCAoS3ZXYXRjaEluY2x1ZGUgPSB7fSkpO1xudmFyIERpcmVjdE1zZ0hlYWRlcnM7XG4oZnVuY3Rpb24oRGlyZWN0TXNnSGVhZGVycykge1xuICAgIERpcmVjdE1zZ0hlYWRlcnNbXCJTdHJlYW1cIl0gPSBcIk5hdHMtU3RyZWFtXCI7XG4gICAgRGlyZWN0TXNnSGVhZGVyc1tcIlNlcXVlbmNlXCJdID0gXCJOYXRzLVNlcXVlbmNlXCI7XG4gICAgRGlyZWN0TXNnSGVhZGVyc1tcIlRpbWVTdGFtcFwiXSA9IFwiTmF0cy1UaW1lLVN0YW1wXCI7XG4gICAgRGlyZWN0TXNnSGVhZGVyc1tcIlN1YmplY3RcIl0gPSBcIk5hdHMtU3ViamVjdFwiO1xufSkoRGlyZWN0TXNnSGVhZGVycyB8fCAoRGlyZWN0TXNnSGVhZGVycyA9IHt9KSk7XG52YXIgUmVwdWJsaXNoSGVhZGVycztcbihmdW5jdGlvbihSZXB1Ymxpc2hIZWFkZXJzKSB7XG4gICAgUmVwdWJsaXNoSGVhZGVyc1tcIlN0cmVhbVwiXSA9IFwiTmF0cy1TdHJlYW1cIjtcbiAgICBSZXB1Ymxpc2hIZWFkZXJzW1wiU3ViamVjdFwiXSA9IFwiTmF0cy1TdWJqZWN0XCI7XG4gICAgUmVwdWJsaXNoSGVhZGVyc1tcIlNlcXVlbmNlXCJdID0gXCJOYXRzLVNlcXVlbmNlXCI7XG4gICAgUmVwdWJsaXNoSGVhZGVyc1tcIkxhc3RTZXF1ZW5jZVwiXSA9IFwiTmF0cy1MYXN0LVNlcXVlbmNlXCI7XG4gICAgUmVwdWJsaXNoSGVhZGVyc1tcIlNpemVcIl0gPSBcIk5hdHMtTXNnLVNpemVcIjtcbn0pKFJlcHVibGlzaEhlYWRlcnMgfHwgKFJlcHVibGlzaEhlYWRlcnMgPSB7fSkpO1xuY29uc3Qga3ZQcmVmaXggPSBcIktWX1wiO1xuY2xhc3MgQ29uc3VtZXJPcHRzQnVpbGRlckltcGwge1xuICAgIGNvbmZpZztcbiAgICBvcmRlcmVkO1xuICAgIG1hY2s7XG4gICAgc3RyZWFtO1xuICAgIGNhbGxiYWNrRm47XG4gICAgbWF4O1xuICAgIHFuYW1lO1xuICAgIGlzQmluZDtcbiAgICBmaWx0ZXJzO1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpe1xuICAgICAgICB0aGlzLnN0cmVhbSA9IFwiXCI7XG4gICAgICAgIHRoaXMubWFjayA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9yZGVyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBkZWZhdWx0Q29uc3VtZXIoXCJcIiwgb3B0cyB8fCB7fSk7XG4gICAgfVxuICAgIGdldE9wdHMoKSB7XG4gICAgICAgIGNvbnN0IG8gPSB7fTtcbiAgICAgICAgby5jb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbmZpZyk7XG4gICAgICAgIGlmIChvLmNvbmZpZy5maWx0ZXJfc3ViamVjdCkge1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJTdWJqZWN0KG8uY29uZmlnLmZpbHRlcl9zdWJqZWN0KTtcbiAgICAgICAgICAgIG8uY29uZmlnLmZpbHRlcl9zdWJqZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvLmNvbmZpZy5maWx0ZXJfc3ViamVjdHMpIHtcbiAgICAgICAgICAgIG8uY29uZmlnLmZpbHRlcl9zdWJqZWN0cz8uZm9yRWFjaCgodik9PntcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlclN1YmplY3Qodik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG8uY29uZmlnLmZpbHRlcl9zdWJqZWN0cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBvLm1hY2sgPSB0aGlzLm1hY2s7XG4gICAgICAgIG8uc3RyZWFtID0gdGhpcy5zdHJlYW07XG4gICAgICAgIG8uY2FsbGJhY2tGbiA9IHRoaXMuY2FsbGJhY2tGbjtcbiAgICAgICAgby5tYXggPSB0aGlzLm1heDtcbiAgICAgICAgby5xdWV1ZSA9IHRoaXMucW5hbWU7XG4gICAgICAgIG8ub3JkZXJlZCA9IHRoaXMub3JkZXJlZDtcbiAgICAgICAgby5jb25maWcuYWNrX3BvbGljeSA9IG8ub3JkZXJlZCA/IEFja1BvbGljeS5Ob25lIDogby5jb25maWcuYWNrX3BvbGljeTtcbiAgICAgICAgby5pc0JpbmQgPSBvLmlzQmluZCB8fCBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVycykge1xuICAgICAgICAgICAgc3dpdGNoKHRoaXMuZmlsdGVycy5sZW5ndGgpe1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBvLmNvbmZpZy5maWx0ZXJfc3ViamVjdCA9IHRoaXMuZmlsdGVyc1swXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgby5jb25maWcuZmlsdGVyX3N1YmplY3RzID0gdGhpcy5maWx0ZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvO1xuICAgIH1cbiAgICBkZXNjcmlwdGlvbihkZXNjcmlwdGlvbikge1xuICAgICAgICB0aGlzLmNvbmZpZy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVsaXZlclRvKHN1YmplY3QpIHtcbiAgICAgICAgdGhpcy5jb25maWcuZGVsaXZlcl9zdWJqZWN0ID0gc3ViamVjdDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGR1cmFibGUobmFtZSkge1xuICAgICAgICB2YWxpZGF0ZUR1cmFibGVOYW1lKG5hbWUpO1xuICAgICAgICB0aGlzLmNvbmZpZy5kdXJhYmxlX25hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3RhcnRTZXF1ZW5jZShzZXEpIHtcbiAgICAgICAgaWYgKHNlcSA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZXF1ZW5jZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29uZmlnLmRlbGl2ZXJfcG9saWN5ID0gRGVsaXZlclBvbGljeS5TdGFydFNlcXVlbmNlO1xuICAgICAgICB0aGlzLmNvbmZpZy5vcHRfc3RhcnRfc2VxID0gc2VxO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3RhcnRUaW1lKHRpbWUpIHtcbiAgICAgICAgdGhpcy5jb25maWcuZGVsaXZlcl9wb2xpY3kgPSBEZWxpdmVyUG9saWN5LlN0YXJ0VGltZTtcbiAgICAgICAgdGhpcy5jb25maWcub3B0X3N0YXJ0X3RpbWUgPSB0aW1lLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZWxpdmVyQWxsKCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5kZWxpdmVyX3BvbGljeSA9IERlbGl2ZXJQb2xpY3kuQWxsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVsaXZlckxhc3RQZXJTdWJqZWN0KCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5kZWxpdmVyX3BvbGljeSA9IERlbGl2ZXJQb2xpY3kuTGFzdFBlclN1YmplY3Q7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZWxpdmVyTGFzdCgpIHtcbiAgICAgICAgdGhpcy5jb25maWcuZGVsaXZlcl9wb2xpY3kgPSBEZWxpdmVyUG9saWN5Lkxhc3Q7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZWxpdmVyTmV3KCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5kZWxpdmVyX3BvbGljeSA9IERlbGl2ZXJQb2xpY3kuTmV3O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3RhcnRBdFRpbWVEZWx0YShtaWxsaXMpIHtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUobmV3IERhdGUoRGF0ZS5ub3coKSAtIG1pbGxpcykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaGVhZGVyc09ubHkoKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmhlYWRlcnNfb25seSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhY2tOb25lKCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5hY2tfcG9saWN5ID0gQWNrUG9saWN5Lk5vbmU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhY2tBbGwoKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmFja19wb2xpY3kgPSBBY2tQb2xpY3kuQWxsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWNrRXhwbGljaXQoKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmFja19wb2xpY3kgPSBBY2tQb2xpY3kuRXhwbGljaXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhY2tXYWl0KG1pbGxpcykge1xuICAgICAgICB0aGlzLmNvbmZpZy5hY2tfd2FpdCA9IG5hbm9zKG1pbGxpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBtYXhEZWxpdmVyKG1heCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5tYXhfZGVsaXZlciA9IG1heDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZpbHRlclN1YmplY3Qocykge1xuICAgICAgICB0aGlzLmZpbHRlcnMgPSB0aGlzLmZpbHRlcnMgfHwgW107XG4gICAgICAgIHRoaXMuZmlsdGVycy5wdXNoKHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVwbGF5SW5zdGFudGx5KCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5yZXBsYXlfcG9saWN5ID0gUmVwbGF5UG9saWN5Lkluc3RhbnQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXBsYXlPcmlnaW5hbCgpIHtcbiAgICAgICAgdGhpcy5jb25maWcucmVwbGF5X3BvbGljeSA9IFJlcGxheVBvbGljeS5PcmlnaW5hbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNhbXBsZShuKSB7XG4gICAgICAgIG4gPSBNYXRoLnRydW5jKG4pO1xuICAgICAgICBpZiAobiA8IDAgfHwgbiA+IDEwMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2YWx1ZSBtdXN0IGJlIGJldHdlZW4gMC0xMDBgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbmZpZy5zYW1wbGVfZnJlcSA9IGAke259JWA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBsaW1pdChuKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLnJhdGVfbGltaXRfYnBzID0gbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG1heFdhaXRpbmcobWF4KSB7XG4gICAgICAgIHRoaXMuY29uZmlnLm1heF93YWl0aW5nID0gbWF4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbWF4QWNrUGVuZGluZyhtYXgpIHtcbiAgICAgICAgdGhpcy5jb25maWcubWF4X2Fja19wZW5kaW5nID0gbWF4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWRsZUhlYXJ0YmVhdChtaWxsaXMpIHtcbiAgICAgICAgdGhpcy5jb25maWcuaWRsZV9oZWFydGJlYXQgPSBuYW5vcyhtaWxsaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZmxvd0NvbnRyb2woKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmZsb3dfY29udHJvbCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZWxpdmVyR3JvdXAobmFtZSkge1xuICAgICAgICB0aGlzLnF1ZXVlKG5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbWFudWFsQWNrKCkge1xuICAgICAgICB0aGlzLm1hY2sgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbWF4TWVzc2FnZXMobWF4KSB7XG4gICAgICAgIHRoaXMubWF4ID0gbWF4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY2FsbGJhY2soZm4pIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja0ZuID0gZm47XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBxdWV1ZShuKSB7XG4gICAgICAgIHRoaXMucW5hbWUgPSBuO1xuICAgICAgICB0aGlzLmNvbmZpZy5kZWxpdmVyX2dyb3VwID0gbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9yZGVyZWRDb25zdW1lcigpIHtcbiAgICAgICAgdGhpcy5vcmRlcmVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGJpbmQoc3RyZWFtLCBkdXJhYmxlKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICB0aGlzLmNvbmZpZy5kdXJhYmxlX25hbWUgPSBkdXJhYmxlO1xuICAgICAgICB0aGlzLmlzQmluZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBiaW5kU3RyZWFtKHN0cmVhbSkge1xuICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGluYWN0aXZlRXBoZW1lcmFsVGhyZXNob2xkKG1pbGxpcykge1xuICAgICAgICB0aGlzLmNvbmZpZy5pbmFjdGl2ZV90aHJlc2hvbGQgPSBuYW5vcyhtaWxsaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbWF4UHVsbEJhdGNoKG4pIHtcbiAgICAgICAgdGhpcy5jb25maWcubWF4X2JhdGNoID0gbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG1heFB1bGxSZXF1ZXN0RXhwaXJlcyhtaWxsaXMpIHtcbiAgICAgICAgdGhpcy5jb25maWcubWF4X2V4cGlyZXMgPSBuYW5vcyhtaWxsaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbWVtb3J5KCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5tZW1fc3RvcmFnZSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBudW1SZXBsaWNhcyhuKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLm51bV9yZXBsaWNhcyA9IG47XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdW1lck5hbWUobikge1xuICAgICAgICB0aGlzLmNvbmZpZy5uYW1lID0gbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZnVuY3Rpb24gY29uc3VtZXJPcHRzKG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IENvbnN1bWVyT3B0c0J1aWxkZXJJbXBsKG9wdHMpO1xufVxuZnVuY3Rpb24gaXNDb25zdW1lck9wdHNCdWlsZGVyKG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIG8uZ2V0T3B0cyA9PT0gXCJmdW5jdGlvblwiO1xufVxuY2xhc3MgQmFzZTY0Q29kZWMge1xuICAgIHN0YXRpYyBlbmNvZGUoYnl0ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBieXRlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGJ0b2EoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGEgPSBBcnJheS5mcm9tKGJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZSguLi5hKSk7XG4gICAgfVxuICAgIHN0YXRpYyBkZWNvZGUocywgYmluYXJ5ID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgYmluID0gYXRvYihzKTtcbiAgICAgICAgaWYgKCFiaW5hcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBiaW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShiaW4sIChjKT0+Yy5jaGFyQ29kZUF0KDApKTtcbiAgICB9XG59XG5jbGFzcyBCYXNlNjRVcmxQYWRkZWRDb2RlYyB7XG4gICAgc3RhdGljIGVuY29kZShieXRlcykge1xuICAgICAgICByZXR1cm4gQmFzZTY0VXJsUGFkZGVkQ29kZWMudG9CNjRVUkxFbmNvZGluZyhCYXNlNjRDb2RlYy5lbmNvZGUoYnl0ZXMpKTtcbiAgICB9XG4gICAgc3RhdGljIGRlY29kZShzLCBiaW5hcnkgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gQmFzZTY0VXJsUGFkZGVkQ29kZWMuZGVjb2RlKEJhc2U2NFVybFBhZGRlZENvZGVjLmZyb21CNjRVUkxFbmNvZGluZyhzKSwgYmluYXJ5KTtcbiAgICB9XG4gICAgc3RhdGljIHRvQjY0VVJMRW5jb2RpbmcoYjY0c3RyKSB7XG4gICAgICAgIHJldHVybiBiNjRzdHIucmVwbGFjZSgvXFwrL2csIFwiLVwiKS5yZXBsYWNlKC9cXC8vZywgXCJfXCIpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUI2NFVSTEVuY29kaW5nKGI2NHN0cikge1xuICAgICAgICByZXR1cm4gYjY0c3RyLnJlcGxhY2UoL18vZywgXCIvXCIpLnJlcGxhY2UoLy0vZywgXCIrXCIpO1xuICAgIH1cbn1cbmNsYXNzIERhdGFCdWZmZXIge1xuICAgIGJ1ZmZlcnM7XG4gICAgYnl0ZUxlbmd0aDtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gMDtcbiAgICB9XG4gICAgc3RhdGljIGNvbmNhdCguLi5idWZzKSB7XG4gICAgICAgIGxldCBtYXggPSAwO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgYnVmcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBtYXggKz0gYnVmc1tpXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkobWF4KTtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGJ1ZnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgb3V0LnNldChidWZzW2ldLCBpbmRleCk7XG4gICAgICAgICAgICBpbmRleCArPSBidWZzW2ldLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUFzY2lpKG0pIHtcbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICBtID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVEUuZW5jb2RlKG0pO1xuICAgIH1cbiAgICBzdGF0aWMgdG9Bc2NpaShhKSB7XG4gICAgICAgIHJldHVybiBURC5kZWNvZGUoYSk7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLmJ1ZmZlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gMDtcbiAgICB9XG4gICAgcGFjaygpIHtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVycy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5idWZmZXJzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICB2LnNldCh0aGlzLmJ1ZmZlcnNbaV0sIGluZGV4KTtcbiAgICAgICAgICAgICAgICBpbmRleCArPSB0aGlzLmJ1ZmZlcnNbaV0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5idWZmZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcnMucHVzaCh2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzaGlmdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzLmJ1ZmZlcnMuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ieXRlTGVuZ3RoIC09IGEubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICB9XG4gICAgZHJhaW4obikge1xuICAgICAgICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wYWNrKCk7XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy5idWZmZXJzLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXggPSB0aGlzLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IHVuZGVmaW5lZCB8fCBuID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIG4gPSBtYXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGQgPSB2LnN1YmFycmF5KDAsIG4pO1xuICAgICAgICAgICAgICAgIGlmIChtYXggPiBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVycy5wdXNoKHYuc3ViYXJyYXkobikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmJ5dGVMZW5ndGggPSBtYXggLSBuO1xuICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICB9XG4gICAgZmlsbChhLCAuLi5idWZzKSB7XG4gICAgICAgIGlmIChhKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcnMucHVzaChhKTtcbiAgICAgICAgICAgIHRoaXMuYnl0ZUxlbmd0aCArPSBhLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgYnVmcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBpZiAoYnVmc1tpXSAmJiBidWZzW2ldLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVycy5wdXNoKGJ1ZnNbaV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuYnl0ZUxlbmd0aCArPSBidWZzW2ldLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwZWVrKCkge1xuICAgICAgICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wYWNrKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJzWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICB9XG4gICAgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJzLmxlbmd0aDtcbiAgICB9XG59XG5mdW5jdGlvbiB0KHQsIGUpIHtcbiAgICByZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZSAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiBlICYmICFBcnJheS5pc0FycmF5KGUpICYmIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgaWYgKFwiZGVmYXVsdFwiICE9PSByICYmICEociBpbiB0KSkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgciwgaS5nZXQgPyBpIDoge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlW3JdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pLCBPYmplY3QuZnJlZXplKHQpO1xufVxudmFyIGUgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBnbG9iYWwgPyBnbG9iYWwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBzZWxmID8gc2VsZiA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHdpbmRvdyA/IHdpbmRvdyA6IHt9O1xuZnVuY3Rpb24gcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpO1xufVxuZnVuY3Rpb24gaSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIik7XG59XG52YXIgaCA9IHIsIHMgPSBpO1xuZnVuY3Rpb24gbih0KSB7XG4gICAgaWYgKGggPT09IHNldFRpbWVvdXQpIHJldHVybiBzZXRUaW1lb3V0KHQsIDApO1xuICAgIGlmICgoaCA9PT0gciB8fCAhaCkgJiYgc2V0VGltZW91dCkgcmV0dXJuIGggPSBzZXRUaW1lb3V0LCBzZXRUaW1lb3V0KHQsIDApO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBoKHQsIDApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBoLmNhbGwobnVsbCwgdCwgMCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBoLmNhbGwodGhpcywgdCwgMCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUuc2V0VGltZW91dCAmJiAoaCA9IHNldFRpbWVvdXQpLCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUuY2xlYXJUaW1lb3V0ICYmIChzID0gY2xlYXJUaW1lb3V0KTtcbnZhciBvLCBhID0gW10sIGYgPSAhMSwgdSA9IC0xO1xuZnVuY3Rpb24gYygpIHtcbiAgICBmICYmIG8gJiYgKGYgPSAhMSwgby5sZW5ndGggPyBhID0gby5jb25jYXQoYSkgOiB1ID0gLTEsIGEubGVuZ3RoICYmIGwoKSk7XG59XG5mdW5jdGlvbiBsKCkge1xuICAgIGlmICghZikge1xuICAgICAgICB2YXIgdCA9IG4oYyk7XG4gICAgICAgIGYgPSAhMDtcbiAgICAgICAgZm9yKHZhciBlID0gYS5sZW5ndGg7IGU7KXtcbiAgICAgICAgICAgIGZvcihvID0gYSwgYSA9IFtdOyArK3UgPCBlOylvICYmIG9bdV0ucnVuKCk7XG4gICAgICAgICAgICB1ID0gLTEsIGUgPSBhLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBvID0gbnVsbCwgZiA9ICExLCBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICBpZiAocyA9PT0gY2xlYXJUaW1lb3V0KSByZXR1cm4gY2xlYXJUaW1lb3V0KHQpO1xuICAgICAgICAgICAgaWYgKChzID09PSBpIHx8ICFzKSAmJiBjbGVhclRpbWVvdXQpIHJldHVybiBzID0gY2xlYXJUaW1lb3V0LCBjbGVhclRpbWVvdXQodCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzKHQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzLmNhbGwobnVsbCwgdCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5jYWxsKHRoaXMsIHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSh0KTtcbiAgICB9XG59XG5mdW5jdGlvbiB5KHQsIGUpIHtcbiAgICB0aGlzLmZ1biA9IHQsIHRoaXMuYXJyYXkgPSBlO1xufVxueS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xuZnVuY3Rpb24gcCgpIHt9XG52YXIgZCA9IHAsIHcgPSBwLCBiID0gcCwgdiA9IHAsIEEgPSBwLCBnID0gcCwgXyA9IHA7XG52YXIgbSA9IGUucGVyZm9ybWFuY2UgfHwge30sIE8gPSBtLm5vdyB8fCBtLm1vek5vdyB8fCBtLm1zTm93IHx8IG0ub05vdyB8fCBtLndlYmtpdE5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKG5ldyBEYXRlKS5nZXRUaW1lKCk7XG59O1xudmFyIEIgPSBuZXcgRGF0ZTtcbnZhciBFID0ge1xuICAgIG5leHRUaWNrOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciBlID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSBmb3IodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKWVbciAtIDFdID0gYXJndW1lbnRzW3JdO1xuICAgICAgICBhLnB1c2gobmV3IHkodCwgZSkpLCAxICE9PSBhLmxlbmd0aCB8fCBmIHx8IG4obCk7XG4gICAgfSxcbiAgICB0aXRsZTogXCJicm93c2VyXCIsXG4gICAgYnJvd3NlcjogITAsXG4gICAgZW52OiB7fSxcbiAgICBhcmd2OiBbXSxcbiAgICB2ZXJzaW9uOiBcIlwiLFxuICAgIHZlcnNpb25zOiB7fSxcbiAgICBvbjogZCxcbiAgICBhZGRMaXN0ZW5lcjogdyxcbiAgICBvbmNlOiBiLFxuICAgIG9mZjogdixcbiAgICByZW1vdmVMaXN0ZW5lcjogQSxcbiAgICByZW1vdmVBbGxMaXN0ZW5lcnM6IGcsXG4gICAgZW1pdDogXyxcbiAgICBiaW5kaW5nOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgIH0sXG4gICAgY3dkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFwiL1wiO1xuICAgIH0sXG4gICAgY2hkaXI6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgIH0sXG4gICAgdW1hc2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIGhydGltZTogZnVuY3Rpb24odCkge1xuICAgICAgICB2YXIgZSA9IC4wMDEgKiBPLmNhbGwobSksIHIgPSBNYXRoLmZsb29yKGUpLCBpID0gTWF0aC5mbG9vcihlICUgMSAqIDFlOSk7XG4gICAgICAgIHJldHVybiB0ICYmIChyIC09IHRbMF0sIChpIC09IHRbMV0pIDwgMCAmJiAoci0tLCBpICs9IDFlOSkpLCBbXG4gICAgICAgICAgICByLFxuICAgICAgICAgICAgaVxuICAgICAgICBdO1xuICAgIH0sXG4gICAgcGxhdGZvcm06IFwiYnJvd3NlclwiLFxuICAgIHJlbGVhc2U6IHt9LFxuICAgIGNvbmZpZzoge30sXG4gICAgdXB0aW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChuZXcgRGF0ZSAtIEIpIC8gMWUzO1xuICAgIH1cbn0sIFMgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBnbG9iYWxUaGlzID8gZ2xvYmFsVGhpcyA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHdpbmRvdyA/IHdpbmRvdyA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGdsb2JhbCA/IGdsb2JhbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHNlbGYgPyBzZWxmIDoge307XG5mdW5jdGlvbiBUKHQpIHtcbiAgICBpZiAodC5fX2VzTW9kdWxlKSByZXR1cm4gdDtcbiAgICB2YXIgZSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgdmFsdWU6ICEwXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHQpLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgICB2YXIgaSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcik7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBpLmdldCA/IGkgOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRbcl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pLCBlO1xufVxudmFyIGssIHggPSB7XG4gICAgZXhwb3J0czoge31cbn0sIGogPSB7fSwgTiA9IFQodCh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGRlZmF1bHQ6IGpcbn0sIFtcbiAgICBqXG5dKSk7XG5rID0geCwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSBcImlucHV0IGlzIGludmFsaWQgdHlwZVwiLCBlID0gXCJvYmplY3RcIiA9PSB0eXBlb2Ygd2luZG93LCByID0gZSA/IHdpbmRvdyA6IHt9O1xuICAgIHIuSlNfU0hBMjU2X05PX1dJTkRPVyAmJiAoZSA9ICExKTtcbiAgICB2YXIgaSA9ICFlICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIHNlbGYsIGggPSAhci5KU19TSEEyNTZfTk9fTk9ERV9KUyAmJiBFLnZlcnNpb25zICYmIEUudmVyc2lvbnMubm9kZTtcbiAgICBoID8gciA9IFMgOiBpICYmIChyID0gc2VsZik7XG4gICAgdmFyIHMgPSAhci5KU19TSEEyNTZfTk9fQ09NTU9OX0pTICYmIGsuZXhwb3J0cywgbiA9ICFyLkpTX1NIQTI1Nl9OT19BUlJBWV9CVUZGRVIgJiYgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgQXJyYXlCdWZmZXIsIG8gPSBcIjAxMjM0NTY3ODlhYmNkZWZcIi5zcGxpdChcIlwiKSwgYSA9IFtcbiAgICAgICAgLTIxNDc0ODM2NDgsXG4gICAgICAgIDgzODg2MDgsXG4gICAgICAgIDMyNzY4LFxuICAgICAgICAxMjhcbiAgICBdLCBmID0gW1xuICAgICAgICAyNCxcbiAgICAgICAgMTYsXG4gICAgICAgIDgsXG4gICAgICAgIDBcbiAgICBdLCB1ID0gW1xuICAgICAgICAxMTE2MzUyNDA4LFxuICAgICAgICAxODk5NDQ3NDQxLFxuICAgICAgICAzMDQ5MzIzNDcxLFxuICAgICAgICAzOTIxMDA5NTczLFxuICAgICAgICA5NjE5ODcxNjMsXG4gICAgICAgIDE1MDg5NzA5OTMsXG4gICAgICAgIDI0NTM2MzU3NDgsXG4gICAgICAgIDI4NzA3NjMyMjEsXG4gICAgICAgIDM2MjQzODEwODAsXG4gICAgICAgIDMxMDU5ODQwMSxcbiAgICAgICAgNjA3MjI1Mjc4LFxuICAgICAgICAxNDI2ODgxOTg3LFxuICAgICAgICAxOTI1MDc4Mzg4LFxuICAgICAgICAyMTYyMDc4MjA2LFxuICAgICAgICAyNjE0ODg4MTAzLFxuICAgICAgICAzMjQ4MjIyNTgwLFxuICAgICAgICAzODM1MzkwNDAxLFxuICAgICAgICA0MDIyMjI0Nzc0LFxuICAgICAgICAyNjQzNDcwNzgsXG4gICAgICAgIDYwNDgwNzYyOCxcbiAgICAgICAgNzcwMjU1OTgzLFxuICAgICAgICAxMjQ5MTUwMTIyLFxuICAgICAgICAxNTU1MDgxNjkyLFxuICAgICAgICAxOTk2MDY0OTg2LFxuICAgICAgICAyNTU0MjIwODgyLFxuICAgICAgICAyODIxODM0MzQ5LFxuICAgICAgICAyOTUyOTk2ODA4LFxuICAgICAgICAzMjEwMzEzNjcxLFxuICAgICAgICAzMzM2NTcxODkxLFxuICAgICAgICAzNTg0NTI4NzExLFxuICAgICAgICAxMTM5MjY5OTMsXG4gICAgICAgIDMzODI0MTg5NSxcbiAgICAgICAgNjY2MzA3MjA1LFxuICAgICAgICA3NzM1Mjk5MTIsXG4gICAgICAgIDEyOTQ3NTczNzIsXG4gICAgICAgIDEzOTYxODIyOTEsXG4gICAgICAgIDE2OTUxODM3MDAsXG4gICAgICAgIDE5ODY2NjEwNTEsXG4gICAgICAgIDIxNzcwMjYzNTAsXG4gICAgICAgIDI0NTY5NTYwMzcsXG4gICAgICAgIDI3MzA0ODU5MjEsXG4gICAgICAgIDI4MjAzMDI0MTEsXG4gICAgICAgIDMyNTk3MzA4MDAsXG4gICAgICAgIDMzNDU3NjQ3NzEsXG4gICAgICAgIDM1MTYwNjU4MTcsXG4gICAgICAgIDM2MDAzNTI4MDQsXG4gICAgICAgIDQwOTQ1NzE5MDksXG4gICAgICAgIDI3NTQyMzM0NCxcbiAgICAgICAgNDMwMjI3NzM0LFxuICAgICAgICA1MDY5NDg2MTYsXG4gICAgICAgIDY1OTA2MDU1NixcbiAgICAgICAgODgzOTk3ODc3LFxuICAgICAgICA5NTgxMzk1NzEsXG4gICAgICAgIDEzMjI4MjIyMTgsXG4gICAgICAgIDE1MzcwMDIwNjMsXG4gICAgICAgIDE3NDc4NzM3NzksXG4gICAgICAgIDE5NTU1NjIyMjIsXG4gICAgICAgIDIwMjQxMDQ4MTUsXG4gICAgICAgIDIyMjc3MzA0NTIsXG4gICAgICAgIDIzNjE4NTI0MjQsXG4gICAgICAgIDI0Mjg0MzY0NzQsXG4gICAgICAgIDI3NTY3MzQxODcsXG4gICAgICAgIDMyMDQwMzE0NzksXG4gICAgICAgIDMzMjkzMjUyOThcbiAgICBdLCBjID0gW1xuICAgICAgICBcImhleFwiLFxuICAgICAgICBcImFycmF5XCIsXG4gICAgICAgIFwiZGlnZXN0XCIsXG4gICAgICAgIFwiYXJyYXlCdWZmZXJcIlxuICAgIF0sIGwgPSBbXTtcbiAgICAhci5KU19TSEEyNTZfTk9fTk9ERV9KUyAmJiBBcnJheS5pc0FycmF5IHx8IChBcnJheS5pc0FycmF5ID0gZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gXCJbb2JqZWN0IEFycmF5XVwiID09PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCk7XG4gICAgfSksICFuIHx8ICFyLkpTX1NIQTI1Nl9OT19BUlJBWV9CVUZGRVJfSVNfVklFVyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcgfHwgKEFycmF5QnVmZmVyLmlzVmlldyA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIFwib2JqZWN0XCIgPT0gdHlwZW9mIHQgJiYgdC5idWZmZXIgJiYgdC5idWZmZXIuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyO1xuICAgIH0pO1xuICAgIHZhciB5ID0gZnVuY3Rpb24odCwgZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB2KGUsICEwKS51cGRhdGUocilbdF0oKTtcbiAgICAgICAgfTtcbiAgICB9LCBwID0gZnVuY3Rpb24odCkge1xuICAgICAgICB2YXIgZSA9IHkoXCJoZXhcIiwgdCk7XG4gICAgICAgIGggJiYgKGUgPSBkKGUsIHQpKSwgZS5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdih0KTtcbiAgICAgICAgfSwgZS51cGRhdGUgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICByZXR1cm4gZS5jcmVhdGUoKS51cGRhdGUodCk7XG4gICAgICAgIH07XG4gICAgICAgIGZvcih2YXIgciA9IDA7IHIgPCBjLmxlbmd0aDsgKytyKXtcbiAgICAgICAgICAgIHZhciBpID0gY1tyXTtcbiAgICAgICAgICAgIGVbaV0gPSB5KGksIHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH0sIGQgPSBmdW5jdGlvbihlLCBpKSB7XG4gICAgICAgIHZhciBoLCBzID0gTiwgbiA9IE4uQnVmZmVyLCBvID0gaSA/IFwic2hhMjI0XCIgOiBcInNoYTI1NlwiO1xuICAgICAgICByZXR1cm4gaCA9IG4uZnJvbSAmJiAhci5KU19TSEEyNTZfTk9fQlVGRkVSX0ZST00gPyBuLmZyb20gOiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IG4odCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gcy5jcmVhdGVIYXNoKG8pLnVwZGF0ZShyLCBcInV0ZjhcIikuZGlnZXN0KFwiaGV4XCIpO1xuICAgICAgICAgICAgaWYgKG51bGwgPT0gcikgdGhyb3cgbmV3IEVycm9yKHQpO1xuICAgICAgICAgICAgcmV0dXJuIHIuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyICYmIChyID0gbmV3IFVpbnQ4QXJyYXkocikpLCBBcnJheS5pc0FycmF5KHIpIHx8IEFycmF5QnVmZmVyLmlzVmlldyhyKSB8fCByLmNvbnN0cnVjdG9yID09PSBuID8gcy5jcmVhdGVIYXNoKG8pLnVwZGF0ZShoKHIpKS5kaWdlc3QoXCJoZXhcIikgOiBlKHIpO1xuICAgICAgICB9O1xuICAgIH0sIHcgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihyLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEEociwgZSwgITApLnVwZGF0ZShpKVt0XSgpO1xuICAgICAgICB9O1xuICAgIH0sIGIgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciBlID0gdyhcImhleFwiLCB0KTtcbiAgICAgICAgZS5jcmVhdGUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEEoZSwgdCk7XG4gICAgICAgIH0sIGUudXBkYXRlID0gZnVuY3Rpb24odCwgcikge1xuICAgICAgICAgICAgcmV0dXJuIGUuY3JlYXRlKHQpLnVwZGF0ZShyKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yKHZhciByID0gMDsgciA8IGMubGVuZ3RoOyArK3Ipe1xuICAgICAgICAgICAgdmFyIGkgPSBjW3JdO1xuICAgICAgICAgICAgZVtpXSA9IHcoaSwgdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgICBmdW5jdGlvbiB2KHQsIGUpIHtcbiAgICAgICAgZSA/IChsWzBdID0gbFsxNl0gPSBsWzFdID0gbFsyXSA9IGxbM10gPSBsWzRdID0gbFs1XSA9IGxbNl0gPSBsWzddID0gbFs4XSA9IGxbOV0gPSBsWzEwXSA9IGxbMTFdID0gbFsxMl0gPSBsWzEzXSA9IGxbMTRdID0gbFsxNV0gPSAwLCB0aGlzLmJsb2NrcyA9IGwpIDogdGhpcy5ibG9ja3MgPSBbXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMFxuICAgICAgICBdLCB0ID8gKHRoaXMuaDAgPSAzMjM4MzcxMDMyLCB0aGlzLmgxID0gOTE0MTUwNjYzLCB0aGlzLmgyID0gODEyNzAyOTk5LCB0aGlzLmgzID0gNDE0NDkxMjY5NywgdGhpcy5oNCA9IDQyOTA3NzU4NTcsIHRoaXMuaDUgPSAxNzUwNjAzMDI1LCB0aGlzLmg2ID0gMTY5NDA3NjgzOSwgdGhpcy5oNyA9IDMyMDQwNzU0MjgpIDogKHRoaXMuaDAgPSAxNzc5MDMzNzAzLCB0aGlzLmgxID0gMzE0NDEzNDI3NywgdGhpcy5oMiA9IDEwMTM5MDQyNDIsIHRoaXMuaDMgPSAyNzczNDgwNzYyLCB0aGlzLmg0ID0gMTM1OTg5MzExOSwgdGhpcy5oNSA9IDI2MDA4MjI5MjQsIHRoaXMuaDYgPSA1Mjg3MzQ2MzUsIHRoaXMuaDcgPSAxNTQxNDU5MjI1KSwgdGhpcy5ibG9jayA9IHRoaXMuc3RhcnQgPSB0aGlzLmJ5dGVzID0gdGhpcy5oQnl0ZXMgPSAwLCB0aGlzLmZpbmFsaXplZCA9IHRoaXMuaGFzaGVkID0gITEsIHRoaXMuZmlyc3QgPSAhMCwgdGhpcy5pczIyNCA9IHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEEoZSwgciwgaSkge1xuICAgICAgICB2YXIgaCwgcyA9IHR5cGVvZiBlO1xuICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gcykge1xuICAgICAgICAgICAgdmFyIG8sIGEgPSBbXSwgZiA9IGUubGVuZ3RoLCB1ID0gMDtcbiAgICAgICAgICAgIGZvcihoID0gMDsgaCA8IGY7ICsraCkobyA9IGUuY2hhckNvZGVBdChoKSkgPCAxMjggPyBhW3UrK10gPSBvIDogbyA8IDIwNDggPyAoYVt1KytdID0gMTkyIHwgbyA+Pj4gNiwgYVt1KytdID0gMTI4IHwgNjMgJiBvKSA6IG8gPCA1NTI5NiB8fCBvID49IDU3MzQ0ID8gKGFbdSsrXSA9IDIyNCB8IG8gPj4+IDEyLCBhW3UrK10gPSAxMjggfCBvID4+PiA2ICYgNjMsIGFbdSsrXSA9IDEyOCB8IDYzICYgbykgOiAobyA9IDY1NTM2ICsgKCgxMDIzICYgbykgPDwgMTAgfCAxMDIzICYgZS5jaGFyQ29kZUF0KCsraCkpLCBhW3UrK10gPSAyNDAgfCBvID4+PiAxOCwgYVt1KytdID0gMTI4IHwgbyA+Pj4gMTIgJiA2MywgYVt1KytdID0gMTI4IHwgbyA+Pj4gNiAmIDYzLCBhW3UrK10gPSAxMjggfCA2MyAmIG8pO1xuICAgICAgICAgICAgZSA9IGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoXCJvYmplY3RcIiAhPT0gcykgdGhyb3cgbmV3IEVycm9yKHQpO1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IGUpIHRocm93IG5ldyBFcnJvcih0KTtcbiAgICAgICAgICAgIGlmIChuICYmIGUuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKSBlID0gbmV3IFVpbnQ4QXJyYXkoZSk7XG4gICAgICAgICAgICBlbHNlIGlmICghKEFycmF5LmlzQXJyYXkoZSkgfHwgbiAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcoZSkpKSB0aHJvdyBuZXcgRXJyb3IodCk7XG4gICAgICAgIH1cbiAgICAgICAgZS5sZW5ndGggPiA2NCAmJiAoZSA9IG5ldyB2KHIsICEwKS51cGRhdGUoZSkuYXJyYXkoKSk7XG4gICAgICAgIHZhciBjID0gW10sIGwgPSBbXTtcbiAgICAgICAgZm9yKGggPSAwOyBoIDwgNjQ7ICsraCl7XG4gICAgICAgICAgICB2YXIgeSA9IGVbaF0gfHwgMDtcbiAgICAgICAgICAgIGNbaF0gPSA5MiBeIHksIGxbaF0gPSA1NCBeIHk7XG4gICAgICAgIH1cbiAgICAgICAgdi5jYWxsKHRoaXMsIHIsIGkpLCB0aGlzLnVwZGF0ZShsKSwgdGhpcy5vS2V5UGFkID0gYywgdGhpcy5pbm5lciA9ICEwLCB0aGlzLnNoYXJlZE1lbW9yeSA9IGk7XG4gICAgfVxuICAgIHYucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpbmFsaXplZCkge1xuICAgICAgICAgICAgdmFyIHIsIGkgPSB0eXBlb2YgZTtcbiAgICAgICAgICAgIGlmIChcInN0cmluZ1wiICE9PSBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgIT09IGkpIHRocm93IG5ldyBFcnJvcih0KTtcbiAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gZSkgdGhyb3cgbmV3IEVycm9yKHQpO1xuICAgICAgICAgICAgICAgIGlmIChuICYmIGUuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKSBlID0gbmV3IFVpbnQ4QXJyYXkoZSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIShBcnJheS5pc0FycmF5KGUpIHx8IG4gJiYgQXJyYXlCdWZmZXIuaXNWaWV3KGUpKSkgdGhyb3cgbmV3IEVycm9yKHQpO1xuICAgICAgICAgICAgICAgIHIgPSAhMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcih2YXIgaCwgcywgbyA9IDAsIGEgPSBlLmxlbmd0aCwgdSA9IHRoaXMuYmxvY2tzOyBvIDwgYTspe1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc2hlZCAmJiAodGhpcy5oYXNoZWQgPSAhMSwgdVswXSA9IHRoaXMuYmxvY2ssIHRoaXMuYmxvY2sgPSB1WzE2XSA9IHVbMV0gPSB1WzJdID0gdVszXSA9IHVbNF0gPSB1WzVdID0gdVs2XSA9IHVbN10gPSB1WzhdID0gdVs5XSA9IHVbMTBdID0gdVsxMV0gPSB1WzEyXSA9IHVbMTNdID0gdVsxNF0gPSB1WzE1XSA9IDApLCByKSBmb3IocyA9IHRoaXMuc3RhcnQ7IG8gPCBhICYmIHMgPCA2NDsgKytvKXVbcyA+Pj4gMl0gfD0gZVtvXSA8PCBmWzMgJiBzKytdO1xuICAgICAgICAgICAgICAgIGVsc2UgZm9yKHMgPSB0aGlzLnN0YXJ0OyBvIDwgYSAmJiBzIDwgNjQ7ICsrbykoaCA9IGUuY2hhckNvZGVBdChvKSkgPCAxMjggPyB1W3MgPj4+IDJdIHw9IGggPDwgZlszICYgcysrXSA6IGggPCAyMDQ4ID8gKHVbcyA+Pj4gMl0gfD0gKDE5MiB8IGggPj4+IDYpIDw8IGZbMyAmIHMrK10sIHVbcyA+Pj4gMl0gfD0gKDEyOCB8IDYzICYgaCkgPDwgZlszICYgcysrXSkgOiBoIDwgNTUyOTYgfHwgaCA+PSA1NzM0NCA/ICh1W3MgPj4+IDJdIHw9ICgyMjQgfCBoID4+PiAxMikgPDwgZlszICYgcysrXSwgdVtzID4+PiAyXSB8PSAoMTI4IHwgaCA+Pj4gNiAmIDYzKSA8PCBmWzMgJiBzKytdLCB1W3MgPj4+IDJdIHw9ICgxMjggfCA2MyAmIGgpIDw8IGZbMyAmIHMrK10pIDogKGggPSA2NTUzNiArICgoMTAyMyAmIGgpIDw8IDEwIHwgMTAyMyAmIGUuY2hhckNvZGVBdCgrK28pKSwgdVtzID4+PiAyXSB8PSAoMjQwIHwgaCA+Pj4gMTgpIDw8IGZbMyAmIHMrK10sIHVbcyA+Pj4gMl0gfD0gKDEyOCB8IGggPj4+IDEyICYgNjMpIDw8IGZbMyAmIHMrK10sIHVbcyA+Pj4gMl0gfD0gKDEyOCB8IGggPj4+IDYgJiA2MykgPDwgZlszICYgcysrXSwgdVtzID4+PiAyXSB8PSAoMTI4IHwgNjMgJiBoKSA8PCBmWzMgJiBzKytdKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RCeXRlSW5kZXggPSBzLCB0aGlzLmJ5dGVzICs9IHMgLSB0aGlzLnN0YXJ0LCBzID49IDY0ID8gKHRoaXMuYmxvY2sgPSB1WzE2XSwgdGhpcy5zdGFydCA9IHMgLSA2NCwgdGhpcy5oYXNoKCksIHRoaXMuaGFzaGVkID0gITApIDogdGhpcy5zdGFydCA9IHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ieXRlcyA+IDQyOTQ5NjcyOTUgJiYgKHRoaXMuaEJ5dGVzICs9IHRoaXMuYnl0ZXMgLyA0Mjk0OTY3Mjk2IHwgMCwgdGhpcy5ieXRlcyA9IHRoaXMuYnl0ZXMgJSA0Mjk0OTY3Mjk2KSwgdGhpcztcbiAgICAgICAgfVxuICAgIH0sIHYucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmluYWxpemVkID0gITA7XG4gICAgICAgICAgICB2YXIgdCA9IHRoaXMuYmxvY2tzLCBlID0gdGhpcy5sYXN0Qnl0ZUluZGV4O1xuICAgICAgICAgICAgdFsxNl0gPSB0aGlzLmJsb2NrLCB0W2UgPj4+IDJdIHw9IGFbMyAmIGVdLCB0aGlzLmJsb2NrID0gdFsxNl0sIGUgPj0gNTYgJiYgKHRoaXMuaGFzaGVkIHx8IHRoaXMuaGFzaCgpLCB0WzBdID0gdGhpcy5ibG9jaywgdFsxNl0gPSB0WzFdID0gdFsyXSA9IHRbM10gPSB0WzRdID0gdFs1XSA9IHRbNl0gPSB0WzddID0gdFs4XSA9IHRbOV0gPSB0WzEwXSA9IHRbMTFdID0gdFsxMl0gPSB0WzEzXSA9IHRbMTRdID0gdFsxNV0gPSAwKSwgdFsxNF0gPSB0aGlzLmhCeXRlcyA8PCAzIHwgdGhpcy5ieXRlcyA+Pj4gMjksIHRbMTVdID0gdGhpcy5ieXRlcyA8PCAzLCB0aGlzLmhhc2goKTtcbiAgICAgICAgfVxuICAgIH0sIHYucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHQsIGUsIHIsIGksIGgsIHMsIG4sIG8sIGEsIGYgPSB0aGlzLmgwLCBjID0gdGhpcy5oMSwgbCA9IHRoaXMuaDIsIHkgPSB0aGlzLmgzLCBwID0gdGhpcy5oNCwgZCA9IHRoaXMuaDUsIHcgPSB0aGlzLmg2LCBiID0gdGhpcy5oNywgdiA9IHRoaXMuYmxvY2tzO1xuICAgICAgICBmb3IodCA9IDE2OyB0IDwgNjQ7ICsrdCllID0gKChoID0gdlt0IC0gMTVdKSA+Pj4gNyB8IGggPDwgMjUpIF4gKGggPj4+IDE4IHwgaCA8PCAxNCkgXiBoID4+PiAzLCByID0gKChoID0gdlt0IC0gMl0pID4+PiAxNyB8IGggPDwgMTUpIF4gKGggPj4+IDE5IHwgaCA8PCAxMykgXiBoID4+PiAxMCwgdlt0XSA9IHZbdCAtIDE2XSArIGUgKyB2W3QgLSA3XSArIHIgfCAwO1xuICAgICAgICBmb3IoYSA9IGMgJiBsLCB0ID0gMDsgdCA8IDY0OyB0ICs9IDQpdGhpcy5maXJzdCA/ICh0aGlzLmlzMjI0ID8gKHMgPSAzMDAwMzIsIGIgPSAoaCA9IHZbMF0gLSAxNDEzMjU3ODE5KSAtIDE1MDA1NDU5OSB8IDAsIHkgPSBoICsgMjQxNzcwNzcgfCAwKSA6IChzID0gNzA0NzUxMTA5LCBiID0gKGggPSB2WzBdIC0gMjEwMjQ0MjQ4KSAtIDE1MjE0ODY1MzQgfCAwLCB5ID0gaCArIDE0MzY5NDU2NSB8IDApLCB0aGlzLmZpcnN0ID0gITEpIDogKGUgPSAoZiA+Pj4gMiB8IGYgPDwgMzApIF4gKGYgPj4+IDEzIHwgZiA8PCAxOSkgXiAoZiA+Pj4gMjIgfCBmIDw8IDEwKSwgaSA9IChzID0gZiAmIGMpIF4gZiAmIGwgXiBhLCBiID0geSArIChoID0gYiArIChyID0gKHAgPj4+IDYgfCBwIDw8IDI2KSBeIChwID4+PiAxMSB8IHAgPDwgMjEpIF4gKHAgPj4+IDI1IHwgcCA8PCA3KSkgKyAocCAmIGQgXiB+cCAmIHcpICsgdVt0XSArIHZbdF0pIHwgMCwgeSA9IGggKyAoZSArIGkpIHwgMCksIGUgPSAoeSA+Pj4gMiB8IHkgPDwgMzApIF4gKHkgPj4+IDEzIHwgeSA8PCAxOSkgXiAoeSA+Pj4gMjIgfCB5IDw8IDEwKSwgaSA9IChuID0geSAmIGYpIF4geSAmIGMgXiBzLCB3ID0gbCArIChoID0gdyArIChyID0gKGIgPj4+IDYgfCBiIDw8IDI2KSBeIChiID4+PiAxMSB8IGIgPDwgMjEpIF4gKGIgPj4+IDI1IHwgYiA8PCA3KSkgKyAoYiAmIHAgXiB+YiAmIGQpICsgdVt0ICsgMV0gKyB2W3QgKyAxXSkgfCAwLCBlID0gKChsID0gaCArIChlICsgaSkgfCAwKSA+Pj4gMiB8IGwgPDwgMzApIF4gKGwgPj4+IDEzIHwgbCA8PCAxOSkgXiAobCA+Pj4gMjIgfCBsIDw8IDEwKSwgaSA9IChvID0gbCAmIHkpIF4gbCAmIGYgXiBuLCBkID0gYyArIChoID0gZCArIChyID0gKHcgPj4+IDYgfCB3IDw8IDI2KSBeICh3ID4+PiAxMSB8IHcgPDwgMjEpIF4gKHcgPj4+IDI1IHwgdyA8PCA3KSkgKyAodyAmIGIgXiB+dyAmIHApICsgdVt0ICsgMl0gKyB2W3QgKyAyXSkgfCAwLCBlID0gKChjID0gaCArIChlICsgaSkgfCAwKSA+Pj4gMiB8IGMgPDwgMzApIF4gKGMgPj4+IDEzIHwgYyA8PCAxOSkgXiAoYyA+Pj4gMjIgfCBjIDw8IDEwKSwgaSA9IChhID0gYyAmIGwpIF4gYyAmIHkgXiBvLCBwID0gZiArIChoID0gcCArIChyID0gKGQgPj4+IDYgfCBkIDw8IDI2KSBeIChkID4+PiAxMSB8IGQgPDwgMjEpIF4gKGQgPj4+IDI1IHwgZCA8PCA3KSkgKyAoZCAmIHcgXiB+ZCAmIGIpICsgdVt0ICsgM10gKyB2W3QgKyAzXSkgfCAwLCBmID0gaCArIChlICsgaSkgfCAwLCB0aGlzLmNocm9tZUJ1Z1dvcmtBcm91bmQgPSAhMDtcbiAgICAgICAgdGhpcy5oMCA9IHRoaXMuaDAgKyBmIHwgMCwgdGhpcy5oMSA9IHRoaXMuaDEgKyBjIHwgMCwgdGhpcy5oMiA9IHRoaXMuaDIgKyBsIHwgMCwgdGhpcy5oMyA9IHRoaXMuaDMgKyB5IHwgMCwgdGhpcy5oNCA9IHRoaXMuaDQgKyBwIHwgMCwgdGhpcy5oNSA9IHRoaXMuaDUgKyBkIHwgMCwgdGhpcy5oNiA9IHRoaXMuaDYgKyB3IHwgMCwgdGhpcy5oNyA9IHRoaXMuaDcgKyBiIHwgMDtcbiAgICB9LCB2LnByb3RvdHlwZS5oZXggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5maW5hbGl6ZSgpO1xuICAgICAgICB2YXIgdCA9IHRoaXMuaDAsIGUgPSB0aGlzLmgxLCByID0gdGhpcy5oMiwgaSA9IHRoaXMuaDMsIGggPSB0aGlzLmg0LCBzID0gdGhpcy5oNSwgbiA9IHRoaXMuaDYsIGEgPSB0aGlzLmg3LCBmID0gb1t0ID4+PiAyOCAmIDE1XSArIG9bdCA+Pj4gMjQgJiAxNV0gKyBvW3QgPj4+IDIwICYgMTVdICsgb1t0ID4+PiAxNiAmIDE1XSArIG9bdCA+Pj4gMTIgJiAxNV0gKyBvW3QgPj4+IDggJiAxNV0gKyBvW3QgPj4+IDQgJiAxNV0gKyBvWzE1ICYgdF0gKyBvW2UgPj4+IDI4ICYgMTVdICsgb1tlID4+PiAyNCAmIDE1XSArIG9bZSA+Pj4gMjAgJiAxNV0gKyBvW2UgPj4+IDE2ICYgMTVdICsgb1tlID4+PiAxMiAmIDE1XSArIG9bZSA+Pj4gOCAmIDE1XSArIG9bZSA+Pj4gNCAmIDE1XSArIG9bMTUgJiBlXSArIG9bciA+Pj4gMjggJiAxNV0gKyBvW3IgPj4+IDI0ICYgMTVdICsgb1tyID4+PiAyMCAmIDE1XSArIG9bciA+Pj4gMTYgJiAxNV0gKyBvW3IgPj4+IDEyICYgMTVdICsgb1tyID4+PiA4ICYgMTVdICsgb1tyID4+PiA0ICYgMTVdICsgb1sxNSAmIHJdICsgb1tpID4+PiAyOCAmIDE1XSArIG9baSA+Pj4gMjQgJiAxNV0gKyBvW2kgPj4+IDIwICYgMTVdICsgb1tpID4+PiAxNiAmIDE1XSArIG9baSA+Pj4gMTIgJiAxNV0gKyBvW2kgPj4+IDggJiAxNV0gKyBvW2kgPj4+IDQgJiAxNV0gKyBvWzE1ICYgaV0gKyBvW2ggPj4+IDI4ICYgMTVdICsgb1toID4+PiAyNCAmIDE1XSArIG9baCA+Pj4gMjAgJiAxNV0gKyBvW2ggPj4+IDE2ICYgMTVdICsgb1toID4+PiAxMiAmIDE1XSArIG9baCA+Pj4gOCAmIDE1XSArIG9baCA+Pj4gNCAmIDE1XSArIG9bMTUgJiBoXSArIG9bcyA+Pj4gMjggJiAxNV0gKyBvW3MgPj4+IDI0ICYgMTVdICsgb1tzID4+PiAyMCAmIDE1XSArIG9bcyA+Pj4gMTYgJiAxNV0gKyBvW3MgPj4+IDEyICYgMTVdICsgb1tzID4+PiA4ICYgMTVdICsgb1tzID4+PiA0ICYgMTVdICsgb1sxNSAmIHNdICsgb1tuID4+PiAyOCAmIDE1XSArIG9bbiA+Pj4gMjQgJiAxNV0gKyBvW24gPj4+IDIwICYgMTVdICsgb1tuID4+PiAxNiAmIDE1XSArIG9bbiA+Pj4gMTIgJiAxNV0gKyBvW24gPj4+IDggJiAxNV0gKyBvW24gPj4+IDQgJiAxNV0gKyBvWzE1ICYgbl07XG4gICAgICAgIHJldHVybiB0aGlzLmlzMjI0IHx8IChmICs9IG9bYSA+Pj4gMjggJiAxNV0gKyBvW2EgPj4+IDI0ICYgMTVdICsgb1thID4+PiAyMCAmIDE1XSArIG9bYSA+Pj4gMTYgJiAxNV0gKyBvW2EgPj4+IDEyICYgMTVdICsgb1thID4+PiA4ICYgMTVdICsgb1thID4+PiA0ICYgMTVdICsgb1sxNSAmIGFdKSwgZjtcbiAgICB9LCB2LnByb3RvdHlwZS50b1N0cmluZyA9IHYucHJvdG90eXBlLmhleCwgdi5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZmluYWxpemUoKTtcbiAgICAgICAgdmFyIHQgPSB0aGlzLmgwLCBlID0gdGhpcy5oMSwgciA9IHRoaXMuaDIsIGkgPSB0aGlzLmgzLCBoID0gdGhpcy5oNCwgcyA9IHRoaXMuaDUsIG4gPSB0aGlzLmg2LCBvID0gdGhpcy5oNywgYSA9IFtcbiAgICAgICAgICAgIHQgPj4+IDI0ICYgMjU1LFxuICAgICAgICAgICAgdCA+Pj4gMTYgJiAyNTUsXG4gICAgICAgICAgICB0ID4+PiA4ICYgMjU1LFxuICAgICAgICAgICAgMjU1ICYgdCxcbiAgICAgICAgICAgIGUgPj4+IDI0ICYgMjU1LFxuICAgICAgICAgICAgZSA+Pj4gMTYgJiAyNTUsXG4gICAgICAgICAgICBlID4+PiA4ICYgMjU1LFxuICAgICAgICAgICAgMjU1ICYgZSxcbiAgICAgICAgICAgIHIgPj4+IDI0ICYgMjU1LFxuICAgICAgICAgICAgciA+Pj4gMTYgJiAyNTUsXG4gICAgICAgICAgICByID4+PiA4ICYgMjU1LFxuICAgICAgICAgICAgMjU1ICYgcixcbiAgICAgICAgICAgIGkgPj4+IDI0ICYgMjU1LFxuICAgICAgICAgICAgaSA+Pj4gMTYgJiAyNTUsXG4gICAgICAgICAgICBpID4+PiA4ICYgMjU1LFxuICAgICAgICAgICAgMjU1ICYgaSxcbiAgICAgICAgICAgIGggPj4+IDI0ICYgMjU1LFxuICAgICAgICAgICAgaCA+Pj4gMTYgJiAyNTUsXG4gICAgICAgICAgICBoID4+PiA4ICYgMjU1LFxuICAgICAgICAgICAgMjU1ICYgaCxcbiAgICAgICAgICAgIHMgPj4+IDI0ICYgMjU1LFxuICAgICAgICAgICAgcyA+Pj4gMTYgJiAyNTUsXG4gICAgICAgICAgICBzID4+PiA4ICYgMjU1LFxuICAgICAgICAgICAgMjU1ICYgcyxcbiAgICAgICAgICAgIG4gPj4+IDI0ICYgMjU1LFxuICAgICAgICAgICAgbiA+Pj4gMTYgJiAyNTUsXG4gICAgICAgICAgICBuID4+PiA4ICYgMjU1LFxuICAgICAgICAgICAgMjU1ICYgblxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gdGhpcy5pczIyNCB8fCBhLnB1c2gobyA+Pj4gMjQgJiAyNTUsIG8gPj4+IDE2ICYgMjU1LCBvID4+PiA4ICYgMjU1LCAyNTUgJiBvKSwgYTtcbiAgICB9LCB2LnByb3RvdHlwZS5hcnJheSA9IHYucHJvdG90eXBlLmRpZ2VzdCwgdi5wcm90b3R5cGUuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5maW5hbGl6ZSgpO1xuICAgICAgICB2YXIgdCA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLmlzMjI0ID8gMjggOiAzMiksIGUgPSBuZXcgRGF0YVZpZXcodCk7XG4gICAgICAgIHJldHVybiBlLnNldFVpbnQzMigwLCB0aGlzLmgwKSwgZS5zZXRVaW50MzIoNCwgdGhpcy5oMSksIGUuc2V0VWludDMyKDgsIHRoaXMuaDIpLCBlLnNldFVpbnQzMigxMiwgdGhpcy5oMyksIGUuc2V0VWludDMyKDE2LCB0aGlzLmg0KSwgZS5zZXRVaW50MzIoMjAsIHRoaXMuaDUpLCBlLnNldFVpbnQzMigyNCwgdGhpcy5oNiksIHRoaXMuaXMyMjQgfHwgZS5zZXRVaW50MzIoMjgsIHRoaXMuaDcpLCB0O1xuICAgIH0sIEEucHJvdG90eXBlID0gbmV3IHYsIEEucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh2LnByb3RvdHlwZS5maW5hbGl6ZS5jYWxsKHRoaXMpLCB0aGlzLmlubmVyKSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyID0gITE7XG4gICAgICAgICAgICB2YXIgdCA9IHRoaXMuYXJyYXkoKTtcbiAgICAgICAgICAgIHYuY2FsbCh0aGlzLCB0aGlzLmlzMjI0LCB0aGlzLnNoYXJlZE1lbW9yeSksIHRoaXMudXBkYXRlKHRoaXMub0tleVBhZCksIHRoaXMudXBkYXRlKHQpLCB2LnByb3RvdHlwZS5maW5hbGl6ZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgZyA9IHAoKTtcbiAgICBnLnNoYTI1NiA9IGcsIGcuc2hhMjI0ID0gcCghMCksIGcuc2hhMjU2LmhtYWMgPSBiKCksIGcuc2hhMjI0LmhtYWMgPSBiKCEwKSwgcyA/IGsuZXhwb3J0cyA9IGcgOiAoci5zaGEyNTYgPSBnLnNoYTI1Niwgci5zaGEyMjQgPSBnLnNoYTIyNCk7XG59KCk7XG52YXIgVSA9IHguZXhwb3J0cywgeiA9IHguZXhwb3J0cy5zaGEyMjQsIEogPSB4LmV4cG9ydHMuc2hhMjU2O1xuZnVuY3Rpb24gcGFyc2VTaGEyNTYocykge1xuICAgIHJldHVybiB0b0J5dGVBcnJheShzKTtcbn1cbmZ1bmN0aW9uIGlzSGV4KHMpIHtcbiAgICBjb25zdCBoZXhSZWdleCA9IC9eWzAtOUEtRmEtZl0rJC87XG4gICAgaWYgKCFoZXhSZWdleC50ZXN0KHMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgaXNBbGxVcHBlckNhc2UgPSAvXlswLTlBLUZdKyQvLnRlc3Qocyk7XG4gICAgY29uc3QgaXNBbGxMb3dlckNhc2UgPSAvXlswLTlhLWZdKyQvLnRlc3Qocyk7XG4gICAgaWYgKCEoaXNBbGxVcHBlckNhc2UgfHwgaXNBbGxMb3dlckNhc2UpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHMubGVuZ3RoICUgMiA9PT0gMDtcbn1cbmZ1bmN0aW9uIGlzQmFzZTY0KHMpIHtcbiAgICByZXR1cm4gL15bQS1aYS16MC05XFwtX10qKD17MCwyfSk/JC8udGVzdChzKSB8fCAvXltBLVphLXowLTkrL10qKD17MCwyfSk/JC8udGVzdChzKTtcbn1cbmZ1bmN0aW9uIGRldGVjdEVuY29kaW5nKGlucHV0KSB7XG4gICAgaWYgKGlzSGV4KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gXCJoZXhcIjtcbiAgICB9IGVsc2UgaWYgKGlzQmFzZTY0KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gXCJiNjRcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCI7XG59XG5mdW5jdGlvbiBoZXhUb0J5dGVBcnJheShzKSB7XG4gICAgaWYgKHMubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJoZXggc3RyaW5nIG11c3QgaGF2ZSBhbiBldmVuIGxlbmd0aFwiKTtcbiAgICB9XG4gICAgY29uc3QgYSA9IG5ldyBVaW50OEFycmF5KHMubGVuZ3RoIC8gMik7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHMubGVuZ3RoOyBpICs9IDIpe1xuICAgICAgICBhW2kgLyAyXSA9IHBhcnNlSW50KHMuc3Vic3RyaW5nKGksIGkgKyAyKSwgMTYpO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn1cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZUFycmF5KHMpIHtcbiAgICBzID0gcy5yZXBsYWNlKC8tL2csIFwiK1wiKTtcbiAgICBzID0gcy5yZXBsYWNlKC9fL2csIFwiL1wiKTtcbiAgICBjb25zdCBzYmluID0gYXRvYihzKTtcbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKHNiaW4sIChjKT0+Yy5jaGFyQ29kZUF0KDApKTtcbn1cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5KGlucHV0KSB7XG4gICAgY29uc3QgZW5jb2RpbmcgPSBkZXRlY3RFbmNvZGluZyhpbnB1dCk7XG4gICAgc3dpdGNoKGVuY29kaW5nKXtcbiAgICAgICAgY2FzZSBcImhleFwiOlxuICAgICAgICAgICAgcmV0dXJuIGhleFRvQnl0ZUFycmF5KGlucHV0KTtcbiAgICAgICAgY2FzZSBcImI2NFwiOlxuICAgICAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZUFycmF5KGlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjaGVja1NoYTI1NihhLCBiKSB7XG4gICAgY29uc3QgYUJ5dGVzID0gdHlwZW9mIGEgPT09IFwic3RyaW5nXCIgPyBwYXJzZVNoYTI1NihhKSA6IGE7XG4gICAgY29uc3QgYkJ5dGVzID0gdHlwZW9mIGIgPT09IFwic3RyaW5nXCIgPyBwYXJzZVNoYTI1NihiKSA6IGI7XG4gICAgaWYgKGFCeXRlcyA9PT0gbnVsbCB8fCBiQnl0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYUJ5dGVzLmxlbmd0aCAhPT0gYkJ5dGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBhQnl0ZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICBpZiAoYUJ5dGVzW2ldICE9PSBiQnl0ZXNbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNsYXNzIEJhc2VSZXF1ZXN0IHtcbiAgICB0b2tlbjtcbiAgICByZWNlaXZlZDtcbiAgICBjdHg7XG4gICAgcmVxdWVzdFN1YmplY3Q7XG4gICAgbXV4O1xuICAgIGNvbnN0cnVjdG9yKG11eCwgcmVxdWVzdFN1YmplY3QsIGFzeW5jVHJhY2VzID0gdHJ1ZSl7XG4gICAgICAgIHRoaXMubXV4ID0gbXV4O1xuICAgICAgICB0aGlzLnJlcXVlc3RTdWJqZWN0ID0gcmVxdWVzdFN1YmplY3Q7XG4gICAgICAgIHRoaXMucmVjZWl2ZWQgPSAwO1xuICAgICAgICB0aGlzLnRva2VuID0gbnVpZC5uZXh0KCk7XG4gICAgICAgIGlmIChhc3luY1RyYWNlcykge1xuICAgICAgICAgICAgdGhpcy5jdHggPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFJlcXVlc3RNYW55IGV4dGVuZHMgQmFzZVJlcXVlc3Qge1xuICAgIGNhbGxiYWNrO1xuICAgIGRvbmU7XG4gICAgdGltZXI7XG4gICAgbWF4O1xuICAgIG9wdHM7XG4gICAgY29uc3RydWN0b3IobXV4LCByZXF1ZXN0U3ViamVjdCwgb3B0cyA9IHtcbiAgICAgICAgbWF4V2FpdDogMTAwMFxuICAgIH0pe1xuICAgICAgICBzdXBlcihtdXgsIHJlcXVlc3RTdWJqZWN0KTtcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdHMuY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FsbGJhY2sgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IHRoaXMub3B0cy5jYWxsYmFjaztcbiAgICAgICAgdGhpcy5tYXggPSB0eXBlb2Ygb3B0cy5tYXhNZXNzYWdlcyA9PT0gXCJudW1iZXJcIiAmJiBvcHRzLm1heE1lc3NhZ2VzID4gMCA/IG9wdHMubWF4TWVzc2FnZXMgOiAtMTtcbiAgICAgICAgdGhpcy5kb25lID0gZGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy5kb25lLnRoZW4oKCk9PntcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sobnVsbCwgbnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgfSwgb3B0cy5tYXhXYWl0KTtcbiAgICB9XG4gICAgY2FuY2VsKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgICB0aGlzLm11eC5jYW5jZWwodGhpcyk7XG4gICAgICAgIHRoaXMuZG9uZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHJlc29sdmVyKGVyciwgbXNnKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN0eCkge1xuICAgICAgICAgICAgICAgIGVyci5zdGFjayArPSBgXFxuXFxuJHt0aGlzLmN0eC5zdGFja31gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jYW5jZWwoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sobnVsbCwgbXNnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuc3RyYXRlZ3kgPT09IFJlcXVlc3RTdHJhdGVneS5Db3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWF4LS07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5zdHJhdGVneSA9PT0gUmVxdWVzdFN0cmF0ZWd5LkppdHRlclRpbWVyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcy5vcHRzLmppdHRlciB8fCAzMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5zdHJhdGVneSA9PT0gUmVxdWVzdFN0cmF0ZWd5LlNlbnRpbmVsTXNnKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1zZyAmJiBtc2cuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBSZXF1ZXN0T25lIGV4dGVuZHMgQmFzZVJlcXVlc3Qge1xuICAgIGRlZmVycmVkO1xuICAgIHRpbWVyO1xuICAgIGNvbnN0cnVjdG9yKG11eCwgcmVxdWVzdFN1YmplY3QsIG9wdHMgPSB7XG4gICAgICAgIHRpbWVvdXQ6IDEwMDBcbiAgICB9LCBhc3luY1RyYWNlcyA9IHRydWUpe1xuICAgICAgICBzdXBlcihtdXgsIHJlcXVlc3RTdWJqZWN0LCBhc3luY1RyYWNlcyk7XG4gICAgICAgIHRoaXMuZGVmZXJyZWQgPSBkZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLnRpbWVyID0gdGltZW91dChvcHRzLnRpbWVvdXQsIGFzeW5jVHJhY2VzKTtcbiAgICB9XG4gICAgcmVzb2x2ZXIoZXJyLCBtc2cpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMudGltZXIuY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3R4KSB7XG4gICAgICAgICAgICAgICAgZXJyLnN0YWNrICs9IGBcXG5cXG4ke3RoaXMuY3R4LnN0YWNrfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRlZmVycmVkLnJlamVjdChlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWZlcnJlZC5yZXNvbHZlKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICB9XG4gICAgY2FuY2VsKGVycikge1xuICAgICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICAgICAgdGhpcy50aW1lci5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm11eC5jYW5jZWwodGhpcyk7XG4gICAgICAgIHRoaXMuZGVmZXJyZWQucmVqZWN0KGVyciA/IGVyciA6IE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLkNhbmNlbGxlZCkpO1xuICAgIH1cbn1cbmNvbnN0IGRlZmF1bHRQcmVmaXggPSBcIiRKUy5BUElcIjtcbmZ1bmN0aW9uIGRlZmF1bHRKc09wdGlvbnMob3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIGlmIChvcHRzLmRvbWFpbikge1xuICAgICAgICBvcHRzLmFwaVByZWZpeCA9IGAkSlMuJHtvcHRzLmRvbWFpbn0uQVBJYDtcbiAgICAgICAgZGVsZXRlIG9wdHMuZG9tYWluO1xuICAgIH1cbiAgICByZXR1cm4gZXh0ZW5kKHtcbiAgICAgICAgYXBpUHJlZml4OiBkZWZhdWx0UHJlZml4LFxuICAgICAgICB0aW1lb3V0OiA1MDAwXG4gICAgfSwgb3B0cyk7XG59XG5jbGFzcyBCYXNlQXBpQ2xpZW50IHtcbiAgICBuYztcbiAgICBvcHRzO1xuICAgIHByZWZpeDtcbiAgICB0aW1lb3V0O1xuICAgIGpjO1xuICAgIGNvbnN0cnVjdG9yKG5jLCBvcHRzKXtcbiAgICAgICAgdGhpcy5uYyA9IG5jO1xuICAgICAgICB0aGlzLm9wdHMgPSBkZWZhdWx0SnNPcHRpb25zKG9wdHMpO1xuICAgICAgICB0aGlzLl9wYXJzZU9wdHMoKTtcbiAgICAgICAgdGhpcy5wcmVmaXggPSB0aGlzLm9wdHMuYXBpUHJlZml4O1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSB0aGlzLm9wdHMudGltZW91dDtcbiAgICAgICAgdGhpcy5qYyA9IEpTT05Db2RlYygpO1xuICAgIH1cbiAgICBnZXRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRzKTtcbiAgICB9XG4gICAgX3BhcnNlT3B0cygpIHtcbiAgICAgICAgbGV0IHByZWZpeCA9IHRoaXMub3B0cy5hcGlQcmVmaXg7XG4gICAgICAgIGlmICghcHJlZml4IHx8IHByZWZpeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZW1wdHkgcHJlZml4XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGMgPSBwcmVmaXhbcHJlZml4Lmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoYyA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgIHByZWZpeCA9IHByZWZpeC5zdWJzdHIoMCwgcHJlZml4Lmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0cy5hcGlQcmVmaXggPSBwcmVmaXg7XG4gICAgfVxuICAgIGFzeW5jIF9yZXF1ZXN0KHN1YmosIGRhdGEgPSBudWxsLCBvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICBvcHRzLnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gICAgICAgIGxldCBhID0gRW1wdHk7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICBhID0gdGhpcy5qYy5lbmNvZGUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgcmV0cmllcyB9ID0gb3B0cztcbiAgICAgICAgcmV0cmllcyA9IHJldHJpZXMgfHwgMTtcbiAgICAgICAgcmV0cmllcyA9IHJldHJpZXMgPT09IC0xID8gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgOiByZXRyaWVzO1xuICAgICAgICBjb25zdCBibyA9IGJhY2tvZmYoKTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHJldHJpZXM7IGkrKyl7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG0gPSBhd2FpdCB0aGlzLm5jLnJlcXVlc3Qoc3ViaiwgYSwgb3B0cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VKc1Jlc3BvbnNlKG0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmUgPSBlcnI7XG4gICAgICAgICAgICAgICAgaWYgKChuZS5jb2RlID09PSBcIjUwM1wiIHx8IG5lLmNvZGUgPT09IEVycm9yQ29kZS5UaW1lb3V0KSAmJiBpICsgMSA8IHJldHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgZGVsYXkoYm8uYmFja29mZihpKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmaW5kU3RyZWFtKHN1YmplY3QpIHtcbiAgICAgICAgY29uc3QgcSA9IHtcbiAgICAgICAgICAgIHN1YmplY3RcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgciA9IGF3YWl0IHRoaXMuX3JlcXVlc3QoYCR7dGhpcy5wcmVmaXh9LlNUUkVBTS5OQU1FU2AsIHEpO1xuICAgICAgICBjb25zdCBuYW1lcyA9IHI7XG4gICAgICAgIGlmICghbmFtZXMuc3RyZWFtcyB8fCBuYW1lcy5zdHJlYW1zLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gc3RyZWFtIG1hdGNoZXMgc3ViamVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZXMuc3RyZWFtc1swXTtcbiAgICB9XG4gICAgZ2V0Q29ubmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmM7XG4gICAgfVxuICAgIHBhcnNlSnNSZXNwb25zZShtKSB7XG4gICAgICAgIGNvbnN0IHYgPSB0aGlzLmpjLmRlY29kZShtLmRhdGEpO1xuICAgICAgICBjb25zdCByID0gdjtcbiAgICAgICAgaWYgKHIuZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IGNoZWNrSnNFcnJvckNvZGUoci5lcnJvci5jb2RlLCByLmVycm9yLmRlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGlmIChlcnIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBlcnIuYXBpX2Vycm9yID0gci5lcnJvcjtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxufVxuY2xhc3MgTGlzdGVySW1wbCB7XG4gICAgZXJyO1xuICAgIG9mZnNldDtcbiAgICBwYWdlSW5mbztcbiAgICBzdWJqZWN0O1xuICAgIGpzbTtcbiAgICBmaWx0ZXI7XG4gICAgcGF5bG9hZDtcbiAgICBjb25zdHJ1Y3RvcihzdWJqZWN0LCBmaWx0ZXIsIGpzbSwgcGF5bG9hZCl7XG4gICAgICAgIGlmICghc3ViamVjdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3ViamVjdCBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1YmplY3QgPSBzdWJqZWN0O1xuICAgICAgICB0aGlzLmpzbSA9IGpzbTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLnBhZ2VJbmZvID0ge307XG4gICAgICAgIHRoaXMuZmlsdGVyID0gZmlsdGVyO1xuICAgICAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkIHx8IHt9O1xuICAgIH1cbiAgICBhc3luYyBuZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5lcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYWdlSW5mbyAmJiB0aGlzLm9mZnNldCA+PSB0aGlzLnBhZ2VJbmZvLnRvdGFsKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0ge1xuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5wYXlsb2FkKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG9mZnNldCwgdGhpcy5wYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgciA9IGF3YWl0IHRoaXMuanNtLl9yZXF1ZXN0KHRoaXMuc3ViamVjdCwgb2Zmc2V0LCB7XG4gICAgICAgICAgICAgICAgdGltZW91dDogdGhpcy5qc20udGltZW91dFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnBhZ2VJbmZvID0gcjtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5jb3VudFJlc3BvbnNlKHIpO1xuICAgICAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gY291bnQ7XG4gICAgICAgICAgICBjb25zdCBhID0gdGhpcy5maWx0ZXIocik7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmVyciA9IGVycjtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb3VudFJlc3BvbnNlKHIpIHtcbiAgICAgICAgc3dpdGNoKHI/LnR5cGUpe1xuICAgICAgICAgICAgY2FzZSBcImlvLm5hdHMuamV0c3RyZWFtLmFwaS52MS5zdHJlYW1fbmFtZXNfcmVzcG9uc2VcIjpcbiAgICAgICAgICAgIGNhc2UgXCJpby5uYXRzLmpldHN0cmVhbS5hcGkudjEuc3RyZWFtX2xpc3RfcmVzcG9uc2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gci5zdHJlYW1zPy5sZW5ndGggfHwgMDtcbiAgICAgICAgICAgIGNhc2UgXCJpby5uYXRzLmpldHN0cmVhbS5hcGkudjEuY29uc3VtZXJfbGlzdF9yZXNwb25zZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiByLmNvbnN1bWVycz8ubGVuZ3RoIHx8IDA7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYGpzbGlzdGVyLnRzOiB1bmtub3duIEFQSSByZXNwb25zZSBmb3IgcGFnZWQgb3V0cHV0OiAke3I/LnR5cGV9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIuc3RyZWFtcz8ubGVuZ3RoIHx8IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICBsZXQgcGFnZSA9IGF3YWl0IHRoaXMubmV4dCgpO1xuICAgICAgICB3aGlsZShwYWdlLmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHBhZ2Upe1xuICAgICAgICAgICAgICAgIHlpZWxkIGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYWdlID0gYXdhaXQgdGhpcy5uZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZVNlbVZlcihzID0gXCJcIikge1xuICAgIGNvbnN0IG0gPSBzLm1hdGNoKC8oXFxkKykuKFxcZCspLihcXGQrKS8pO1xuICAgIGlmIChtKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtYWpvcjogcGFyc2VJbnQobVsxXSksXG4gICAgICAgICAgICBtaW5vcjogcGFyc2VJbnQobVsyXSksXG4gICAgICAgICAgICBtaWNybzogcGFyc2VJbnQobVszXSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGAnJHtzfScgaXMgbm90IGEgc2VtdmVyIHZhbHVlYCk7XG59XG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICBpZiAoYS5tYWpvciA8IGIubWFqb3IpIHJldHVybiAtMTtcbiAgICBpZiAoYS5tYWpvciA+IGIubWFqb3IpIHJldHVybiAxO1xuICAgIGlmIChhLm1pbm9yIDwgYi5taW5vcikgcmV0dXJuIC0xO1xuICAgIGlmIChhLm1pbm9yID4gYi5taW5vcikgcmV0dXJuIDE7XG4gICAgaWYgKGEubWljcm8gPCBiLm1pY3JvKSByZXR1cm4gLTE7XG4gICAgaWYgKGEubWljcm8gPiBiLm1pY3JvKSByZXR1cm4gMTtcbiAgICByZXR1cm4gMDtcbn1cbnZhciBGZWF0dXJlO1xuKGZ1bmN0aW9uKEZlYXR1cmUpIHtcbiAgICBGZWF0dXJlW1wiSlNfS1ZcIl0gPSBcImpzX2t2XCI7XG4gICAgRmVhdHVyZVtcIkpTX09CSkVDVFNUT1JFXCJdID0gXCJqc19vYmplY3RzdG9yZVwiO1xuICAgIEZlYXR1cmVbXCJKU19QVUxMX01BWF9CWVRFU1wiXSA9IFwianNfcHVsbF9tYXhfYnl0ZXNcIjtcbiAgICBGZWF0dXJlW1wiSlNfTkVXX0NPTlNVTUVSX0NSRUFURV9BUElcIl0gPSBcImpzX25ld19jb25zdW1lcl9jcmVhdGVcIjtcbiAgICBGZWF0dXJlW1wiSlNfQUxMT1dfRElSRUNUXCJdID0gXCJqc19hbGxvd19kaXJlY3RcIjtcbiAgICBGZWF0dXJlW1wiSlNfTVVMVElQTEVfQ09OU1VNRVJfRklMVEVSXCJdID0gXCJqc19tdWx0aXBsZV9jb25zdW1lcl9maWx0ZXJcIjtcbiAgICBGZWF0dXJlW1wiSlNfU0lNUExJRklDQVRJT05cIl0gPSBcImpzX3NpbXBsaWZpY2F0aW9uXCI7XG4gICAgRmVhdHVyZVtcIkpTX1NUUkVBTV9DT05TVU1FUl9NRVRBREFUQVwiXSA9IFwianNfc3RyZWFtX2NvbnN1bWVyX21ldGFkYXRhXCI7XG4gICAgRmVhdHVyZVtcIkpTX0NPTlNVTUVSX0ZJTFRFUl9TVUJKRUNUU1wiXSA9IFwianNfY29uc3VtZXJfZmlsdGVyX3N1YmplY3RzXCI7XG4gICAgRmVhdHVyZVtcIkpTX1NUUkVBTV9GSVJTVF9TRVFcIl0gPSBcImpzX3N0cmVhbV9maXJzdF9zZXFcIjtcbiAgICBGZWF0dXJlW1wiSlNfU1RSRUFNX1NVQkpFQ1RfVFJBTlNGT1JNXCJdID0gXCJqc19zdHJlYW1fc3ViamVjdF90cmFuc2Zvcm1cIjtcbiAgICBGZWF0dXJlW1wiSlNfU1RSRUFNX1NPVVJDRV9TVUJKRUNUX1RSQU5TRk9STVwiXSA9IFwianNfc3RyZWFtX3NvdXJjZV9zdWJqZWN0X3RyYW5zZm9ybVwiO1xuICAgIEZlYXR1cmVbXCJKU19TVFJFQU1fQ09NUFJFU1NJT05cIl0gPSBcImpzX3N0cmVhbV9jb21wcmVzc2lvblwiO1xuICAgIEZlYXR1cmVbXCJKU19ERUZBVUxUX0NPTlNVTUVSX0xJTUlUU1wiXSA9IFwianNfZGVmYXVsdF9jb25zdW1lcl9saW1pdHNcIjtcbiAgICBGZWF0dXJlW1wiSlNfQkFUQ0hfRElSRUNUX0dFVFwiXSA9IFwianNfYmF0Y2hfZGlyZWN0X2dldFwiO1xufSkoRmVhdHVyZSB8fCAoRmVhdHVyZSA9IHt9KSk7XG5jbGFzcyBGZWF0dXJlcyB7XG4gICAgc2VydmVyO1xuICAgIGZlYXR1cmVzO1xuICAgIGRpc2FibGVkO1xuICAgIGNvbnN0cnVjdG9yKHYpe1xuICAgICAgICB0aGlzLmZlYXR1cmVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gW107XG4gICAgICAgIHRoaXMudXBkYXRlKHYpO1xuICAgIH1cbiAgICByZXNldERpc2FibGVkKCkge1xuICAgICAgICB0aGlzLmRpc2FibGVkLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMudXBkYXRlKHRoaXMuc2VydmVyKTtcbiAgICB9XG4gICAgZGlzYWJsZShmKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQucHVzaChmKTtcbiAgICAgICAgdGhpcy51cGRhdGUodGhpcy5zZXJ2ZXIpO1xuICAgIH1cbiAgICBpc0Rpc2FibGVkKGYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQuaW5kZXhPZihmKSAhPT0gLTE7XG4gICAgfVxuICAgIHVwZGF0ZSh2KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdiA9IHBhcnNlU2VtVmVyKHYpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VydmVyID0gdjtcbiAgICAgICAgdGhpcy5zZXQoRmVhdHVyZS5KU19LViwgXCIyLjYuMlwiKTtcbiAgICAgICAgdGhpcy5zZXQoRmVhdHVyZS5KU19PQkpFQ1RTVE9SRSwgXCIyLjYuM1wiKTtcbiAgICAgICAgdGhpcy5zZXQoRmVhdHVyZS5KU19QVUxMX01BWF9CWVRFUywgXCIyLjguM1wiKTtcbiAgICAgICAgdGhpcy5zZXQoRmVhdHVyZS5KU19ORVdfQ09OU1VNRVJfQ1JFQVRFX0FQSSwgXCIyLjkuMFwiKTtcbiAgICAgICAgdGhpcy5zZXQoRmVhdHVyZS5KU19BTExPV19ESVJFQ1QsIFwiMi45LjBcIik7XG4gICAgICAgIHRoaXMuc2V0KEZlYXR1cmUuSlNfTVVMVElQTEVfQ09OU1VNRVJfRklMVEVSLCBcIjIuMTAuMFwiKTtcbiAgICAgICAgdGhpcy5zZXQoRmVhdHVyZS5KU19TSU1QTElGSUNBVElPTiwgXCIyLjkuNFwiKTtcbiAgICAgICAgdGhpcy5zZXQoRmVhdHVyZS5KU19TVFJFQU1fQ09OU1VNRVJfTUVUQURBVEEsIFwiMi4xMC4wXCIpO1xuICAgICAgICB0aGlzLnNldChGZWF0dXJlLkpTX0NPTlNVTUVSX0ZJTFRFUl9TVUJKRUNUUywgXCIyLjEwLjBcIik7XG4gICAgICAgIHRoaXMuc2V0KEZlYXR1cmUuSlNfU1RSRUFNX0ZJUlNUX1NFUSwgXCIyLjEwLjBcIik7XG4gICAgICAgIHRoaXMuc2V0KEZlYXR1cmUuSlNfU1RSRUFNX1NVQkpFQ1RfVFJBTlNGT1JNLCBcIjIuMTAuMFwiKTtcbiAgICAgICAgdGhpcy5zZXQoRmVhdHVyZS5KU19TVFJFQU1fU09VUkNFX1NVQkpFQ1RfVFJBTlNGT1JNLCBcIjIuMTAuMFwiKTtcbiAgICAgICAgdGhpcy5zZXQoRmVhdHVyZS5KU19TVFJFQU1fQ09NUFJFU1NJT04sIFwiMi4xMC4wXCIpO1xuICAgICAgICB0aGlzLnNldChGZWF0dXJlLkpTX0RFRkFVTFRfQ09OU1VNRVJfTElNSVRTLCBcIjIuMTAuMFwiKTtcbiAgICAgICAgdGhpcy5zZXQoRmVhdHVyZS5KU19CQVRDSF9ESVJFQ1RfR0VULCBcIjIuMTEuMFwiKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlZC5mb3JFYWNoKChmKT0+e1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlcy5kZWxldGUoZik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXQoZiwgcmVxdWlyZXMpIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlcy5zZXQoZiwge1xuICAgICAgICAgICAgbWluOiByZXF1aXJlcyxcbiAgICAgICAgICAgIG9rOiBjb21wYXJlKHRoaXMuc2VydmVyLCBwYXJzZVNlbVZlcihyZXF1aXJlcykpID49IDBcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldChmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZlYXR1cmVzLmdldChmKSB8fCB7XG4gICAgICAgICAgICBtaW46IFwidW5rbm93blwiLFxuICAgICAgICAgICAgb2s6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN1cHBvcnRzKGYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGYpPy5vayB8fCBmYWxzZTtcbiAgICB9XG4gICAgcmVxdWlyZSh2KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdiA9IHBhcnNlU2VtVmVyKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wYXJlKHRoaXMuc2VydmVyLCB2KSA+PSAwO1xuICAgIH1cbn1cbmNsYXNzIENvbnN1bWVyQVBJSW1wbCBleHRlbmRzIEJhc2VBcGlDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKG5jLCBvcHRzKXtcbiAgICAgICAgc3VwZXIobmMsIG9wdHMpO1xuICAgIH1cbiAgICBhc3luYyBhZGQoc3RyZWFtLCBjZmcsIGFjdGlvbiA9IENvbnN1bWVyQXBpQWN0aW9uLkNyZWF0ZSkge1xuICAgICAgICB2YWxpZGF0ZVN0cmVhbU5hbWUoc3RyZWFtKTtcbiAgICAgICAgaWYgKGNmZy5kZWxpdmVyX2dyb3VwICYmIGNmZy5mbG93X2NvbnRyb2wpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImpldHN0cmVhbSBmbG93IGNvbnRyb2wgaXMgbm90IHN1cHBvcnRlZCB3aXRoIHF1ZXVlIGdyb3Vwc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ZnLmRlbGl2ZXJfZ3JvdXAgJiYgY2ZnLmlkbGVfaGVhcnRiZWF0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJqZXRzdHJlYW0gaWRsZSBoZWFydGJlYXQgaXMgbm90IHN1cHBvcnRlZCB3aXRoIHF1ZXVlIGdyb3Vwc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjciA9IHt9O1xuICAgICAgICBjci5jb25maWcgPSBjZmc7XG4gICAgICAgIGNyLnN0cmVhbV9uYW1lID0gc3RyZWFtO1xuICAgICAgICBjci5hY3Rpb24gPSBhY3Rpb247XG4gICAgICAgIGlmIChjci5jb25maWcuZHVyYWJsZV9uYW1lKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUR1cmFibGVOYW1lKGNyLmNvbmZpZy5kdXJhYmxlX25hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5jaSA9IHRoaXMubmM7XG4gICAgICAgIGxldCB7IG1pbiwgb2s6IG5ld0FQSSB9ID0gbmNpLmZlYXR1cmVzLmdldChGZWF0dXJlLkpTX05FV19DT05TVU1FUl9DUkVBVEVfQVBJKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGNmZy5uYW1lID09PSBcIlwiID8gdW5kZWZpbmVkIDogY2ZnLm5hbWU7XG4gICAgICAgIGlmIChuYW1lICYmICFuZXdBUEkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29uc3VtZXIgJ25hbWUnIHJlcXVpcmVzIHNlcnZlciAke21pbn1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBtaW5WYWxpZGF0aW9uKFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG0gPSBlcnIubWVzc2FnZTtcbiAgICAgICAgICAgICAgICBjb25zdCBpZHggPSBtLmluZGV4T2YoXCJjYW5ub3QgY29udGFpblwiKTtcbiAgICAgICAgICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnN1bWVyICduYW1lJyAke20uc3Vic3RyaW5nKGlkeCl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgc3ViajtcbiAgICAgICAgbGV0IGNvbnN1bWVyTmFtZSA9IFwiXCI7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNmZy5maWx0ZXJfc3ViamVjdHMpKSB7XG4gICAgICAgICAgICBjb25zdCB7IG1pbiwgb2sgfSA9IG5jaS5mZWF0dXJlcy5nZXQoRmVhdHVyZS5KU19NVUxUSVBMRV9DT05TVU1FUl9GSUxURVIpO1xuICAgICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29uc3VtZXIgJ2ZpbHRlcl9zdWJqZWN0cycgcmVxdWlyZXMgc2VydmVyICR7bWlufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3QVBJID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNmZy5tZXRhZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgeyBtaW4sIG9rIH0gPSBuY2kuZmVhdHVyZXMuZ2V0KEZlYXR1cmUuSlNfU1RSRUFNX0NPTlNVTUVSX01FVEFEQVRBKTtcbiAgICAgICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnN1bWVyICdtZXRhZGF0YScgcmVxdWlyZXMgc2VydmVyICR7bWlufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdBUEkpIHtcbiAgICAgICAgICAgIGNvbnN1bWVyTmFtZSA9IGNmZy5uYW1lID8/IGNmZy5kdXJhYmxlX25hbWUgPz8gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc3VtZXJOYW1lICE9PSBcIlwiKSB7XG4gICAgICAgICAgICBsZXQgZnMgPSBjZmcuZmlsdGVyX3N1YmplY3QgPz8gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGZzID09PSBcIj5cIikge1xuICAgICAgICAgICAgICAgIGZzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3ViaiA9IGZzICE9PSB1bmRlZmluZWQgPyBgJHt0aGlzLnByZWZpeH0uQ09OU1VNRVIuQ1JFQVRFLiR7c3RyZWFtfS4ke2NvbnN1bWVyTmFtZX0uJHtmc31gIDogYCR7dGhpcy5wcmVmaXh9LkNPTlNVTUVSLkNSRUFURS4ke3N0cmVhbX0uJHtjb25zdW1lck5hbWV9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1YmogPSBjZmcuZHVyYWJsZV9uYW1lID8gYCR7dGhpcy5wcmVmaXh9LkNPTlNVTUVSLkRVUkFCTEUuQ1JFQVRFLiR7c3RyZWFtfS4ke2NmZy5kdXJhYmxlX25hbWV9YCA6IGAke3RoaXMucHJlZml4fS5DT05TVU1FUi5DUkVBVEUuJHtzdHJlYW19YDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByID0gYXdhaXQgdGhpcy5fcmVxdWVzdChzdWJqLCBjcik7XG4gICAgICAgIHJldHVybiByO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGUoc3RyZWFtLCBkdXJhYmxlLCBjZmcpIHtcbiAgICAgICAgY29uc3QgY2kgPSBhd2FpdCB0aGlzLmluZm8oc3RyZWFtLCBkdXJhYmxlKTtcbiAgICAgICAgY29uc3QgY2hhbmdhYmxlID0gY2ZnO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQoc3RyZWFtLCBPYmplY3QuYXNzaWduKGNpLmNvbmZpZywgY2hhbmdhYmxlKSwgQ29uc3VtZXJBcGlBY3Rpb24uVXBkYXRlKTtcbiAgICB9XG4gICAgYXN5bmMgaW5mbyhzdHJlYW0sIG5hbWUpIHtcbiAgICAgICAgdmFsaWRhdGVTdHJlYW1OYW1lKHN0cmVhbSk7XG4gICAgICAgIHZhbGlkYXRlRHVyYWJsZU5hbWUobmFtZSk7XG4gICAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLl9yZXF1ZXN0KGAke3RoaXMucHJlZml4fS5DT05TVU1FUi5JTkZPLiR7c3RyZWFtfS4ke25hbWV9YCk7XG4gICAgICAgIHJldHVybiByO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGUoc3RyZWFtLCBuYW1lKSB7XG4gICAgICAgIHZhbGlkYXRlU3RyZWFtTmFtZShzdHJlYW0pO1xuICAgICAgICB2YWxpZGF0ZUR1cmFibGVOYW1lKG5hbWUpO1xuICAgICAgICBjb25zdCByID0gYXdhaXQgdGhpcy5fcmVxdWVzdChgJHt0aGlzLnByZWZpeH0uQ09OU1VNRVIuREVMRVRFLiR7c3RyZWFtfS4ke25hbWV9YCk7XG4gICAgICAgIGNvbnN0IGNyID0gcjtcbiAgICAgICAgcmV0dXJuIGNyLnN1Y2Nlc3M7XG4gICAgfVxuICAgIGxpc3Qoc3RyZWFtKSB7XG4gICAgICAgIHZhbGlkYXRlU3RyZWFtTmFtZShzdHJlYW0pO1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSAodik9PntcbiAgICAgICAgICAgIGNvbnN0IGNsciA9IHY7XG4gICAgICAgICAgICByZXR1cm4gY2xyLmNvbnN1bWVycztcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3ViaiA9IGAke3RoaXMucHJlZml4fS5DT05TVU1FUi5MSVNULiR7c3RyZWFtfWA7XG4gICAgICAgIHJldHVybiBuZXcgTGlzdGVySW1wbChzdWJqLCBmaWx0ZXIsIHRoaXMpO1xuICAgIH1cbiAgICBwYXVzZShzdHJlYW0sIG5hbWUsIHVudGlsKSB7XG4gICAgICAgIGNvbnN0IHN1YmogPSBgJHt0aGlzLnByZWZpeH0uQ09OU1VNRVIuUEFVU0UuJHtzdHJlYW19LiR7bmFtZX1gO1xuICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgICAgcGF1c2VfdW50aWw6IHVudGlsLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3Qoc3Viaiwgb3B0cyk7XG4gICAgfVxuICAgIHJlc3VtZShzdHJlYW0sIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF1c2Uoc3RyZWFtLCBuYW1lLCBuZXcgRGF0ZSgwKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tGbihmbiwgbmFtZSwgcmVxdWlyZWQgPSBmYWxzZSkge1xuICAgIGlmIChyZXF1aXJlZCA9PT0gdHJ1ZSAmJiAhZm4pIHtcbiAgICAgICAgdGhyb3cgTmF0c0Vycm9yLmVycm9yRm9yQ29kZShFcnJvckNvZGUuQXBpRXJyb3IsIG5ldyBFcnJvcihgJHtuYW1lfSBpcyBub3QgYSBmdW5jdGlvbmApKTtcbiAgICB9XG4gICAgaWYgKGZuICYmIHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLkFwaUVycm9yLCBuZXcgRXJyb3IoYCR7bmFtZX0gaXMgbm90IGEgZnVuY3Rpb25gKSk7XG4gICAgfVxufVxuY2xhc3MgVHlwZWRTdWJzY3JpcHRpb24gZXh0ZW5kcyBRdWV1ZWRJdGVyYXRvckltcGwge1xuICAgIHN1YjtcbiAgICBhZGFwdGVyO1xuICAgIHN1Ykl0ZXJEb25lO1xuICAgIGNvbnN0cnVjdG9yKG5jLCBzdWJqZWN0LCBvcHRzKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgY2hlY2tGbihvcHRzLmFkYXB0ZXIsIFwiYWRhcHRlclwiLCB0cnVlKTtcbiAgICAgICAgdGhpcy5hZGFwdGVyID0gb3B0cy5hZGFwdGVyO1xuICAgICAgICBpZiAob3B0cy5jYWxsYmFjaykge1xuICAgICAgICAgICAgY2hlY2tGbihvcHRzLmNhbGxiYWNrLCBcImNhbGxiYWNrXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9JdGVyYXRvciA9IHR5cGVvZiBvcHRzLmNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgIGlmIChvcHRzLmluZ2VzdGlvbkZpbHRlckZuKSB7XG4gICAgICAgICAgICBjaGVja0ZuKG9wdHMuaW5nZXN0aW9uRmlsdGVyRm4sIFwiaW5nZXN0aW9uRmlsdGVyRm5cIik7XG4gICAgICAgICAgICB0aGlzLmluZ2VzdGlvbkZpbHRlckZuID0gb3B0cy5pbmdlc3Rpb25GaWx0ZXJGbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5wcm90b2NvbEZpbHRlckZuKSB7XG4gICAgICAgICAgICBjaGVja0ZuKG9wdHMucHJvdG9jb2xGaWx0ZXJGbiwgXCJwcm90b2NvbEZpbHRlckZuXCIpO1xuICAgICAgICAgICAgdGhpcy5wcm90b2NvbEZpbHRlckZuID0gb3B0cy5wcm90b2NvbEZpbHRlckZuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmRpc3BhdGNoZWRGbikge1xuICAgICAgICAgICAgY2hlY2tGbihvcHRzLmRpc3BhdGNoZWRGbiwgXCJkaXNwYXRjaGVkRm5cIik7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoZWRGbiA9IG9wdHMuZGlzcGF0Y2hlZEZuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmNsZWFudXBGbikge1xuICAgICAgICAgICAgY2hlY2tGbihvcHRzLmNsZWFudXBGbiwgXCJjbGVhbnVwRm5cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNhbGxiYWNrID0gKGVyciwgbXNnKT0+e1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFjayhlcnIsIG1zZyk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRzLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjb25zdCB1aCA9IG9wdHMuY2FsbGJhY2s7XG4gICAgICAgICAgICBjYWxsYmFjayA9IChlcnIsIG1zZyk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBbamVyLCB0bV0gPSB0aGlzLmFkYXB0ZXIoZXJyLCBtc2cpO1xuICAgICAgICAgICAgICAgIGlmIChqZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdWgoamVyLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IGluZ2VzdCB9ID0gdGhpcy5pbmdlc3Rpb25GaWx0ZXJGbiA/IHRoaXMuaW5nZXN0aW9uRmlsdGVyRm4odG0sIHRoaXMpIDoge1xuICAgICAgICAgICAgICAgICAgICBpbmdlc3Q6IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChpbmdlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2sgPSB0aGlzLnByb3RvY29sRmlsdGVyRm4gPyB0aGlzLnByb3RvY29sRmlsdGVyRm4odG0pIDogdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1aChqZXIsIHRtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRpc3BhdGNoZWRGbiAmJiB0bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hlZEZuKHRtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBtYXgsIHF1ZXVlLCB0aW1lb3V0IH0gPSBvcHRzO1xuICAgICAgICBjb25zdCBzb3B0cyA9IHtcbiAgICAgICAgICAgIHF1ZXVlLFxuICAgICAgICAgICAgdGltZW91dCxcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgIH07XG4gICAgICAgIGlmIChtYXggJiYgbWF4ID4gMCkge1xuICAgICAgICAgICAgc29wdHMubWF4ID0gbWF4O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3ViID0gbmMuc3Vic2NyaWJlKHN1YmplY3QsIHNvcHRzKTtcbiAgICAgICAgaWYgKG9wdHMuY2xlYW51cEZuKSB7XG4gICAgICAgICAgICB0aGlzLnN1Yi5jbGVhbnVwRm4gPSBvcHRzLmNsZWFudXBGbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubm9JdGVyYXRvcikge1xuICAgICAgICAgICAgdGhpcy5pdGVyQ2xvc2VkLnRoZW4oKCk9PntcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1Ykl0ZXJEb25lID0gZGVmZXJyZWQoKTtcbiAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGhpcy5zdWIuY2xvc2VkLFxuICAgICAgICAgICAgdGhpcy5pdGVyQ2xvc2VkXG4gICAgICAgIF0pLnRoZW4oKCk9PntcbiAgICAgICAgICAgIHRoaXMuc3ViSXRlckRvbmUucmVzb2x2ZSgpO1xuICAgICAgICB9KS5jYXRjaCgoKT0+e1xuICAgICAgICAgICAgdGhpcy5zdWJJdGVyRG9uZS5yZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICAoYXN5bmMgKHMpPT57XG4gICAgICAgICAgICBhd2FpdCBzLmNsb3NlZDtcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB9KSh0aGlzLnN1YikudGhlbigpLmNhdGNoKCk7XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlKG1heCkge1xuICAgICAgICB0aGlzLnN1Yi51bnN1YnNjcmliZShtYXgpO1xuICAgIH1cbiAgICBkcmFpbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViLmRyYWluKCk7XG4gICAgfVxuICAgIGlzRHJhaW5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1Yi5pc0RyYWluaW5nKCk7XG4gICAgfVxuICAgIGlzQ2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIuaXNDbG9zZWQoKTtcbiAgICB9XG4gICAgY2FsbGJhY2soZSwgbXNnKSB7XG4gICAgICAgIHRoaXMuc3ViLmNhbmNlbFRpbWVvdXQoKTtcbiAgICAgICAgY29uc3QgW2VyciwgdG1dID0gdGhpcy5hZGFwdGVyKGUsIG1zZyk7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0bSkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKHRtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRTdWJqZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIuZ2V0U3ViamVjdCgpO1xuICAgIH1cbiAgICBnZXRSZWNlaXZlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViLmdldFJlY2VpdmVkKCk7XG4gICAgfVxuICAgIGdldFByb2Nlc3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViLmdldFByb2Nlc3NlZCgpO1xuICAgIH1cbiAgICBnZXRQZW5kaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIuZ2V0UGVuZGluZygpO1xuICAgIH1cbiAgICBnZXRJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViLmdldElEKCk7XG4gICAgfVxuICAgIGdldE1heCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViLmdldE1heCgpO1xuICAgIH1cbiAgICBnZXQgY2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIuY2xvc2VkO1xuICAgIH1cbn1cbmxldCB0cmFuc3BvcnRDb25maWc7XG5mdW5jdGlvbiBzZXRUcmFuc3BvcnRGYWN0b3J5KGNvbmZpZykge1xuICAgIHRyYW5zcG9ydENvbmZpZyA9IGNvbmZpZztcbn1cbmZ1bmN0aW9uIGRlZmF1bHRQb3J0KCkge1xuICAgIHJldHVybiB0cmFuc3BvcnRDb25maWcgIT09IHVuZGVmaW5lZCAmJiB0cmFuc3BvcnRDb25maWcuZGVmYXVsdFBvcnQgIT09IHVuZGVmaW5lZCA/IHRyYW5zcG9ydENvbmZpZy5kZWZhdWx0UG9ydCA6IDQyMjI7XG59XG5mdW5jdGlvbiBnZXRVcmxQYXJzZUZuKCkge1xuICAgIHJldHVybiB0cmFuc3BvcnRDb25maWcgIT09IHVuZGVmaW5lZCAmJiB0cmFuc3BvcnRDb25maWcudXJsUGFyc2VGbiA/IHRyYW5zcG9ydENvbmZpZy51cmxQYXJzZUZuIDogdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gbmV3VHJhbnNwb3J0KCkge1xuICAgIGlmICghdHJhbnNwb3J0Q29uZmlnIHx8IHR5cGVvZiB0cmFuc3BvcnRDb25maWcuZmFjdG9yeSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyYW5zcG9ydCBmbiBpcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNwb3J0Q29uZmlnLmZhY3RvcnkoKTtcbn1cbmZ1bmN0aW9uIGdldFJlc29sdmVGbigpIHtcbiAgICByZXR1cm4gdHJhbnNwb3J0Q29uZmlnICE9PSB1bmRlZmluZWQgJiYgdHJhbnNwb3J0Q29uZmlnLmRuc1Jlc29sdmVGbiA/IHRyYW5zcG9ydENvbmZpZy5kbnNSZXNvbHZlRm4gOiB1bmRlZmluZWQ7XG59XG5jb25zdCBDUl9MRiA9IFwiXFxyXFxuXCI7XG5DUl9MRi5sZW5ndGg7XG5jb25zdCBDUkxGID0gRGF0YUJ1ZmZlci5mcm9tQXNjaWkoQ1JfTEYpO1xuY29uc3QgQ1IgPSBuZXcgVWludDhBcnJheShDUkxGKVswXTtcbmNvbnN0IExGID0gbmV3IFVpbnQ4QXJyYXkoQ1JMRilbMV07XG5mdW5jdGlvbiBwcm90b0xlbihiYSkge1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBiYS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGNvbnN0IG4gPSBpICsgMTtcbiAgICAgICAgaWYgKGJhLmJ5dGVMZW5ndGggPiBuICYmIGJhW2ldID09PSBDUiAmJiBiYVtuXSA9PT0gTEYpIHtcbiAgICAgICAgICAgIHJldHVybiBuICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RQcm90b2NvbE1lc3NhZ2UoYSkge1xuICAgIGNvbnN0IGxlbiA9IHByb3RvTGVuKGEpO1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIGNvbnN0IGJhID0gbmV3IFVpbnQ4QXJyYXkoYSk7XG4gICAgICAgIGNvbnN0IG91dCA9IGJhLnNsaWNlKDAsIGxlbik7XG4gICAgICAgIHJldHVybiBURC5kZWNvZGUob3V0KTtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCI7XG59XG5jb25zdCBJUHY0TEVOID0gNDtcbmNvbnN0IEFTQ0lJMCA9IDQ4O1xuY29uc3QgQVNDSUlBID0gNjU7XG5jb25zdCBBU0NJSWEgPSA5NztcbmZ1bmN0aW9uIGlwVjQoYSwgYiwgYywgZCkge1xuICAgIGNvbnN0IGlwID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgIGNvbnN0IHByZWZpeCA9IFtcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMHhmZixcbiAgICAgICAgMHhmZlxuICAgIF07XG4gICAgcHJlZml4LmZvckVhY2goKHYsIGlkeCk9PntcbiAgICAgICAgaXBbaWR4XSA9IHY7XG4gICAgfSk7XG4gICAgaXBbMTJdID0gYTtcbiAgICBpcFsxM10gPSBiO1xuICAgIGlwWzE0XSA9IGM7XG4gICAgaXBbMTVdID0gZDtcbiAgICByZXR1cm4gaXA7XG59XG5mdW5jdGlvbiBpc0lQKGgpIHtcbiAgICByZXR1cm4gcGFyc2VJUChoKSAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gcGFyc2VJUChoKSB7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGgubGVuZ3RoOyBpKyspe1xuICAgICAgICBzd2l0Y2goaFtpXSl7XG4gICAgICAgICAgICBjYXNlIFwiLlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUlQdjQoaCk7XG4gICAgICAgICAgICBjYXNlIFwiOlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUlQdjYoaCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xufVxuZnVuY3Rpb24gcGFyc2VJUHY0KHMpIHtcbiAgICBjb25zdCBpcCA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCA0OyBpKyspe1xuICAgICAgICBpZiAocy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBpZiAoc1swXSAhPT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcyA9IHMuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbiwgYywgb2sgfSA9IGR0b2kocyk7XG4gICAgICAgIGlmICghb2sgfHwgbiA+IDB4RkYpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcyA9IHMuc3Vic3RyaW5nKGMpO1xuICAgICAgICBpcFtpXSA9IG47XG4gICAgfVxuICAgIHJldHVybiBpcFY0KGlwWzBdLCBpcFsxXSwgaXBbMl0sIGlwWzNdKTtcbn1cbmZ1bmN0aW9uIHBhcnNlSVB2NihzKSB7XG4gICAgY29uc3QgaXAgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgbGV0IGVsbGlwc2lzID0gLTE7XG4gICAgaWYgKHMubGVuZ3RoID49IDIgJiYgc1swXSA9PT0gXCI6XCIgJiYgc1sxXSA9PT0gXCI6XCIpIHtcbiAgICAgICAgZWxsaXBzaXMgPSAwO1xuICAgICAgICBzID0gcy5zdWJzdHJpbmcoMik7XG4gICAgICAgIGlmIChzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGlwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZShpIDwgMTYpe1xuICAgICAgICBjb25zdCB7IG4sIGMsIG9rIH0gPSB4dG9pKHMpO1xuICAgICAgICBpZiAoIW9rIHx8IG4gPiAweEZGRkYpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPCBzLmxlbmd0aCAmJiBzW2NdID09PSBcIi5cIikge1xuICAgICAgICAgICAgaWYgKGVsbGlwc2lzIDwgMCAmJiBpICE9IDE2IC0gNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSArIDQgPiAxNikge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpcDQgPSBwYXJzZUlQdjQocyk7XG4gICAgICAgICAgICBpZiAoaXA0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXBbaV0gPSBpcDRbMTJdO1xuICAgICAgICAgICAgaXBbaSArIDFdID0gaXA0WzEzXTtcbiAgICAgICAgICAgIGlwW2kgKyAyXSA9IGlwNFsxNF07XG4gICAgICAgICAgICBpcFtpICsgM10gPSBpcDRbMTVdO1xuICAgICAgICAgICAgcyA9IFwiXCI7XG4gICAgICAgICAgICBpICs9IElQdjRMRU47XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpcFtpXSA9IG4gPj4gODtcbiAgICAgICAgaXBbaSArIDFdID0gbjtcbiAgICAgICAgaSArPSAyO1xuICAgICAgICBzID0gcy5zdWJzdHJpbmcoYyk7XG4gICAgICAgIGlmIChzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNbMF0gIT09IFwiOlwiIHx8IHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcyA9IHMuc3Vic3RyaW5nKDEpO1xuICAgICAgICBpZiAoc1swXSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgIGlmIChlbGxpcHNpcyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsbGlwc2lzID0gaTtcbiAgICAgICAgICAgIHMgPSBzLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIGlmIChzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoaSA8IDE2KSB7XG4gICAgICAgIGlmIChlbGxpcHNpcyA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbiA9IDE2IC0gaTtcbiAgICAgICAgZm9yKGxldCBqID0gaSAtIDE7IGogPj0gZWxsaXBzaXM7IGotLSl7XG4gICAgICAgICAgICBpcFtqICsgbl0gPSBpcFtqXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IobGV0IGogPSBlbGxpcHNpcyArIG4gLSAxOyBqID49IGVsbGlwc2lzOyBqLS0pe1xuICAgICAgICAgICAgaXBbal0gPSAwO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChlbGxpcHNpcyA+PSAwKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBpcDtcbn1cbmZ1bmN0aW9uIGR0b2kocykge1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgbiA9IDA7XG4gICAgZm9yKGkgPSAwOyBpIDwgcy5sZW5ndGggJiYgNDggPD0gcy5jaGFyQ29kZUF0KGkpICYmIHMuY2hhckNvZGVBdChpKSA8PSA1NzsgaSsrKXtcbiAgICAgICAgbiA9IG4gKiAxMCArIChzLmNoYXJDb2RlQXQoaSkgLSBBU0NJSTApO1xuICAgICAgICBpZiAobiA+PSAweEZGRkZGRikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuOiAweEZGRkZGRixcbiAgICAgICAgICAgICAgICBjOiBpLFxuICAgICAgICAgICAgICAgIG9rOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbjogMCxcbiAgICAgICAgICAgIGM6IDAsXG4gICAgICAgICAgICBvazogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbjogbixcbiAgICAgICAgYzogaSxcbiAgICAgICAgb2s6IHRydWVcbiAgICB9O1xufVxuZnVuY3Rpb24geHRvaShzKSB7XG4gICAgbGV0IG4gPSAwO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IoaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgaWYgKDQ4IDw9IHMuY2hhckNvZGVBdChpKSAmJiBzLmNoYXJDb2RlQXQoaSkgPD0gNTcpIHtcbiAgICAgICAgICAgIG4gKj0gMTY7XG4gICAgICAgICAgICBuICs9IHMuY2hhckNvZGVBdChpKSAtIEFTQ0lJMDtcbiAgICAgICAgfSBlbHNlIGlmICg5NyA8PSBzLmNoYXJDb2RlQXQoaSkgJiYgcy5jaGFyQ29kZUF0KGkpIDw9IDEwMikge1xuICAgICAgICAgICAgbiAqPSAxNjtcbiAgICAgICAgICAgIG4gKz0gcy5jaGFyQ29kZUF0KGkpIC0gQVNDSUlhICsgMTA7XG4gICAgICAgIH0gZWxzZSBpZiAoNjUgPD0gcy5jaGFyQ29kZUF0KGkpICYmIHMuY2hhckNvZGVBdChpKSA8PSA3MCkge1xuICAgICAgICAgICAgbiAqPSAxNjtcbiAgICAgICAgICAgIG4gKz0gcy5jaGFyQ29kZUF0KGkpIC0gQVNDSUlBICsgMTA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobiA+PSAweEZGRkZGRikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuOiAwLFxuICAgICAgICAgICAgICAgIGM6IGksXG4gICAgICAgICAgICAgICAgb2s6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuOiAwLFxuICAgICAgICAgICAgYzogaSxcbiAgICAgICAgICAgIG9rOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBuOiBuLFxuICAgICAgICBjOiBpLFxuICAgICAgICBvazogdHJ1ZVxuICAgIH07XG59XG5mdW5jdGlvbiBpc0lQVjRPckhvc3RuYW1lKGhwKSB7XG4gICAgaWYgKGhwLmluZGV4T2YoXCJbXCIpICE9PSAtMSB8fCBocC5pbmRleE9mKFwiOjpcIikgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGhwLmluZGV4T2YoXCIuXCIpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGhwLnNwbGl0KFwiOlwiKS5sZW5ndGggPD0gMikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNJUFY2KGhwKSB7XG4gICAgcmV0dXJuICFpc0lQVjRPckhvc3RuYW1lKGhwKTtcbn1cbmZ1bmN0aW9uIGZpbHRlcklwdjZNYXBwZWRUb0lwdjQoaHApIHtcbiAgICBjb25zdCBwcmVmaXggPSBcIjo6RkZGRjpcIjtcbiAgICBjb25zdCBpZHggPSBocC50b1VwcGVyQ2FzZSgpLmluZGV4T2YocHJlZml4KTtcbiAgICBpZiAoaWR4ICE9PSAtMSAmJiBocC5pbmRleE9mKFwiLlwiKSAhPT0gLTEpIHtcbiAgICAgICAgbGV0IGlwID0gaHAuc3Vic3RyaW5nKGlkeCArIHByZWZpeC5sZW5ndGgpO1xuICAgICAgICBpcCA9IGlwLnJlcGxhY2UoXCJbXCIsIFwiXCIpO1xuICAgICAgICByZXR1cm4gaXAucmVwbGFjZShcIl1cIiwgXCJcIik7XG4gICAgfVxuICAgIHJldHVybiBocDtcbn1cbmZ1bmN0aW9uIGhvc3RQb3J0KHUpIHtcbiAgICB1ID0gdS50cmltKCk7XG4gICAgaWYgKHUubWF0Y2goL14oLio6XFwvXFwvKSguKikvbSkpIHtcbiAgICAgICAgdSA9IHUucmVwbGFjZSgvXiguKjpcXC9cXC8pKC4qKS9nbSwgXCIkMlwiKTtcbiAgICB9XG4gICAgdSA9IGZpbHRlcklwdjZNYXBwZWRUb0lwdjQodSk7XG4gICAgaWYgKGlzSVBWNih1KSAmJiB1LmluZGV4T2YoXCJbXCIpID09PSAtMSkge1xuICAgICAgICB1ID0gYFske3V9XWA7XG4gICAgfVxuICAgIGNvbnN0IG9wID0gaXNJUFY2KHUpID8gdS5tYXRjaCgvKF06KShcXGQrKS8pIDogdS5tYXRjaCgvKDopKFxcZCspLyk7XG4gICAgY29uc3QgcG9ydCA9IG9wICYmIG9wLmxlbmd0aCA9PT0gMyAmJiBvcFsxXSAmJiBvcFsyXSA/IHBhcnNlSW50KG9wWzJdKSA6IDQyMjI7XG4gICAgY29uc3QgcHJvdG9jb2wgPSBwb3J0ID09PSA4MCA/IFwiaHR0cHNcIiA6IFwiaHR0cFwiO1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7cHJvdG9jb2x9Oi8vJHt1fWApO1xuICAgIHVybC5wb3J0ID0gYCR7cG9ydH1gO1xuICAgIGxldCBob3N0bmFtZSA9IHVybC5ob3N0bmFtZTtcbiAgICBpZiAoaG9zdG5hbWUuY2hhckF0KDApID09PSBcIltcIikge1xuICAgICAgICBob3N0bmFtZSA9IGhvc3RuYW1lLnN1YnN0cmluZygxLCBob3N0bmFtZS5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgY29uc3QgbGlzdGVuID0gdXJsLmhvc3Q7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGlzdGVuLFxuICAgICAgICBob3N0bmFtZSxcbiAgICAgICAgcG9ydFxuICAgIH07XG59XG5jbGFzcyBTZXJ2ZXJJbXBsIHtcbiAgICBzcmM7XG4gICAgbGlzdGVuO1xuICAgIGhvc3RuYW1lO1xuICAgIHBvcnQ7XG4gICAgZGlkQ29ubmVjdDtcbiAgICByZWNvbm5lY3RzO1xuICAgIGxhc3RDb25uZWN0O1xuICAgIGdvc3NpcGVkO1xuICAgIHRsc05hbWU7XG4gICAgcmVzb2x2ZXM7XG4gICAgY29uc3RydWN0b3IodSwgZ29zc2lwZWQgPSBmYWxzZSl7XG4gICAgICAgIHRoaXMuc3JjID0gdTtcbiAgICAgICAgdGhpcy50bHNOYW1lID0gXCJcIjtcbiAgICAgICAgY29uc3QgdiA9IGhvc3RQb3J0KHUpO1xuICAgICAgICB0aGlzLmxpc3RlbiA9IHYubGlzdGVuO1xuICAgICAgICB0aGlzLmhvc3RuYW1lID0gdi5ob3N0bmFtZTtcbiAgICAgICAgdGhpcy5wb3J0ID0gdi5wb3J0O1xuICAgICAgICB0aGlzLmRpZENvbm5lY3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RzID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Q29ubmVjdCA9IDA7XG4gICAgICAgIHRoaXMuZ29zc2lwZWQgPSBnb3NzaXBlZDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbjtcbiAgICB9XG4gICAgYXN5bmMgcmVzb2x2ZShvcHRzKSB7XG4gICAgICAgIGlmICghb3B0cy5mbiB8fCBvcHRzLnJlc29sdmUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmID0gW107XG4gICAgICAgIGlmIChpc0lQKHRoaXMuaG9zdG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpcHMgPSBhd2FpdCBvcHRzLmZuKHRoaXMuaG9zdG5hbWUpO1xuICAgICAgICAgICAgaWYgKG9wdHMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgcmVzb2x2ZSAke3RoaXMuaG9zdG5hbWV9ID0gJHtpcHMuam9pbihcIixcIil9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlwIG9mIGlwcyl7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdG8gPSB0aGlzLnBvcnQgPT09IDgwID8gXCJodHRwc1wiIDogXCJodHRwXCI7XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHtwcm90b306Ly8ke2lzSVBWNihpcCkgPyBcIltcIiArIGlwICsgXCJdXCIgOiBpcH1gKTtcbiAgICAgICAgICAgICAgICB1cmwucG9ydCA9IGAke3RoaXMucG9ydH1gO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNzID0gbmV3IFNlcnZlckltcGwodXJsLmhvc3QsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBzcy50bHNOYW1lID0gdGhpcy5ob3N0bmFtZTtcbiAgICAgICAgICAgICAgICBidWYucHVzaChzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMucmFuZG9taXplKSB7XG4gICAgICAgICAgICBzaHVmZmxlKGJ1Zik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNvbHZlcyA9IGJ1ZjtcbiAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG59XG5jbGFzcyBTZXJ2ZXJzIHtcbiAgICBmaXJzdFNlbGVjdDtcbiAgICBzZXJ2ZXJzO1xuICAgIGN1cnJlbnRTZXJ2ZXI7XG4gICAgdGxzTmFtZTtcbiAgICByYW5kb21pemU7XG4gICAgY29uc3RydWN0b3IobGlzdGVucyA9IFtdLCBvcHRzID0ge30pe1xuICAgICAgICB0aGlzLmZpcnN0U2VsZWN0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZXJ2ZXJzID0gW107XG4gICAgICAgIHRoaXMudGxzTmFtZSA9IFwiXCI7XG4gICAgICAgIHRoaXMucmFuZG9taXplID0gb3B0cy5yYW5kb21pemUgfHwgZmFsc2U7XG4gICAgICAgIGNvbnN0IHVybFBhcnNlRm4gPSBnZXRVcmxQYXJzZUZuKCk7XG4gICAgICAgIGlmIChsaXN0ZW5zKSB7XG4gICAgICAgICAgICBsaXN0ZW5zLmZvckVhY2goKGhwKT0+e1xuICAgICAgICAgICAgICAgIGhwID0gdXJsUGFyc2VGbiA/IHVybFBhcnNlRm4oaHApIDogaHA7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZXJzLnB1c2gobmV3IFNlcnZlckltcGwoaHApKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMucmFuZG9taXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZXJzID0gc2h1ZmZsZSh0aGlzLnNlcnZlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNlcnZlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFNlcnZlcihgJHtERUZBVUxUX0hPU1R9OiR7ZGVmYXVsdFBvcnQoKX1gLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50U2VydmVyID0gdGhpcy5zZXJ2ZXJzWzBdO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5zZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIHVwZGF0ZVRMU05hbWUoKSB7XG4gICAgICAgIGNvbnN0IGNzID0gdGhpcy5nZXRDdXJyZW50U2VydmVyKCk7XG4gICAgICAgIGlmICghaXNJUChjcy5ob3N0bmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMudGxzTmFtZSA9IGNzLmhvc3RuYW1lO1xuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJzLmZvckVhY2goKHMpPT57XG4gICAgICAgICAgICAgICAgaWYgKHMuZ29zc2lwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcy50bHNOYW1lID0gdGhpcy50bHNOYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEN1cnJlbnRTZXJ2ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTZXJ2ZXI7XG4gICAgfVxuICAgIGFkZFNlcnZlcih1LCBpbXBsaWNpdCA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHVybFBhcnNlRm4gPSBnZXRVcmxQYXJzZUZuKCk7XG4gICAgICAgIHUgPSB1cmxQYXJzZUZuID8gdXJsUGFyc2VGbih1KSA6IHU7XG4gICAgICAgIGNvbnN0IHMgPSBuZXcgU2VydmVySW1wbCh1LCBpbXBsaWNpdCk7XG4gICAgICAgIGlmIChpc0lQKHMuaG9zdG5hbWUpKSB7XG4gICAgICAgICAgICBzLnRsc05hbWUgPSB0aGlzLnRsc05hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXJ2ZXJzLnB1c2gocyk7XG4gICAgfVxuICAgIHNlbGVjdFNlcnZlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlyc3RTZWxlY3QpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RTZWxlY3QgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTZXJ2ZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdCA9IHRoaXMuc2VydmVycy5zaGlmdCgpO1xuICAgICAgICBpZiAodCkge1xuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJzLnB1c2godCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTZXJ2ZXIgPSB0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH1cbiAgICByZW1vdmVDdXJyZW50U2VydmVyKCkge1xuICAgICAgICB0aGlzLnJlbW92ZVNlcnZlcih0aGlzLmN1cnJlbnRTZXJ2ZXIpO1xuICAgIH1cbiAgICByZW1vdmVTZXJ2ZXIoc2VydmVyKSB7XG4gICAgICAgIGlmIChzZXJ2ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zZXJ2ZXJzLmluZGV4T2Yoc2VydmVyKTtcbiAgICAgICAgICAgIHRoaXMuc2VydmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmVycy5sZW5ndGg7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZlcnMubGVuZ3RoID8gdGhpcy5zZXJ2ZXJzWzBdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXRTZXJ2ZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2ZXJzO1xuICAgIH1cbiAgICB1cGRhdGUoaW5mbywgZW5jcnlwdGVkKSB7XG4gICAgICAgIGNvbnN0IGFkZGVkID0gW107XG4gICAgICAgIGxldCBkZWxldGVkID0gW107XG4gICAgICAgIGNvbnN0IHVybFBhcnNlRm4gPSBnZXRVcmxQYXJzZUZuKCk7XG4gICAgICAgIGNvbnN0IGRpc2NvdmVyZWQgPSBuZXcgTWFwKCk7XG4gICAgICAgIGlmIChpbmZvLmNvbm5lY3RfdXJscyAmJiBpbmZvLmNvbm5lY3RfdXJscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpbmZvLmNvbm5lY3RfdXJscy5mb3JFYWNoKChocCk9PntcbiAgICAgICAgICAgICAgICBocCA9IHVybFBhcnNlRm4gPyB1cmxQYXJzZUZuKGhwLCBlbmNyeXB0ZWQpIDogaHA7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IG5ldyBTZXJ2ZXJJbXBsKGhwLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBkaXNjb3ZlcmVkLnNldChocCwgcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b0RlbGV0ZSA9IFtdO1xuICAgICAgICB0aGlzLnNlcnZlcnMuZm9yRWFjaCgocywgaW5kZXgpPT57XG4gICAgICAgICAgICBjb25zdCB1ID0gcy5saXN0ZW47XG4gICAgICAgICAgICBpZiAocy5nb3NzaXBlZCAmJiB0aGlzLmN1cnJlbnRTZXJ2ZXIubGlzdGVuICE9PSB1ICYmIGRpc2NvdmVyZWQuZ2V0KHUpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0b0RlbGV0ZS5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc2NvdmVyZWQuZGVsZXRlKHUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdG9EZWxldGUucmV2ZXJzZSgpO1xuICAgICAgICB0b0RlbGV0ZS5mb3JFYWNoKChpbmRleCk9PntcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWQgPSB0aGlzLnNlcnZlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIGRlbGV0ZWQgPSBkZWxldGVkLmNvbmNhdChyZW1vdmVkWzBdLmxpc3Rlbik7XG4gICAgICAgIH0pO1xuICAgICAgICBkaXNjb3ZlcmVkLmZvckVhY2goKHYsIGspPT57XG4gICAgICAgICAgICB0aGlzLnNlcnZlcnMucHVzaCh2KTtcbiAgICAgICAgICAgIGFkZGVkLnB1c2goayk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkZWQsXG4gICAgICAgICAgICBkZWxldGVkXG4gICAgICAgIH07XG4gICAgfVxufVxuY2xhc3MgTXV4U3Vic2NyaXB0aW9uIHtcbiAgICBiYXNlSW5ib3g7XG4gICAgcmVxcztcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLnJlcXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXMuc2l6ZTtcbiAgICB9XG4gICAgaW5pdChwcmVmaXgpIHtcbiAgICAgICAgdGhpcy5iYXNlSW5ib3ggPSBgJHtjcmVhdGVJbmJveChwcmVmaXgpfS5gO1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlSW5ib3g7XG4gICAgfVxuICAgIGFkZChyKSB7XG4gICAgICAgIGlmICghaXNOYU4oci5yZWNlaXZlZCkpIHtcbiAgICAgICAgICAgIHIucmVjZWl2ZWQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVxcy5zZXQoci50b2tlbiwgcik7XG4gICAgfVxuICAgIGdldCh0b2tlbikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXFzLmdldCh0b2tlbik7XG4gICAgfVxuICAgIGNhbmNlbChyKSB7XG4gICAgICAgIHRoaXMucmVxcy5kZWxldGUoci50b2tlbik7XG4gICAgfVxuICAgIGdldFRva2VuKG0pIHtcbiAgICAgICAgY29uc3QgcyA9IG0uc3ViamVjdCB8fCBcIlwiO1xuICAgICAgICBpZiAocy5pbmRleE9mKHRoaXMuYmFzZUluYm94KSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHMuc3Vic3RyaW5nKHRoaXMuYmFzZUluYm94Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFsbCgpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5yZXFzLnZhbHVlcygpKTtcbiAgICB9XG4gICAgaGFuZGxlRXJyb3IoaXNNdXhQZXJtaXNzaW9uRXJyb3IsIGVycikge1xuICAgICAgICBpZiAoZXJyICYmIGVyci5wZXJtaXNzaW9uQ29udGV4dCkge1xuICAgICAgICAgICAgaWYgKGlzTXV4UGVybWlzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGwoKS5mb3JFYWNoKChyKT0+e1xuICAgICAgICAgICAgICAgICAgICByLnJlc29sdmVyKGVyciwge30pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY3R4ID0gZXJyLnBlcm1pc3Npb25Db250ZXh0O1xuICAgICAgICAgICAgaWYgKGN0eC5vcGVyYXRpb24gPT09IFwicHVibGlzaFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxID0gdGhpcy5hbGwoKS5maW5kKChzKT0+e1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5yZXF1ZXN0U3ViamVjdCA9PT0gY3R4LnN1YmplY3Q7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICByZXEucmVzb2x2ZXIoZXJyLCB7fSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRpc3BhdGNoZXIoKSB7XG4gICAgICAgIHJldHVybiAoZXJyLCBtKT0+e1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmdldFRva2VuKG0pO1xuICAgICAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IHRoaXMuZ2V0KHRva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyID09PSBudWxsICYmIG0uaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gaXNSZXF1ZXN0RXJyb3IobSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgci5yZXNvbHZlcihlcnIsIG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLlRpbWVvdXQpO1xuICAgICAgICB0aGlzLnJlcXMuZm9yRWFjaCgocmVxKT0+e1xuICAgICAgICAgICAgcmVxLnJlc29sdmVyKGVyciwge30pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBIZWFydGJlYXQge1xuICAgIHBoO1xuICAgIGludGVydmFsO1xuICAgIG1heE91dDtcbiAgICB0aW1lcjtcbiAgICBwZW5kaW5ncztcbiAgICBjb25zdHJ1Y3RvcihwaCwgaW50ZXJ2YWwsIG1heE91dCl7XG4gICAgICAgIHRoaXMucGggPSBwaDtcbiAgICAgICAgdGhpcy5pbnRlcnZhbCA9IGludGVydmFsO1xuICAgICAgICB0aGlzLm1heE91dCA9IG1heE91dDtcbiAgICAgICAgdGhpcy5wZW5kaW5ncyA9IFtdO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGUoKTtcbiAgICB9XG4gICAgY2FuY2VsKHN0YWxlKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgICAgICB0aGlzLnRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICAgIGlmIChzdGFsZSkge1xuICAgICAgICAgICAgdGhpcy5waC5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3NjaGVkdWxlKCkge1xuICAgICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgdGhpcy5waC5kaXNwYXRjaFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgdHlwZTogRGVidWdFdmVudHMuUGluZ1RpbWVyLFxuICAgICAgICAgICAgICAgIGRhdGE6IGAke3RoaXMucGVuZGluZ3MubGVuZ3RoICsgMX1gXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdzLmxlbmd0aCA9PT0gdGhpcy5tYXhPdXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbCh0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwaW5nID0gZGVmZXJyZWQoKTtcbiAgICAgICAgICAgIHRoaXMucGguZmx1c2gocGluZykudGhlbigoKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICAgICAgICB9KS5jYXRjaCgoKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ3MucHVzaChwaW5nKTtcbiAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlKCk7XG4gICAgICAgIH0sIHRoaXMuaW50ZXJ2YWwpO1xuICAgIH1cbiAgICBfcmVzZXQoKSB7XG4gICAgICAgIHRoaXMucGVuZGluZ3MgPSB0aGlzLnBlbmRpbmdzLmZpbHRlcigocCk9PntcbiAgICAgICAgICAgIGNvbnN0IGQgPSBwO1xuICAgICAgICAgICAgZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIEFzc2VydGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1zZyl7XG4gICAgICAgIHN1cGVyKG1zZyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiQXNzZXJ0aW9uRXJyb3JcIjtcbiAgICB9XG59XG5mdW5jdGlvbiBhc3NlcnQoY29uZCwgbXNnID0gXCJBc3NlcnRpb24gZmFpbGVkLlwiKSB7XG4gICAgaWYgKCFjb25kKSB7XG4gICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihtc2cpO1xuICAgIH1cbn1cbmNvbnN0IE1JTl9SRUFEID0gMzIgKiAxMDI0O1xuY29uc3QgTUFYX1NJWkUgPSAyICoqIDMyIC0gMjtcbmZ1bmN0aW9uIGNvcHkoc3JjLCBkc3QsIG9mZiA9IDApIHtcbiAgICBjb25zdCByID0gZHN0LmJ5dGVMZW5ndGggLSBvZmY7XG4gICAgaWYgKHNyYy5ieXRlTGVuZ3RoID4gcikge1xuICAgICAgICBzcmMgPSBzcmMuc3ViYXJyYXkoMCwgcik7XG4gICAgfVxuICAgIGRzdC5zZXQoc3JjLCBvZmYpO1xuICAgIHJldHVybiBzcmMuYnl0ZUxlbmd0aDtcbn1cbmNsYXNzIERlbm9CdWZmZXIge1xuICAgIF9idWY7XG4gICAgX29mZjtcbiAgICBjb25zdHJ1Y3RvcihhYil7XG4gICAgICAgIHRoaXMuX29mZiA9IDA7XG4gICAgICAgIGlmIChhYiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9idWYgPSBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9idWYgPSBuZXcgVWludDhBcnJheShhYik7XG4gICAgfVxuICAgIGJ5dGVzKG9wdGlvbnMgPSB7XG4gICAgICAgIGNvcHk6IHRydWVcbiAgICB9KSB7XG4gICAgICAgIGlmIChvcHRpb25zLmNvcHkgPT09IGZhbHNlKSByZXR1cm4gdGhpcy5fYnVmLnN1YmFycmF5KHRoaXMuX29mZik7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWYuc2xpY2UodGhpcy5fb2ZmKTtcbiAgICB9XG4gICAgZW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWYuYnl0ZUxlbmd0aCA8PSB0aGlzLl9vZmY7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWYuYnl0ZUxlbmd0aCAtIHRoaXMuX29mZjtcbiAgICB9XG4gICAgZ2V0IGNhcGFjaXR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnVmLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICB0cnVuY2F0ZShuKSB7XG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPCAwIHx8IG4gPiB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJieXRlcy5CdWZmZXI6IHRydW5jYXRpb24gb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jlc2xpY2UodGhpcy5fb2ZmICsgbik7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLl9yZXNsaWNlKDApO1xuICAgICAgICB0aGlzLl9vZmYgPSAwO1xuICAgIH1cbiAgICBfdHJ5R3Jvd0J5UmVzbGljZShuKSB7XG4gICAgICAgIGNvbnN0IGwgPSB0aGlzLl9idWYuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG4gPD0gdGhpcy5jYXBhY2l0eSAtIGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2xpY2UobCArIG4pO1xuICAgICAgICAgICAgcmV0dXJuIGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBfcmVzbGljZShsZW4pIHtcbiAgICAgICAgYXNzZXJ0KGxlbiA8PSB0aGlzLl9idWYuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB0aGlzLl9idWYgPSBuZXcgVWludDhBcnJheSh0aGlzLl9idWYuYnVmZmVyLCAwLCBsZW4pO1xuICAgIH1cbiAgICByZWFkQnl0ZSgpIHtcbiAgICAgICAgY29uc3QgYSA9IG5ldyBVaW50OEFycmF5KDEpO1xuICAgICAgICBpZiAodGhpcy5yZWFkKGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gYVswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmVhZChwKSB7XG4gICAgICAgIGlmICh0aGlzLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIGlmIChwLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5yZWFkID0gY29weSh0aGlzLl9idWYuc3ViYXJyYXkodGhpcy5fb2ZmKSwgcCk7XG4gICAgICAgIHRoaXMuX29mZiArPSBucmVhZDtcbiAgICAgICAgcmV0dXJuIG5yZWFkO1xuICAgIH1cbiAgICB3cml0ZUJ5dGUobikge1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZShVaW50OEFycmF5Lm9mKG4pKTtcbiAgICB9XG4gICAgd3JpdGVTdHJpbmcocykge1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZShURS5lbmNvZGUocykpO1xuICAgIH1cbiAgICB3cml0ZShwKSB7XG4gICAgICAgIGNvbnN0IG0gPSB0aGlzLl9ncm93KHAuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiBjb3B5KHAsIHRoaXMuX2J1ZiwgbSk7XG4gICAgfVxuICAgIF9ncm93KG4pIHtcbiAgICAgICAgY29uc3QgbSA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAobSA9PT0gMCAmJiB0aGlzLl9vZmYgIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpID0gdGhpcy5fdHJ5R3Jvd0J5UmVzbGljZShuKTtcbiAgICAgICAgaWYgKGkgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYyA9IHRoaXMuY2FwYWNpdHk7XG4gICAgICAgIGlmIChuIDw9IE1hdGguZmxvb3IoYyAvIDIpIC0gbSkge1xuICAgICAgICAgICAgY29weSh0aGlzLl9idWYuc3ViYXJyYXkodGhpcy5fb2ZmKSwgdGhpcy5fYnVmKTtcbiAgICAgICAgfSBlbHNlIGlmIChjICsgbiA+IE1BWF9TSVpFKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYnVmZmVyIGNhbm5vdCBiZSBncm93biBiZXlvbmQgdGhlIG1heGltdW0gc2l6ZS5cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShNYXRoLm1pbigyICogYyArIG4sIE1BWF9TSVpFKSk7XG4gICAgICAgICAgICBjb3B5KHRoaXMuX2J1Zi5zdWJhcnJheSh0aGlzLl9vZmYpLCBidWYpO1xuICAgICAgICAgICAgdGhpcy5fYnVmID0gYnVmO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29mZiA9IDA7XG4gICAgICAgIHRoaXMuX3Jlc2xpY2UoTWF0aC5taW4obSArIG4sIE1BWF9TSVpFKSk7XG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cbiAgICBncm93KG4pIHtcbiAgICAgICAgaWYgKG4gPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkJ1ZmZlci5fZ3JvdzogbmVnYXRpdmUgY291bnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbSA9IHRoaXMuX2dyb3cobik7XG4gICAgICAgIHRoaXMuX3Jlc2xpY2UobSk7XG4gICAgfVxuICAgIHJlYWRGcm9tKHIpIHtcbiAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICBjb25zdCB0bXAgPSBuZXcgVWludDhBcnJheShNSU5fUkVBRCk7XG4gICAgICAgIHdoaWxlKHRydWUpe1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkR3JvdyA9IHRoaXMuY2FwYWNpdHkgLSB0aGlzLmxlbmd0aCA8IE1JTl9SRUFEO1xuICAgICAgICAgICAgY29uc3QgYnVmID0gc2hvdWxkR3JvdyA/IHRtcCA6IG5ldyBVaW50OEFycmF5KHRoaXMuX2J1Zi5idWZmZXIsIHRoaXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IG5yZWFkID0gci5yZWFkKGJ1Zik7XG4gICAgICAgICAgICBpZiAobnJlYWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRHcm93KSB0aGlzLndyaXRlKGJ1Zi5zdWJhcnJheSgwLCBucmVhZCkpO1xuICAgICAgICAgICAgZWxzZSB0aGlzLl9yZXNsaWNlKHRoaXMubGVuZ3RoICsgbnJlYWQpO1xuICAgICAgICAgICAgbiArPSBucmVhZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbnZhciBLaW5kO1xuKGZ1bmN0aW9uKEtpbmQpIHtcbiAgICBLaW5kW0tpbmRbXCJPS1wiXSA9IDBdID0gXCJPS1wiO1xuICAgIEtpbmRbS2luZFtcIkVSUlwiXSA9IDFdID0gXCJFUlJcIjtcbiAgICBLaW5kW0tpbmRbXCJNU0dcIl0gPSAyXSA9IFwiTVNHXCI7XG4gICAgS2luZFtLaW5kW1wiSU5GT1wiXSA9IDNdID0gXCJJTkZPXCI7XG4gICAgS2luZFtLaW5kW1wiUElOR1wiXSA9IDRdID0gXCJQSU5HXCI7XG4gICAgS2luZFtLaW5kW1wiUE9OR1wiXSA9IDVdID0gXCJQT05HXCI7XG59KShLaW5kIHx8IChLaW5kID0ge30pKTtcbmZ1bmN0aW9uIG5ld01zZ0FyZygpIHtcbiAgICBjb25zdCBtYSA9IHt9O1xuICAgIG1hLnNpZCA9IC0xO1xuICAgIG1hLmhkciA9IC0xO1xuICAgIG1hLnNpemUgPSAtMTtcbiAgICByZXR1cm4gbWE7XG59XG5jb25zdCBBU0NJSV8wID0gNDg7XG5jbGFzcyBQYXJzZXIge1xuICAgIGRpc3BhdGNoZXI7XG4gICAgc3RhdGU7XG4gICAgYXM7XG4gICAgZHJvcDtcbiAgICBoZHI7XG4gICAgbWE7XG4gICAgYXJnQnVmO1xuICAgIG1zZ0J1ZjtcbiAgICBjb25zdHJ1Y3RvcihkaXNwYXRjaGVyKXtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlcjtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX1NUQVJUO1xuICAgICAgICB0aGlzLmFzID0gMDtcbiAgICAgICAgdGhpcy5kcm9wID0gMDtcbiAgICAgICAgdGhpcy5oZHIgPSAwO1xuICAgIH1cbiAgICBwYXJzZShidWYpIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBjb25zdCBiID0gYnVmW2ldO1xuICAgICAgICAgICAgc3dpdGNoKHRoaXMuc3RhdGUpe1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfU1RBUlQ6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuTTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MubTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfTTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhkciA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWEgPSBuZXdNc2dBcmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuSDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuaDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfSDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhkciA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYSA9IG5ld01zZ0FyZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5QOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5wOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9QO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5QTFVTOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9QTFVTO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5NSU5VUzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfTUlOVVM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLkk6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLmk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX0k7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfSDpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5NOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5tOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9NO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYnVmLnN1YmFycmF5KGkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLk9QX006XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuUzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfTVM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfTVM6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuRzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuZzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfTVNHO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYnVmLnN1YmFycmF5KGkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLk9QX01TRzpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5TUEFDRTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuVEFCOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9NU0dfU1BDO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYnVmLnN1YmFycmF5KGkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLk9QX01TR19TUEM6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuU1BBQ0U6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLlRBQjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk1TR19BUkc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcyA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5NU0dfQVJHOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goYil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLkNSOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLk5MOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJnID0gdGhpcy5hcmdCdWYgPyB0aGlzLmFyZ0J1Zi5ieXRlcygpIDogYnVmLnN1YmFycmF5KHRoaXMuYXMsIGkgLSB0aGlzLmRyb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NNc2dBcmdzKGFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXMgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk1TR19QQVlMT0FEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gdGhpcy5hcyArIHRoaXMubWEuc2l6ZSAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXJnQnVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXJnQnVmLndyaXRlQnl0ZShiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5NU0dfUEFZTE9BRDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubXNnQnVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tc2dCdWYubGVuZ3RoID49IHRoaXMubWEuc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLm1zZ0J1Zi5ieXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHk6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGVyLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBLaW5kLk1TRyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXNnOiB0aGlzLm1hLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmdCdWYgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tc2dCdWYgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk1TR19FTkQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0b0NvcHkgPSB0aGlzLm1hLnNpemUgLSB0aGlzLm1zZ0J1Zi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXZhaWwgPSBidWYubGVuZ3RoIC0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXZhaWwgPCB0b0NvcHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9Db3B5ID0gYXZhaWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b0NvcHkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubXNnQnVmLndyaXRlKGJ1Zi5zdWJhcnJheShpLCBpICsgdG9Db3B5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBpICsgdG9Db3B5IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1zZ0J1Zi53cml0ZUJ5dGUoYik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgLSB0aGlzLmFzID49IHRoaXMubWEuc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGVyLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEtpbmQuTVNHLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1zZzogdGhpcy5tYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBidWYuc3ViYXJyYXkodGhpcy5hcywgaSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmdCdWYgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1zZ0J1ZiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5NU0dfRU5EO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuTVNHX0VORDpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5OTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3AgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXMgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfU1RBUlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfUExVUzpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5POlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5vOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9QTFVTX087XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfUExVU19POlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goYil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLks6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLms6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX1BMVVNfT0s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfUExVU19PSzpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5OTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoZXIucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEtpbmQuT0tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3AgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9TVEFSVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLk9QX01JTlVTOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goYil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLkU6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLmU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX01JTlVTX0U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfTUlOVVNfRTpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5SOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5yOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9NSU5VU19FUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGJ1Zi5zdWJhcnJheShpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9NSU5VU19FUjpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5SOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5yOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9NSU5VU19FUlI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfTUlOVVNfRVJSOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goYil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLlNQQUNFOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5UQUI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX01JTlVTX0VSUl9TUEM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfTUlOVVNfRVJSX1NQQzpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5TUEFDRTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuVEFCOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuTUlOVVNfRVJSX0FSRztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFzID0gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLk1JTlVTX0VSUl9BUkc6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuQ1I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuTkw6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYXJnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hcmdCdWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IHRoaXMuYXJnQnVmLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFyZ0J1ZiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGJ1Zi5zdWJhcnJheSh0aGlzLmFzLCBpIC0gdGhpcy5kcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoZXIucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBLaW5kLkVSUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGFyZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcyA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfU1RBUlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXJnQnVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXJnQnVmLndyaXRlKFVpbnQ4QXJyYXkub2YoYikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLk9QX1A6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuSTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuaTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfUEk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLk86XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLm86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX1BPO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYnVmLnN1YmFycmF5KGkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLk9QX1BPOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goYil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLk46XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLm46XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX1BPTjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGJ1Zi5zdWJhcnJheShpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9QT046XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuRzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuZzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfUE9ORztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGJ1Zi5zdWJhcnJheShpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9QT05HOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goYil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLk5MOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hlci5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogS2luZC5QT05HXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfU1RBUlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9QSTpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5OOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5uOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9QSU47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfUElOOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goYil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLkc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLmc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX1BJTkc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfUElORzpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5OTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoZXIucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEtpbmQuUElOR1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX1NUQVJUO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfSTpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5OOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5uOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9JTjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGJ1Zi5zdWJhcnJheShpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9JTjpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5GOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5mOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9JTkY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfSU5GOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goYil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLk86XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLm86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX0lORk87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfSU5GTzpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5TUEFDRTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuVEFCOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9JTkZPX1NQQztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGJ1Zi5zdWJhcnJheShpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9JTkZPX1NQQzpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5TUEFDRTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuVEFCOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSU5GT19BUkc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcyA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5JTkZPX0FSRzpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5DUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3AgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5OTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhcmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFyZ0J1Zikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gdGhpcy5hcmdCdWYuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXJnQnVmID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYnVmLnN1YmFycmF5KHRoaXMuYXMsIGkgLSB0aGlzLmRyb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hlci5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEtpbmQuSU5GTyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGFyZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcyA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfU1RBUlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXJnQnVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXJnQnVmLndyaXRlQnl0ZShiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGJ1Zi5zdWJhcnJheShpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0aGlzLnN0YXRlID09PSBTdGF0ZS5NU0dfQVJHIHx8IHRoaXMuc3RhdGUgPT09IFN0YXRlLk1JTlVTX0VSUl9BUkcgfHwgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuSU5GT19BUkcpICYmICF0aGlzLmFyZ0J1Zikge1xuICAgICAgICAgICAgdGhpcy5hcmdCdWYgPSBuZXcgRGVub0J1ZmZlcihidWYuc3ViYXJyYXkodGhpcy5hcywgaSAtIHRoaXMuZHJvcCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5NU0dfUEFZTE9BRCAmJiAhdGhpcy5tc2dCdWYpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hcmdCdWYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb25lTXNnQXJnKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1zZ0J1ZiA9IG5ldyBEZW5vQnVmZmVyKGJ1Zi5zdWJhcnJheSh0aGlzLmFzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xvbmVNc2dBcmcoKSB7XG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLm1hLnN1YmplY3QubGVuZ3RoO1xuICAgICAgICBjb25zdCByID0gdGhpcy5tYS5yZXBseSA/IHRoaXMubWEucmVwbHkubGVuZ3RoIDogMDtcbiAgICAgICAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkocyArIHIpO1xuICAgICAgICBidWYuc2V0KHRoaXMubWEuc3ViamVjdCk7XG4gICAgICAgIGlmICh0aGlzLm1hLnJlcGx5KSB7XG4gICAgICAgICAgICBidWYuc2V0KHRoaXMubWEucmVwbHksIHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXJnQnVmID0gbmV3IERlbm9CdWZmZXIoYnVmKTtcbiAgICAgICAgdGhpcy5tYS5zdWJqZWN0ID0gYnVmLnN1YmFycmF5KDAsIHMpO1xuICAgICAgICBpZiAodGhpcy5tYS5yZXBseSkge1xuICAgICAgICAgICAgdGhpcy5tYS5yZXBseSA9IGJ1Zi5zdWJhcnJheShzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9jZXNzTXNnQXJncyhhcmcpIHtcbiAgICAgICAgaWYgKHRoaXMuaGRyID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NIZWFkZXJNc2dBcmdzKGFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJncyA9IFtdO1xuICAgICAgICBsZXQgc3RhcnQgPSAtMTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGFyZy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBjb25zdCBiID0gYXJnW2ldO1xuICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgIGNhc2UgY2MuU1BBQ0U6XG4gICAgICAgICAgICAgICAgY2FzZSBjYy5UQUI6XG4gICAgICAgICAgICAgICAgY2FzZSBjYy5DUjpcbiAgICAgICAgICAgICAgICBjYXNlIGNjLk5MOlxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGFyZy5zdWJhcnJheShzdGFydCwgaSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgYXJncy5wdXNoKGFyZy5zdWJhcnJheShzdGFydCkpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaChhcmdzLmxlbmd0aCl7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgdGhpcy5tYS5zdWJqZWN0ID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hLnNpZCA9IHRoaXMucHJvdG9QYXJzZUludChhcmdzWzFdKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hLnJlcGx5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMubWEuc2l6ZSA9IHRoaXMucHJvdG9QYXJzZUludChhcmdzWzJdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICB0aGlzLm1hLnN1YmplY3QgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIHRoaXMubWEuc2lkID0gdGhpcy5wcm90b1BhcnNlSW50KGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgIHRoaXMubWEucmVwbHkgPSBhcmdzWzJdO1xuICAgICAgICAgICAgICAgIHRoaXMubWEuc2l6ZSA9IHRoaXMucHJvdG9QYXJzZUludChhcmdzWzNdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGFyZywgXCJwcm9jZXNzTXNnQXJncyBQYXJzZSBFcnJvclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYS5zaWQgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYXJnLCBcInByb2Nlc3NNc2dBcmdzIEJhZCBvciBNaXNzaW5nIFNpZCBFcnJvclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYS5zaXplIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGFyZywgXCJwcm9jZXNzTXNnQXJncyBCYWQgb3IgTWlzc2luZyBTaXplIEVycm9yXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZhaWwoZGF0YSwgbGFiZWwgPSBcIlwiKSB7XG4gICAgICAgIGlmICghbGFiZWwpIHtcbiAgICAgICAgICAgIGxhYmVsID0gYHBhcnNlIGVycm9yIFske3RoaXMuc3RhdGV9XWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYWJlbCA9IGAke2xhYmVsfSBbJHt0aGlzLnN0YXRlfV1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoYCR7bGFiZWx9OiAke1RELmRlY29kZShkYXRhKX1gKTtcbiAgICB9XG4gICAgcHJvY2Vzc0hlYWRlck1zZ0FyZ3MoYXJnKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbXTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gLTE7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBhcmcubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgY29uc3QgYiA9IGFyZ1tpXTtcbiAgICAgICAgICAgIHN3aXRjaChiKXtcbiAgICAgICAgICAgICAgICBjYXNlIGNjLlNQQUNFOlxuICAgICAgICAgICAgICAgIGNhc2UgY2MuVEFCOlxuICAgICAgICAgICAgICAgIGNhc2UgY2MuQ1I6XG4gICAgICAgICAgICAgICAgY2FzZSBjYy5OTDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChhcmcuc3ViYXJyYXkoc3RhcnQsIGkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChhcmcuc3ViYXJyYXkoc3RhcnQpKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2goYXJncy5sZW5ndGgpe1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHRoaXMubWEuc3ViamVjdCA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgdGhpcy5tYS5zaWQgPSB0aGlzLnByb3RvUGFyc2VJbnQoYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYS5yZXBseSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLm1hLmhkciA9IHRoaXMucHJvdG9QYXJzZUludChhcmdzWzJdKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hLnNpemUgPSB0aGlzLnByb3RvUGFyc2VJbnQoYXJnc1szXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgdGhpcy5tYS5zdWJqZWN0ID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hLnNpZCA9IHRoaXMucHJvdG9QYXJzZUludChhcmdzWzFdKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hLnJlcGx5ID0gYXJnc1syXTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hLmhkciA9IHRoaXMucHJvdG9QYXJzZUludChhcmdzWzNdKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hLnNpemUgPSB0aGlzLnByb3RvUGFyc2VJbnQoYXJnc1s0XSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChhcmcsIFwicHJvY2Vzc0hlYWRlck1zZ0FyZ3MgUGFyc2UgRXJyb3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWEuc2lkIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGFyZywgXCJwcm9jZXNzSGVhZGVyTXNnQXJncyBCYWQgb3IgTWlzc2luZyBTaWQgRXJyb3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWEuaGRyIDwgMCB8fCB0aGlzLm1hLmhkciA+IHRoaXMubWEuc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGFyZywgXCJwcm9jZXNzSGVhZGVyTXNnQXJncyBCYWQgb3IgTWlzc2luZyBIZWFkZXIgU2l6ZSBFcnJvclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYS5zaXplIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGFyZywgXCJwcm9jZXNzSGVhZGVyTXNnQXJncyBCYWQgb3IgTWlzc2luZyBTaXplIEVycm9yXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb3RvUGFyc2VJbnQoYSkge1xuICAgICAgICBpZiAoYS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbiA9IDA7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGlmIChhW2ldIDwgNDggfHwgYVtpXSA+IDU3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbiA9IG4gKiAxMCArIChhW2ldIC0gQVNDSUlfMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxufVxudmFyIFN0YXRlO1xuKGZ1bmN0aW9uKFN0YXRlKSB7XG4gICAgU3RhdGVbU3RhdGVbXCJPUF9TVEFSVFwiXSA9IDBdID0gXCJPUF9TVEFSVFwiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BfUExVU1wiXSA9IDFdID0gXCJPUF9QTFVTXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJPUF9QTFVTX09cIl0gPSAyXSA9IFwiT1BfUExVU19PXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJPUF9QTFVTX09LXCJdID0gM10gPSBcIk9QX1BMVVNfT0tcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX01JTlVTXCJdID0gNF0gPSBcIk9QX01JTlVTXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJPUF9NSU5VU19FXCJdID0gNV0gPSBcIk9QX01JTlVTX0VcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX01JTlVTX0VSXCJdID0gNl0gPSBcIk9QX01JTlVTX0VSXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJPUF9NSU5VU19FUlJcIl0gPSA3XSA9IFwiT1BfTUlOVVNfRVJSXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJPUF9NSU5VU19FUlJfU1BDXCJdID0gOF0gPSBcIk9QX01JTlVTX0VSUl9TUENcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk1JTlVTX0VSUl9BUkdcIl0gPSA5XSA9IFwiTUlOVVNfRVJSX0FSR1wiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BfTVwiXSA9IDEwXSA9IFwiT1BfTVwiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BfTVNcIl0gPSAxMV0gPSBcIk9QX01TXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJPUF9NU0dcIl0gPSAxMl0gPSBcIk9QX01TR1wiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BfTVNHX1NQQ1wiXSA9IDEzXSA9IFwiT1BfTVNHX1NQQ1wiO1xuICAgIFN0YXRlW1N0YXRlW1wiTVNHX0FSR1wiXSA9IDE0XSA9IFwiTVNHX0FSR1wiO1xuICAgIFN0YXRlW1N0YXRlW1wiTVNHX1BBWUxPQURcIl0gPSAxNV0gPSBcIk1TR19QQVlMT0FEXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJNU0dfRU5EXCJdID0gMTZdID0gXCJNU0dfRU5EXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJPUF9IXCJdID0gMTddID0gXCJPUF9IXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJPUF9QXCJdID0gMThdID0gXCJPUF9QXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJPUF9QSVwiXSA9IDE5XSA9IFwiT1BfUElcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX1BJTlwiXSA9IDIwXSA9IFwiT1BfUElOXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJPUF9QSU5HXCJdID0gMjFdID0gXCJPUF9QSU5HXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJPUF9QT1wiXSA9IDIyXSA9IFwiT1BfUE9cIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX1BPTlwiXSA9IDIzXSA9IFwiT1BfUE9OXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJPUF9QT05HXCJdID0gMjRdID0gXCJPUF9QT05HXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJPUF9JXCJdID0gMjVdID0gXCJPUF9JXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJPUF9JTlwiXSA9IDI2XSA9IFwiT1BfSU5cIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX0lORlwiXSA9IDI3XSA9IFwiT1BfSU5GXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJPUF9JTkZPXCJdID0gMjhdID0gXCJPUF9JTkZPXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJPUF9JTkZPX1NQQ1wiXSA9IDI5XSA9IFwiT1BfSU5GT19TUENcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIklORk9fQVJHXCJdID0gMzBdID0gXCJJTkZPX0FSR1wiO1xufSkoU3RhdGUgfHwgKFN0YXRlID0ge30pKTtcbnZhciBjYztcbihmdW5jdGlvbihjYykge1xuICAgIGNjW2NjW1wiQ1JcIl0gPSBcIlxcclwiLmNoYXJDb2RlQXQoMCldID0gXCJDUlwiO1xuICAgIGNjW2NjW1wiRVwiXSA9IFwiRVwiLmNoYXJDb2RlQXQoMCldID0gXCJFXCI7XG4gICAgY2NbY2NbXCJlXCJdID0gXCJlXCIuY2hhckNvZGVBdCgwKV0gPSBcImVcIjtcbiAgICBjY1tjY1tcIkZcIl0gPSBcIkZcIi5jaGFyQ29kZUF0KDApXSA9IFwiRlwiO1xuICAgIGNjW2NjW1wiZlwiXSA9IFwiZlwiLmNoYXJDb2RlQXQoMCldID0gXCJmXCI7XG4gICAgY2NbY2NbXCJHXCJdID0gXCJHXCIuY2hhckNvZGVBdCgwKV0gPSBcIkdcIjtcbiAgICBjY1tjY1tcImdcIl0gPSBcImdcIi5jaGFyQ29kZUF0KDApXSA9IFwiZ1wiO1xuICAgIGNjW2NjW1wiSFwiXSA9IFwiSFwiLmNoYXJDb2RlQXQoMCldID0gXCJIXCI7XG4gICAgY2NbY2NbXCJoXCJdID0gXCJoXCIuY2hhckNvZGVBdCgwKV0gPSBcImhcIjtcbiAgICBjY1tjY1tcIklcIl0gPSBcIklcIi5jaGFyQ29kZUF0KDApXSA9IFwiSVwiO1xuICAgIGNjW2NjW1wiaVwiXSA9IFwiaVwiLmNoYXJDb2RlQXQoMCldID0gXCJpXCI7XG4gICAgY2NbY2NbXCJLXCJdID0gXCJLXCIuY2hhckNvZGVBdCgwKV0gPSBcIktcIjtcbiAgICBjY1tjY1tcImtcIl0gPSBcImtcIi5jaGFyQ29kZUF0KDApXSA9IFwia1wiO1xuICAgIGNjW2NjW1wiTVwiXSA9IFwiTVwiLmNoYXJDb2RlQXQoMCldID0gXCJNXCI7XG4gICAgY2NbY2NbXCJtXCJdID0gXCJtXCIuY2hhckNvZGVBdCgwKV0gPSBcIm1cIjtcbiAgICBjY1tjY1tcIk1JTlVTXCJdID0gXCItXCIuY2hhckNvZGVBdCgwKV0gPSBcIk1JTlVTXCI7XG4gICAgY2NbY2NbXCJOXCJdID0gXCJOXCIuY2hhckNvZGVBdCgwKV0gPSBcIk5cIjtcbiAgICBjY1tjY1tcIm5cIl0gPSBcIm5cIi5jaGFyQ29kZUF0KDApXSA9IFwiblwiO1xuICAgIGNjW2NjW1wiTkxcIl0gPSBcIlxcblwiLmNoYXJDb2RlQXQoMCldID0gXCJOTFwiO1xuICAgIGNjW2NjW1wiT1wiXSA9IFwiT1wiLmNoYXJDb2RlQXQoMCldID0gXCJPXCI7XG4gICAgY2NbY2NbXCJvXCJdID0gXCJvXCIuY2hhckNvZGVBdCgwKV0gPSBcIm9cIjtcbiAgICBjY1tjY1tcIlBcIl0gPSBcIlBcIi5jaGFyQ29kZUF0KDApXSA9IFwiUFwiO1xuICAgIGNjW2NjW1wicFwiXSA9IFwicFwiLmNoYXJDb2RlQXQoMCldID0gXCJwXCI7XG4gICAgY2NbY2NbXCJQTFVTXCJdID0gXCIrXCIuY2hhckNvZGVBdCgwKV0gPSBcIlBMVVNcIjtcbiAgICBjY1tjY1tcIlJcIl0gPSBcIlJcIi5jaGFyQ29kZUF0KDApXSA9IFwiUlwiO1xuICAgIGNjW2NjW1wiclwiXSA9IFwiclwiLmNoYXJDb2RlQXQoMCldID0gXCJyXCI7XG4gICAgY2NbY2NbXCJTXCJdID0gXCJTXCIuY2hhckNvZGVBdCgwKV0gPSBcIlNcIjtcbiAgICBjY1tjY1tcInNcIl0gPSBcInNcIi5jaGFyQ29kZUF0KDApXSA9IFwic1wiO1xuICAgIGNjW2NjW1wiU1BBQ0VcIl0gPSBcIiBcIi5jaGFyQ29kZUF0KDApXSA9IFwiU1BBQ0VcIjtcbiAgICBjY1tjY1tcIlRBQlwiXSA9IFwiXFx0XCIuY2hhckNvZGVBdCgwKV0gPSBcIlRBQlwiO1xufSkoY2MgfHwgKGNjID0ge30pKTtcbihmdW5jdGlvbihuYWNsKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciB1NjQgPSBmdW5jdGlvbihoLCBsKSB7XG4gICAgICAgIHRoaXMuaGkgPSBoIHwgMCA+Pj4gMDtcbiAgICAgICAgdGhpcy5sbyA9IGwgfCAwID4+PiAwO1xuICAgIH07XG4gICAgdmFyIGdmID0gZnVuY3Rpb24oaW5pdCkge1xuICAgICAgICB2YXIgaSwgciA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuICAgICAgICBpZiAoaW5pdCkgZm9yKGkgPSAwOyBpIDwgaW5pdC5sZW5ndGg7IGkrKylyW2ldID0gaW5pdFtpXTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICB2YXIgcmFuZG9tYnl0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBQUk5HJyk7XG4gICAgfTtcbiAgICB2YXIgXzAgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgdmFyIF85ID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICAgIF85WzBdID0gOTtcbiAgICB2YXIgZ2YwID0gZ2YoKSwgZ2YxID0gZ2YoW1xuICAgICAgICAxXG4gICAgXSksIF8xMjE2NjUgPSBnZihbXG4gICAgICAgIDB4ZGI0MSxcbiAgICAgICAgMVxuICAgIF0pLCBEID0gZ2YoW1xuICAgICAgICAweDc4YTMsXG4gICAgICAgIDB4MTM1OSxcbiAgICAgICAgMHg0ZGNhLFxuICAgICAgICAweDc1ZWIsXG4gICAgICAgIDB4ZDhhYixcbiAgICAgICAgMHg0MTQxLFxuICAgICAgICAweDBhNGQsXG4gICAgICAgIDB4MDA3MCxcbiAgICAgICAgMHhlODk4LFxuICAgICAgICAweDc3NzksXG4gICAgICAgIDB4NDA3OSxcbiAgICAgICAgMHg4Y2M3LFxuICAgICAgICAweGZlNzMsXG4gICAgICAgIDB4MmI2ZixcbiAgICAgICAgMHg2Y2VlLFxuICAgICAgICAweDUyMDNcbiAgICBdKSwgRDIgPSBnZihbXG4gICAgICAgIDB4ZjE1OSxcbiAgICAgICAgMHgyNmIyLFxuICAgICAgICAweDliOTQsXG4gICAgICAgIDB4ZWJkNixcbiAgICAgICAgMHhiMTU2LFxuICAgICAgICAweDgyODMsXG4gICAgICAgIDB4MTQ5YSxcbiAgICAgICAgMHgwMGUwLFxuICAgICAgICAweGQxMzAsXG4gICAgICAgIDB4ZWVmMyxcbiAgICAgICAgMHg4MGYyLFxuICAgICAgICAweDE5OGUsXG4gICAgICAgIDB4ZmNlNyxcbiAgICAgICAgMHg1NmRmLFxuICAgICAgICAweGQ5ZGMsXG4gICAgICAgIDB4MjQwNlxuICAgIF0pLCBYID0gZ2YoW1xuICAgICAgICAweGQ1MWEsXG4gICAgICAgIDB4OGYyNSxcbiAgICAgICAgMHgyZDYwLFxuICAgICAgICAweGM5NTYsXG4gICAgICAgIDB4YTdiMixcbiAgICAgICAgMHg5NTI1LFxuICAgICAgICAweGM3NjAsXG4gICAgICAgIDB4NjkyYyxcbiAgICAgICAgMHhkYzVjLFxuICAgICAgICAweGZkZDYsXG4gICAgICAgIDB4ZTIzMSxcbiAgICAgICAgMHhjMGE0LFxuICAgICAgICAweDUzZmUsXG4gICAgICAgIDB4Y2Q2ZSxcbiAgICAgICAgMHgzNmQzLFxuICAgICAgICAweDIxNjlcbiAgICBdKSwgWSA9IGdmKFtcbiAgICAgICAgMHg2NjU4LFxuICAgICAgICAweDY2NjYsXG4gICAgICAgIDB4NjY2NixcbiAgICAgICAgMHg2NjY2LFxuICAgICAgICAweDY2NjYsXG4gICAgICAgIDB4NjY2NixcbiAgICAgICAgMHg2NjY2LFxuICAgICAgICAweDY2NjYsXG4gICAgICAgIDB4NjY2NixcbiAgICAgICAgMHg2NjY2LFxuICAgICAgICAweDY2NjYsXG4gICAgICAgIDB4NjY2NixcbiAgICAgICAgMHg2NjY2LFxuICAgICAgICAweDY2NjYsXG4gICAgICAgIDB4NjY2NixcbiAgICAgICAgMHg2NjY2XG4gICAgXSksIEkgPSBnZihbXG4gICAgICAgIDB4YTBiMCxcbiAgICAgICAgMHg0YTBlLFxuICAgICAgICAweDFiMjcsXG4gICAgICAgIDB4YzRlZSxcbiAgICAgICAgMHhlNDc4LFxuICAgICAgICAweGFkMmYsXG4gICAgICAgIDB4MTgwNixcbiAgICAgICAgMHgyZjQzLFxuICAgICAgICAweGQ3YTcsXG4gICAgICAgIDB4M2RmYixcbiAgICAgICAgMHgwMDk5LFxuICAgICAgICAweDJiNGQsXG4gICAgICAgIDB4ZGYwYixcbiAgICAgICAgMHg0ZmMxLFxuICAgICAgICAweDI0ODAsXG4gICAgICAgIDB4MmI4M1xuICAgIF0pO1xuICAgIGZ1bmN0aW9uIEwzMih4LCBjKSB7XG4gICAgICAgIHJldHVybiB4IDw8IGMgfCB4ID4+PiAzMiAtIGM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxkMzIoeCwgaSkge1xuICAgICAgICB2YXIgdSA9IHhbaSArIDNdICYgMHhmZjtcbiAgICAgICAgdSA9IHUgPDwgOCB8IHhbaSArIDJdICYgMHhmZjtcbiAgICAgICAgdSA9IHUgPDwgOCB8IHhbaSArIDFdICYgMHhmZjtcbiAgICAgICAgcmV0dXJuIHUgPDwgOCB8IHhbaSArIDBdICYgMHhmZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGw2NCh4LCBpKSB7XG4gICAgICAgIHZhciBoID0geFtpXSA8PCAyNCB8IHhbaSArIDFdIDw8IDE2IHwgeFtpICsgMl0gPDwgOCB8IHhbaSArIDNdO1xuICAgICAgICB2YXIgbCA9IHhbaSArIDRdIDw8IDI0IHwgeFtpICsgNV0gPDwgMTYgfCB4W2kgKyA2XSA8PCA4IHwgeFtpICsgN107XG4gICAgICAgIHJldHVybiBuZXcgdTY0KGgsIGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdDMyKHgsIGosIHUpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDQ7IGkrKyl7XG4gICAgICAgICAgICB4W2ogKyBpXSA9IHUgJiAyNTU7XG4gICAgICAgICAgICB1ID4+Pj0gODtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0czY0KHgsIGksIHUpIHtcbiAgICAgICAgeFtpXSA9IHUuaGkgPj4gMjQgJiAweGZmO1xuICAgICAgICB4W2kgKyAxXSA9IHUuaGkgPj4gMTYgJiAweGZmO1xuICAgICAgICB4W2kgKyAyXSA9IHUuaGkgPj4gOCAmIDB4ZmY7XG4gICAgICAgIHhbaSArIDNdID0gdS5oaSAmIDB4ZmY7XG4gICAgICAgIHhbaSArIDRdID0gdS5sbyA+PiAyNCAmIDB4ZmY7XG4gICAgICAgIHhbaSArIDVdID0gdS5sbyA+PiAxNiAmIDB4ZmY7XG4gICAgICAgIHhbaSArIDZdID0gdS5sbyA+PiA4ICYgMHhmZjtcbiAgICAgICAgeFtpICsgN10gPSB1LmxvICYgMHhmZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gdm4oeCwgeGksIHksIHlpLCBuKSB7XG4gICAgICAgIHZhciBpLCBkID0gMDtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgbjsgaSsrKWQgfD0geFt4aSArIGldIF4geVt5aSArIGldO1xuICAgICAgICByZXR1cm4gKDEgJiBkIC0gMSA+Pj4gOCkgLSAxO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcnlwdG9fdmVyaWZ5XzE2KHgsIHhpLCB5LCB5aSkge1xuICAgICAgICByZXR1cm4gdm4oeCwgeGksIHksIHlpLCAxNik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyeXB0b192ZXJpZnlfMzIoeCwgeGksIHksIHlpKSB7XG4gICAgICAgIHJldHVybiB2bih4LCB4aSwgeSwgeWksIDMyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29yZShvdXQsIGlucCwgaywgYywgaCkge1xuICAgICAgICB2YXIgdyA9IG5ldyBVaW50MzJBcnJheSgxNiksIHggPSBuZXcgVWludDMyQXJyYXkoMTYpLCB5ID0gbmV3IFVpbnQzMkFycmF5KDE2KSwgdCA9IG5ldyBVaW50MzJBcnJheSg0KTtcbiAgICAgICAgdmFyIGksIGosIG07XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDQ7IGkrKyl7XG4gICAgICAgICAgICB4WzUgKiBpXSA9IGxkMzIoYywgNCAqIGkpO1xuICAgICAgICAgICAgeFsxICsgaV0gPSBsZDMyKGssIDQgKiBpKTtcbiAgICAgICAgICAgIHhbNiArIGldID0gbGQzMihpbnAsIDQgKiBpKTtcbiAgICAgICAgICAgIHhbMTEgKyBpXSA9IGxkMzIoaywgMTYgKyA0ICogaSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgMTY7IGkrKyl5W2ldID0geFtpXTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgMjA7IGkrKyl7XG4gICAgICAgICAgICBmb3IoaiA9IDA7IGogPCA0OyBqKyspe1xuICAgICAgICAgICAgICAgIGZvcihtID0gMDsgbSA8IDQ7IG0rKyl0W21dID0geFsoNSAqIGogKyA0ICogbSkgJSAxNl07XG4gICAgICAgICAgICAgICAgdFsxXSBePSBMMzIodFswXSArIHRbM10gfCAwLCA3KTtcbiAgICAgICAgICAgICAgICB0WzJdIF49IEwzMih0WzFdICsgdFswXSB8IDAsIDkpO1xuICAgICAgICAgICAgICAgIHRbM10gXj0gTDMyKHRbMl0gKyB0WzFdIHwgMCwgMTMpO1xuICAgICAgICAgICAgICAgIHRbMF0gXj0gTDMyKHRbM10gKyB0WzJdIHwgMCwgMTgpO1xuICAgICAgICAgICAgICAgIGZvcihtID0gMDsgbSA8IDQ7IG0rKyl3WzQgKiBqICsgKGogKyBtKSAlIDRdID0gdFttXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcihtID0gMDsgbSA8IDE2OyBtKyspeFttXSA9IHdbbV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGgpIHtcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IDE2OyBpKyspeFtpXSA9IHhbaV0gKyB5W2ldIHwgMDtcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IDQ7IGkrKyl7XG4gICAgICAgICAgICAgICAgeFs1ICogaV0gPSB4WzUgKiBpXSAtIGxkMzIoYywgNCAqIGkpIHwgMDtcbiAgICAgICAgICAgICAgICB4WzYgKyBpXSA9IHhbNiArIGldIC0gbGQzMihpbnAsIDQgKiBpKSB8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCA0OyBpKyspe1xuICAgICAgICAgICAgICAgIHN0MzIob3V0LCA0ICogaSwgeFs1ICogaV0pO1xuICAgICAgICAgICAgICAgIHN0MzIob3V0LCAxNiArIDQgKiBpLCB4WzYgKyBpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCAxNjsgaSsrKXN0MzIob3V0LCA0ICogaSwgeFtpXSArIHlbaV0gfCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjcnlwdG9fY29yZV9zYWxzYTIwKG91dCwgaW5wLCBrLCBjKSB7XG4gICAgICAgIGNvcmUob3V0LCBpbnAsIGssIGMsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyeXB0b19jb3JlX2hzYWxzYTIwKG91dCwgaW5wLCBrLCBjKSB7XG4gICAgICAgIGNvcmUob3V0LCBpbnAsIGssIGMsIHRydWUpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgdmFyIHNpZ21hID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAxMDEsXG4gICAgICAgIDEyMCxcbiAgICAgICAgMTEyLFxuICAgICAgICA5NyxcbiAgICAgICAgMTEwLFxuICAgICAgICAxMDAsXG4gICAgICAgIDMyLFxuICAgICAgICA1MSxcbiAgICAgICAgNTAsXG4gICAgICAgIDQ1LFxuICAgICAgICA5OCxcbiAgICAgICAgMTIxLFxuICAgICAgICAxMTYsXG4gICAgICAgIDEwMSxcbiAgICAgICAgMzIsXG4gICAgICAgIDEwN1xuICAgIF0pO1xuICAgIGZ1bmN0aW9uIGNyeXB0b19zdHJlYW1fc2Fsc2EyMF94b3IoYywgY3BvcywgbSwgbXBvcywgYiwgbiwgaykge1xuICAgICAgICB2YXIgeiA9IG5ldyBVaW50OEFycmF5KDE2KSwgeCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgICAgICAgdmFyIHUsIGk7XG4gICAgICAgIGlmICghYikgcmV0dXJuIDA7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDE2OyBpKyspeltpXSA9IDA7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDg7IGkrKyl6W2ldID0gbltpXTtcbiAgICAgICAgd2hpbGUoYiA+PSA2NCl7XG4gICAgICAgICAgICBjcnlwdG9fY29yZV9zYWxzYTIwKHgsIHosIGssIHNpZ21hKTtcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IDY0OyBpKyspY1tjcG9zICsgaV0gPSAobSA/IG1bbXBvcyArIGldIDogMCkgXiB4W2ldO1xuICAgICAgICAgICAgdSA9IDE7XG4gICAgICAgICAgICBmb3IoaSA9IDg7IGkgPCAxNjsgaSsrKXtcbiAgICAgICAgICAgICAgICB1ID0gdSArICh6W2ldICYgMHhmZikgfCAwO1xuICAgICAgICAgICAgICAgIHpbaV0gPSB1ICYgMHhmZjtcbiAgICAgICAgICAgICAgICB1ID4+Pj0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIgLT0gNjQ7XG4gICAgICAgICAgICBjcG9zICs9IDY0O1xuICAgICAgICAgICAgaWYgKG0pIG1wb3MgKz0gNjQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGIgPiAwKSB7XG4gICAgICAgICAgICBjcnlwdG9fY29yZV9zYWxzYTIwKHgsIHosIGssIHNpZ21hKTtcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IGI7IGkrKyljW2Nwb3MgKyBpXSA9IChtID8gbVttcG9zICsgaV0gOiAwKSBeIHhbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyeXB0b19zdHJlYW1fc2Fsc2EyMChjLCBjcG9zLCBkLCBuLCBrKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG9fc3RyZWFtX3NhbHNhMjBfeG9yKGMsIGNwb3MsIG51bGwsIDAsIGQsIG4sIGspO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcnlwdG9fc3RyZWFtKGMsIGNwb3MsIGQsIG4sIGspIHtcbiAgICAgICAgdmFyIHMgPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgICAgIGNyeXB0b19jb3JlX2hzYWxzYTIwKHMsIG4sIGssIHNpZ21hKTtcbiAgICAgICAgcmV0dXJuIGNyeXB0b19zdHJlYW1fc2Fsc2EyMChjLCBjcG9zLCBkLCBuLnN1YmFycmF5KDE2KSwgcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyeXB0b19zdHJlYW1feG9yKGMsIGNwb3MsIG0sIG1wb3MsIGQsIG4sIGspIHtcbiAgICAgICAgdmFyIHMgPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgICAgIGNyeXB0b19jb3JlX2hzYWxzYTIwKHMsIG4sIGssIHNpZ21hKTtcbiAgICAgICAgcmV0dXJuIGNyeXB0b19zdHJlYW1fc2Fsc2EyMF94b3IoYywgY3BvcywgbSwgbXBvcywgZCwgbi5zdWJhcnJheSgxNiksIHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGQxMzA1KGgsIGMpIHtcbiAgICAgICAgdmFyIGosIHUgPSAwO1xuICAgICAgICBmb3IoaiA9IDA7IGogPCAxNzsgaisrKXtcbiAgICAgICAgICAgIHUgPSB1ICsgKGhbal0gKyBjW2pdIHwgMCkgfCAwO1xuICAgICAgICAgICAgaFtqXSA9IHUgJiAyNTU7XG4gICAgICAgICAgICB1ID4+Pj0gODtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgbWludXNwID0gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAgICAgNSxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMjUyXG4gICAgXSk7XG4gICAgZnVuY3Rpb24gY3J5cHRvX29uZXRpbWVhdXRoKG91dCwgb3V0cG9zLCBtLCBtcG9zLCBuLCBrKSB7XG4gICAgICAgIHZhciBzLCBpLCBqLCB1O1xuICAgICAgICB2YXIgeCA9IG5ldyBVaW50MzJBcnJheSgxNyksIHIgPSBuZXcgVWludDMyQXJyYXkoMTcpLCBoID0gbmV3IFVpbnQzMkFycmF5KDE3KSwgYyA9IG5ldyBVaW50MzJBcnJheSgxNyksIGcgPSBuZXcgVWludDMyQXJyYXkoMTcpO1xuICAgICAgICBmb3IoaiA9IDA7IGogPCAxNzsgaisrKXJbal0gPSBoW2pdID0gMDtcbiAgICAgICAgZm9yKGogPSAwOyBqIDwgMTY7IGorKylyW2pdID0ga1tqXTtcbiAgICAgICAgclszXSAmPSAxNTtcbiAgICAgICAgcls0XSAmPSAyNTI7XG4gICAgICAgIHJbN10gJj0gMTU7XG4gICAgICAgIHJbOF0gJj0gMjUyO1xuICAgICAgICByWzExXSAmPSAxNTtcbiAgICAgICAgclsxMl0gJj0gMjUyO1xuICAgICAgICByWzE1XSAmPSAxNTtcbiAgICAgICAgd2hpbGUobiA+IDApe1xuICAgICAgICAgICAgZm9yKGogPSAwOyBqIDwgMTc7IGorKyljW2pdID0gMDtcbiAgICAgICAgICAgIGZvcihqID0gMDsgaiA8IDE2ICYmIGogPCBuOyArK2opY1tqXSA9IG1bbXBvcyArIGpdO1xuICAgICAgICAgICAgY1tqXSA9IDE7XG4gICAgICAgICAgICBtcG9zICs9IGo7XG4gICAgICAgICAgICBuIC09IGo7XG4gICAgICAgICAgICBhZGQxMzA1KGgsIGMpO1xuICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgMTc7IGkrKyl7XG4gICAgICAgICAgICAgICAgeFtpXSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yKGogPSAwOyBqIDwgMTc7IGorKyl4W2ldID0geFtpXSArIGhbal0gKiAoaiA8PSBpID8gcltpIC0gal0gOiAzMjAgKiByW2kgKyAxNyAtIGpdIHwgMCkgfCAwIHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IDE3OyBpKyspaFtpXSA9IHhbaV07XG4gICAgICAgICAgICB1ID0gMDtcbiAgICAgICAgICAgIGZvcihqID0gMDsgaiA8IDE2OyBqKyspe1xuICAgICAgICAgICAgICAgIHUgPSB1ICsgaFtqXSB8IDA7XG4gICAgICAgICAgICAgICAgaFtqXSA9IHUgJiAyNTU7XG4gICAgICAgICAgICAgICAgdSA+Pj49IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1ID0gdSArIGhbMTZdIHwgMDtcbiAgICAgICAgICAgIGhbMTZdID0gdSAmIDM7XG4gICAgICAgICAgICB1ID0gNSAqICh1ID4+PiAyKSB8IDA7XG4gICAgICAgICAgICBmb3IoaiA9IDA7IGogPCAxNjsgaisrKXtcbiAgICAgICAgICAgICAgICB1ID0gdSArIGhbal0gfCAwO1xuICAgICAgICAgICAgICAgIGhbal0gPSB1ICYgMjU1O1xuICAgICAgICAgICAgICAgIHUgPj4+PSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdSA9IHUgKyBoWzE2XSB8IDA7XG4gICAgICAgICAgICBoWzE2XSA9IHU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGogPSAwOyBqIDwgMTc7IGorKylnW2pdID0gaFtqXTtcbiAgICAgICAgYWRkMTMwNShoLCBtaW51c3ApO1xuICAgICAgICBzID0gLShoWzE2XSA+Pj4gNykgfCAwO1xuICAgICAgICBmb3IoaiA9IDA7IGogPCAxNzsgaisrKWhbal0gXj0gcyAmIChnW2pdIF4gaFtqXSk7XG4gICAgICAgIGZvcihqID0gMDsgaiA8IDE2OyBqKyspY1tqXSA9IGtbaiArIDE2XTtcbiAgICAgICAgY1sxNl0gPSAwO1xuICAgICAgICBhZGQxMzA1KGgsIGMpO1xuICAgICAgICBmb3IoaiA9IDA7IGogPCAxNjsgaisrKW91dFtvdXRwb3MgKyBqXSA9IGhbal07XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcnlwdG9fb25ldGltZWF1dGhfdmVyaWZ5KGgsIGhwb3MsIG0sIG1wb3MsIG4sIGspIHtcbiAgICAgICAgdmFyIHggPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgIGNyeXB0b19vbmV0aW1lYXV0aCh4LCAwLCBtLCBtcG9zLCBuLCBrKTtcbiAgICAgICAgcmV0dXJuIGNyeXB0b192ZXJpZnlfMTYoaCwgaHBvcywgeCwgMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyeXB0b19zZWNyZXRib3goYywgbSwgZCwgbiwgaykge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgaWYgKGQgPCAzMikgcmV0dXJuIC0xO1xuICAgICAgICBjcnlwdG9fc3RyZWFtX3hvcihjLCAwLCBtLCAwLCBkLCBuLCBrKTtcbiAgICAgICAgY3J5cHRvX29uZXRpbWVhdXRoKGMsIDE2LCBjLCAzMiwgZCAtIDMyLCBjKTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgMTY7IGkrKyljW2ldID0gMDtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyeXB0b19zZWNyZXRib3hfb3BlbihtLCBjLCBkLCBuLCBrKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgeCA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICAgICAgaWYgKGQgPCAzMikgcmV0dXJuIC0xO1xuICAgICAgICBjcnlwdG9fc3RyZWFtKHgsIDAsIDMyLCBuLCBrKTtcbiAgICAgICAgaWYgKGNyeXB0b19vbmV0aW1lYXV0aF92ZXJpZnkoYywgMTYsIGMsIDMyLCBkIC0gMzIsIHgpICE9PSAwKSByZXR1cm4gLTE7XG4gICAgICAgIGNyeXB0b19zdHJlYW1feG9yKG0sIDAsIGMsIDAsIGQsIG4sIGspO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCAzMjsgaSsrKW1baV0gPSAwO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0MjU1MTkociwgYSkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgMTY7IGkrKylyW2ldID0gYVtpXSB8IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhcjI1NTE5KG8pIHtcbiAgICAgICAgdmFyIGM7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCAxNjsgaSsrKXtcbiAgICAgICAgICAgIG9baV0gKz0gNjU1MzY7XG4gICAgICAgICAgICBjID0gTWF0aC5mbG9vcihvW2ldIC8gNjU1MzYpO1xuICAgICAgICAgICAgb1soaSArIDEpICogKGkgPCAxNSA/IDEgOiAwKV0gKz0gYyAtIDEgKyAzNyAqIChjIC0gMSkgKiAoaSA9PT0gMTUgPyAxIDogMCk7XG4gICAgICAgICAgICBvW2ldIC09IGMgKiA2NTUzNjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzZWwyNTUxOShwLCBxLCBiKSB7XG4gICAgICAgIHZhciB0LCBjID0gfihiIC0gMSk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKXtcbiAgICAgICAgICAgIHQgPSBjICYgKHBbaV0gXiBxW2ldKTtcbiAgICAgICAgICAgIHBbaV0gXj0gdDtcbiAgICAgICAgICAgIHFbaV0gXj0gdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwYWNrMjU1MTkobywgbikge1xuICAgICAgICB2YXIgaSwgaiwgYjtcbiAgICAgICAgdmFyIG0gPSBnZigpLCB0ID0gZ2YoKTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgMTY7IGkrKyl0W2ldID0gbltpXTtcbiAgICAgICAgY2FyMjU1MTkodCk7XG4gICAgICAgIGNhcjI1NTE5KHQpO1xuICAgICAgICBjYXIyNTUxOSh0KTtcbiAgICAgICAgZm9yKGogPSAwOyBqIDwgMjsgaisrKXtcbiAgICAgICAgICAgIG1bMF0gPSB0WzBdIC0gMHhmZmVkO1xuICAgICAgICAgICAgZm9yKGkgPSAxOyBpIDwgMTU7IGkrKyl7XG4gICAgICAgICAgICAgICAgbVtpXSA9IHRbaV0gLSAweGZmZmYgLSAobVtpIC0gMV0gPj4gMTYgJiAxKTtcbiAgICAgICAgICAgICAgICBtW2kgLSAxXSAmPSAweGZmZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtWzE1XSA9IHRbMTVdIC0gMHg3ZmZmIC0gKG1bMTRdID4+IDE2ICYgMSk7XG4gICAgICAgICAgICBiID0gbVsxNV0gPj4gMTYgJiAxO1xuICAgICAgICAgICAgbVsxNF0gJj0gMHhmZmZmO1xuICAgICAgICAgICAgc2VsMjU1MTkodCwgbSwgMSAtIGIpO1xuICAgICAgICB9XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDE2OyBpKyspe1xuICAgICAgICAgICAgb1syICogaV0gPSB0W2ldICYgMHhmZjtcbiAgICAgICAgICAgIG9bMiAqIGkgKyAxXSA9IHRbaV0gPj4gODtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBuZXEyNTUxOShhLCBiKSB7XG4gICAgICAgIHZhciBjID0gbmV3IFVpbnQ4QXJyYXkoMzIpLCBkID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICAgICAgICBwYWNrMjU1MTkoYywgYSk7XG4gICAgICAgIHBhY2syNTUxOShkLCBiKTtcbiAgICAgICAgcmV0dXJuIGNyeXB0b192ZXJpZnlfMzIoYywgMCwgZCwgMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcjI1NTE5KGEpIHtcbiAgICAgICAgdmFyIGQgPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgICAgIHBhY2syNTUxOShkLCBhKTtcbiAgICAgICAgcmV0dXJuIGRbMF0gJiAxO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bnBhY2syNTUxOShvLCBuKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCAxNjsgaSsrKW9baV0gPSBuWzIgKiBpXSArIChuWzIgKiBpICsgMV0gPDwgOCk7XG4gICAgICAgIG9bMTVdICY9IDB4N2ZmZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gQShvLCBhLCBiKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCAxNjsgaSsrKW9baV0gPSBhW2ldICsgYltpXSB8IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFoobywgYSwgYikge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgMTY7IGkrKylvW2ldID0gYVtpXSAtIGJbaV0gfCAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBNKG8sIGEsIGIpIHtcbiAgICAgICAgdmFyIGksIGosIHQgPSBuZXcgRmxvYXQ2NEFycmF5KDMxKTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgMzE7IGkrKyl0W2ldID0gMDtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgMTY7IGkrKyl7XG4gICAgICAgICAgICBmb3IoaiA9IDA7IGogPCAxNjsgaisrKXtcbiAgICAgICAgICAgICAgICB0W2kgKyBqXSArPSBhW2ldICogYltqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IoaSA9IDA7IGkgPCAxNTsgaSsrKXtcbiAgICAgICAgICAgIHRbaV0gKz0gMzggKiB0W2kgKyAxNl07XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgMTY7IGkrKylvW2ldID0gdFtpXTtcbiAgICAgICAgY2FyMjU1MTkobyk7XG4gICAgICAgIGNhcjI1NTE5KG8pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBTKG8sIGEpIHtcbiAgICAgICAgTShvLCBhLCBhKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW52MjU1MTkobywgaSkge1xuICAgICAgICB2YXIgYyA9IGdmKCk7XG4gICAgICAgIHZhciBhO1xuICAgICAgICBmb3IoYSA9IDA7IGEgPCAxNjsgYSsrKWNbYV0gPSBpW2FdO1xuICAgICAgICBmb3IoYSA9IDI1MzsgYSA+PSAwOyBhLS0pe1xuICAgICAgICAgICAgUyhjLCBjKTtcbiAgICAgICAgICAgIGlmIChhICE9PSAyICYmIGEgIT09IDQpIE0oYywgYywgaSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGEgPSAwOyBhIDwgMTY7IGErKylvW2FdID0gY1thXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG93MjUyMyhvLCBpKSB7XG4gICAgICAgIHZhciBjID0gZ2YoKTtcbiAgICAgICAgdmFyIGE7XG4gICAgICAgIGZvcihhID0gMDsgYSA8IDE2OyBhKyspY1thXSA9IGlbYV07XG4gICAgICAgIGZvcihhID0gMjUwOyBhID49IDA7IGEtLSl7XG4gICAgICAgICAgICBTKGMsIGMpO1xuICAgICAgICAgICAgaWYgKGEgIT09IDEpIE0oYywgYywgaSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGEgPSAwOyBhIDwgMTY7IGErKylvW2FdID0gY1thXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3J5cHRvX3NjYWxhcm11bHQocSwgbiwgcCkge1xuICAgICAgICB2YXIgeiA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICAgICAgdmFyIHggPSBuZXcgRmxvYXQ2NEFycmF5KDgwKSwgciwgaTtcbiAgICAgICAgdmFyIGEgPSBnZigpLCBiID0gZ2YoKSwgYyA9IGdmKCksIGQgPSBnZigpLCBlID0gZ2YoKSwgZiA9IGdmKCk7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDMxOyBpKyspeltpXSA9IG5baV07XG4gICAgICAgIHpbMzFdID0gblszMV0gJiAxMjcgfCA2NDtcbiAgICAgICAgelswXSAmPSAyNDg7XG4gICAgICAgIHVucGFjazI1NTE5KHgsIHApO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCAxNjsgaSsrKXtcbiAgICAgICAgICAgIGJbaV0gPSB4W2ldO1xuICAgICAgICAgICAgZFtpXSA9IGFbaV0gPSBjW2ldID0gMDtcbiAgICAgICAgfVxuICAgICAgICBhWzBdID0gZFswXSA9IDE7XG4gICAgICAgIGZvcihpID0gMjU0OyBpID49IDA7IC0taSl7XG4gICAgICAgICAgICByID0geltpID4+PiAzXSA+Pj4gKGkgJiA3KSAmIDE7XG4gICAgICAgICAgICBzZWwyNTUxOShhLCBiLCByKTtcbiAgICAgICAgICAgIHNlbDI1NTE5KGMsIGQsIHIpO1xuICAgICAgICAgICAgQShlLCBhLCBjKTtcbiAgICAgICAgICAgIFooYSwgYSwgYyk7XG4gICAgICAgICAgICBBKGMsIGIsIGQpO1xuICAgICAgICAgICAgWihiLCBiLCBkKTtcbiAgICAgICAgICAgIFMoZCwgZSk7XG4gICAgICAgICAgICBTKGYsIGEpO1xuICAgICAgICAgICAgTShhLCBjLCBhKTtcbiAgICAgICAgICAgIE0oYywgYiwgZSk7XG4gICAgICAgICAgICBBKGUsIGEsIGMpO1xuICAgICAgICAgICAgWihhLCBhLCBjKTtcbiAgICAgICAgICAgIFMoYiwgYSk7XG4gICAgICAgICAgICBaKGMsIGQsIGYpO1xuICAgICAgICAgICAgTShhLCBjLCBfMTIxNjY1KTtcbiAgICAgICAgICAgIEEoYSwgYSwgZCk7XG4gICAgICAgICAgICBNKGMsIGMsIGEpO1xuICAgICAgICAgICAgTShhLCBkLCBmKTtcbiAgICAgICAgICAgIE0oZCwgYiwgeCk7XG4gICAgICAgICAgICBTKGIsIGUpO1xuICAgICAgICAgICAgc2VsMjU1MTkoYSwgYiwgcik7XG4gICAgICAgICAgICBzZWwyNTUxOShjLCBkLCByKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IoaSA9IDA7IGkgPCAxNjsgaSsrKXtcbiAgICAgICAgICAgIHhbaSArIDE2XSA9IGFbaV07XG4gICAgICAgICAgICB4W2kgKyAzMl0gPSBjW2ldO1xuICAgICAgICAgICAgeFtpICsgNDhdID0gYltpXTtcbiAgICAgICAgICAgIHhbaSArIDY0XSA9IGRbaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHgzMiA9IHguc3ViYXJyYXkoMzIpO1xuICAgICAgICB2YXIgeDE2ID0geC5zdWJhcnJheSgxNik7XG4gICAgICAgIGludjI1NTE5KHgzMiwgeDMyKTtcbiAgICAgICAgTSh4MTYsIHgxNiwgeDMyKTtcbiAgICAgICAgcGFjazI1NTE5KHEsIHgxNik7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcnlwdG9fc2NhbGFybXVsdF9iYXNlKHEsIG4pIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0b19zY2FsYXJtdWx0KHEsIG4sIF85KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3J5cHRvX2JveF9rZXlwYWlyKHksIHgpIHtcbiAgICAgICAgcmFuZG9tYnl0ZXMoeCwgMzIpO1xuICAgICAgICByZXR1cm4gY3J5cHRvX3NjYWxhcm11bHRfYmFzZSh5LCB4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3J5cHRvX2JveF9iZWZvcmVubShrLCB5LCB4KSB7XG4gICAgICAgIHZhciBzID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICAgICAgICBjcnlwdG9fc2NhbGFybXVsdChzLCB4LCB5KTtcbiAgICAgICAgcmV0dXJuIGNyeXB0b19jb3JlX2hzYWxzYTIwKGssIF8wLCBzLCBzaWdtYSk7XG4gICAgfVxuICAgIHZhciBjcnlwdG9fYm94X2FmdGVybm0gPSBjcnlwdG9fc2VjcmV0Ym94O1xuICAgIHZhciBjcnlwdG9fYm94X29wZW5fYWZ0ZXJubSA9IGNyeXB0b19zZWNyZXRib3hfb3BlbjtcbiAgICBmdW5jdGlvbiBjcnlwdG9fYm94KGMsIG0sIGQsIG4sIHksIHgpIHtcbiAgICAgICAgdmFyIGsgPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgICAgIGNyeXB0b19ib3hfYmVmb3Jlbm0oaywgeSwgeCk7XG4gICAgICAgIHJldHVybiBjcnlwdG9fYm94X2FmdGVybm0oYywgbSwgZCwgbiwgayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyeXB0b19ib3hfb3BlbihtLCBjLCBkLCBuLCB5LCB4KSB7XG4gICAgICAgIHZhciBrID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICAgICAgICBjcnlwdG9fYm94X2JlZm9yZW5tKGssIHksIHgpO1xuICAgICAgICByZXR1cm4gY3J5cHRvX2JveF9vcGVuX2FmdGVybm0obSwgYywgZCwgbiwgayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZDY0KCkge1xuICAgICAgICB2YXIgYSA9IDAsIGIgPSAwLCBjID0gMCwgZCA9IDAsIG0xNiA9IDY1NTM1LCBsLCBoLCBpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgbCA9IGFyZ3VtZW50c1tpXS5sbztcbiAgICAgICAgICAgIGggPSBhcmd1bWVudHNbaV0uaGk7XG4gICAgICAgICAgICBhICs9IGwgJiBtMTY7XG4gICAgICAgICAgICBiICs9IGwgPj4+IDE2O1xuICAgICAgICAgICAgYyArPSBoICYgbTE2O1xuICAgICAgICAgICAgZCArPSBoID4+PiAxNjtcbiAgICAgICAgfVxuICAgICAgICBiICs9IGEgPj4+IDE2O1xuICAgICAgICBjICs9IGIgPj4+IDE2O1xuICAgICAgICBkICs9IGMgPj4+IDE2O1xuICAgICAgICByZXR1cm4gbmV3IHU2NChjICYgbTE2IHwgZCA8PCAxNiwgYSAmIG0xNiB8IGIgPDwgMTYpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaHI2NCh4LCBjKSB7XG4gICAgICAgIHJldHVybiBuZXcgdTY0KHguaGkgPj4+IGMsIHgubG8gPj4+IGMgfCB4LmhpIDw8IDMyIC0gYyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHhvcjY0KCkge1xuICAgICAgICB2YXIgbCA9IDAsIGggPSAwLCBpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgbCBePSBhcmd1bWVudHNbaV0ubG87XG4gICAgICAgICAgICBoIF49IGFyZ3VtZW50c1tpXS5oaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IHU2NChoLCBsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUih4LCBjKSB7XG4gICAgICAgIHZhciBoLCBsLCBjMSA9IDMyIC0gYztcbiAgICAgICAgaWYgKGMgPCAzMikge1xuICAgICAgICAgICAgaCA9IHguaGkgPj4+IGMgfCB4LmxvIDw8IGMxO1xuICAgICAgICAgICAgbCA9IHgubG8gPj4+IGMgfCB4LmhpIDw8IGMxO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPCA2NCkge1xuICAgICAgICAgICAgaCA9IHgubG8gPj4+IGMgfCB4LmhpIDw8IGMxO1xuICAgICAgICAgICAgbCA9IHguaGkgPj4+IGMgfCB4LmxvIDw8IGMxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdTY0KGgsIGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBDaCh4LCB5LCB6KSB7XG4gICAgICAgIHZhciBoID0geC5oaSAmIHkuaGkgXiB+eC5oaSAmIHouaGksIGwgPSB4LmxvICYgeS5sbyBeIH54LmxvICYgei5sbztcbiAgICAgICAgcmV0dXJuIG5ldyB1NjQoaCwgbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE1haih4LCB5LCB6KSB7XG4gICAgICAgIHZhciBoID0geC5oaSAmIHkuaGkgXiB4LmhpICYgei5oaSBeIHkuaGkgJiB6LmhpLCBsID0geC5sbyAmIHkubG8gXiB4LmxvICYgei5sbyBeIHkubG8gJiB6LmxvO1xuICAgICAgICByZXR1cm4gbmV3IHU2NChoLCBsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gU2lnbWEwKHgpIHtcbiAgICAgICAgcmV0dXJuIHhvcjY0KFIoeCwgMjgpLCBSKHgsIDM0KSwgUih4LCAzOSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBTaWdtYTEoeCkge1xuICAgICAgICByZXR1cm4geG9yNjQoUih4LCAxNCksIFIoeCwgMTgpLCBSKHgsIDQxKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNpZ21hMCh4KSB7XG4gICAgICAgIHJldHVybiB4b3I2NChSKHgsIDEpLCBSKHgsIDgpLCBzaHI2NCh4LCA3KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNpZ21hMSh4KSB7XG4gICAgICAgIHJldHVybiB4b3I2NChSKHgsIDE5KSwgUih4LCA2MSksIHNocjY0KHgsIDYpKTtcbiAgICB9XG4gICAgdmFyIEsgPSBbXG4gICAgICAgIG5ldyB1NjQoMHg0MjhhMmY5OCwgMHhkNzI4YWUyMiksXG4gICAgICAgIG5ldyB1NjQoMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCksXG4gICAgICAgIG5ldyB1NjQoMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiksXG4gICAgICAgIG5ldyB1NjQoMHhlOWI1ZGJhNSwgMHg4MTg5ZGJiYyksXG4gICAgICAgIG5ldyB1NjQoMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOCksXG4gICAgICAgIG5ldyB1NjQoMHg1OWYxMTFmMSwgMHhiNjA1ZDAxOSksXG4gICAgICAgIG5ldyB1NjQoMHg5MjNmODJhNCwgMHhhZjE5NGY5YiksXG4gICAgICAgIG5ldyB1NjQoMHhhYjFjNWVkNSwgMHhkYTZkODExOCksXG4gICAgICAgIG5ldyB1NjQoMHhkODA3YWE5OCwgMHhhMzAzMDI0MiksXG4gICAgICAgIG5ldyB1NjQoMHgxMjgzNWIwMSwgMHg0NTcwNmZiZSksXG4gICAgICAgIG5ldyB1NjQoMHgyNDMxODViZSwgMHg0ZWU0YjI4YyksXG4gICAgICAgIG5ldyB1NjQoMHg1NTBjN2RjMywgMHhkNWZmYjRlMiksXG4gICAgICAgIG5ldyB1NjQoMHg3MmJlNWQ3NCwgMHhmMjdiODk2ZiksXG4gICAgICAgIG5ldyB1NjQoMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSksXG4gICAgICAgIG5ldyB1NjQoMHg5YmRjMDZhNywgMHgyNWM3MTIzNSksXG4gICAgICAgIG5ldyB1NjQoMHhjMTliZjE3NCwgMHhjZjY5MjY5NCksXG4gICAgICAgIG5ldyB1NjQoMHhlNDliNjljMSwgMHg5ZWYxNGFkMiksXG4gICAgICAgIG5ldyB1NjQoMHhlZmJlNDc4NiwgMHgzODRmMjVlMyksXG4gICAgICAgIG5ldyB1NjQoMHgwZmMxOWRjNiwgMHg4YjhjZDViNSksXG4gICAgICAgIG5ldyB1NjQoMHgyNDBjYTFjYywgMHg3N2FjOWM2NSksXG4gICAgICAgIG5ldyB1NjQoMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NSksXG4gICAgICAgIG5ldyB1NjQoMHg0YTc0ODRhYSwgMHg2ZWE2ZTQ4MyksXG4gICAgICAgIG5ldyB1NjQoMHg1Y2IwYTlkYywgMHhiZDQxZmJkNCksXG4gICAgICAgIG5ldyB1NjQoMHg3NmY5ODhkYSwgMHg4MzExNTNiNSksXG4gICAgICAgIG5ldyB1NjQoMHg5ODNlNTE1MiwgMHhlZTY2ZGZhYiksXG4gICAgICAgIG5ldyB1NjQoMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCksXG4gICAgICAgIG5ldyB1NjQoMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiksXG4gICAgICAgIG5ldyB1NjQoMHhiZjU5N2ZjNywgMHhiZWVmMGVlNCksXG4gICAgICAgIG5ldyB1NjQoMHhjNmUwMGJmMywgMHgzZGE4OGZjMiksXG4gICAgICAgIG5ldyB1NjQoMHhkNWE3OTE0NywgMHg5MzBhYTcyNSksXG4gICAgICAgIG5ldyB1NjQoMHgwNmNhNjM1MSwgMHhlMDAzODI2ZiksXG4gICAgICAgIG5ldyB1NjQoMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCksXG4gICAgICAgIG5ldyB1NjQoMHgyN2I3MGE4NSwgMHg0NmQyMmZmYyksXG4gICAgICAgIG5ldyB1NjQoMHgyZTFiMjEzOCwgMHg1YzI2YzkyNiksXG4gICAgICAgIG5ldyB1NjQoMHg0ZDJjNmRmYywgMHg1YWM0MmFlZCksXG4gICAgICAgIG5ldyB1NjQoMHg1MzM4MGQxMywgMHg5ZDk1YjNkZiksXG4gICAgICAgIG5ldyB1NjQoMHg2NTBhNzM1NCwgMHg4YmFmNjNkZSksXG4gICAgICAgIG5ldyB1NjQoMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCksXG4gICAgICAgIG5ldyB1NjQoMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiksXG4gICAgICAgIG5ldyB1NjQoMHg5MjcyMmM4NSwgMHgxNDgyMzUzYiksXG4gICAgICAgIG5ldyB1NjQoMHhhMmJmZThhMSwgMHg0Y2YxMDM2NCksXG4gICAgICAgIG5ldyB1NjQoMHhhODFhNjY0YiwgMHhiYzQyMzAwMSksXG4gICAgICAgIG5ldyB1NjQoMHhjMjRiOGI3MCwgMHhkMGY4OTc5MSksXG4gICAgICAgIG5ldyB1NjQoMHhjNzZjNTFhMywgMHgwNjU0YmUzMCksXG4gICAgICAgIG5ldyB1NjQoMHhkMTkyZTgxOSwgMHhkNmVmNTIxOCksXG4gICAgICAgIG5ldyB1NjQoMHhkNjk5MDYyNCwgMHg1NTY1YTkxMCksXG4gICAgICAgIG5ldyB1NjQoMHhmNDBlMzU4NSwgMHg1NzcxMjAyYSksXG4gICAgICAgIG5ldyB1NjQoMHgxMDZhYTA3MCwgMHgzMmJiZDFiOCksXG4gICAgICAgIG5ldyB1NjQoMHgxOWE0YzExNiwgMHhiOGQyZDBjOCksXG4gICAgICAgIG5ldyB1NjQoMHgxZTM3NmMwOCwgMHg1MTQxYWI1MyksXG4gICAgICAgIG5ldyB1NjQoMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSksXG4gICAgICAgIG5ldyB1NjQoMHgzNGIwYmNiNSwgMHhlMTliNDhhOCksXG4gICAgICAgIG5ldyB1NjQoMHgzOTFjMGNiMywgMHhjNWM5NWE2MyksXG4gICAgICAgIG5ldyB1NjQoMHg0ZWQ4YWE0YSwgMHhlMzQxOGFjYiksXG4gICAgICAgIG5ldyB1NjQoMHg1YjljY2E0ZiwgMHg3NzYzZTM3MyksXG4gICAgICAgIG5ldyB1NjQoMHg2ODJlNmZmMywgMHhkNmIyYjhhMyksXG4gICAgICAgIG5ldyB1NjQoMHg3NDhmODJlZSwgMHg1ZGVmYjJmYyksXG4gICAgICAgIG5ldyB1NjQoMHg3OGE1NjM2ZiwgMHg0MzE3MmY2MCksXG4gICAgICAgIG5ldyB1NjQoMHg4NGM4NzgxNCwgMHhhMWYwYWI3MiksXG4gICAgICAgIG5ldyB1NjQoMHg4Y2M3MDIwOCwgMHgxYTY0MzllYyksXG4gICAgICAgIG5ldyB1NjQoMHg5MGJlZmZmYSwgMHgyMzYzMWUyOCksXG4gICAgICAgIG5ldyB1NjQoMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSksXG4gICAgICAgIG5ldyB1NjQoMHhiZWY5YTNmNywgMHhiMmM2NzkxNSksXG4gICAgICAgIG5ldyB1NjQoMHhjNjcxNzhmMiwgMHhlMzcyNTMyYiksXG4gICAgICAgIG5ldyB1NjQoMHhjYTI3M2VjZSwgMHhlYTI2NjE5YyksXG4gICAgICAgIG5ldyB1NjQoMHhkMTg2YjhjNywgMHgyMWMwYzIwNyksXG4gICAgICAgIG5ldyB1NjQoMHhlYWRhN2RkNiwgMHhjZGUwZWIxZSksXG4gICAgICAgIG5ldyB1NjQoMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCksXG4gICAgICAgIG5ldyB1NjQoMHgwNmYwNjdhYSwgMHg3MjE3NmZiYSksXG4gICAgICAgIG5ldyB1NjQoMHgwYTYzN2RjNSwgMHhhMmM4OThhNiksXG4gICAgICAgIG5ldyB1NjQoMHgxMTNmOTgwNCwgMHhiZWY5MGRhZSksXG4gICAgICAgIG5ldyB1NjQoMHgxYjcxMGIzNSwgMHgxMzFjNDcxYiksXG4gICAgICAgIG5ldyB1NjQoMHgyOGRiNzdmNSwgMHgyMzA0N2Q4NCksXG4gICAgICAgIG5ldyB1NjQoMHgzMmNhYWI3YiwgMHg0MGM3MjQ5MyksXG4gICAgICAgIG5ldyB1NjQoMHgzYzllYmUwYSwgMHgxNWM5YmViYyksXG4gICAgICAgIG5ldyB1NjQoMHg0MzFkNjdjNCwgMHg5YzEwMGQ0YyksXG4gICAgICAgIG5ldyB1NjQoMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNiksXG4gICAgICAgIG5ldyB1NjQoMHg1OTdmMjk5YywgMHhmYzY1N2UyYSksXG4gICAgICAgIG5ldyB1NjQoMHg1ZmNiNmZhYiwgMHgzYWQ2ZmFlYyksXG4gICAgICAgIG5ldyB1NjQoMHg2YzQ0MTk4YywgMHg0YTQ3NTgxNylcbiAgICBdO1xuICAgIGZ1bmN0aW9uIGNyeXB0b19oYXNoYmxvY2tzKHgsIG0sIG4pIHtcbiAgICAgICAgdmFyIHogPSBbXSwgYiA9IFtdLCBhID0gW10sIHcgPSBbXSwgdCwgaSwgajtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgODsgaSsrKXpbaV0gPSBhW2ldID0gZGw2NCh4LCA4ICogaSk7XG4gICAgICAgIHZhciBwb3MgPSAwO1xuICAgICAgICB3aGlsZShuID49IDEyOCl7XG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCAxNjsgaSsrKXdbaV0gPSBkbDY0KG0sIDggKiBpICsgcG9zKTtcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IDgwOyBpKyspe1xuICAgICAgICAgICAgICAgIGZvcihqID0gMDsgaiA8IDg7IGorKyliW2pdID0gYVtqXTtcbiAgICAgICAgICAgICAgICB0ID0gYWRkNjQoYVs3XSwgU2lnbWExKGFbNF0pLCBDaChhWzRdLCBhWzVdLCBhWzZdKSwgS1tpXSwgd1tpICUgMTZdKTtcbiAgICAgICAgICAgICAgICBiWzddID0gYWRkNjQodCwgU2lnbWEwKGFbMF0pLCBNYWooYVswXSwgYVsxXSwgYVsyXSkpO1xuICAgICAgICAgICAgICAgIGJbM10gPSBhZGQ2NChiWzNdLCB0KTtcbiAgICAgICAgICAgICAgICBmb3IoaiA9IDA7IGogPCA4OyBqKyspYVsoaiArIDEpICUgOF0gPSBiW2pdO1xuICAgICAgICAgICAgICAgIGlmIChpICUgMTYgPT09IDE1KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcihqID0gMDsgaiA8IDE2OyBqKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgd1tqXSA9IGFkZDY0KHdbal0sIHdbKGogKyA5KSAlIDE2XSwgc2lnbWEwKHdbKGogKyAxKSAlIDE2XSksIHNpZ21hMSh3WyhqICsgMTQpICUgMTZdKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCA4OyBpKyspe1xuICAgICAgICAgICAgICAgIGFbaV0gPSBhZGQ2NChhW2ldLCB6W2ldKTtcbiAgICAgICAgICAgICAgICB6W2ldID0gYVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyArPSAxMjg7XG4gICAgICAgICAgICBuIC09IDEyODtcbiAgICAgICAgfVxuICAgICAgICBmb3IoaSA9IDA7IGkgPCA4OyBpKyspdHM2NCh4LCA4ICogaSwgeltpXSk7XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICB2YXIgaXYgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgIDB4NmEsXG4gICAgICAgIDB4MDksXG4gICAgICAgIDB4ZTYsXG4gICAgICAgIDB4NjcsXG4gICAgICAgIDB4ZjMsXG4gICAgICAgIDB4YmMsXG4gICAgICAgIDB4YzksXG4gICAgICAgIDB4MDgsXG4gICAgICAgIDB4YmIsXG4gICAgICAgIDB4NjcsXG4gICAgICAgIDB4YWUsXG4gICAgICAgIDB4ODUsXG4gICAgICAgIDB4ODQsXG4gICAgICAgIDB4Y2EsXG4gICAgICAgIDB4YTcsXG4gICAgICAgIDB4M2IsXG4gICAgICAgIDB4M2MsXG4gICAgICAgIDB4NmUsXG4gICAgICAgIDB4ZjMsXG4gICAgICAgIDB4NzIsXG4gICAgICAgIDB4ZmUsXG4gICAgICAgIDB4OTQsXG4gICAgICAgIDB4ZjgsXG4gICAgICAgIDB4MmIsXG4gICAgICAgIDB4YTUsXG4gICAgICAgIDB4NGYsXG4gICAgICAgIDB4ZjUsXG4gICAgICAgIDB4M2EsXG4gICAgICAgIDB4NWYsXG4gICAgICAgIDB4MWQsXG4gICAgICAgIDB4MzYsXG4gICAgICAgIDB4ZjEsXG4gICAgICAgIDB4NTEsXG4gICAgICAgIDB4MGUsXG4gICAgICAgIDB4NTIsXG4gICAgICAgIDB4N2YsXG4gICAgICAgIDB4YWQsXG4gICAgICAgIDB4ZTYsXG4gICAgICAgIDB4ODIsXG4gICAgICAgIDB4ZDEsXG4gICAgICAgIDB4OWIsXG4gICAgICAgIDB4MDUsXG4gICAgICAgIDB4NjgsXG4gICAgICAgIDB4OGMsXG4gICAgICAgIDB4MmIsXG4gICAgICAgIDB4M2UsXG4gICAgICAgIDB4NmMsXG4gICAgICAgIDB4MWYsXG4gICAgICAgIDB4MWYsXG4gICAgICAgIDB4ODMsXG4gICAgICAgIDB4ZDksXG4gICAgICAgIDB4YWIsXG4gICAgICAgIDB4ZmIsXG4gICAgICAgIDB4NDEsXG4gICAgICAgIDB4YmQsXG4gICAgICAgIDB4NmIsXG4gICAgICAgIDB4NWIsXG4gICAgICAgIDB4ZTAsXG4gICAgICAgIDB4Y2QsXG4gICAgICAgIDB4MTksXG4gICAgICAgIDB4MTMsXG4gICAgICAgIDB4N2UsXG4gICAgICAgIDB4MjEsXG4gICAgICAgIDB4NzlcbiAgICBdKTtcbiAgICBmdW5jdGlvbiBjcnlwdG9faGFzaChvdXQsIG0sIG4pIHtcbiAgICAgICAgdmFyIGggPSBuZXcgVWludDhBcnJheSg2NCksIHggPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICAgICAgICB2YXIgaSwgYiA9IG47XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDY0OyBpKyspaFtpXSA9IGl2W2ldO1xuICAgICAgICBjcnlwdG9faGFzaGJsb2NrcyhoLCBtLCBuKTtcbiAgICAgICAgbiAlPSAxMjg7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDI1NjsgaSsrKXhbaV0gPSAwO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBuOyBpKyspeFtpXSA9IG1bYiAtIG4gKyBpXTtcbiAgICAgICAgeFtuXSA9IDEyODtcbiAgICAgICAgbiA9IDI1NiAtIDEyOCAqIChuIDwgMTEyID8gMSA6IDApO1xuICAgICAgICB4W24gLSA5XSA9IDA7XG4gICAgICAgIHRzNjQoeCwgbiAtIDgsIG5ldyB1NjQoYiAvIDB4MjAwMDAwMDAgfCAwLCBiIDw8IDMpKTtcbiAgICAgICAgY3J5cHRvX2hhc2hibG9ja3MoaCwgeCwgbik7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDY0OyBpKyspb3V0W2ldID0gaFtpXTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZChwLCBxKSB7XG4gICAgICAgIHZhciBhID0gZ2YoKSwgYiA9IGdmKCksIGMgPSBnZigpLCBkID0gZ2YoKSwgZSA9IGdmKCksIGYgPSBnZigpLCBnID0gZ2YoKSwgaCA9IGdmKCksIHQgPSBnZigpO1xuICAgICAgICBaKGEsIHBbMV0sIHBbMF0pO1xuICAgICAgICBaKHQsIHFbMV0sIHFbMF0pO1xuICAgICAgICBNKGEsIGEsIHQpO1xuICAgICAgICBBKGIsIHBbMF0sIHBbMV0pO1xuICAgICAgICBBKHQsIHFbMF0sIHFbMV0pO1xuICAgICAgICBNKGIsIGIsIHQpO1xuICAgICAgICBNKGMsIHBbM10sIHFbM10pO1xuICAgICAgICBNKGMsIGMsIEQyKTtcbiAgICAgICAgTShkLCBwWzJdLCBxWzJdKTtcbiAgICAgICAgQShkLCBkLCBkKTtcbiAgICAgICAgWihlLCBiLCBhKTtcbiAgICAgICAgWihmLCBkLCBjKTtcbiAgICAgICAgQShnLCBkLCBjKTtcbiAgICAgICAgQShoLCBiLCBhKTtcbiAgICAgICAgTShwWzBdLCBlLCBmKTtcbiAgICAgICAgTShwWzFdLCBoLCBnKTtcbiAgICAgICAgTShwWzJdLCBnLCBmKTtcbiAgICAgICAgTShwWzNdLCBlLCBoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3N3YXAocCwgcSwgYikge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgNDsgaSsrKXtcbiAgICAgICAgICAgIHNlbDI1NTE5KHBbaV0sIHFbaV0sIGIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhY2sociwgcCkge1xuICAgICAgICB2YXIgdHggPSBnZigpLCB0eSA9IGdmKCksIHppID0gZ2YoKTtcbiAgICAgICAgaW52MjU1MTkoemksIHBbMl0pO1xuICAgICAgICBNKHR4LCBwWzBdLCB6aSk7XG4gICAgICAgIE0odHksIHBbMV0sIHppKTtcbiAgICAgICAgcGFjazI1NTE5KHIsIHR5KTtcbiAgICAgICAgclszMV0gXj0gcGFyMjU1MTkodHgpIDw8IDc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYWxhcm11bHQocCwgcSwgcykge1xuICAgICAgICB2YXIgYiwgaTtcbiAgICAgICAgc2V0MjU1MTkocFswXSwgZ2YwKTtcbiAgICAgICAgc2V0MjU1MTkocFsxXSwgZ2YxKTtcbiAgICAgICAgc2V0MjU1MTkocFsyXSwgZ2YxKTtcbiAgICAgICAgc2V0MjU1MTkocFszXSwgZ2YwKTtcbiAgICAgICAgZm9yKGkgPSAyNTU7IGkgPj0gMDsgLS1pKXtcbiAgICAgICAgICAgIGIgPSBzW2kgLyA4IHwgMF0gPj4gKGkgJiA3KSAmIDE7XG4gICAgICAgICAgICBjc3dhcChwLCBxLCBiKTtcbiAgICAgICAgICAgIGFkZChxLCBwKTtcbiAgICAgICAgICAgIGFkZChwLCBwKTtcbiAgICAgICAgICAgIGNzd2FwKHAsIHEsIGIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYWxhcmJhc2UocCwgcykge1xuICAgICAgICB2YXIgcSA9IFtcbiAgICAgICAgICAgIGdmKCksXG4gICAgICAgICAgICBnZigpLFxuICAgICAgICAgICAgZ2YoKSxcbiAgICAgICAgICAgIGdmKClcbiAgICAgICAgXTtcbiAgICAgICAgc2V0MjU1MTkocVswXSwgWCk7XG4gICAgICAgIHNldDI1NTE5KHFbMV0sIFkpO1xuICAgICAgICBzZXQyNTUxOShxWzJdLCBnZjEpO1xuICAgICAgICBNKHFbM10sIFgsIFkpO1xuICAgICAgICBzY2FsYXJtdWx0KHAsIHEsIHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcnlwdG9fc2lnbl9rZXlwYWlyKHBrLCBzaywgc2VlZGVkKSB7XG4gICAgICAgIHZhciBkID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICAgICAgICB2YXIgcCA9IFtcbiAgICAgICAgICAgIGdmKCksXG4gICAgICAgICAgICBnZigpLFxuICAgICAgICAgICAgZ2YoKSxcbiAgICAgICAgICAgIGdmKClcbiAgICAgICAgXTtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGlmICghc2VlZGVkKSByYW5kb21ieXRlcyhzaywgMzIpO1xuICAgICAgICBjcnlwdG9faGFzaChkLCBzaywgMzIpO1xuICAgICAgICBkWzBdICY9IDI0ODtcbiAgICAgICAgZFszMV0gJj0gMTI3O1xuICAgICAgICBkWzMxXSB8PSA2NDtcbiAgICAgICAgc2NhbGFyYmFzZShwLCBkKTtcbiAgICAgICAgcGFjayhwaywgcCk7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDMyOyBpKyspc2tbaSArIDMyXSA9IHBrW2ldO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgdmFyIEwgPSBuZXcgRmxvYXQ2NEFycmF5KFtcbiAgICAgICAgMHhlZCxcbiAgICAgICAgMHhkMyxcbiAgICAgICAgMHhmNSxcbiAgICAgICAgMHg1YyxcbiAgICAgICAgMHgxYSxcbiAgICAgICAgMHg2MyxcbiAgICAgICAgMHgxMixcbiAgICAgICAgMHg1OCxcbiAgICAgICAgMHhkNixcbiAgICAgICAgMHg5YyxcbiAgICAgICAgMHhmNyxcbiAgICAgICAgMHhhMixcbiAgICAgICAgMHhkZSxcbiAgICAgICAgMHhmOSxcbiAgICAgICAgMHhkZSxcbiAgICAgICAgMHgxNCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMHgxMFxuICAgIF0pO1xuICAgIGZ1bmN0aW9uIG1vZEwociwgeCkge1xuICAgICAgICB2YXIgY2FycnksIGksIGosIGs7XG4gICAgICAgIGZvcihpID0gNjM7IGkgPj0gMzI7IC0taSl7XG4gICAgICAgICAgICBjYXJyeSA9IDA7XG4gICAgICAgICAgICBmb3IoaiA9IGkgLSAzMiwgayA9IGkgLSAxMjsgaiA8IGs7ICsrail7XG4gICAgICAgICAgICAgICAgeFtqXSArPSBjYXJyeSAtIDE2ICogeFtpXSAqIExbaiAtIChpIC0gMzIpXTtcbiAgICAgICAgICAgICAgICBjYXJyeSA9IE1hdGguZmxvb3IoKHhbal0gKyAxMjgpIC8gMjU2KTtcbiAgICAgICAgICAgICAgICB4W2pdIC09IGNhcnJ5ICogMjU2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeFtqXSArPSBjYXJyeTtcbiAgICAgICAgICAgIHhbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgICAgZm9yKGogPSAwOyBqIDwgMzI7IGorKyl7XG4gICAgICAgICAgICB4W2pdICs9IGNhcnJ5IC0gKHhbMzFdID4+IDQpICogTFtqXTtcbiAgICAgICAgICAgIGNhcnJ5ID0geFtqXSA+PiA4O1xuICAgICAgICAgICAgeFtqXSAmPSAyNTU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGogPSAwOyBqIDwgMzI7IGorKyl4W2pdIC09IGNhcnJ5ICogTFtqXTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgMzI7IGkrKyl7XG4gICAgICAgICAgICB4W2kgKyAxXSArPSB4W2ldID4+IDg7XG4gICAgICAgICAgICByW2ldID0geFtpXSAmIDI1NTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWR1Y2Uocikge1xuICAgICAgICB2YXIgeCA9IG5ldyBGbG9hdDY0QXJyYXkoNjQpLCBpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCA2NDsgaSsrKXhbaV0gPSByW2ldO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCA2NDsgaSsrKXJbaV0gPSAwO1xuICAgICAgICBtb2RMKHIsIHgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcnlwdG9fc2lnbihzbSwgbSwgbiwgc2spIHtcbiAgICAgICAgdmFyIGQgPSBuZXcgVWludDhBcnJheSg2NCksIGggPSBuZXcgVWludDhBcnJheSg2NCksIHIgPSBuZXcgVWludDhBcnJheSg2NCk7XG4gICAgICAgIHZhciBpLCBqLCB4ID0gbmV3IEZsb2F0NjRBcnJheSg2NCk7XG4gICAgICAgIHZhciBwID0gW1xuICAgICAgICAgICAgZ2YoKSxcbiAgICAgICAgICAgIGdmKCksXG4gICAgICAgICAgICBnZigpLFxuICAgICAgICAgICAgZ2YoKVxuICAgICAgICBdO1xuICAgICAgICBjcnlwdG9faGFzaChkLCBzaywgMzIpO1xuICAgICAgICBkWzBdICY9IDI0ODtcbiAgICAgICAgZFszMV0gJj0gMTI3O1xuICAgICAgICBkWzMxXSB8PSA2NDtcbiAgICAgICAgdmFyIHNtbGVuID0gbiArIDY0O1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBuOyBpKyspc21bNjQgKyBpXSA9IG1baV07XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDMyOyBpKyspc21bMzIgKyBpXSA9IGRbMzIgKyBpXTtcbiAgICAgICAgY3J5cHRvX2hhc2gociwgc20uc3ViYXJyYXkoMzIpLCBuICsgMzIpO1xuICAgICAgICByZWR1Y2Uocik7XG4gICAgICAgIHNjYWxhcmJhc2UocCwgcik7XG4gICAgICAgIHBhY2soc20sIHApO1xuICAgICAgICBmb3IoaSA9IDMyOyBpIDwgNjQ7IGkrKylzbVtpXSA9IHNrW2ldO1xuICAgICAgICBjcnlwdG9faGFzaChoLCBzbSwgbiArIDY0KTtcbiAgICAgICAgcmVkdWNlKGgpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCA2NDsgaSsrKXhbaV0gPSAwO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCAzMjsgaSsrKXhbaV0gPSByW2ldO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCAzMjsgaSsrKXtcbiAgICAgICAgICAgIGZvcihqID0gMDsgaiA8IDMyOyBqKyspe1xuICAgICAgICAgICAgICAgIHhbaSArIGpdICs9IGhbaV0gKiBkW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1vZEwoc20uc3ViYXJyYXkoMzIpLCB4KTtcbiAgICAgICAgcmV0dXJuIHNtbGVuO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bnBhY2tuZWcociwgcCkge1xuICAgICAgICB2YXIgdCA9IGdmKCksIGNoayA9IGdmKCksIG51bSA9IGdmKCksIGRlbiA9IGdmKCksIGRlbjIgPSBnZigpLCBkZW40ID0gZ2YoKSwgZGVuNiA9IGdmKCk7XG4gICAgICAgIHNldDI1NTE5KHJbMl0sIGdmMSk7XG4gICAgICAgIHVucGFjazI1NTE5KHJbMV0sIHApO1xuICAgICAgICBTKG51bSwgclsxXSk7XG4gICAgICAgIE0oZGVuLCBudW0sIEQpO1xuICAgICAgICBaKG51bSwgbnVtLCByWzJdKTtcbiAgICAgICAgQShkZW4sIHJbMl0sIGRlbik7XG4gICAgICAgIFMoZGVuMiwgZGVuKTtcbiAgICAgICAgUyhkZW40LCBkZW4yKTtcbiAgICAgICAgTShkZW42LCBkZW40LCBkZW4yKTtcbiAgICAgICAgTSh0LCBkZW42LCBudW0pO1xuICAgICAgICBNKHQsIHQsIGRlbik7XG4gICAgICAgIHBvdzI1MjModCwgdCk7XG4gICAgICAgIE0odCwgdCwgbnVtKTtcbiAgICAgICAgTSh0LCB0LCBkZW4pO1xuICAgICAgICBNKHQsIHQsIGRlbik7XG4gICAgICAgIE0oclswXSwgdCwgZGVuKTtcbiAgICAgICAgUyhjaGssIHJbMF0pO1xuICAgICAgICBNKGNoaywgY2hrLCBkZW4pO1xuICAgICAgICBpZiAobmVxMjU1MTkoY2hrLCBudW0pKSBNKHJbMF0sIHJbMF0sIEkpO1xuICAgICAgICBTKGNoaywgclswXSk7XG4gICAgICAgIE0oY2hrLCBjaGssIGRlbik7XG4gICAgICAgIGlmIChuZXEyNTUxOShjaGssIG51bSkpIHJldHVybiAtMTtcbiAgICAgICAgaWYgKHBhcjI1NTE5KHJbMF0pID09PSBwWzMxXSA+PiA3KSBaKHJbMF0sIGdmMCwgclswXSk7XG4gICAgICAgIE0oclszXSwgclswXSwgclsxXSk7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcnlwdG9fc2lnbl9vcGVuKG0sIHNtLCBuLCBwaykge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIHQgPSBuZXcgVWludDhBcnJheSgzMiksIGggPSBuZXcgVWludDhBcnJheSg2NCk7XG4gICAgICAgIHZhciBwID0gW1xuICAgICAgICAgICAgZ2YoKSxcbiAgICAgICAgICAgIGdmKCksXG4gICAgICAgICAgICBnZigpLFxuICAgICAgICAgICAgZ2YoKVxuICAgICAgICBdLCBxID0gW1xuICAgICAgICAgICAgZ2YoKSxcbiAgICAgICAgICAgIGdmKCksXG4gICAgICAgICAgICBnZigpLFxuICAgICAgICAgICAgZ2YoKVxuICAgICAgICBdO1xuICAgICAgICBpZiAobiA8IDY0KSByZXR1cm4gLTE7XG4gICAgICAgIGlmICh1bnBhY2tuZWcocSwgcGspKSByZXR1cm4gLTE7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IG47IGkrKyltW2ldID0gc21baV07XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDMyOyBpKyspbVtpICsgMzJdID0gcGtbaV07XG4gICAgICAgIGNyeXB0b19oYXNoKGgsIG0sIG4pO1xuICAgICAgICByZWR1Y2UoaCk7XG4gICAgICAgIHNjYWxhcm11bHQocCwgcSwgaCk7XG4gICAgICAgIHNjYWxhcmJhc2UocSwgc20uc3ViYXJyYXkoMzIpKTtcbiAgICAgICAgYWRkKHAsIHEpO1xuICAgICAgICBwYWNrKHQsIHApO1xuICAgICAgICBuIC09IDY0O1xuICAgICAgICBpZiAoY3J5cHRvX3ZlcmlmeV8zMihzbSwgMCwgdCwgMCkpIHtcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IG47IGkrKyltW2ldID0gMDtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBmb3IoaSA9IDA7IGkgPCBuOyBpKyspbVtpXSA9IHNtW2kgKyA2NF07XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICB2YXIgY3J5cHRvX3NlY3JldGJveF9LRVlCWVRFUyA9IDMyLCBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVMgPSAyNCwgY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVMgPSAzMiwgY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVMgPSAxNiwgY3J5cHRvX3NjYWxhcm11bHRfQllURVMgPSAzMiwgY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVMgPSAzMiwgY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUyA9IDMyLCBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTID0gMzIsIGNyeXB0b19ib3hfQkVGT1JFTk1CWVRFUyA9IDMyLCBjcnlwdG9fYm94X05PTkNFQllURVMgPSBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVMsIGNyeXB0b19ib3hfWkVST0JZVEVTID0gY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVMsIGNyeXB0b19ib3hfQk9YWkVST0JZVEVTID0gY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVMsIGNyeXB0b19zaWduX0JZVEVTID0gNjQsIGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTID0gMzIsIGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTID0gNjQsIGNyeXB0b19zaWduX1NFRURCWVRFUyA9IDMyLCBjcnlwdG9faGFzaF9CWVRFUyA9IDY0O1xuICAgIG5hY2wubG93bGV2ZWwgPSB7XG4gICAgICAgIGNyeXB0b19jb3JlX2hzYWxzYTIwOiBjcnlwdG9fY29yZV9oc2Fsc2EyMCxcbiAgICAgICAgY3J5cHRvX3N0cmVhbV94b3I6IGNyeXB0b19zdHJlYW1feG9yLFxuICAgICAgICBjcnlwdG9fc3RyZWFtOiBjcnlwdG9fc3RyZWFtLFxuICAgICAgICBjcnlwdG9fc3RyZWFtX3NhbHNhMjBfeG9yOiBjcnlwdG9fc3RyZWFtX3NhbHNhMjBfeG9yLFxuICAgICAgICBjcnlwdG9fc3RyZWFtX3NhbHNhMjA6IGNyeXB0b19zdHJlYW1fc2Fsc2EyMCxcbiAgICAgICAgY3J5cHRvX29uZXRpbWVhdXRoOiBjcnlwdG9fb25ldGltZWF1dGgsXG4gICAgICAgIGNyeXB0b19vbmV0aW1lYXV0aF92ZXJpZnk6IGNyeXB0b19vbmV0aW1lYXV0aF92ZXJpZnksXG4gICAgICAgIGNyeXB0b192ZXJpZnlfMTY6IGNyeXB0b192ZXJpZnlfMTYsXG4gICAgICAgIGNyeXB0b192ZXJpZnlfMzI6IGNyeXB0b192ZXJpZnlfMzIsXG4gICAgICAgIGNyeXB0b19zZWNyZXRib3g6IGNyeXB0b19zZWNyZXRib3gsXG4gICAgICAgIGNyeXB0b19zZWNyZXRib3hfb3BlbjogY3J5cHRvX3NlY3JldGJveF9vcGVuLFxuICAgICAgICBjcnlwdG9fc2NhbGFybXVsdDogY3J5cHRvX3NjYWxhcm11bHQsXG4gICAgICAgIGNyeXB0b19zY2FsYXJtdWx0X2Jhc2U6IGNyeXB0b19zY2FsYXJtdWx0X2Jhc2UsXG4gICAgICAgIGNyeXB0b19ib3hfYmVmb3Jlbm06IGNyeXB0b19ib3hfYmVmb3Jlbm0sXG4gICAgICAgIGNyeXB0b19ib3hfYWZ0ZXJubTogY3J5cHRvX2JveF9hZnRlcm5tLFxuICAgICAgICBjcnlwdG9fYm94OiBjcnlwdG9fYm94LFxuICAgICAgICBjcnlwdG9fYm94X29wZW46IGNyeXB0b19ib3hfb3BlbixcbiAgICAgICAgY3J5cHRvX2JveF9rZXlwYWlyOiBjcnlwdG9fYm94X2tleXBhaXIsXG4gICAgICAgIGNyeXB0b19oYXNoOiBjcnlwdG9faGFzaCxcbiAgICAgICAgY3J5cHRvX3NpZ246IGNyeXB0b19zaWduLFxuICAgICAgICBjcnlwdG9fc2lnbl9rZXlwYWlyOiBjcnlwdG9fc2lnbl9rZXlwYWlyLFxuICAgICAgICBjcnlwdG9fc2lnbl9vcGVuOiBjcnlwdG9fc2lnbl9vcGVuLFxuICAgICAgICBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTOiBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTLFxuICAgICAgICBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVM6IGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUyxcbiAgICAgICAgY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVM6IGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTLFxuICAgICAgICBjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUzogY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVMsXG4gICAgICAgIGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTOiBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUyxcbiAgICAgICAgY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVM6IGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTLFxuICAgICAgICBjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTOiBjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTLFxuICAgICAgICBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTOiBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTLFxuICAgICAgICBjcnlwdG9fYm94X0JFRk9SRU5NQllURVM6IGNyeXB0b19ib3hfQkVGT1JFTk1CWVRFUyxcbiAgICAgICAgY3J5cHRvX2JveF9OT05DRUJZVEVTOiBjcnlwdG9fYm94X05PTkNFQllURVMsXG4gICAgICAgIGNyeXB0b19ib3hfWkVST0JZVEVTOiBjcnlwdG9fYm94X1pFUk9CWVRFUyxcbiAgICAgICAgY3J5cHRvX2JveF9CT1haRVJPQllURVM6IGNyeXB0b19ib3hfQk9YWkVST0JZVEVTLFxuICAgICAgICBjcnlwdG9fc2lnbl9CWVRFUzogY3J5cHRvX3NpZ25fQllURVMsXG4gICAgICAgIGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTOiBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyxcbiAgICAgICAgY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVM6IGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTLFxuICAgICAgICBjcnlwdG9fc2lnbl9TRUVEQllURVM6IGNyeXB0b19zaWduX1NFRURCWVRFUyxcbiAgICAgICAgY3J5cHRvX2hhc2hfQllURVM6IGNyeXB0b19oYXNoX0JZVEVTLFxuICAgICAgICBnZjogZ2YsXG4gICAgICAgIEQ6IEQsXG4gICAgICAgIEw6IEwsXG4gICAgICAgIHBhY2syNTUxOTogcGFjazI1NTE5LFxuICAgICAgICB1bnBhY2syNTUxOTogdW5wYWNrMjU1MTksXG4gICAgICAgIE06IE0sXG4gICAgICAgIEE6IEEsXG4gICAgICAgIFM6IFMsXG4gICAgICAgIFo6IFosXG4gICAgICAgIHBvdzI1MjM6IHBvdzI1MjMsXG4gICAgICAgIGFkZDogYWRkLFxuICAgICAgICBzZXQyNTUxOTogc2V0MjU1MTksXG4gICAgICAgIG1vZEw6IG1vZEwsXG4gICAgICAgIHNjYWxhcm11bHQ6IHNjYWxhcm11bHQsXG4gICAgICAgIHNjYWxhcmJhc2U6IHNjYWxhcmJhc2VcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGNoZWNrTGVuZ3RocyhrLCBuKSB7XG4gICAgICAgIGlmIChrLmxlbmd0aCAhPT0gY3J5cHRvX3NlY3JldGJveF9LRVlCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQga2V5IHNpemUnKTtcbiAgICAgICAgaWYgKG4ubGVuZ3RoICE9PSBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIG5vbmNlIHNpemUnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tCb3hMZW5ndGhzKHBrLCBzaykge1xuICAgICAgICBpZiAocGsubGVuZ3RoICE9PSBjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwdWJsaWMga2V5IHNpemUnKTtcbiAgICAgICAgaWYgKHNrLmxlbmd0aCAhPT0gY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VjcmV0IGtleSBzaXplJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrQXJyYXlUeXBlcygpIHtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBpZiAoIShhcmd1bWVudHNbaV0gaW5zdGFuY2VvZiBVaW50OEFycmF5KSkgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5leHBlY3RlZCB0eXBlLCB1c2UgVWludDhBcnJheScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFudXAoYXJyKSB7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspYXJyW2ldID0gMDtcbiAgICB9XG4gICAgbmFjbC5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdmFyIGIgPSBuZXcgVWludDhBcnJheShuKTtcbiAgICAgICAgcmFuZG9tYnl0ZXMoYiwgbik7XG4gICAgICAgIHJldHVybiBiO1xuICAgIH07XG4gICAgbmFjbC5zZWNyZXRib3ggPSBmdW5jdGlvbihtc2csIG5vbmNlLCBrZXkpIHtcbiAgICAgICAgY2hlY2tBcnJheVR5cGVzKG1zZywgbm9uY2UsIGtleSk7XG4gICAgICAgIGNoZWNrTGVuZ3RocyhrZXksIG5vbmNlKTtcbiAgICAgICAgdmFyIG0gPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUyArIG1zZy5sZW5ndGgpO1xuICAgICAgICB2YXIgYyA9IG5ldyBVaW50OEFycmF5KG0ubGVuZ3RoKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKyltW2kgKyBjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFU10gPSBtc2dbaV07XG4gICAgICAgIGNyeXB0b19zZWNyZXRib3goYywgbSwgbS5sZW5ndGgsIG5vbmNlLCBrZXkpO1xuICAgICAgICByZXR1cm4gYy5zdWJhcnJheShjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUyk7XG4gICAgfTtcbiAgICBuYWNsLnNlY3JldGJveC5vcGVuID0gZnVuY3Rpb24oYm94LCBub25jZSwga2V5KSB7XG4gICAgICAgIGNoZWNrQXJyYXlUeXBlcyhib3gsIG5vbmNlLCBrZXkpO1xuICAgICAgICBjaGVja0xlbmd0aHMoa2V5LCBub25jZSk7XG4gICAgICAgIHZhciBjID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVMgKyBib3gubGVuZ3RoKTtcbiAgICAgICAgdmFyIG0gPSBuZXcgVWludDhBcnJheShjLmxlbmd0aCk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBib3gubGVuZ3RoOyBpKyspY1tpICsgY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVNdID0gYm94W2ldO1xuICAgICAgICBpZiAoYy5sZW5ndGggPCAzMikgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChjcnlwdG9fc2VjcmV0Ym94X29wZW4obSwgYywgYy5sZW5ndGgsIG5vbmNlLCBrZXkpICE9PSAwKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG0uc3ViYXJyYXkoY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVMpO1xuICAgIH07XG4gICAgbmFjbC5zZWNyZXRib3gua2V5TGVuZ3RoID0gY3J5cHRvX3NlY3JldGJveF9LRVlCWVRFUztcbiAgICBuYWNsLnNlY3JldGJveC5ub25jZUxlbmd0aCA9IGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUztcbiAgICBuYWNsLnNlY3JldGJveC5vdmVyaGVhZExlbmd0aCA9IGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTO1xuICAgIG5hY2wuc2NhbGFyTXVsdCA9IGZ1bmN0aW9uKG4sIHApIHtcbiAgICAgICAgY2hlY2tBcnJheVR5cGVzKG4sIHApO1xuICAgICAgICBpZiAobi5sZW5ndGggIT09IGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBuIHNpemUnKTtcbiAgICAgICAgaWYgKHAubGVuZ3RoICE9PSBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgcCBzaXplJyk7XG4gICAgICAgIHZhciBxID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NjYWxhcm11bHRfQllURVMpO1xuICAgICAgICBjcnlwdG9fc2NhbGFybXVsdChxLCBuLCBwKTtcbiAgICAgICAgcmV0dXJuIHE7XG4gICAgfTtcbiAgICBuYWNsLnNjYWxhck11bHQuYmFzZSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgY2hlY2tBcnJheVR5cGVzKG4pO1xuICAgICAgICBpZiAobi5sZW5ndGggIT09IGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBuIHNpemUnKTtcbiAgICAgICAgdmFyIHEgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2NhbGFybXVsdF9CWVRFUyk7XG4gICAgICAgIGNyeXB0b19zY2FsYXJtdWx0X2Jhc2UocSwgbik7XG4gICAgICAgIHJldHVybiBxO1xuICAgIH07XG4gICAgbmFjbC5zY2FsYXJNdWx0LnNjYWxhckxlbmd0aCA9IGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTO1xuICAgIG5hY2wuc2NhbGFyTXVsdC5ncm91cEVsZW1lbnRMZW5ndGggPSBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUztcbiAgICBuYWNsLmJveCA9IGZ1bmN0aW9uKG1zZywgbm9uY2UsIHB1YmxpY0tleSwgc2VjcmV0S2V5KSB7XG4gICAgICAgIHZhciBrID0gbmFjbC5ib3guYmVmb3JlKHB1YmxpY0tleSwgc2VjcmV0S2V5KTtcbiAgICAgICAgcmV0dXJuIG5hY2wuc2VjcmV0Ym94KG1zZywgbm9uY2UsIGspO1xuICAgIH07XG4gICAgbmFjbC5ib3guYmVmb3JlID0gZnVuY3Rpb24ocHVibGljS2V5LCBzZWNyZXRLZXkpIHtcbiAgICAgICAgY2hlY2tBcnJheVR5cGVzKHB1YmxpY0tleSwgc2VjcmV0S2V5KTtcbiAgICAgICAgY2hlY2tCb3hMZW5ndGhzKHB1YmxpY0tleSwgc2VjcmV0S2V5KTtcbiAgICAgICAgdmFyIGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fYm94X0JFRk9SRU5NQllURVMpO1xuICAgICAgICBjcnlwdG9fYm94X2JlZm9yZW5tKGssIHB1YmxpY0tleSwgc2VjcmV0S2V5KTtcbiAgICAgICAgcmV0dXJuIGs7XG4gICAgfTtcbiAgICBuYWNsLmJveC5hZnRlciA9IG5hY2wuc2VjcmV0Ym94O1xuICAgIG5hY2wuYm94Lm9wZW4gPSBmdW5jdGlvbihtc2csIG5vbmNlLCBwdWJsaWNLZXksIHNlY3JldEtleSkge1xuICAgICAgICB2YXIgayA9IG5hY2wuYm94LmJlZm9yZShwdWJsaWNLZXksIHNlY3JldEtleSk7XG4gICAgICAgIHJldHVybiBuYWNsLnNlY3JldGJveC5vcGVuKG1zZywgbm9uY2UsIGspO1xuICAgIH07XG4gICAgbmFjbC5ib3gub3Blbi5hZnRlciA9IG5hY2wuc2VjcmV0Ym94Lm9wZW47XG4gICAgbmFjbC5ib3gua2V5UGFpciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTKTtcbiAgICAgICAgdmFyIHNrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUyk7XG4gICAgICAgIGNyeXB0b19ib3hfa2V5cGFpcihwaywgc2spO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHVibGljS2V5OiBwayxcbiAgICAgICAgICAgIHNlY3JldEtleTogc2tcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIG5hY2wuYm94LmtleVBhaXIuZnJvbVNlY3JldEtleSA9IGZ1bmN0aW9uKHNlY3JldEtleSkge1xuICAgICAgICBjaGVja0FycmF5VHlwZXMoc2VjcmV0S2V5KTtcbiAgICAgICAgaWYgKHNlY3JldEtleS5sZW5ndGggIT09IGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xuICAgICAgICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTKTtcbiAgICAgICAgY3J5cHRvX3NjYWxhcm11bHRfYmFzZShwaywgc2VjcmV0S2V5KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHB1YmxpY0tleTogcGssXG4gICAgICAgICAgICBzZWNyZXRLZXk6IG5ldyBVaW50OEFycmF5KHNlY3JldEtleSlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIG5hY2wuYm94LnB1YmxpY0tleUxlbmd0aCA9IGNyeXB0b19ib3hfUFVCTElDS0VZQllURVM7XG4gICAgbmFjbC5ib3guc2VjcmV0S2V5TGVuZ3RoID0gY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUztcbiAgICBuYWNsLmJveC5zaGFyZWRLZXlMZW5ndGggPSBjcnlwdG9fYm94X0JFRk9SRU5NQllURVM7XG4gICAgbmFjbC5ib3gubm9uY2VMZW5ndGggPSBjcnlwdG9fYm94X05PTkNFQllURVM7XG4gICAgbmFjbC5ib3gub3ZlcmhlYWRMZW5ndGggPSBuYWNsLnNlY3JldGJveC5vdmVyaGVhZExlbmd0aDtcbiAgICBuYWNsLnNpZ24gPSBmdW5jdGlvbihtc2csIHNlY3JldEtleSkge1xuICAgICAgICBjaGVja0FycmF5VHlwZXMobXNnLCBzZWNyZXRLZXkpO1xuICAgICAgICBpZiAoc2VjcmV0S2V5Lmxlbmd0aCAhPT0gY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xuICAgICAgICB2YXIgc2lnbmVkTXNnID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fQllURVMgKyBtc2cubGVuZ3RoKTtcbiAgICAgICAgY3J5cHRvX3NpZ24oc2lnbmVkTXNnLCBtc2csIG1zZy5sZW5ndGgsIHNlY3JldEtleSk7XG4gICAgICAgIHJldHVybiBzaWduZWRNc2c7XG4gICAgfTtcbiAgICBuYWNsLnNpZ24ub3BlbiA9IGZ1bmN0aW9uKHNpZ25lZE1zZywgcHVibGljS2V5KSB7XG4gICAgICAgIGNoZWNrQXJyYXlUeXBlcyhzaWduZWRNc2csIHB1YmxpY0tleSk7XG4gICAgICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgcHVibGljIGtleSBzaXplJyk7XG4gICAgICAgIHZhciB0bXAgPSBuZXcgVWludDhBcnJheShzaWduZWRNc2cubGVuZ3RoKTtcbiAgICAgICAgdmFyIG1sZW4gPSBjcnlwdG9fc2lnbl9vcGVuKHRtcCwgc2lnbmVkTXNnLCBzaWduZWRNc2cubGVuZ3RoLCBwdWJsaWNLZXkpO1xuICAgICAgICBpZiAobWxlbiA8IDApIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgbSA9IG5ldyBVaW50OEFycmF5KG1sZW4pO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKyltW2ldID0gdG1wW2ldO1xuICAgICAgICByZXR1cm4gbTtcbiAgICB9O1xuICAgIG5hY2wuc2lnbi5kZXRhY2hlZCA9IGZ1bmN0aW9uKG1zZywgc2VjcmV0S2V5KSB7XG4gICAgICAgIHZhciBzaWduZWRNc2cgPSBuYWNsLnNpZ24obXNnLCBzZWNyZXRLZXkpO1xuICAgICAgICB2YXIgc2lnID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fQllURVMpO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2lnLmxlbmd0aDsgaSsrKXNpZ1tpXSA9IHNpZ25lZE1zZ1tpXTtcbiAgICAgICAgcmV0dXJuIHNpZztcbiAgICB9O1xuICAgIG5hY2wuc2lnbi5kZXRhY2hlZC52ZXJpZnkgPSBmdW5jdGlvbihtc2csIHNpZywgcHVibGljS2V5KSB7XG4gICAgICAgIGNoZWNrQXJyYXlUeXBlcyhtc2csIHNpZywgcHVibGljS2V5KTtcbiAgICAgICAgaWYgKHNpZy5sZW5ndGggIT09IGNyeXB0b19zaWduX0JZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzaWduYXR1cmUgc2l6ZScpO1xuICAgICAgICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIHB1YmxpYyBrZXkgc2l6ZScpO1xuICAgICAgICB2YXIgc20gPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9CWVRFUyArIG1zZy5sZW5ndGgpO1xuICAgICAgICB2YXIgbSA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX0JZVEVTICsgbXNnLmxlbmd0aCk7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBjcnlwdG9fc2lnbl9CWVRFUzsgaSsrKXNtW2ldID0gc2lnW2ldO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspc21baSArIGNyeXB0b19zaWduX0JZVEVTXSA9IG1zZ1tpXTtcbiAgICAgICAgcmV0dXJuIGNyeXB0b19zaWduX29wZW4obSwgc20sIHNtLmxlbmd0aCwgcHVibGljS2V5KSA+PSAwO1xuICAgIH07XG4gICAgbmFjbC5zaWduLmtleVBhaXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMpO1xuICAgICAgICB2YXIgc2sgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUyk7XG4gICAgICAgIGNyeXB0b19zaWduX2tleXBhaXIocGssIHNrKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHB1YmxpY0tleTogcGssXG4gICAgICAgICAgICBzZWNyZXRLZXk6IHNrXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBuYWNsLnNpZ24ua2V5UGFpci5mcm9tU2VjcmV0S2V5ID0gZnVuY3Rpb24oc2VjcmV0S2V5KSB7XG4gICAgICAgIGNoZWNrQXJyYXlUeXBlcyhzZWNyZXRLZXkpO1xuICAgICAgICBpZiAoc2VjcmV0S2V5Lmxlbmd0aCAhPT0gY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xuICAgICAgICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBway5sZW5ndGg7IGkrKylwa1tpXSA9IHNlY3JldEtleVszMiArIGldO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHVibGljS2V5OiBwayxcbiAgICAgICAgICAgIHNlY3JldEtleTogbmV3IFVpbnQ4QXJyYXkoc2VjcmV0S2V5KVxuICAgICAgICB9O1xuICAgIH07XG4gICAgbmFjbC5zaWduLmtleVBhaXIuZnJvbVNlZWQgPSBmdW5jdGlvbihzZWVkKSB7XG4gICAgICAgIGNoZWNrQXJyYXlUeXBlcyhzZWVkKTtcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoICE9PSBjcnlwdG9fc2lnbl9TRUVEQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIHNlZWQgc2l6ZScpO1xuICAgICAgICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyk7XG4gICAgICAgIHZhciBzayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IDMyOyBpKyspc2tbaV0gPSBzZWVkW2ldO1xuICAgICAgICBjcnlwdG9fc2lnbl9rZXlwYWlyKHBrLCBzaywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwdWJsaWNLZXk6IHBrLFxuICAgICAgICAgICAgc2VjcmV0S2V5OiBza1xuICAgICAgICB9O1xuICAgIH07XG4gICAgbmFjbC5zaWduLnB1YmxpY0tleUxlbmd0aCA9IGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTO1xuICAgIG5hY2wuc2lnbi5zZWNyZXRLZXlMZW5ndGggPSBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUztcbiAgICBuYWNsLnNpZ24uc2VlZExlbmd0aCA9IGNyeXB0b19zaWduX1NFRURCWVRFUztcbiAgICBuYWNsLnNpZ24uc2lnbmF0dXJlTGVuZ3RoID0gY3J5cHRvX3NpZ25fQllURVM7XG4gICAgbmFjbC5oYXNoID0gZnVuY3Rpb24obXNnKSB7XG4gICAgICAgIGNoZWNrQXJyYXlUeXBlcyhtc2cpO1xuICAgICAgICB2YXIgaCA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19oYXNoX0JZVEVTKTtcbiAgICAgICAgY3J5cHRvX2hhc2goaCwgbXNnLCBtc2cubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGg7XG4gICAgfTtcbiAgICBuYWNsLmhhc2guaGFzaExlbmd0aCA9IGNyeXB0b19oYXNoX0JZVEVTO1xuICAgIG5hY2wudmVyaWZ5ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICBjaGVja0FycmF5VHlwZXMoeCwgeSk7XG4gICAgICAgIGlmICh4Lmxlbmd0aCA9PT0gMCB8fCB5Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoeC5sZW5ndGggIT09IHkubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB2bih4LCAwLCB5LCAwLCB4Lmxlbmd0aCkgPT09IDAgPyB0cnVlIDogZmFsc2U7XG4gICAgfTtcbiAgICBuYWNsLnNldFBSTkcgPSBmdW5jdGlvbihmbikge1xuICAgICAgICByYW5kb21ieXRlcyA9IGZuO1xuICAgIH07XG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3J5cHRvMSA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMuY3J5cHRvIHx8IGdsb2JhbFRoaXMubXNDcnlwdG8gOiBudWxsO1xuICAgICAgICBpZiAoY3J5cHRvMSAmJiBjcnlwdG8xLmdldFJhbmRvbVZhbHVlcykge1xuICAgICAgICAgICAgdmFyIFFVT1RBID0gNjU1MzY7XG4gICAgICAgICAgICBuYWNsLnNldFBSTkcoZnVuY3Rpb24oeCwgbikge1xuICAgICAgICAgICAgICAgIHZhciBpLCB2ID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gICAgICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgbjsgaSArPSBRVU9UQSl7XG4gICAgICAgICAgICAgICAgICAgIGNyeXB0bzEuZ2V0UmFuZG9tVmFsdWVzKHYuc3ViYXJyYXkoaSwgaSArIE1hdGgubWluKG4gLSBpLCBRVU9UQSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgbjsgaSsrKXhbaV0gPSB2W2ldO1xuICAgICAgICAgICAgICAgIGNsZWFudXAodik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNyeXB0bzEgPSByZXF1aXJlKCdjcnlwdG8nKTtcbiAgICAgICAgICAgIGlmIChjcnlwdG8xICYmIGNyeXB0bzEucmFuZG9tQnl0ZXMpIHtcbiAgICAgICAgICAgICAgICBuYWNsLnNldFBSTkcoZnVuY3Rpb24oeCwgbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSwgdiA9IGNyeXB0bzEucmFuZG9tQnl0ZXMobik7XG4gICAgICAgICAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IG47IGkrKyl4W2ldID0gdltpXTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCh2KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pKCk7XG59KSh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cyA/IG1vZHVsZS5leHBvcnRzIDogZ2xvYmFsVGhpcy5uYWNsID0gZ2xvYmFsVGhpcy5uYWNsIHx8IHt9KTtcbmNvbnN0IG5hY2wgPSB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cyA/IG1vZHVsZS5leHBvcnRzIDogZ2xvYmFsVGhpcy5uYWNsO1xuY29uc3QgZGVub0hlbHBlciA9IHtcbiAgICBmcm9tU2VlZDogbmFjbC5zaWduLmtleVBhaXIuZnJvbVNlZWQsXG4gICAgc2lnbjogbmFjbC5zaWduLmRldGFjaGVkLFxuICAgIHZlcmlmeTogbmFjbC5zaWduLmRldGFjaGVkLnZlcmlmeSxcbiAgICByYW5kb21CeXRlczogbmFjbC5yYW5kb21CeXRlc1xufTtcbmxldCBoZWxwZXI7XG5mdW5jdGlvbiBzZXRFZDI1NTE5SGVscGVyKGxpYikge1xuICAgIGhlbHBlciA9IGxpYjtcbn1cbmZ1bmN0aW9uIGdldEVkMjU1MTlIZWxwZXIoKSB7XG4gICAgcmV0dXJuIGhlbHBlcjtcbn1cbmNvbnN0IGNyYzE2dGFiID0gbmV3IFVpbnQxNkFycmF5KFtcbiAgICAweDAwMDAsXG4gICAgMHgxMDIxLFxuICAgIDB4MjA0MixcbiAgICAweDMwNjMsXG4gICAgMHg0MDg0LFxuICAgIDB4NTBhNSxcbiAgICAweDYwYzYsXG4gICAgMHg3MGU3LFxuICAgIDB4ODEwOCxcbiAgICAweDkxMjksXG4gICAgMHhhMTRhLFxuICAgIDB4YjE2YixcbiAgICAweGMxOGMsXG4gICAgMHhkMWFkLFxuICAgIDB4ZTFjZSxcbiAgICAweGYxZWYsXG4gICAgMHgxMjMxLFxuICAgIDB4MDIxMCxcbiAgICAweDMyNzMsXG4gICAgMHgyMjUyLFxuICAgIDB4NTJiNSxcbiAgICAweDQyOTQsXG4gICAgMHg3MmY3LFxuICAgIDB4NjJkNixcbiAgICAweDkzMzksXG4gICAgMHg4MzE4LFxuICAgIDB4YjM3YixcbiAgICAweGEzNWEsXG4gICAgMHhkM2JkLFxuICAgIDB4YzM5YyxcbiAgICAweGYzZmYsXG4gICAgMHhlM2RlLFxuICAgIDB4MjQ2MixcbiAgICAweDM0NDMsXG4gICAgMHgwNDIwLFxuICAgIDB4MTQwMSxcbiAgICAweDY0ZTYsXG4gICAgMHg3NGM3LFxuICAgIDB4NDRhNCxcbiAgICAweDU0ODUsXG4gICAgMHhhNTZhLFxuICAgIDB4YjU0YixcbiAgICAweDg1MjgsXG4gICAgMHg5NTA5LFxuICAgIDB4ZTVlZSxcbiAgICAweGY1Y2YsXG4gICAgMHhjNWFjLFxuICAgIDB4ZDU4ZCxcbiAgICAweDM2NTMsXG4gICAgMHgyNjcyLFxuICAgIDB4MTYxMSxcbiAgICAweDA2MzAsXG4gICAgMHg3NmQ3LFxuICAgIDB4NjZmNixcbiAgICAweDU2OTUsXG4gICAgMHg0NmI0LFxuICAgIDB4Yjc1YixcbiAgICAweGE3N2EsXG4gICAgMHg5NzE5LFxuICAgIDB4ODczOCxcbiAgICAweGY3ZGYsXG4gICAgMHhlN2ZlLFxuICAgIDB4ZDc5ZCxcbiAgICAweGM3YmMsXG4gICAgMHg0OGM0LFxuICAgIDB4NThlNSxcbiAgICAweDY4ODYsXG4gICAgMHg3OGE3LFxuICAgIDB4MDg0MCxcbiAgICAweDE4NjEsXG4gICAgMHgyODAyLFxuICAgIDB4MzgyMyxcbiAgICAweGM5Y2MsXG4gICAgMHhkOWVkLFxuICAgIDB4ZTk4ZSxcbiAgICAweGY5YWYsXG4gICAgMHg4OTQ4LFxuICAgIDB4OTk2OSxcbiAgICAweGE5MGEsXG4gICAgMHhiOTJiLFxuICAgIDB4NWFmNSxcbiAgICAweDRhZDQsXG4gICAgMHg3YWI3LFxuICAgIDB4NmE5NixcbiAgICAweDFhNzEsXG4gICAgMHgwYTUwLFxuICAgIDB4M2EzMyxcbiAgICAweDJhMTIsXG4gICAgMHhkYmZkLFxuICAgIDB4Y2JkYyxcbiAgICAweGZiYmYsXG4gICAgMHhlYjllLFxuICAgIDB4OWI3OSxcbiAgICAweDhiNTgsXG4gICAgMHhiYjNiLFxuICAgIDB4YWIxYSxcbiAgICAweDZjYTYsXG4gICAgMHg3Yzg3LFxuICAgIDB4NGNlNCxcbiAgICAweDVjYzUsXG4gICAgMHgyYzIyLFxuICAgIDB4M2MwMyxcbiAgICAweDBjNjAsXG4gICAgMHgxYzQxLFxuICAgIDB4ZWRhZSxcbiAgICAweGZkOGYsXG4gICAgMHhjZGVjLFxuICAgIDB4ZGRjZCxcbiAgICAweGFkMmEsXG4gICAgMHhiZDBiLFxuICAgIDB4OGQ2OCxcbiAgICAweDlkNDksXG4gICAgMHg3ZTk3LFxuICAgIDB4NmViNixcbiAgICAweDVlZDUsXG4gICAgMHg0ZWY0LFxuICAgIDB4M2UxMyxcbiAgICAweDJlMzIsXG4gICAgMHgxZTUxLFxuICAgIDB4MGU3MCxcbiAgICAweGZmOWYsXG4gICAgMHhlZmJlLFxuICAgIDB4ZGZkZCxcbiAgICAweGNmZmMsXG4gICAgMHhiZjFiLFxuICAgIDB4YWYzYSxcbiAgICAweDlmNTksXG4gICAgMHg4Zjc4LFxuICAgIDB4OTE4OCxcbiAgICAweDgxYTksXG4gICAgMHhiMWNhLFxuICAgIDB4YTFlYixcbiAgICAweGQxMGMsXG4gICAgMHhjMTJkLFxuICAgIDB4ZjE0ZSxcbiAgICAweGUxNmYsXG4gICAgMHgxMDgwLFxuICAgIDB4MDBhMSxcbiAgICAweDMwYzIsXG4gICAgMHgyMGUzLFxuICAgIDB4NTAwNCxcbiAgICAweDQwMjUsXG4gICAgMHg3MDQ2LFxuICAgIDB4NjA2NyxcbiAgICAweDgzYjksXG4gICAgMHg5Mzk4LFxuICAgIDB4YTNmYixcbiAgICAweGIzZGEsXG4gICAgMHhjMzNkLFxuICAgIDB4ZDMxYyxcbiAgICAweGUzN2YsXG4gICAgMHhmMzVlLFxuICAgIDB4MDJiMSxcbiAgICAweDEyOTAsXG4gICAgMHgyMmYzLFxuICAgIDB4MzJkMixcbiAgICAweDQyMzUsXG4gICAgMHg1MjE0LFxuICAgIDB4NjI3NyxcbiAgICAweDcyNTYsXG4gICAgMHhiNWVhLFxuICAgIDB4YTVjYixcbiAgICAweDk1YTgsXG4gICAgMHg4NTg5LFxuICAgIDB4ZjU2ZSxcbiAgICAweGU1NGYsXG4gICAgMHhkNTJjLFxuICAgIDB4YzUwZCxcbiAgICAweDM0ZTIsXG4gICAgMHgyNGMzLFxuICAgIDB4MTRhMCxcbiAgICAweDA0ODEsXG4gICAgMHg3NDY2LFxuICAgIDB4NjQ0NyxcbiAgICAweDU0MjQsXG4gICAgMHg0NDA1LFxuICAgIDB4YTdkYixcbiAgICAweGI3ZmEsXG4gICAgMHg4Nzk5LFxuICAgIDB4OTdiOCxcbiAgICAweGU3NWYsXG4gICAgMHhmNzdlLFxuICAgIDB4YzcxZCxcbiAgICAweGQ3M2MsXG4gICAgMHgyNmQzLFxuICAgIDB4MzZmMixcbiAgICAweDA2OTEsXG4gICAgMHgxNmIwLFxuICAgIDB4NjY1NyxcbiAgICAweDc2NzYsXG4gICAgMHg0NjE1LFxuICAgIDB4NTYzNCxcbiAgICAweGQ5NGMsXG4gICAgMHhjOTZkLFxuICAgIDB4ZjkwZSxcbiAgICAweGU5MmYsXG4gICAgMHg5OWM4LFxuICAgIDB4ODllOSxcbiAgICAweGI5OGEsXG4gICAgMHhhOWFiLFxuICAgIDB4NTg0NCxcbiAgICAweDQ4NjUsXG4gICAgMHg3ODA2LFxuICAgIDB4NjgyNyxcbiAgICAweDE4YzAsXG4gICAgMHgwOGUxLFxuICAgIDB4Mzg4MixcbiAgICAweDI4YTMsXG4gICAgMHhjYjdkLFxuICAgIDB4ZGI1YyxcbiAgICAweGViM2YsXG4gICAgMHhmYjFlLFxuICAgIDB4OGJmOSxcbiAgICAweDliZDgsXG4gICAgMHhhYmJiLFxuICAgIDB4YmI5YSxcbiAgICAweDRhNzUsXG4gICAgMHg1YTU0LFxuICAgIDB4NmEzNyxcbiAgICAweDdhMTYsXG4gICAgMHgwYWYxLFxuICAgIDB4MWFkMCxcbiAgICAweDJhYjMsXG4gICAgMHgzYTkyLFxuICAgIDB4ZmQyZSxcbiAgICAweGVkMGYsXG4gICAgMHhkZDZjLFxuICAgIDB4Y2Q0ZCxcbiAgICAweGJkYWEsXG4gICAgMHhhZDhiLFxuICAgIDB4OWRlOCxcbiAgICAweDhkYzksXG4gICAgMHg3YzI2LFxuICAgIDB4NmMwNyxcbiAgICAweDVjNjQsXG4gICAgMHg0YzQ1LFxuICAgIDB4M2NhMixcbiAgICAweDJjODMsXG4gICAgMHgxY2UwLFxuICAgIDB4MGNjMSxcbiAgICAweGVmMWYsXG4gICAgMHhmZjNlLFxuICAgIDB4Y2Y1ZCxcbiAgICAweGRmN2MsXG4gICAgMHhhZjliLFxuICAgIDB4YmZiYSxcbiAgICAweDhmZDksXG4gICAgMHg5ZmY4LFxuICAgIDB4NmUxNyxcbiAgICAweDdlMzYsXG4gICAgMHg0ZTU1LFxuICAgIDB4NWU3NCxcbiAgICAweDJlOTMsXG4gICAgMHgzZWIyLFxuICAgIDB4MGVkMSxcbiAgICAweDFlZjBcbl0pO1xuY2xhc3MgY3JjMTYge1xuICAgIHN0YXRpYyBjaGVja3N1bShkYXRhKSB7XG4gICAgICAgIGxldCBjcmMgPSAwO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgZGF0YS5ieXRlTGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgbGV0IGIgPSBkYXRhW2ldO1xuICAgICAgICAgICAgY3JjID0gY3JjIDw8IDggJiAweGZmZmYgXiBjcmMxNnRhYlsoY3JjID4+IDggXiBiKSAmIDB4MDBGRl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyYztcbiAgICB9XG4gICAgc3RhdGljIHZhbGlkYXRlKGRhdGEsIGV4cGVjdGVkKSB7XG4gICAgICAgIGxldCBiYSA9IGNyYzE2LmNoZWNrc3VtKGRhdGEpO1xuICAgICAgICByZXR1cm4gYmEgPT0gZXhwZWN0ZWQ7XG4gICAgfVxufVxuY29uc3QgYjMyQWxwaGFiZXQgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3XCI7XG5jbGFzcyBiYXNlMzIge1xuICAgIHN0YXRpYyBlbmNvZGUoc3JjKSB7XG4gICAgICAgIGxldCBiaXRzID0gMDtcbiAgICAgICAgbGV0IHZhbHVlID0gMDtcbiAgICAgICAgbGV0IGEgPSBuZXcgVWludDhBcnJheShzcmMpO1xuICAgICAgICBsZXQgYnVmID0gbmV3IFVpbnQ4QXJyYXkoc3JjLmJ5dGVMZW5ndGggKiAyKTtcbiAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgYS5ieXRlTGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA8PCA4IHwgYVtpXTtcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIHdoaWxlKGJpdHMgPj0gNSl7XG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gdmFsdWUgPj4+IGJpdHMgLSA1ICYgMzE7XG4gICAgICAgICAgICAgICAgYnVmW2orK10gPSBiMzJBbHBoYWJldC5jaGFyQXQoaW5kZXgpLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgYml0cyAtPSA1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChiaXRzID4gMCkge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gdmFsdWUgPDwgNSAtIGJpdHMgJiAzMTtcbiAgICAgICAgICAgIGJ1ZltqKytdID0gYjMyQWxwaGFiZXQuY2hhckF0KGluZGV4KS5jaGFyQ29kZUF0KDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWYuc2xpY2UoMCwgaik7XG4gICAgfVxuICAgIHN0YXRpYyBkZWNvZGUoc3JjKSB7XG4gICAgICAgIGxldCBiaXRzID0gMDtcbiAgICAgICAgbGV0IF9fYnl0ZSA9IDA7XG4gICAgICAgIGxldCBqID0gMDtcbiAgICAgICAgbGV0IGEgPSBuZXcgVWludDhBcnJheShzcmMpO1xuICAgICAgICBsZXQgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoYS5ieXRlTGVuZ3RoICogNSAvIDggfCAwKTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGEuYnl0ZUxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGxldCB2ID0gU3RyaW5nLmZyb21DaGFyQ29kZShhW2ldKTtcbiAgICAgICAgICAgIGxldCB2diA9IGIzMkFscGhhYmV0LmluZGV4T2Yodik7XG4gICAgICAgICAgICBpZiAodnYgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBCYXNlMzIgY2hhcmFjdGVyOiBcIiArIGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX19ieXRlID0gX19ieXRlIDw8IDUgfCB2djtcbiAgICAgICAgICAgIGJpdHMgKz0gNTtcbiAgICAgICAgICAgIGlmIChiaXRzID49IDgpIHtcbiAgICAgICAgICAgICAgICBvdXRbaisrXSA9IF9fYnl0ZSA+Pj4gYml0cyAtIDggJiAyNTU7XG4gICAgICAgICAgICAgICAgYml0cyAtPSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQuc2xpY2UoMCwgaik7XG4gICAgfVxufVxuY2xhc3MgTktleXNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBuYW1lO1xuICAgIGNvZGU7XG4gICAgY2hhaW5lZEVycm9yO1xuICAgIGNvbnN0cnVjdG9yKGNvZGUsIGNoYWluZWRFcnJvcil7XG4gICAgICAgIHN1cGVyKGNvZGUpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIk5LZXlzRXJyb3JcIjtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5jaGFpbmVkRXJyb3IgPSBjaGFpbmVkRXJyb3I7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlT3BlcmF0b3IoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVBhaXIoUHJlZml4Lk9wZXJhdG9yKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFjY291bnQoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVBhaXIoUHJlZml4LkFjY291bnQpO1xufVxuZnVuY3Rpb24gY3JlYXRlVXNlcigpIHtcbiAgICByZXR1cm4gY3JlYXRlUGFpcihQcmVmaXguVXNlcik7XG59XG52YXIgTktleXNFcnJvckNvZGU7XG4oZnVuY3Rpb24oTktleXNFcnJvckNvZGUpIHtcbiAgICBOS2V5c0Vycm9yQ29kZVtcIkludmFsaWRQcmVmaXhCeXRlXCJdID0gXCJua2V5czogaW52YWxpZCBwcmVmaXggYnl0ZVwiO1xuICAgIE5LZXlzRXJyb3JDb2RlW1wiSW52YWxpZEtleVwiXSA9IFwibmtleXM6IGludmFsaWQga2V5XCI7XG4gICAgTktleXNFcnJvckNvZGVbXCJJbnZhbGlkUHVibGljS2V5XCJdID0gXCJua2V5czogaW52YWxpZCBwdWJsaWMga2V5XCI7XG4gICAgTktleXNFcnJvckNvZGVbXCJJbnZhbGlkU2VlZExlblwiXSA9IFwibmtleXM6IGludmFsaWQgc2VlZCBsZW5ndGhcIjtcbiAgICBOS2V5c0Vycm9yQ29kZVtcIkludmFsaWRTZWVkXCJdID0gXCJua2V5czogaW52YWxpZCBzZWVkXCI7XG4gICAgTktleXNFcnJvckNvZGVbXCJJbnZhbGlkRW5jb2RpbmdcIl0gPSBcIm5rZXlzOiBpbnZhbGlkIGVuY29kZWQga2V5XCI7XG4gICAgTktleXNFcnJvckNvZGVbXCJJbnZhbGlkU2lnbmF0dXJlXCJdID0gXCJua2V5czogc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmYWlsZWRcIjtcbiAgICBOS2V5c0Vycm9yQ29kZVtcIkNhbm5vdFNpZ25cIl0gPSBcIm5rZXlzOiBjYW5ub3Qgc2lnbiwgbm8gcHJpdmF0ZSBrZXkgYXZhaWxhYmxlXCI7XG4gICAgTktleXNFcnJvckNvZGVbXCJQdWJsaWNLZXlPbmx5XCJdID0gXCJua2V5czogbm8gc2VlZCBvciBwcml2YXRlIGtleSBhdmFpbGFibGVcIjtcbiAgICBOS2V5c0Vycm9yQ29kZVtcIkludmFsaWRDaGVja3N1bVwiXSA9IFwibmtleXM6IGludmFsaWQgY2hlY2tzdW1cIjtcbiAgICBOS2V5c0Vycm9yQ29kZVtcIlNlcmlhbGl6YXRpb25FcnJvclwiXSA9IFwibmtleXM6IHNlcmlhbGl6YXRpb24gZXJyb3JcIjtcbiAgICBOS2V5c0Vycm9yQ29kZVtcIkFwaUVycm9yXCJdID0gXCJua2V5czogYXBpIGVycm9yXCI7XG4gICAgTktleXNFcnJvckNvZGVbXCJDbGVhcmVkUGFpclwiXSA9IFwibmtleXM6IHBhaXIgaXMgY2xlYXJlZFwiO1xufSkoTktleXNFcnJvckNvZGUgfHwgKE5LZXlzRXJyb3JDb2RlID0ge30pKTtcbnZhciBQcmVmaXg7XG4oZnVuY3Rpb24oUHJlZml4KSB7XG4gICAgUHJlZml4W1ByZWZpeFtcIlNlZWRcIl0gPSAxNDRdID0gXCJTZWVkXCI7XG4gICAgUHJlZml4W1ByZWZpeFtcIlByaXZhdGVcIl0gPSAxMjBdID0gXCJQcml2YXRlXCI7XG4gICAgUHJlZml4W1ByZWZpeFtcIk9wZXJhdG9yXCJdID0gMTEyXSA9IFwiT3BlcmF0b3JcIjtcbiAgICBQcmVmaXhbUHJlZml4W1wiU2VydmVyXCJdID0gMTA0XSA9IFwiU2VydmVyXCI7XG4gICAgUHJlZml4W1ByZWZpeFtcIkNsdXN0ZXJcIl0gPSAxNl0gPSBcIkNsdXN0ZXJcIjtcbiAgICBQcmVmaXhbUHJlZml4W1wiQWNjb3VudFwiXSA9IDBdID0gXCJBY2NvdW50XCI7XG4gICAgUHJlZml4W1ByZWZpeFtcIlVzZXJcIl0gPSAxNjBdID0gXCJVc2VyXCI7XG59KShQcmVmaXggfHwgKFByZWZpeCA9IHt9KSk7XG5jbGFzcyBQcmVmaXhlcyB7XG4gICAgc3RhdGljIGlzVmFsaWRQdWJsaWNQcmVmaXgocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBwcmVmaXggPT0gUHJlZml4LlNlcnZlciB8fCBwcmVmaXggPT0gUHJlZml4Lk9wZXJhdG9yIHx8IHByZWZpeCA9PSBQcmVmaXguQ2x1c3RlciB8fCBwcmVmaXggPT0gUHJlZml4LkFjY291bnQgfHwgcHJlZml4ID09IFByZWZpeC5Vc2VyO1xuICAgIH1cbiAgICBzdGF0aWMgc3RhcnRzV2l0aFZhbGlkUHJlZml4KHMpIHtcbiAgICAgICAgbGV0IGMgPSBzWzBdO1xuICAgICAgICByZXR1cm4gYyA9PSBcIlNcIiB8fCBjID09IFwiUFwiIHx8IGMgPT0gXCJPXCIgfHwgYyA9PSBcIk5cIiB8fCBjID09IFwiQ1wiIHx8IGMgPT0gXCJBXCIgfHwgYyA9PSBcIlVcIjtcbiAgICB9XG4gICAgc3RhdGljIGlzVmFsaWRQcmVmaXgocHJlZml4KSB7XG4gICAgICAgIGxldCB2ID0gdGhpcy5wYXJzZVByZWZpeChwcmVmaXgpO1xuICAgICAgICByZXR1cm4gdiAhPSAtMTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlUHJlZml4KHYpIHtcbiAgICAgICAgc3dpdGNoKHYpe1xuICAgICAgICAgICAgY2FzZSBQcmVmaXguU2VlZDpcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJlZml4LlNlZWQ7XG4gICAgICAgICAgICBjYXNlIFByZWZpeC5Qcml2YXRlOlxuICAgICAgICAgICAgICAgIHJldHVybiBQcmVmaXguUHJpdmF0ZTtcbiAgICAgICAgICAgIGNhc2UgUHJlZml4Lk9wZXJhdG9yOlxuICAgICAgICAgICAgICAgIHJldHVybiBQcmVmaXguT3BlcmF0b3I7XG4gICAgICAgICAgICBjYXNlIFByZWZpeC5TZXJ2ZXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByZWZpeC5TZXJ2ZXI7XG4gICAgICAgICAgICBjYXNlIFByZWZpeC5DbHVzdGVyOlxuICAgICAgICAgICAgICAgIHJldHVybiBQcmVmaXguQ2x1c3RlcjtcbiAgICAgICAgICAgIGNhc2UgUHJlZml4LkFjY291bnQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByZWZpeC5BY2NvdW50O1xuICAgICAgICAgICAgY2FzZSBQcmVmaXguVXNlcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJlZml4LlVzZXI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIENvZGVjIHtcbiAgICBzdGF0aWMgZW5jb2RlKHByZWZpeCwgc3JjKSB7XG4gICAgICAgIGlmICghc3JjIHx8ICEoc3JjIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLlNlcmlhbGl6YXRpb25FcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFQcmVmaXhlcy5pc1ZhbGlkUHJlZml4KHByZWZpeCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkludmFsaWRQcmVmaXhCeXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ29kZWMuX2VuY29kZShmYWxzZSwgcHJlZml4LCBzcmMpO1xuICAgIH1cbiAgICBzdGF0aWMgZW5jb2RlU2VlZChyb2xlLCBzcmMpIHtcbiAgICAgICAgaWYgKCFzcmMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkFwaUVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIVByZWZpeGVzLmlzVmFsaWRQdWJsaWNQcmVmaXgocm9sZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkludmFsaWRQcmVmaXhCeXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3JjLmJ5dGVMZW5ndGggIT09IDMyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTktleXNFcnJvcihOS2V5c0Vycm9yQ29kZS5JbnZhbGlkU2VlZExlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENvZGVjLl9lbmNvZGUodHJ1ZSwgcm9sZSwgc3JjKTtcbiAgICB9XG4gICAgc3RhdGljIGRlY29kZShleHBlY3RlZCwgc3JjKSB7XG4gICAgICAgIGlmICghUHJlZml4ZXMuaXNWYWxpZFByZWZpeChleHBlY3RlZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkludmFsaWRQcmVmaXhCeXRlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYXcgPSBDb2RlYy5fZGVjb2RlKHNyYyk7XG4gICAgICAgIGlmIChyYXdbMF0gIT09IGV4cGVjdGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTktleXNFcnJvcihOS2V5c0Vycm9yQ29kZS5JbnZhbGlkUHJlZml4Qnl0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhdy5zbGljZSgxKTtcbiAgICB9XG4gICAgc3RhdGljIGRlY29kZVNlZWQoc3JjKSB7XG4gICAgICAgIGNvbnN0IHJhdyA9IENvZGVjLl9kZWNvZGUoc3JjKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gQ29kZWMuX2RlY29kZVByZWZpeChyYXcpO1xuICAgICAgICBpZiAocHJlZml4WzBdICE9IFByZWZpeC5TZWVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTktleXNFcnJvcihOS2V5c0Vycm9yQ29kZS5JbnZhbGlkU2VlZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFQcmVmaXhlcy5pc1ZhbGlkUHVibGljUHJlZml4KHByZWZpeFsxXSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkludmFsaWRQcmVmaXhCeXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYnVmOiByYXcuc2xpY2UoMiksXG4gICAgICAgICAgICBwcmVmaXg6IHByZWZpeFsxXVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgX2VuY29kZShzZWVkLCByb2xlLCBwYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0IHBheWxvYWRPZmZzZXQgPSBzZWVkID8gMiA6IDE7XG4gICAgICAgIGNvbnN0IHBheWxvYWRMZW4gPSBwYXlsb2FkLmJ5dGVMZW5ndGg7XG4gICAgICAgIGNvbnN0IGNhcCA9IHBheWxvYWRPZmZzZXQgKyBwYXlsb2FkTGVuICsgMjtcbiAgICAgICAgY29uc3QgY2hlY2tPZmZzZXQgPSBwYXlsb2FkT2Zmc2V0ICsgcGF5bG9hZExlbjtcbiAgICAgICAgY29uc3QgcmF3ID0gbmV3IFVpbnQ4QXJyYXkoY2FwKTtcbiAgICAgICAgaWYgKHNlZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWRQcmVmaXggPSBDb2RlYy5fZW5jb2RlUHJlZml4KFByZWZpeC5TZWVkLCByb2xlKTtcbiAgICAgICAgICAgIHJhdy5zZXQoZW5jb2RlZFByZWZpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByYXdbMF0gPSByb2xlO1xuICAgICAgICB9XG4gICAgICAgIHJhdy5zZXQocGF5bG9hZCwgcGF5bG9hZE9mZnNldCk7XG4gICAgICAgIGNvbnN0IGNoZWNrc3VtID0gY3JjMTYuY2hlY2tzdW0ocmF3LnNsaWNlKDAsIGNoZWNrT2Zmc2V0KSk7XG4gICAgICAgIGNvbnN0IGR2ID0gbmV3IERhdGFWaWV3KHJhdy5idWZmZXIpO1xuICAgICAgICBkdi5zZXRVaW50MTYoY2hlY2tPZmZzZXQsIGNoZWNrc3VtLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGJhc2UzMi5lbmNvZGUocmF3KTtcbiAgICB9XG4gICAgc3RhdGljIF9kZWNvZGUoc3JjKSB7XG4gICAgICAgIGlmIChzcmMuYnl0ZUxlbmd0aCA8IDQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkludmFsaWRFbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJhdztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJhdyA9IGJhc2UzMi5kZWNvZGUoc3JjKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkludmFsaWRFbmNvZGluZywgZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoZWNrT2Zmc2V0ID0gcmF3LmJ5dGVMZW5ndGggLSAyO1xuICAgICAgICBjb25zdCBkdiA9IG5ldyBEYXRhVmlldyhyYXcuYnVmZmVyKTtcbiAgICAgICAgY29uc3QgY2hlY2tzdW0gPSBkdi5nZXRVaW50MTYoY2hlY2tPZmZzZXQsIHRydWUpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gcmF3LnNsaWNlKDAsIGNoZWNrT2Zmc2V0KTtcbiAgICAgICAgaWYgKCFjcmMxNi52YWxpZGF0ZShwYXlsb2FkLCBjaGVja3N1bSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkludmFsaWRDaGVja3N1bSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfVxuICAgIHN0YXRpYyBfZW5jb2RlUHJlZml4KGtpbmQsIHJvbGUpIHtcbiAgICAgICAgY29uc3QgYjEgPSBraW5kIHwgcm9sZSA+PiA1O1xuICAgICAgICBjb25zdCBiMiA9IChyb2xlICYgMzEpIDw8IDM7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICBiMSxcbiAgICAgICAgICAgIGIyXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBzdGF0aWMgX2RlY29kZVByZWZpeChyYXcpIHtcbiAgICAgICAgY29uc3QgYjEgPSByYXdbMF0gJiAyNDg7XG4gICAgICAgIGNvbnN0IGIyID0gKHJhd1swXSAmIDcpIDw8IDUgfCAocmF3WzFdICYgMjQ4KSA+PiAzO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgYjEsXG4gICAgICAgICAgICBiMlxuICAgICAgICBdKTtcbiAgICB9XG59XG5jbGFzcyBLUCB7XG4gICAgc2VlZDtcbiAgICBjb25zdHJ1Y3RvcihzZWVkKXtcbiAgICAgICAgdGhpcy5zZWVkID0gc2VlZDtcbiAgICB9XG4gICAgZ2V0UmF3U2VlZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkNsZWFyZWRQYWlyKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2QgPSBDb2RlYy5kZWNvZGVTZWVkKHRoaXMuc2VlZCk7XG4gICAgICAgIHJldHVybiBzZC5idWY7XG4gICAgfVxuICAgIGdldFNlZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5zZWVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTktleXNFcnJvcihOS2V5c0Vycm9yQ29kZS5DbGVhcmVkUGFpcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2VlZDtcbiAgICB9XG4gICAgZ2V0UHVibGljS2V5KCkge1xuICAgICAgICBpZiAoIXRoaXMuc2VlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5LZXlzRXJyb3IoTktleXNFcnJvckNvZGUuQ2xlYXJlZFBhaXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNkID0gQ29kZWMuZGVjb2RlU2VlZCh0aGlzLnNlZWQpO1xuICAgICAgICBjb25zdCBrcCA9IGdldEVkMjU1MTlIZWxwZXIoKS5mcm9tU2VlZCh0aGlzLmdldFJhd1NlZWQoKSk7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IENvZGVjLmVuY29kZShzZC5wcmVmaXgsIGtwLnB1YmxpY0tleSk7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnVmKTtcbiAgICB9XG4gICAgZ2V0UHJpdmF0ZUtleSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkNsZWFyZWRQYWlyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrcCA9IGdldEVkMjU1MTlIZWxwZXIoKS5mcm9tU2VlZCh0aGlzLmdldFJhd1NlZWQoKSk7XG4gICAgICAgIHJldHVybiBDb2RlYy5lbmNvZGUoUHJlZml4LlByaXZhdGUsIGtwLnNlY3JldEtleSk7XG4gICAgfVxuICAgIHNpZ24oaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkNsZWFyZWRQYWlyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrcCA9IGdldEVkMjU1MTlIZWxwZXIoKS5mcm9tU2VlZCh0aGlzLmdldFJhd1NlZWQoKSk7XG4gICAgICAgIHJldHVybiBnZXRFZDI1NTE5SGVscGVyKCkuc2lnbihpbnB1dCwga3Auc2VjcmV0S2V5KTtcbiAgICB9XG4gICAgdmVyaWZ5KGlucHV0LCBzaWcpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkNsZWFyZWRQYWlyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrcCA9IGdldEVkMjU1MTlIZWxwZXIoKS5mcm9tU2VlZCh0aGlzLmdldFJhd1NlZWQoKSk7XG4gICAgICAgIHJldHVybiBnZXRFZDI1NTE5SGVscGVyKCkudmVyaWZ5KGlucHV0LCBzaWcsIGtwLnB1YmxpY0tleSk7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2VlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VlZC5maWxsKDApO1xuICAgICAgICB0aGlzLnNlZWQgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUGFpcihwcmVmaXgpIHtcbiAgICBjb25zdCByYXdTZWVkID0gZ2V0RWQyNTUxOUhlbHBlcigpLnJhbmRvbUJ5dGVzKDMyKTtcbiAgICBsZXQgc3RyID0gQ29kZWMuZW5jb2RlU2VlZChwcmVmaXgsIG5ldyBVaW50OEFycmF5KHJhd1NlZWQpKTtcbiAgICByZXR1cm4gbmV3IEtQKHN0cik7XG59XG5jbGFzcyBQdWJsaWNLZXkge1xuICAgIHB1YmxpY0tleTtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWNLZXkpe1xuICAgICAgICB0aGlzLnB1YmxpY0tleSA9IHB1YmxpY0tleTtcbiAgICB9XG4gICAgZ2V0UHVibGljS2V5KCkge1xuICAgICAgICBpZiAoIXRoaXMucHVibGljS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTktleXNFcnJvcihOS2V5c0Vycm9yQ29kZS5DbGVhcmVkUGFpcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZSh0aGlzLnB1YmxpY0tleSk7XG4gICAgfVxuICAgIGdldFByaXZhdGVLZXkoKSB7XG4gICAgICAgIGlmICghdGhpcy5wdWJsaWNLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkNsZWFyZWRQYWlyKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgTktleXNFcnJvcihOS2V5c0Vycm9yQ29kZS5QdWJsaWNLZXlPbmx5KTtcbiAgICB9XG4gICAgZ2V0U2VlZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnB1YmxpY0tleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5LZXlzRXJyb3IoTktleXNFcnJvckNvZGUuQ2xlYXJlZFBhaXIpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLlB1YmxpY0tleU9ubHkpO1xuICAgIH1cbiAgICBzaWduKF8pIHtcbiAgICAgICAgaWYgKCF0aGlzLnB1YmxpY0tleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5LZXlzRXJyb3IoTktleXNFcnJvckNvZGUuQ2xlYXJlZFBhaXIpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkNhbm5vdFNpZ24pO1xuICAgIH1cbiAgICB2ZXJpZnkoaW5wdXQsIHNpZykge1xuICAgICAgICBpZiAoIXRoaXMucHVibGljS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTktleXNFcnJvcihOS2V5c0Vycm9yQ29kZS5DbGVhcmVkUGFpcik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJ1ZiA9IENvZGVjLl9kZWNvZGUodGhpcy5wdWJsaWNLZXkpO1xuICAgICAgICByZXR1cm4gZ2V0RWQyNTUxOUhlbHBlcigpLnZlcmlmeShpbnB1dCwgc2lnLCBidWYuc2xpY2UoMSkpO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnB1YmxpY0tleSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHVibGljS2V5LmZpbGwoMCk7XG4gICAgICAgIHRoaXMucHVibGljS2V5ID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZyb21QdWJsaWMoc3JjKSB7XG4gICAgY29uc3QgYmEgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3JjKTtcbiAgICBjb25zdCByYXcgPSBDb2RlYy5fZGVjb2RlKGJhKTtcbiAgICBjb25zdCBwcmVmaXggPSBQcmVmaXhlcy5wYXJzZVByZWZpeChyYXdbMF0pO1xuICAgIGlmIChQcmVmaXhlcy5pc1ZhbGlkUHVibGljUHJlZml4KHByZWZpeCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkoYmEpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgTktleXNFcnJvcihOS2V5c0Vycm9yQ29kZS5JbnZhbGlkUHVibGljS2V5KTtcbn1cbmZ1bmN0aW9uIGZyb21TZWVkKHNyYykge1xuICAgIENvZGVjLmRlY29kZVNlZWQoc3JjKTtcbiAgICByZXR1cm4gbmV3IEtQKHNyYyk7XG59XG5mdW5jdGlvbiBlbmNvZGUxKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZSguLi5ieXRlcykpO1xufVxuZnVuY3Rpb24gZGVjb2RlMShiNjRzdHIpIHtcbiAgICBjb25zdCBiaW4gPSBhdG9iKGI2NHN0cik7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShiaW4ubGVuZ3RoKTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgYmluLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgYnl0ZXNbaV0gPSBiaW4uY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuc2V0RWQyNTUxOUhlbHBlcihkZW5vSGVscGVyKTtcbmNvbnN0IG1vZCA9IHtcbiAgICBjcmVhdGVBY2NvdW50LFxuICAgIGNyZWF0ZU9wZXJhdG9yLFxuICAgIGNyZWF0ZVBhaXIsXG4gICAgY3JlYXRlVXNlcixcbiAgICBmcm9tUHVibGljLFxuICAgIGZyb21TZWVkLFxuICAgIE5LZXlzRXJyb3IsXG4gICAgTktleXNFcnJvckNvZGUsXG4gICAgUHJlZml4LFxuICAgIGRlY29kZTogZGVjb2RlMSxcbiAgICBlbmNvZGU6IGVuY29kZTFcbn07XG5mdW5jdGlvbiBtdWx0aUF1dGhlbnRpY2F0b3IoYXV0aGVudGljYXRvcnMpIHtcbiAgICByZXR1cm4gKG5vbmNlKT0+e1xuICAgICAgICBsZXQgYXV0aCA9IHt9O1xuICAgICAgICBhdXRoZW50aWNhdG9ycy5mb3JFYWNoKChhKT0+e1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IGEobm9uY2UpIHx8IHt9O1xuICAgICAgICAgICAgYXV0aCA9IE9iamVjdC5hc3NpZ24oYXV0aCwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXV0aDtcbiAgICB9O1xufVxuZnVuY3Rpb24gbm9BdXRoRm4oKSB7XG4gICAgcmV0dXJuICgpPT57XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xufVxuZnVuY3Rpb24gdXNlcm5hbWVQYXNzd29yZEF1dGhlbnRpY2F0b3IodXNlciwgcGFzcykge1xuICAgIHJldHVybiAoKT0+e1xuICAgICAgICBjb25zdCB1ID0gdHlwZW9mIHVzZXIgPT09IFwiZnVuY3Rpb25cIiA/IHVzZXIoKSA6IHVzZXI7XG4gICAgICAgIGNvbnN0IHAgPSB0eXBlb2YgcGFzcyA9PT0gXCJmdW5jdGlvblwiID8gcGFzcygpIDogcGFzcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZXI6IHUsXG4gICAgICAgICAgICBwYXNzOiBwXG4gICAgICAgIH07XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRva2VuQXV0aGVudGljYXRvcih0b2tlbikge1xuICAgIHJldHVybiAoKT0+e1xuICAgICAgICBjb25zdCBhdXRoX3Rva2VuID0gdHlwZW9mIHRva2VuID09PSBcImZ1bmN0aW9uXCIgPyB0b2tlbigpIDogdG9rZW47XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhdXRoX3Rva2VuXG4gICAgICAgIH07XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG5rZXlBdXRoZW50aWNhdG9yKHNlZWQpIHtcbiAgICByZXR1cm4gKG5vbmNlKT0+e1xuICAgICAgICBjb25zdCBzID0gdHlwZW9mIHNlZWQgPT09IFwiZnVuY3Rpb25cIiA/IHNlZWQoKSA6IHNlZWQ7XG4gICAgICAgIGNvbnN0IGtwID0gcyA/IG1vZC5mcm9tU2VlZChzKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgbmtleSA9IGtwID8ga3AuZ2V0UHVibGljS2V5KCkgOiBcIlwiO1xuICAgICAgICBjb25zdCBjaGFsbGVuZ2UgPSBURS5lbmNvZGUobm9uY2UgfHwgXCJcIik7XG4gICAgICAgIGNvbnN0IHNpZ0J5dGVzID0ga3AgIT09IHVuZGVmaW5lZCAmJiBub25jZSA/IGtwLnNpZ24oY2hhbGxlbmdlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc2lnID0gc2lnQnl0ZXMgPyBtb2QuZW5jb2RlKHNpZ0J5dGVzKSA6IFwiXCI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBua2V5LFxuICAgICAgICAgICAgc2lnXG4gICAgICAgIH07XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGp3dEF1dGhlbnRpY2F0b3IoYWp3dCwgc2VlZCkge1xuICAgIHJldHVybiAobm9uY2UpPT57XG4gICAgICAgIGNvbnN0IGp3dCA9IHR5cGVvZiBhand0ID09PSBcImZ1bmN0aW9uXCIgPyBhand0KCkgOiBhand0O1xuICAgICAgICBjb25zdCBmbiA9IG5rZXlBdXRoZW50aWNhdG9yKHNlZWQpO1xuICAgICAgICBjb25zdCB7IG5rZXksIHNpZyB9ID0gZm4obm9uY2UpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgand0LFxuICAgICAgICAgICAgbmtleSxcbiAgICAgICAgICAgIHNpZ1xuICAgICAgICB9O1xuICAgIH07XG59XG5mdW5jdGlvbiBjcmVkc0F1dGhlbnRpY2F0b3IoY3JlZHMpIHtcbiAgICBjb25zdCBmbiA9IHR5cGVvZiBjcmVkcyAhPT0gXCJmdW5jdGlvblwiID8gKCk9PmNyZWRzIDogY3JlZHM7XG4gICAgY29uc3QgcGFyc2UgPSAoKT0+e1xuICAgICAgICBjb25zdCBDUkVEUyA9IC9cXHMqKD86KD86Wy1dezMsfVteXFxuXSpbLV17Myx9XFxuKSguKykoPzpcXG5cXHMqWy1dezMsfVteXFxuXSpbLV17Myx9XFxuKSkvaWc7XG4gICAgICAgIGNvbnN0IHMgPSBURC5kZWNvZGUoZm4oKSk7XG4gICAgICAgIGxldCBtID0gQ1JFRFMuZXhlYyhzKTtcbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICB0aHJvdyBOYXRzRXJyb3IuZXJyb3JGb3JDb2RlKEVycm9yQ29kZS5CYWRDcmVkcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgand0ID0gbVsxXS50cmltKCk7XG4gICAgICAgIG0gPSBDUkVEUy5leGVjKHMpO1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHRocm93IE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLkJhZENyZWRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHRocm93IE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLkJhZENyZWRzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWVkID0gVEUuZW5jb2RlKG1bMV0udHJpbSgpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGp3dCxcbiAgICAgICAgICAgIHNlZWRcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGp3dEZuID0gKCk9PntcbiAgICAgICAgY29uc3QgeyBqd3QgfSA9IHBhcnNlKCk7XG4gICAgICAgIHJldHVybiBqd3Q7XG4gICAgfTtcbiAgICBjb25zdCBua2V5Rm4gPSAoKT0+e1xuICAgICAgICBjb25zdCB7IHNlZWQgfSA9IHBhcnNlKCk7XG4gICAgICAgIHJldHVybiBzZWVkO1xuICAgIH07XG4gICAgcmV0dXJuIGp3dEF1dGhlbnRpY2F0b3Ioand0Rm4sIG5rZXlGbik7XG59XG5jb25zdCBERUZBVUxUX1BJTkdfSU5URVJWQUwgPSAyICogNjAgKiAxMDAwO1xuY29uc3QgREVGQVVMVF9NQVhfUElOR19PVVQgPSAyO1xuY29uc3QgREVGQVVMVF9SRUNPTk5FQ1RfVElNRV9XQUlUID0gMiAqIDEwMDA7XG5mdW5jdGlvbiBkZWZhdWx0T3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBtYXhQaW5nT3V0OiAyLFxuICAgICAgICBtYXhSZWNvbm5lY3RBdHRlbXB0czogMTAsXG4gICAgICAgIG5vUmFuZG9taXplOiBmYWxzZSxcbiAgICAgICAgcGVkYW50aWM6IGZhbHNlLFxuICAgICAgICBwaW5nSW50ZXJ2YWw6IERFRkFVTFRfUElOR19JTlRFUlZBTCxcbiAgICAgICAgcmVjb25uZWN0OiB0cnVlLFxuICAgICAgICByZWNvbm5lY3RKaXR0ZXI6IDEwMCxcbiAgICAgICAgcmVjb25uZWN0Sml0dGVyVExTOiAxMDAwLFxuICAgICAgICByZWNvbm5lY3RUaW1lV2FpdDogREVGQVVMVF9SRUNPTk5FQ1RfVElNRV9XQUlULFxuICAgICAgICB0bHM6IHVuZGVmaW5lZCxcbiAgICAgICAgdmVyYm9zZTogZmFsc2UsXG4gICAgICAgIHdhaXRPbkZpcnN0Q29ubmVjdDogZmFsc2UsXG4gICAgICAgIGlnbm9yZUF1dGhFcnJvckFib3J0OiBmYWxzZVxuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZEF1dGhlbnRpY2F0b3Iob3B0cykge1xuICAgIGNvbnN0IGJ1ZiA9IFtdO1xuICAgIGlmICh0eXBlb2Ygb3B0cy5hdXRoZW50aWNhdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgYnVmLnB1c2gob3B0cy5hdXRoZW50aWNhdG9yKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0cy5hdXRoZW50aWNhdG9yKSkge1xuICAgICAgICBidWYucHVzaCguLi5vcHRzLmF1dGhlbnRpY2F0b3IpO1xuICAgIH1cbiAgICBpZiAob3B0cy50b2tlbikge1xuICAgICAgICBidWYucHVzaCh0b2tlbkF1dGhlbnRpY2F0b3Iob3B0cy50b2tlbikpO1xuICAgIH1cbiAgICBpZiAob3B0cy51c2VyKSB7XG4gICAgICAgIGJ1Zi5wdXNoKHVzZXJuYW1lUGFzc3dvcmRBdXRoZW50aWNhdG9yKG9wdHMudXNlciwgb3B0cy5wYXNzKSk7XG4gICAgfVxuICAgIHJldHVybiBidWYubGVuZ3RoID09PSAwID8gbm9BdXRoRm4oKSA6IG11bHRpQXV0aGVudGljYXRvcihidWYpO1xufVxuZnVuY3Rpb24gcGFyc2VPcHRpb25zKG9wdHMpIHtcbiAgICBjb25zdCBkaHAgPSBgJHtERUZBVUxUX0hPU1R9OiR7ZGVmYXVsdFBvcnQoKX1gO1xuICAgIG9wdHMgPSBvcHRzIHx8IHtcbiAgICAgICAgc2VydmVyczogW1xuICAgICAgICAgICAgZGhwXG4gICAgICAgIF1cbiAgICB9O1xuICAgIG9wdHMuc2VydmVycyA9IG9wdHMuc2VydmVycyB8fCBbXTtcbiAgICBpZiAodHlwZW9mIG9wdHMuc2VydmVycyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBvcHRzLnNlcnZlcnMgPSBbXG4gICAgICAgICAgICBvcHRzLnNlcnZlcnNcbiAgICAgICAgXTtcbiAgICB9XG4gICAgaWYgKG9wdHMuc2VydmVycy5sZW5ndGggPiAwICYmIG9wdHMucG9ydCkge1xuICAgICAgICB0aHJvdyBuZXcgTmF0c0Vycm9yKFwicG9ydCBhbmQgc2VydmVycyBvcHRpb25zIGFyZSBtdXR1YWxseSBleGNsdXNpdmVcIiwgRXJyb3JDb2RlLkludmFsaWRPcHRpb24pO1xuICAgIH1cbiAgICBpZiAob3B0cy5zZXJ2ZXJzLmxlbmd0aCA9PT0gMCAmJiBvcHRzLnBvcnQpIHtcbiAgICAgICAgb3B0cy5zZXJ2ZXJzID0gW1xuICAgICAgICAgICAgYCR7REVGQVVMVF9IT1NUfToke29wdHMucG9ydH1gXG4gICAgICAgIF07XG4gICAgfVxuICAgIGlmIChvcHRzLnNlcnZlcnMgJiYgb3B0cy5zZXJ2ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBvcHRzLnNlcnZlcnMgPSBbXG4gICAgICAgICAgICBkaHBcbiAgICAgICAgXTtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IGV4dGVuZChkZWZhdWx0T3B0aW9ucygpLCBvcHRzKTtcbiAgICBvcHRpb25zLmF1dGhlbnRpY2F0b3IgPSBidWlsZEF1dGhlbnRpY2F0b3Iob3B0aW9ucyk7XG4gICAgW1xuICAgICAgICBcInJlY29ubmVjdERlbGF5SGFuZGxlclwiLFxuICAgICAgICBcImF1dGhlbnRpY2F0b3JcIlxuICAgIF0uZm9yRWFjaCgobik9PntcbiAgICAgICAgaWYgKG9wdGlvbnNbbl0gJiYgdHlwZW9mIG9wdGlvbnNbbl0gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5hdHNFcnJvcihgJHtufSBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb25gLCBFcnJvckNvZGUuTm90RnVuY3Rpb24pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFvcHRpb25zLnJlY29ubmVjdERlbGF5SGFuZGxlcikge1xuICAgICAgICBvcHRpb25zLnJlY29ubmVjdERlbGF5SGFuZGxlciA9ICgpPT57XG4gICAgICAgICAgICBsZXQgZXh0cmEgPSBvcHRpb25zLnRscyA/IG9wdGlvbnMucmVjb25uZWN0Sml0dGVyVExTIDogb3B0aW9ucy5yZWNvbm5lY3RKaXR0ZXI7XG4gICAgICAgICAgICBpZiAoZXh0cmEpIHtcbiAgICAgICAgICAgICAgICBleHRyYSsrO1xuICAgICAgICAgICAgICAgIGV4dHJhID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogZXh0cmEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVjb25uZWN0VGltZVdhaXQgKyBleHRyYTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaW5ib3hQcmVmaXgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNyZWF0ZUluYm94KG9wdGlvbnMuaW5ib3hQcmVmaXgpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOYXRzRXJyb3IoZXJyLm1lc3NhZ2UsIEVycm9yQ29kZS5BcGlFcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucmVzb2x2ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMucmVzb2x2ZSA9IHR5cGVvZiBnZXRSZXNvbHZlRm4oKSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yZXNvbHZlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZ2V0UmVzb2x2ZUZuKCkgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5hdHNFcnJvcihgJ3Jlc29sdmUnIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBjbGllbnRgLCBFcnJvckNvZGUuSW52YWxpZE9wdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiBjaGVja09wdGlvbnMoaW5mbywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgcHJvdG8sIHRsc19yZXF1aXJlZDogdGxzUmVxdWlyZWQsIHRsc19hdmFpbGFibGU6IHRsc0F2YWlsYWJsZSB9ID0gaW5mbztcbiAgICBpZiAoKHByb3RvID09PSB1bmRlZmluZWQgfHwgcHJvdG8gPCAxKSAmJiBvcHRpb25zLm5vRWNobykge1xuICAgICAgICB0aHJvdyBuZXcgTmF0c0Vycm9yKFwibm9FY2hvXCIsIEVycm9yQ29kZS5TZXJ2ZXJPcHRpb25Ob3RBdmFpbGFibGUpO1xuICAgIH1cbiAgICBjb25zdCB0bHMgPSB0bHNSZXF1aXJlZCB8fCB0bHNBdmFpbGFibGUgfHwgZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMudGxzICYmICF0bHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IE5hdHNFcnJvcihcInRsc1wiLCBFcnJvckNvZGUuU2VydmVyT3B0aW9uTm90QXZhaWxhYmxlKTtcbiAgICB9XG59XG5jb25zdCBGTFVTSF9USFJFU0hPTEQgPSAxMDI0ICogMzI7XG5jb25zdCBJTkZPID0gL15JTkZPXFxzKyhbXlxcclxcbl0rKVxcclxcbi9pO1xuY29uc3QgUE9OR19DTUQgPSBlbmNvZGUoXCJQT05HXFxyXFxuXCIpO1xuY29uc3QgUElOR19DTUQgPSBlbmNvZGUoXCJQSU5HXFxyXFxuXCIpO1xuY2xhc3MgQ29ubmVjdCB7XG4gICAgZWNobztcbiAgICBub19yZXNwb25kZXJzO1xuICAgIHByb3RvY29sO1xuICAgIHZlcmJvc2U7XG4gICAgcGVkYW50aWM7XG4gICAgand0O1xuICAgIG5rZXk7XG4gICAgc2lnO1xuICAgIHVzZXI7XG4gICAgcGFzcztcbiAgICBhdXRoX3Rva2VuO1xuICAgIHRsc19yZXF1aXJlZDtcbiAgICBuYW1lO1xuICAgIGxhbmc7XG4gICAgdmVyc2lvbjtcbiAgICBoZWFkZXJzO1xuICAgIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCwgb3B0cywgbm9uY2Upe1xuICAgICAgICB0aGlzLnByb3RvY29sID0gMTtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdHJhbnNwb3J0LnZlcnNpb247XG4gICAgICAgIHRoaXMubGFuZyA9IHRyYW5zcG9ydC5sYW5nO1xuICAgICAgICB0aGlzLmVjaG8gPSBvcHRzLm5vRWNobyA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnZlcmJvc2UgPSBvcHRzLnZlcmJvc2U7XG4gICAgICAgIHRoaXMucGVkYW50aWMgPSBvcHRzLnBlZGFudGljO1xuICAgICAgICB0aGlzLnRsc19yZXF1aXJlZCA9IG9wdHMudGxzID8gdHJ1ZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5uYW1lID0gb3B0cy5uYW1lO1xuICAgICAgICBjb25zdCBjcmVkcyA9IChvcHRzICYmIHR5cGVvZiBvcHRzLmF1dGhlbnRpY2F0b3IgPT09IFwiZnVuY3Rpb25cIiA/IG9wdHMuYXV0aGVudGljYXRvcihub25jZSkgOiB7fSkgfHwge307XG4gICAgICAgIGV4dGVuZCh0aGlzLCBjcmVkcyk7XG4gICAgfVxufVxuY2xhc3MgU3Vic2NyaXB0aW9uSW1wbCBleHRlbmRzIFF1ZXVlZEl0ZXJhdG9ySW1wbCB7XG4gICAgc2lkO1xuICAgIHF1ZXVlO1xuICAgIGRyYWluaW5nO1xuICAgIG1heDtcbiAgICBzdWJqZWN0O1xuICAgIGRyYWluZWQ7XG4gICAgcHJvdG9jb2w7XG4gICAgdGltZXI7XG4gICAgaW5mbztcbiAgICBjbGVhbnVwRm47XG4gICAgY2xvc2VkO1xuICAgIHJlcXVlc3RTdWJqZWN0O1xuICAgIGNvbnN0cnVjdG9yKHByb3RvY29sLCBzdWJqZWN0LCBvcHRzID0ge30pe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBleHRlbmQodGhpcywgb3B0cyk7XG4gICAgICAgIHRoaXMucHJvdG9jb2wgPSBwcm90b2NvbDtcbiAgICAgICAgdGhpcy5zdWJqZWN0ID0gc3ViamVjdDtcbiAgICAgICAgdGhpcy5kcmFpbmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5vSXRlcmF0b3IgPSB0eXBlb2Ygb3B0cy5jYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGRlZmVycmVkKCk7XG4gICAgICAgIGNvbnN0IGFzeW5jVHJhY2VzID0gIShwcm90b2NvbC5vcHRpb25zPy5ub0FzeW5jVHJhY2VzIHx8IGZhbHNlKTtcbiAgICAgICAgaWYgKG9wdHMudGltZW91dCkge1xuICAgICAgICAgICAgdGhpcy50aW1lciA9IHRpbWVvdXQob3B0cy50aW1lb3V0LCBhc3luY1RyYWNlcyk7XG4gICAgICAgICAgICB0aGlzLnRpbWVyLnRoZW4oKCk9PntcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3AoZXJyKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ub0l0ZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2soZXJyLCB7fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm5vSXRlcmF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuaXRlckNsb3NlZC50aGVuKCgpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFByZVBvc3RIYW5kbGVycyhvcHRzKSB7XG4gICAgICAgIGlmICh0aGlzLm5vSXRlcmF0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHVjID0gdGhpcy5jYWxsYmFjaztcbiAgICAgICAgICAgIGNvbnN0IGluZ2VzdGlvbiA9IG9wdHMuaW5nZXN0aW9uRmlsdGVyRm4gPyBvcHRzLmluZ2VzdGlvbkZpbHRlckZuIDogKCk9PntcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpbmdlc3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29sOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyID0gb3B0cy5wcm90b2NvbEZpbHRlckZuID8gb3B0cy5wcm90b2NvbEZpbHRlckZuIDogKCk9PntcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBkaXNwYXRjaGVkID0gb3B0cy5kaXNwYXRjaGVkRm4gPyBvcHRzLmRpc3BhdGNoZWRGbiA6ICgpPT57fTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sgPSAoZXJyLCBtc2cpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpbmdlc3QgfSA9IGluZ2VzdGlvbihtc2cpO1xuICAgICAgICAgICAgICAgIGlmICghaW5nZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlcihtc2cpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVjKGVyciwgbXNnKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hlZChtc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnByb3RvY29sRmlsdGVyRm4gPSBvcHRzLnByb3RvY29sRmlsdGVyRm47XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoZWRGbiA9IG9wdHMuZGlzcGF0Y2hlZEZuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbGxiYWNrKGVyciwgbXNnKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsVGltZW91dCgpO1xuICAgICAgICBlcnIgPyB0aGlzLnN0b3AoZXJyKSA6IHRoaXMucHVzaChtc2cpO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsVGltZW91dCgpO1xuICAgICAgICAgICAgY29uc3QgZm4gPSAoKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNsZWFudXBGbikge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhbnVwRm4odGhpcywgdGhpcy5pbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoX2Vycikge31cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLm5vSXRlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2goZm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlKG1heCkge1xuICAgICAgICB0aGlzLnByb3RvY29sLnVuc3Vic2NyaWJlKHRoaXMsIG1heCk7XG4gICAgfVxuICAgIGNhbmNlbFRpbWVvdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgdGhpcy50aW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkcmFpbigpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvdG9jb2wuaXNDbG9zZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLkNvbm5lY3Rpb25DbG9zZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0Nsb3NlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoTmF0c0Vycm9yLmVycm9yRm9yQ29kZShFcnJvckNvZGUuU3ViQ2xvc2VkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmRyYWluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhaW5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5wcm90b2NvbC51bnN1Yih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZHJhaW5lZCA9IHRoaXMucHJvdG9jb2wuZmx1c2goZGVmZXJyZWQoKSkudGhlbigoKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdG9jb2wuc3Vic2NyaXB0aW9ucy5jYW5jZWwodGhpcyk7XG4gICAgICAgICAgICB9KS5jYXRjaCgoKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdG9jb2wuc3Vic2NyaXB0aW9ucy5jYW5jZWwodGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kcmFpbmVkO1xuICAgIH1cbiAgICBpc0RyYWluaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmFpbmluZztcbiAgICB9XG4gICAgaXNDbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvbmU7XG4gICAgfVxuICAgIGdldFN1YmplY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YmplY3Q7XG4gICAgfVxuICAgIGdldE1heCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4O1xuICAgIH1cbiAgICBnZXRJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lkO1xuICAgIH1cbn1cbmNsYXNzIFN1YnNjcmlwdGlvbnMge1xuICAgIG11eDtcbiAgICBzdWJzO1xuICAgIHNpZENvdW50ZXI7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5zaWRDb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5tdXggPSBudWxsO1xuICAgICAgICB0aGlzLnN1YnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnMuc2l6ZTtcbiAgICB9XG4gICAgYWRkKHMpIHtcbiAgICAgICAgdGhpcy5zaWRDb3VudGVyKys7XG4gICAgICAgIHMuc2lkID0gdGhpcy5zaWRDb3VudGVyO1xuICAgICAgICB0aGlzLnN1YnMuc2V0KHMuc2lkLCBzKTtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIHNldE11eChzKSB7XG4gICAgICAgIHRoaXMubXV4ID0gcztcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIGdldE11eCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXV4O1xuICAgIH1cbiAgICBnZXQoc2lkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnMuZ2V0KHNpZCk7XG4gICAgfVxuICAgIHJlc3ViKHMpIHtcbiAgICAgICAgdGhpcy5zaWRDb3VudGVyKys7XG4gICAgICAgIHRoaXMuc3Vicy5kZWxldGUocy5zaWQpO1xuICAgICAgICBzLnNpZCA9IHRoaXMuc2lkQ291bnRlcjtcbiAgICAgICAgdGhpcy5zdWJzLnNldChzLnNpZCwgcyk7XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBhbGwoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuc3Vicy52YWx1ZXMoKSk7XG4gICAgfVxuICAgIGNhbmNlbChzKSB7XG4gICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgICBzLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnN1YnMuZGVsZXRlKHMuc2lkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVFcnJvcihlcnIpIHtcbiAgICAgICAgaWYgKGVyciAmJiBlcnIucGVybWlzc2lvbkNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IGVyci5wZXJtaXNzaW9uQ29udGV4dDtcbiAgICAgICAgICAgIGNvbnN0IHN1YnMgPSB0aGlzLmFsbCgpO1xuICAgICAgICAgICAgbGV0IHN1YjtcbiAgICAgICAgICAgIGlmIChjdHgub3BlcmF0aW9uID09PSBcInN1YnNjcmlwdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgc3ViID0gc3Vicy5maW5kKChzKT0+e1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5zdWJqZWN0ID09PSBjdHguc3ViamVjdCAmJiBzLnF1ZXVlID09PSBjdHgucXVldWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3R4Lm9wZXJhdGlvbiA9PT0gXCJwdWJsaXNoXCIpIHtcbiAgICAgICAgICAgICAgICBzdWIgPSBzdWJzLmZpbmQoKHMpPT57XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzLnJlcXVlc3RTdWJqZWN0ID09PSBjdHguc3ViamVjdDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdWIpIHtcbiAgICAgICAgICAgICAgICBzdWIuY2FsbGJhY2soZXJyLCB7fSk7XG4gICAgICAgICAgICAgICAgc3ViLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzLmRlbGV0ZShzdWIuc2lkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ViICE9PSB0aGlzLm11eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLnN1YnMuZm9yRWFjaCgoc3ViKT0+e1xuICAgICAgICAgICAgc3ViLmNsb3NlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFByb3RvY29sSGFuZGxlciB7XG4gICAgY29ubmVjdGVkO1xuICAgIGNvbm5lY3RlZE9uY2U7XG4gICAgaW5mb1JlY2VpdmVkO1xuICAgIGluZm87XG4gICAgbXV4U3Vic2NyaXB0aW9ucztcbiAgICBvcHRpb25zO1xuICAgIG91dGJvdW5kO1xuICAgIHBvbmdzO1xuICAgIHN1YnNjcmlwdGlvbnM7XG4gICAgdHJhbnNwb3J0O1xuICAgIG5vTW9yZVB1Ymxpc2hpbmc7XG4gICAgY29ubmVjdEVycm9yO1xuICAgIHB1Ymxpc2hlcjtcbiAgICBfY2xvc2VkO1xuICAgIGNsb3NlZDtcbiAgICBsaXN0ZW5lcnM7XG4gICAgaGVhcnRiZWF0cztcbiAgICBwYXJzZXI7XG4gICAgb3V0TXNncztcbiAgICBpbk1zZ3M7XG4gICAgb3V0Qnl0ZXM7XG4gICAgaW5CeXRlcztcbiAgICBwZW5kaW5nTGltaXQ7XG4gICAgbGFzdEVycm9yO1xuICAgIGFib3J0UmVjb25uZWN0O1xuICAgIHdoeUNsb3NlZDtcbiAgICBzZXJ2ZXJzO1xuICAgIHNlcnZlcjtcbiAgICBmZWF0dXJlcztcbiAgICBjb25uZWN0UHJvbWlzZTtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBwdWJsaXNoZXIpe1xuICAgICAgICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRPbmNlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5mb1JlY2VpdmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubm9Nb3JlUHVibGlzaGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFib3J0UmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMucGVuZGluZ0xpbWl0ID0gRkxVU0hfVEhSRVNIT0xEO1xuICAgICAgICB0aGlzLm91dE1zZ3MgPSAwO1xuICAgICAgICB0aGlzLmluTXNncyA9IDA7XG4gICAgICAgIHRoaXMub3V0Qnl0ZXMgPSAwO1xuICAgICAgICB0aGlzLmluQnl0ZXMgPSAwO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnB1Ymxpc2hlciA9IHB1Ymxpc2hlcjtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IFN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgdGhpcy5tdXhTdWJzY3JpcHRpb25zID0gbmV3IE11eFN1YnNjcmlwdGlvbigpO1xuICAgICAgICB0aGlzLm91dGJvdW5kID0gbmV3IERhdGFCdWZmZXIoKTtcbiAgICAgICAgdGhpcy5wb25ncyA9IFtdO1xuICAgICAgICB0aGlzLndoeUNsb3NlZCA9IFwiXCI7XG4gICAgICAgIHRoaXMucGVuZGluZ0xpbWl0ID0gb3B0aW9ucy5wZW5kaW5nTGltaXQgfHwgdGhpcy5wZW5kaW5nTGltaXQ7XG4gICAgICAgIHRoaXMuZmVhdHVyZXMgPSBuZXcgRmVhdHVyZXMoe1xuICAgICAgICAgICAgbWFqb3I6IDAsXG4gICAgICAgICAgICBtaW5vcjogMCxcbiAgICAgICAgICAgIG1pY3JvOiAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbm5lY3RQcm9taXNlID0gbnVsbDtcbiAgICAgICAgY29uc3Qgc2VydmVycyA9IHR5cGVvZiBvcHRpb25zLnNlcnZlcnMgPT09IFwic3RyaW5nXCIgPyBbXG4gICAgICAgICAgICBvcHRpb25zLnNlcnZlcnNcbiAgICAgICAgXSA6IG9wdGlvbnMuc2VydmVycztcbiAgICAgICAgdGhpcy5zZXJ2ZXJzID0gbmV3IFNlcnZlcnMoc2VydmVycywge1xuICAgICAgICAgICAgcmFuZG9taXplOiAhb3B0aW9ucy5ub1JhbmRvbWl6ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSBkZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLnBhcnNlciA9IG5ldyBQYXJzZXIodGhpcyk7XG4gICAgICAgIHRoaXMuaGVhcnRiZWF0cyA9IG5ldyBIZWFydGJlYXQodGhpcywgdGhpcy5vcHRpb25zLnBpbmdJbnRlcnZhbCB8fCBERUZBVUxUX1BJTkdfSU5URVJWQUwsIHRoaXMub3B0aW9ucy5tYXhQaW5nT3V0IHx8IERFRkFVTFRfTUFYX1BJTkdfT1VUKTtcbiAgICB9XG4gICAgcmVzZXRPdXRib3VuZCgpIHtcbiAgICAgICAgdGhpcy5vdXRib3VuZC5yZXNldCgpO1xuICAgICAgICBjb25zdCBwb25ncyA9IHRoaXMucG9uZ3M7XG4gICAgICAgIHRoaXMucG9uZ3MgPSBbXTtcbiAgICAgICAgY29uc3QgZXJyID0gTmF0c0Vycm9yLmVycm9yRm9yQ29kZShFcnJvckNvZGUuRGlzY29ubmVjdCk7XG4gICAgICAgIGVyci5zdGFjayA9IFwiXCI7XG4gICAgICAgIHBvbmdzLmZvckVhY2goKHApPT57XG4gICAgICAgICAgICBwLnJlamVjdChlcnIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBuZXcgUGFyc2VyKHRoaXMpO1xuICAgICAgICB0aGlzLmluZm9SZWNlaXZlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBkaXNwYXRjaFN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaCgocSk9PntcbiAgICAgICAgICAgIHEucHVzaChzdGF0dXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdHVzKCkge1xuICAgICAgICBjb25zdCBpdGVyID0gbmV3IFF1ZXVlZEl0ZXJhdG9ySW1wbCgpO1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5wdXNoKGl0ZXIpO1xuICAgICAgICByZXR1cm4gaXRlcjtcbiAgICB9XG4gICAgcHJlcGFyZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0KSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5kaXNjYXJkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmZvID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnJlc2V0T3V0Ym91bmQoKTtcbiAgICAgICAgY29uc3QgcG9uZyA9IGRlZmVycmVkKCk7XG4gICAgICAgIHBvbmcuY2F0Y2goKCk9Pnt9KTtcbiAgICAgICAgdGhpcy5wb25ncy51bnNoaWZ0KHBvbmcpO1xuICAgICAgICB0aGlzLmNvbm5lY3RFcnJvciA9IChlcnIpPT57XG4gICAgICAgICAgICBwb25nLnJlamVjdChlcnIpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IG5ld1RyYW5zcG9ydCgpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZWQoKS50aGVuKGFzeW5jIChfZXJyKT0+e1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0Nsb3NlZCgpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5kaXNjb25uZWN0ZWQodGhpcy50cmFuc3BvcnQuY2xvc2VFcnJvciB8fCB0aGlzLmxhc3RFcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBvbmc7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hTdGF0dXMoe1xuICAgICAgICAgICAgdHlwZTogRGVidWdFdmVudHMuU3RhbGVDb25uZWN0aW9uLFxuICAgICAgICAgICAgZGF0YTogXCJcIlxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICByZWNvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgdHlwZTogRGVidWdFdmVudHMuQ2xpZW50SW5pdGlhdGVkUmVjb25uZWN0LFxuICAgICAgICAgICAgICAgIGRhdGE6IFwiXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgYXN5bmMgZGlzY29ubmVjdGVkKGVycikge1xuICAgICAgICB0aGlzLmRpc3BhdGNoU3RhdHVzKHtcbiAgICAgICAgICAgIHR5cGU6IEV2ZW50cy5EaXNjb25uZWN0LFxuICAgICAgICAgICAgZGF0YTogdGhpcy5zZXJ2ZXJzLmdldEN1cnJlbnRTZXJ2ZXIoKS50b1N0cmluZygpXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlY29ubmVjdCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5kaWFsTG9vcCgpLnRoZW4oKCk9PntcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoU3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRzLlJlY29ubmVjdCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdGhpcy5zZXJ2ZXJzLmdldEN1cnJlbnRTZXJ2ZXIoKS50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGFzdEVycm9yPy5jb2RlID09PSBFcnJvckNvZGUuQXV0aGVudGljYXRpb25FeHBpcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdEVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xvc2UoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fY2xvc2UoZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBkaWFsKHNydikge1xuICAgICAgICBjb25zdCBwb25nID0gdGhpcy5wcmVwYXJlKCk7XG4gICAgICAgIGxldCB0aW1lcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRpbWVyID0gdGltZW91dCh0aGlzLm9wdGlvbnMudGltZW91dCB8fCAyMDAwMCk7XG4gICAgICAgICAgICBjb25zdCBjcCA9IHRoaXMudHJhbnNwb3J0LmNvbm5lY3Qoc3J2LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgICAgICBjcCxcbiAgICAgICAgICAgICAgICB0aW1lclxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAoYXN5bmMgKCk9PntcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGIgb2YgdGhpcy50cmFuc3BvcnQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZXIucGFyc2UoYik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJyZWFkZXIgY2xvc2VkXCIsIGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKS50aGVuKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcG9uZy5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgICAgICB0aW1lcixcbiAgICAgICAgICAgICAgICBwb25nXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgICAgIHRpbWVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0RXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnNlbmRTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RlZE9uY2UgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zZXJ2ZXIuZGlkQ29ubmVjdCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNlcnZlci5yZWNvbm5lY3RzID0gMDtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hQZW5kaW5nKCk7XG4gICAgICAgICAgICB0aGlzLmhlYXJ0YmVhdHMuc3RhcnQoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICB0aW1lci5jYW5jZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMudHJhbnNwb3J0LmNsb3NlKGVycik7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2RvRGlhbChzcnYpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGFsdHMgPSBhd2FpdCBzcnYucmVzb2x2ZSh7XG4gICAgICAgICAgICBmbjogZ2V0UmVzb2x2ZUZuKCksXG4gICAgICAgICAgICBkZWJ1ZzogdGhpcy5vcHRpb25zLmRlYnVnLFxuICAgICAgICAgICAgcmFuZG9taXplOiAhdGhpcy5vcHRpb25zLm5vUmFuZG9taXplLFxuICAgICAgICAgICAgcmVzb2x2ZVxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGxhc3RFcnIgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGEgb2YgYWx0cyl7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxhc3RFcnIgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hTdGF0dXMoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBEZWJ1Z0V2ZW50cy5SZWNvbm5lY3RpbmcsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGEudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZGlhbChhKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBsYXN0RXJyID0gZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGxhc3RFcnI7XG4gICAgfVxuICAgIGRpYWxMb29wKCkge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0UHJvbWlzZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0UHJvbWlzZSA9IHRoaXMuZG9kaWFsTG9vcCgpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0UHJvbWlzZS50aGVuKCgpPT57fSkuY2F0Y2goKCk9Pnt9KS5maW5hbGx5KCgpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0UHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0UHJvbWlzZTtcbiAgICB9XG4gICAgYXN5bmMgZG9kaWFsTG9vcCgpIHtcbiAgICAgICAgbGV0IGxhc3RFcnJvcjtcbiAgICAgICAgd2hpbGUodHJ1ZSl7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZXJzLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB3YWl0ID0gdGhpcy5vcHRpb25zLnJlY29ubmVjdERlbGF5SGFuZGxlciA/IHRoaXMub3B0aW9ucy5yZWNvbm5lY3REZWxheUhhbmRsZXIoKSA6IERFRkFVTFRfUkVDT05ORUNUX1RJTUVfV0FJVDtcbiAgICAgICAgICAgIGxldCBtYXhXYWl0ID0gd2FpdDtcbiAgICAgICAgICAgIGNvbnN0IHNydiA9IHRoaXMuc2VsZWN0U2VydmVyKCk7XG4gICAgICAgICAgICBpZiAoIXNydiB8fCB0aGlzLmFib3J0UmVjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBsYXN0RXJyb3I7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxhc3RFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmxhc3RFcnJvcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBOYXRzRXJyb3IuZXJyb3JGb3JDb2RlKEVycm9yQ29kZS5Db25uZWN0aW9uUmVmdXNlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGlmIChzcnYubGFzdENvbm5lY3QgPT09IDAgfHwgc3J2Lmxhc3RDb25uZWN0ICsgd2FpdCA8PSBub3cpIHtcbiAgICAgICAgICAgICAgICBzcnYubGFzdENvbm5lY3QgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2RvRGlhbChzcnYpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29ubmVjdGVkT25jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy53YWl0T25GaXJzdENvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VydmVycy5yZW1vdmVDdXJyZW50U2VydmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3J2LnJlY29ubmVjdHMrKztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbXJhID0gdGhpcy5vcHRpb25zLm1heFJlY29ubmVjdEF0dGVtcHRzIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtcmEgIT09IC0xICYmIHNydi5yZWNvbm5lY3RzID49IG1yYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZXJzLnJlbW92ZUN1cnJlbnRTZXJ2ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWF4V2FpdCA9IE1hdGgubWluKG1heFdhaXQsIHNydi5sYXN0Q29ubmVjdCArIHdhaXQgLSBub3cpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGRlbGF5KG1heFdhaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBjb25uZWN0KG9wdGlvbnMsIHB1Ymxpc2hlcikge1xuICAgICAgICBjb25zdCBoID0gbmV3IFByb3RvY29sSGFuZGxlcihvcHRpb25zLCBwdWJsaXNoZXIpO1xuICAgICAgICBhd2FpdCBoLmRpYWxMb29wKCk7XG4gICAgICAgIHJldHVybiBoO1xuICAgIH1cbiAgICBzdGF0aWMgdG9FcnJvcihzKSB7XG4gICAgICAgIGNvbnN0IHQgPSBzID8gcy50b0xvd2VyQ2FzZSgpIDogXCJcIjtcbiAgICAgICAgaWYgKHQuaW5kZXhPZihcInBlcm1pc3Npb25zIHZpb2xhdGlvblwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBOYXRzRXJyb3IocywgRXJyb3JDb2RlLlBlcm1pc3Npb25zVmlvbGF0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBzLm1hdGNoKC8oUHVibGlzaHxTdWJzY3JpcHRpb24pIHRvIFwiKFxcUyspXCIvKTtcbiAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgZXJyLnBlcm1pc3Npb25Db250ZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IG1bMV0udG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgc3ViamVjdDogbVsyXSxcbiAgICAgICAgICAgICAgICAgICAgcXVldWU6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgcW0gPSBzLm1hdGNoKC91c2luZyBxdWV1ZSBcIihcXFMrKVwiLyk7XG4gICAgICAgICAgICAgICAgaWYgKHFtKSB7XG4gICAgICAgICAgICAgICAgICAgIGVyci5wZXJtaXNzaW9uQ29udGV4dC5xdWV1ZSA9IHFtWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgIH0gZWxzZSBpZiAodC5pbmRleE9mKFwiYXV0aG9yaXphdGlvbiB2aW9sYXRpb25cIikgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5hdHNFcnJvcihzLCBFcnJvckNvZGUuQXV0aG9yaXphdGlvblZpb2xhdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAodC5pbmRleE9mKFwidXNlciBhdXRoZW50aWNhdGlvbiBleHBpcmVkXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOYXRzRXJyb3IocywgRXJyb3JDb2RlLkF1dGhlbnRpY2F0aW9uRXhwaXJlZCk7XG4gICAgICAgIH0gZWxzZSBpZiAodC5pbmRleE9mKFwiYWNjb3VudCBhdXRoZW50aWNhdGlvbiBleHBpcmVkXCIpICE9IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5hdHNFcnJvcihzLCBFcnJvckNvZGUuQWNjb3VudEV4cGlyZWQpO1xuICAgICAgICB9IGVsc2UgaWYgKHQuaW5kZXhPZihcImF1dGhlbnRpY2F0aW9uIHRpbWVvdXRcIikgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5hdHNFcnJvcihzLCBFcnJvckNvZGUuQXV0aGVudGljYXRpb25UaW1lb3V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTmF0c0Vycm9yKHMsIEVycm9yQ29kZS5Qcm90b2NvbEVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9jZXNzTXNnKG1zZywgZGF0YSkge1xuICAgICAgICB0aGlzLmluTXNncysrO1xuICAgICAgICB0aGlzLmluQnl0ZXMgKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGlmICghdGhpcy5zdWJzY3JpcHRpb25zLnNpZENvdW50ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWIgPSB0aGlzLnN1YnNjcmlwdGlvbnMuZ2V0KG1zZy5zaWQpO1xuICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1Yi5yZWNlaXZlZCArPSAxO1xuICAgICAgICBpZiAoc3ViLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICBzdWIuY2FsbGJhY2sobnVsbCwgbmV3IE1zZ0ltcGwobXNnLCBkYXRhLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1Yi5tYXggIT09IHVuZGVmaW5lZCAmJiBzdWIucmVjZWl2ZWQgPj0gc3ViLm1heCkge1xuICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc0Vycm9yKG0pIHtcbiAgICAgICAgY29uc3QgcyA9IGRlY29kZShtKTtcbiAgICAgICAgY29uc3QgZXJyID0gUHJvdG9jb2xIYW5kbGVyLnRvRXJyb3Iocyk7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHtcbiAgICAgICAgICAgIHR5cGU6IEV2ZW50cy5FcnJvcixcbiAgICAgICAgICAgIGRhdGE6IGVyci5jb2RlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChlcnIuaXNQZXJtaXNzaW9uRXJyb3IoKSkge1xuICAgICAgICAgICAgbGV0IGlzTXV4UGVybWlzc2lvbkVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZXJyLnBlcm1pc3Npb25Db250ZXh0KSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLnBlcm1pc3Npb25Db250ZXh0ID0gZXJyLnBlcm1pc3Npb25Db250ZXh0O1xuICAgICAgICAgICAgICAgIGNvbnN0IG11eCA9IHRoaXMuc3Vic2NyaXB0aW9ucy5nZXRNdXgoKTtcbiAgICAgICAgICAgICAgICBpc011eFBlcm1pc3Npb25FcnJvciA9IG11eD8uc3ViamVjdCA9PT0gZXJyLnBlcm1pc3Npb25Db250ZXh0LnN1YmplY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuaGFuZGxlRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHRoaXMubXV4U3Vic2NyaXB0aW9ucy5oYW5kbGVFcnJvcihpc011eFBlcm1pc3Npb25FcnJvciwgZXJyKTtcbiAgICAgICAgICAgIGlmIChpc011eFBlcm1pc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5zZXRNdXgobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwYXRjaFN0YXR1cyhzdGF0dXMpO1xuICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGVycik7XG4gICAgfVxuICAgIGhhbmRsZUVycm9yKGVycikge1xuICAgICAgICBpZiAoZXJyLmlzQXV0aEVycm9yKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQXV0aEVycm9yKGVycik7XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyLmlzUHJvdG9jb2xFcnJvcigpKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RFcnJvciA9IGVycjtcbiAgICAgICAgfSBlbHNlIGlmIChlcnIuaXNBdXRoVGltZW91dCgpKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RFcnJvciA9IGVycjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVyci5pc1Blcm1pc3Npb25FcnJvcigpKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RFcnJvciA9IGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVBdXRoRXJyb3IoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLmxhc3RFcnJvciAmJiBlcnIuY29kZSA9PT0gdGhpcy5sYXN0RXJyb3IuY29kZSAmJiB0aGlzLm9wdGlvbnMuaWdub3JlQXV0aEVycm9yQWJvcnQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLmFib3J0UmVjb25uZWN0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25uZWN0RXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdEVycm9yKGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9jZXNzUGluZygpIHtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQuc2VuZChQT05HX0NNRCk7XG4gICAgfVxuICAgIHByb2Nlc3NQb25nKCkge1xuICAgICAgICBjb25zdCBjYiA9IHRoaXMucG9uZ3Muc2hpZnQoKTtcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICBjYi5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc0luZm8obSkge1xuICAgICAgICBjb25zdCBpbmZvID0gSlNPTi5wYXJzZShkZWNvZGUobSkpO1xuICAgICAgICB0aGlzLmluZm8gPSBpbmZvO1xuICAgICAgICBjb25zdCB1cGRhdGVzID0gdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5pZ25vcmVDbHVzdGVyVXBkYXRlcyA/IHVuZGVmaW5lZCA6IHRoaXMuc2VydmVycy51cGRhdGUoaW5mbywgdGhpcy50cmFuc3BvcnQuaXNFbmNyeXB0ZWQoKSk7XG4gICAgICAgIGlmICghdGhpcy5pbmZvUmVjZWl2ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZXMudXBkYXRlKHBhcnNlU2VtVmVyKGluZm8udmVyc2lvbikpO1xuICAgICAgICAgICAgdGhpcy5pbmZvUmVjZWl2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0LmlzRW5jcnlwdGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlcnZlcnMudXBkYXRlVExTTmFtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB2ZXJzaW9uLCBsYW5nIH0gPSB0aGlzLnRyYW5zcG9ydDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IG5ldyBDb25uZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgbGFuZ1xuICAgICAgICAgICAgICAgIH0sIHRoaXMub3B0aW9ucywgaW5mby5ub25jZSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8uaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICBjLmhlYWRlcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjLm5vX3Jlc3BvbmRlcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjcyA9IEpTT04uc3RyaW5naWZ5KGMpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LnNlbmQoZW5jb2RlKGBDT05ORUNUICR7Y3N9JHtDUl9MRn1gKSk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuc2VuZChQSU5HX0NNRCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZShlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVzKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoU3RhdHVzKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBFdmVudHMuVXBkYXRlLFxuICAgICAgICAgICAgICAgIGRhdGE6IHVwZGF0ZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxkbSA9IGluZm8ubGRtICE9PSB1bmRlZmluZWQgPyBpbmZvLmxkbSA6IGZhbHNlO1xuICAgICAgICBpZiAobGRtKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoU3RhdHVzKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBFdmVudHMuTERNLFxuICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMuc2VydmVycy5nZXRDdXJyZW50U2VydmVyKCkudG9TdHJpbmcoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHVzaChlKSB7XG4gICAgICAgIHN3aXRjaChlLmtpbmQpe1xuICAgICAgICAgICAgY2FzZSBLaW5kLk1TRzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgbXNnLCBkYXRhIH0gPSBlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NNc2cobXNnLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBLaW5kLk9LOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLaW5kLkVSUjpcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NFcnJvcihlLmRhdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLaW5kLlBJTkc6XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzUGluZygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLaW5kLlBPTkc6XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzUG9uZygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLaW5kLklORk86XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzSW5mbyhlLmRhdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbmRDb21tYW5kKGNtZCwgLi4ucGF5bG9hZHMpIHtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRib3VuZC5sZW5ndGgoKTtcbiAgICAgICAgbGV0IGJ1ZjtcbiAgICAgICAgaWYgKHR5cGVvZiBjbWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGJ1ZiA9IGVuY29kZShjbWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmID0gY21kO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0Ym91bmQuZmlsbChidWYsIC4uLnBheWxvYWRzKTtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCk9PntcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoUGVuZGluZygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vdXRib3VuZC5zaXplKCkgPj0gdGhpcy5wZW5kaW5nTGltaXQpIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hQZW5kaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHVibGlzaChzdWJqZWN0LCBwYXlsb2FkID0gRW1wdHksIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgIGlmIChwYXlsb2FkIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgZGF0YSA9IHBheWxvYWQ7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBheWxvYWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGRhdGEgPSBURS5lbmNvZGUocGF5bG9hZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBOYXRzRXJyb3IuZXJyb3JGb3JDb2RlKEVycm9yQ29kZS5CYWRQYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBvcHRpb25zLnJlcGx5ID0gb3B0aW9ucy5yZXBseSB8fCBcIlwiO1xuICAgICAgICBsZXQgaGVhZGVycyA9IEVtcHR5O1xuICAgICAgICBsZXQgaGxlbiA9IDA7XG4gICAgICAgIGlmIChvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZm8gJiYgIXRoaXMuaW5mby5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5hdHNFcnJvcihcImhlYWRlcnNcIiwgRXJyb3JDb2RlLlNlcnZlck9wdGlvbk5vdEF2YWlsYWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZHJzID0gb3B0aW9ucy5oZWFkZXJzO1xuICAgICAgICAgICAgaGVhZGVycyA9IGhkcnMuZW5jb2RlKCk7XG4gICAgICAgICAgICBobGVuID0gaGVhZGVycy5sZW5ndGg7XG4gICAgICAgICAgICBsZW4gPSBkYXRhLmxlbmd0aCArIGhsZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5mbyAmJiBsZW4gPiB0aGlzLmluZm8ubWF4X3BheWxvYWQpIHtcbiAgICAgICAgICAgIHRocm93IE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLk1heFBheWxvYWRFeGNlZWRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRCeXRlcyArPSBsZW47XG4gICAgICAgIHRoaXMub3V0TXNncysrO1xuICAgICAgICBsZXQgcHJvdG87XG4gICAgICAgIGlmIChvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnJlcGx5KSB7XG4gICAgICAgICAgICAgICAgcHJvdG8gPSBgSFBVQiAke3N1YmplY3R9ICR7b3B0aW9ucy5yZXBseX0gJHtobGVufSAke2xlbn1cXHJcXG5gO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm90byA9IGBIUFVCICR7c3ViamVjdH0gJHtobGVufSAke2xlbn1cXHJcXG5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZW5kQ29tbWFuZChwcm90bywgaGVhZGVycywgZGF0YSwgQ1JMRik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5yZXBseSkge1xuICAgICAgICAgICAgICAgIHByb3RvID0gYFBVQiAke3N1YmplY3R9ICR7b3B0aW9ucy5yZXBseX0gJHtsZW59XFxyXFxuYDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvdG8gPSBgUFVCICR7c3ViamVjdH0gJHtsZW59XFxyXFxuYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2VuZENvbW1hbmQocHJvdG8sIGRhdGEsIENSTEYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3Qocikge1xuICAgICAgICB0aGlzLmluaXRNdXgoKTtcbiAgICAgICAgdGhpcy5tdXhTdWJzY3JpcHRpb25zLmFkZChyKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIHN1YnNjcmliZShzKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQocyk7XG4gICAgICAgIHRoaXMuX3N1YnVuc3ViKHMpO1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgX3N1YihzKSB7XG4gICAgICAgIGlmIChzLnF1ZXVlKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRDb21tYW5kKGBTVUIgJHtzLnN1YmplY3R9ICR7cy5xdWV1ZX0gJHtzLnNpZH1cXHJcXG5gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZENvbW1hbmQoYFNVQiAke3Muc3ViamVjdH0gJHtzLnNpZH1cXHJcXG5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfc3VidW5zdWIocykge1xuICAgICAgICB0aGlzLl9zdWIocyk7XG4gICAgICAgIGlmIChzLm1heCkge1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZShzLCBzLm1heCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlKHMsIG1heCkge1xuICAgICAgICB0aGlzLnVuc3ViKHMsIG1heCk7XG4gICAgICAgIGlmIChzLm1heCA9PT0gdW5kZWZpbmVkIHx8IHMucmVjZWl2ZWQgPj0gcy5tYXgpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5jYW5jZWwocyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5zdWIocywgbWF4KSB7XG4gICAgICAgIGlmICghcyB8fCB0aGlzLmlzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4KSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRDb21tYW5kKGBVTlNVQiAke3Muc2lkfSAke21heH1cXHJcXG5gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZENvbW1hbmQoYFVOU1VCICR7cy5zaWR9XFxyXFxuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcy5tYXggPSBtYXg7XG4gICAgfVxuICAgIHJlc3ViKHMsIHN1YmplY3QpIHtcbiAgICAgICAgaWYgKCFzIHx8IHRoaXMuaXNDbG9zZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudW5zdWIocyk7XG4gICAgICAgIHMuc3ViamVjdCA9IHN1YmplY3Q7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5yZXN1YihzKTtcbiAgICAgICAgdGhpcy5fc3ViKHMpO1xuICAgIH1cbiAgICBmbHVzaChwKSB7XG4gICAgICAgIGlmICghcCkge1xuICAgICAgICAgICAgcCA9IGRlZmVycmVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb25ncy5wdXNoKHApO1xuICAgICAgICB0aGlzLm91dGJvdW5kLmZpbGwoUElOR19DTUQpO1xuICAgICAgICB0aGlzLmZsdXNoUGVuZGluZygpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgc2VuZFN1YnNjcmlwdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IGNtZHMgPSBbXTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFsbCgpLmZvckVhY2goKHMpPT57XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBzO1xuICAgICAgICAgICAgaWYgKHN1Yi5xdWV1ZSkge1xuICAgICAgICAgICAgICAgIGNtZHMucHVzaChgU1VCICR7c3ViLnN1YmplY3R9ICR7c3ViLnF1ZXVlfSAke3N1Yi5zaWR9JHtDUl9MRn1gKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY21kcy5wdXNoKGBTVUIgJHtzdWIuc3ViamVjdH0gJHtzdWIuc2lkfSR7Q1JfTEZ9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY21kcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LnNlbmQoZW5jb2RlKGNtZHMuam9pbihcIlwiKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9jbG9zZShlcnIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2h5Q2xvc2VkID0gbmV3IEVycm9yKFwiY2xvc2UgdHJhY2VcIikuc3RhY2sgfHwgXCJcIjtcbiAgICAgICAgdGhpcy5oZWFydGJlYXRzLmNhbmNlbCgpO1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0RXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdEVycm9yKGVycik7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm11eFN1YnNjcmlwdGlvbnMuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmNsb3NlKCk7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goKGwpPT57XG4gICAgICAgICAgICBsLnN0b3AoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgICAgIGF3YWl0IHRoaXMudHJhbnNwb3J0LmNsb3NlKGVycik7XG4gICAgICAgIGF3YWl0IHRoaXMuY2xvc2VkLnJlc29sdmUoZXJyKTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9zZSgpO1xuICAgIH1cbiAgICBpc0Nsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlZDtcbiAgICB9XG4gICAgZHJhaW4oKSB7XG4gICAgICAgIGNvbnN0IHN1YnMgPSB0aGlzLnN1YnNjcmlwdGlvbnMuYWxsKCk7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIHN1YnMuZm9yRWFjaCgoc3ViKT0+e1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChzdWIuZHJhaW4oKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oYXN5bmMgKCk9PntcbiAgICAgICAgICAgIHRoaXMubm9Nb3JlUHVibGlzaGluZyA9IHRydWU7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9zZSgpO1xuICAgICAgICB9KS5jYXRjaCgoKT0+e30pO1xuICAgIH1cbiAgICBmbHVzaFBlbmRpbmcoKSB7XG4gICAgICAgIGlmICghdGhpcy5pbmZvUmVjZWl2ZWQgfHwgIXRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3V0Ym91bmQuc2l6ZSgpKSB7XG4gICAgICAgICAgICBjb25zdCBkID0gdGhpcy5vdXRib3VuZC5kcmFpbigpO1xuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuc2VuZChkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbml0TXV4KCkge1xuICAgICAgICBjb25zdCBtdXggPSB0aGlzLnN1YnNjcmlwdGlvbnMuZ2V0TXV4KCk7XG4gICAgICAgIGlmICghbXV4KSB7XG4gICAgICAgICAgICBjb25zdCBpbmJveCA9IHRoaXMubXV4U3Vic2NyaXB0aW9ucy5pbml0KHRoaXMub3B0aW9ucy5pbmJveFByZWZpeCk7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBuZXcgU3Vic2NyaXB0aW9uSW1wbCh0aGlzLCBgJHtpbmJveH0qYCk7XG4gICAgICAgICAgICBzdWIuY2FsbGJhY2sgPSB0aGlzLm11eFN1YnNjcmlwdGlvbnMuZGlzcGF0Y2hlcigpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnNldE11eChzdWIpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoc3ViKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3RTZXJ2ZXIoKSB7XG4gICAgICAgIGNvbnN0IHNlcnZlciA9IHRoaXMuc2VydmVycy5zZWxlY3RTZXJ2ZXIoKTtcbiAgICAgICAgaWYgKHNlcnZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VydmVyID0gc2VydmVyO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2ZXI7XG4gICAgfVxuICAgIGdldFNlcnZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmVyO1xuICAgIH1cbn1cbmNvbnN0IFNlcnZpY2VBcGlQcmVmaXggPSBcIiRTUlZcIjtcbmNsYXNzIFNlcnZpY2VNc2dJbXBsIHtcbiAgICBtc2c7XG4gICAgY29uc3RydWN0b3IobXNnKXtcbiAgICAgICAgdGhpcy5tc2cgPSBtc2c7XG4gICAgfVxuICAgIGdldCBkYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tc2cuZGF0YTtcbiAgICB9XG4gICAgZ2V0IHNpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXNnLnNpZDtcbiAgICB9XG4gICAgZ2V0IHN1YmplY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1zZy5zdWJqZWN0O1xuICAgIH1cbiAgICBnZXQgcmVwbHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1zZy5yZXBseSB8fCBcIlwiO1xuICAgIH1cbiAgICBnZXQgaGVhZGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXNnLmhlYWRlcnM7XG4gICAgfVxuICAgIHJlc3BvbmQoZGF0YSwgb3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5tc2cucmVzcG9uZChkYXRhLCBvcHRzKTtcbiAgICB9XG4gICAgcmVzcG9uZEVycm9yKGNvZGUsIGRlc2NyaXB0aW9uLCBkYXRhLCBvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICBvcHRzLmhlYWRlcnMgPSBvcHRzLmhlYWRlcnMgfHwgaGVhZGVycygpO1xuICAgICAgICBvcHRzLmhlYWRlcnM/LnNldChTZXJ2aWNlRXJyb3JDb2RlSGVhZGVyLCBgJHtjb2RlfWApO1xuICAgICAgICBvcHRzLmhlYWRlcnM/LnNldChTZXJ2aWNlRXJyb3JIZWFkZXIsIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubXNnLnJlc3BvbmQoZGF0YSwgb3B0cyk7XG4gICAgfVxuICAgIGpzb24ocmV2aXZlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5tc2cuanNvbihyZXZpdmVyKTtcbiAgICB9XG4gICAgc3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tc2cuc3RyaW5nKCk7XG4gICAgfVxufVxuY2xhc3MgU2VydmljZUdyb3VwSW1wbCB7XG4gICAgc3ViamVjdDtcbiAgICBxdWV1ZTtcbiAgICBzcnY7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBuYW1lID0gXCJcIiwgcXVldWUgPSBcIlwiKXtcbiAgICAgICAgaWYgKG5hbWUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHZhbGlkSW50ZXJuYWxUb2tlbihcInNlcnZpY2UgZ3JvdXBcIiwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJvb3QgPSBcIlwiO1xuICAgICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgU2VydmljZUltcGwpIHtcbiAgICAgICAgICAgIHRoaXMuc3J2ID0gcGFyZW50O1xuICAgICAgICAgICAgcm9vdCA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyZW50IGluc3RhbmNlb2YgU2VydmljZUdyb3VwSW1wbCkge1xuICAgICAgICAgICAgY29uc3Qgc2cgPSBwYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLnNydiA9IHNnLnNydjtcbiAgICAgICAgICAgIGlmIChxdWV1ZSA9PT0gXCJcIiAmJiBzZy5xdWV1ZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIHF1ZXVlID0gc2cucXVldWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb290ID0gc2cuc3ViamVjdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gU2VydmljZUdyb3VwIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJqZWN0ID0gdGhpcy5jYWxjU3ViamVjdChyb290LCBuYW1lKTtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IHF1ZXVlO1xuICAgIH1cbiAgICBjYWxjU3ViamVjdChyb290LCBuYW1lID0gXCJcIikge1xuICAgICAgICBpZiAobmFtZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3QgIT09IFwiXCIgPyBgJHtyb290fS4ke25hbWV9YCA6IG5hbWU7XG4gICAgfVxuICAgIGFkZEVuZHBvaW50KG5hbWUgPSBcIlwiLCBvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHtcbiAgICAgICAgICAgIHN1YmplY3Q6IG5hbWVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYXJncyA9IHR5cGVvZiBvcHRzID09PSBcImZ1bmN0aW9uXCIgPyB7XG4gICAgICAgICAgICBoYW5kbGVyOiBvcHRzLFxuICAgICAgICAgICAgc3ViamVjdDogbmFtZVxuICAgICAgICB9IDogb3B0cztcbiAgICAgICAgdmFsaWRhdGVOYW1lKFwiZW5kcG9pbnRcIiwgbmFtZSk7XG4gICAgICAgIGxldCB7IHN1YmplY3QsIGhhbmRsZXIsIG1ldGFkYXRhLCBxdWV1ZSB9ID0gYXJncztcbiAgICAgICAgc3ViamVjdCA9IHN1YmplY3QgfHwgbmFtZTtcbiAgICAgICAgcXVldWUgPSBxdWV1ZSB8fCB0aGlzLnF1ZXVlO1xuICAgICAgICB2YWxpZFN1YmplY3ROYW1lKFwiZW5kcG9pbnQgc3ViamVjdFwiLCBzdWJqZWN0KTtcbiAgICAgICAgc3ViamVjdCA9IHRoaXMuY2FsY1N1YmplY3QodGhpcy5zdWJqZWN0LCBzdWJqZWN0KTtcbiAgICAgICAgY29uc3QgbmUgPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgc3ViamVjdCxcbiAgICAgICAgICAgIHF1ZXVlLFxuICAgICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICAgIG1ldGFkYXRhXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLnNydi5fYWRkRW5kcG9pbnQobmUpO1xuICAgIH1cbiAgICBhZGRHcm91cChuYW1lID0gXCJcIiwgcXVldWUgPSBcIlwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VydmljZUdyb3VwSW1wbCh0aGlzLCBuYW1lLCBxdWV1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRTdWJqZWN0TmFtZShjb250ZXh0LCBzdWJqKSB7XG4gICAgaWYgKHN1YmogPT09IFwiXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnRleHR9IGNhbm5vdCBiZSBlbXB0eWApO1xuICAgIH1cbiAgICBpZiAoc3Viai5pbmRleE9mKFwiIFwiKSAhPT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnRleHR9IGNhbm5vdCBjb250YWluIHNwYWNlczogJyR7c3Vian0nYCk7XG4gICAgfVxuICAgIGNvbnN0IHRva2VucyA9IHN1Ymouc3BsaXQoXCIuXCIpO1xuICAgIHRva2Vucy5mb3JFYWNoKCh2LCBpZHgpPT57XG4gICAgICAgIGlmICh2ID09PSBcIj5cIiAmJiBpZHggIT09IHRva2Vucy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29udGV4dH0gY2Fubm90IGhhdmUgaW50ZXJuYWwgJz4nOiAnJHtzdWJqfSdgKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gdmFsaWRJbnRlcm5hbFRva2VuKGNvbnRleHQsIHN1YmopIHtcbiAgICBpZiAoc3Viai5pbmRleE9mKFwiIFwiKSAhPT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnRleHR9IGNhbm5vdCBjb250YWluIHNwYWNlczogJyR7c3Vian0nYCk7XG4gICAgfVxuICAgIGNvbnN0IHRva2VucyA9IHN1Ymouc3BsaXQoXCIuXCIpO1xuICAgIHRva2Vucy5mb3JFYWNoKCh2KT0+e1xuICAgICAgICBpZiAodiA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0fSBuYW1lIGNhbm5vdCBjb250YWluIGludGVybmFsICc+JzogJyR7c3Vian0nYCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmNsYXNzIFNlcnZpY2VJbXBsIHtcbiAgICBuYztcbiAgICBfaWQ7XG4gICAgY29uZmlnO1xuICAgIGhhbmRsZXJzO1xuICAgIGludGVybmFsO1xuICAgIF9zdG9wcGVkO1xuICAgIF9kb25lO1xuICAgIHN0YXJ0ZWQ7XG4gICAgc3RhdGljIGNvbnRyb2xTdWJqZWN0KHZlcmIsIG5hbWUgPSBcIlwiLCBpZCA9IFwiXCIsIHByZWZpeCkge1xuICAgICAgICBjb25zdCBwcmUgPSBwcmVmaXggPz8gU2VydmljZUFwaVByZWZpeDtcbiAgICAgICAgaWYgKG5hbWUgPT09IFwiXCIgJiYgaWQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHtwcmV9LiR7dmVyYn1gO1xuICAgICAgICB9XG4gICAgICAgIHZhbGlkYXRlTmFtZShcImNvbnRyb2wgc3ViamVjdCBuYW1lXCIsIG5hbWUpO1xuICAgICAgICBpZiAoaWQgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlTmFtZShcImNvbnRyb2wgc3ViamVjdCBpZFwiLCBpZCk7XG4gICAgICAgICAgICByZXR1cm4gYCR7cHJlfS4ke3ZlcmJ9LiR7bmFtZX0uJHtpZH1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtwcmV9LiR7dmVyYn0uJHtuYW1lfWA7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG5jLCBjb25maWcgPSB7XG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHZlcnNpb246IFwiXCJcbiAgICB9KXtcbiAgICAgICAgdGhpcy5uYyA9IG5jO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyk7XG4gICAgICAgIGlmICghdGhpcy5jb25maWcucXVldWUpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLnF1ZXVlID0gXCJxXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGVOYW1lKFwibmFtZVwiLCB0aGlzLmNvbmZpZy5uYW1lKTtcbiAgICAgICAgdmFsaWRhdGVOYW1lKFwicXVldWVcIiwgdGhpcy5jb25maWcucXVldWUpO1xuICAgICAgICBwYXJzZVNlbVZlcih0aGlzLmNvbmZpZy52ZXJzaW9uKTtcbiAgICAgICAgdGhpcy5faWQgPSBudWlkLm5leHQoKTtcbiAgICAgICAgdGhpcy5pbnRlcm5hbCA9IFtdO1xuICAgICAgICB0aGlzLl9kb25lID0gZGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLm5jLmNsb3NlZCgpLnRoZW4oKCk9PntcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKS5jYXRjaCgpO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgdGhpcy5jbG9zZShlcnIpLmNhdGNoKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgc3ViamVjdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZXJzLmZpbHRlcigocyk9PntcbiAgICAgICAgICAgIHJldHVybiBzLmludGVybmFsID09PSBmYWxzZTtcbiAgICAgICAgfSkubWFwKChzKT0+e1xuICAgICAgICAgICAgcmV0dXJuIHMuc3ViamVjdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLm5hbWU7XG4gICAgfVxuICAgIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmRlc2NyaXB0aW9uID8/IFwiXCI7XG4gICAgfVxuICAgIGdldCB2ZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcudmVyc2lvbjtcbiAgICB9XG4gICAgZ2V0IG1ldGFkYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcubWV0YWRhdGE7XG4gICAgfVxuICAgIGVycm9yVG9IZWFkZXIoZXJyKSB7XG4gICAgICAgIGNvbnN0IGggPSBoZWFkZXJzKCk7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBTZXJ2aWNlRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlID0gZXJyO1xuICAgICAgICAgICAgaC5zZXQoU2VydmljZUVycm9ySGVhZGVyLCBzZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIGguc2V0KFNlcnZpY2VFcnJvckNvZGVIZWFkZXIsIGAke3NlLmNvZGV9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoLnNldChTZXJ2aWNlRXJyb3JIZWFkZXIsIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgIGguc2V0KFNlcnZpY2VFcnJvckNvZGVIZWFkZXIsIFwiNTAwXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoO1xuICAgIH1cbiAgICBzZXR1cEhhbmRsZXIoaCwgaW50ZXJuYWwgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBxdWV1ZSA9IGludGVybmFsID8gXCJcIiA6IGgucXVldWUgPyBoLnF1ZXVlIDogdGhpcy5jb25maWcucXVldWU7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgc3ViamVjdCwgaGFuZGxlciB9ID0gaDtcbiAgICAgICAgY29uc3Qgc3YgPSBoO1xuICAgICAgICBzdi5pbnRlcm5hbCA9IGludGVybmFsO1xuICAgICAgICBpZiAoaW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWwucHVzaChzdik7XG4gICAgICAgIH1cbiAgICAgICAgc3Yuc3RhdHMgPSBuZXcgTmFtZWRFbmRwb2ludFN0YXRzSW1wbChuYW1lLCBzdWJqZWN0LCBxdWV1ZSk7XG4gICAgICAgIHN2LnF1ZXVlID0gcXVldWU7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gaGFuZGxlciA/IChlcnIsIG1zZyk9PntcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyKGVyciwgbmV3IFNlcnZpY2VNc2dJbXBsKG1zZykpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgc3Yuc3RhdHMuY291bnRFcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIG1zZz8ucmVzcG9uZChFbXB0eSwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmVycm9yVG9IZWFkZXIoZXJyKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgICAgIHN2LnN0YXRzLmNvdW50TGF0ZW5jeShzdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIHN2LnN1YiA9IHRoaXMubmMuc3Vic2NyaWJlKHN1YmplY3QsIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgcXVldWVcbiAgICAgICAgfSk7XG4gICAgICAgIHN2LnN1Yi5jbG9zZWQudGhlbigoKT0+e1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9zdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZShuZXcgRXJyb3IoYHJlcXVpcmVkIHN1YnNjcmlwdGlvbiAke2guc3ViamVjdH0gc3RvcHBlZGApKS5jYXRjaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9zdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmUgPSBuZXcgRXJyb3IoYHJlcXVpcmVkIHN1YnNjcmlwdGlvbiAke2guc3ViamVjdH0gZXJyb3JlZDogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICBuZS5zdGFjayA9IGVyci5zdGFjaztcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKG5lKS5jYXRjaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHN2O1xuICAgIH1cbiAgICBpbmZvKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU2VydmljZVJlc3BvbnNlVHlwZS5JTkZPLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICB2ZXJzaW9uOiB0aGlzLnZlcnNpb24sXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgIG1ldGFkYXRhOiB0aGlzLm1ldGFkYXRhLFxuICAgICAgICAgICAgZW5kcG9pbnRzOiB0aGlzLmVuZHBvaW50cygpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVuZHBvaW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubWFwKCh2KT0+e1xuICAgICAgICAgICAgY29uc3QgeyBzdWJqZWN0LCBtZXRhZGF0YSwgbmFtZSwgcXVldWUgfSA9IHY7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1YmplY3QsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBxdWV1ZV9ncm91cDogcXVldWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBzdGF0cygpIHtcbiAgICAgICAgY29uc3QgZW5kcG9pbnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgaCBvZiB0aGlzLmhhbmRsZXJzKXtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5jb25maWcuc3RhdHNIYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBoLnN0YXRzLmRhdGEgPSBhd2FpdCB0aGlzLmNvbmZpZy5zdGF0c0hhbmRsZXIoaCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGguc3RhdHMuY291bnRFcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVuZHBvaW50cy5wdXNoKGguc3RhdHMuc3RhdHMoaC5xaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTZXJ2aWNlUmVzcG9uc2VUeXBlLlNUQVRTLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICB2ZXJzaW9uOiB0aGlzLnZlcnNpb24sXG4gICAgICAgICAgICBzdGFydGVkOiB0aGlzLnN0YXJ0ZWQsXG4gICAgICAgICAgICBtZXRhZGF0YTogdGhpcy5tZXRhZGF0YSxcbiAgICAgICAgICAgIGVuZHBvaW50c1xuICAgICAgICB9O1xuICAgIH1cbiAgICBhZGRJbnRlcm5hbEhhbmRsZXIodmVyYiwgaGFuZGxlcikge1xuICAgICAgICBjb25zdCB2ID0gYCR7dmVyYn1gLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHRoaXMuX2RvQWRkSW50ZXJuYWxIYW5kbGVyKGAke3Z9LWFsbGAsIHZlcmIsIGhhbmRsZXIpO1xuICAgICAgICB0aGlzLl9kb0FkZEludGVybmFsSGFuZGxlcihgJHt2fS1raW5kYCwgdmVyYiwgaGFuZGxlciwgdGhpcy5uYW1lKTtcbiAgICAgICAgdGhpcy5fZG9BZGRJbnRlcm5hbEhhbmRsZXIoYCR7dn1gLCB2ZXJiLCBoYW5kbGVyLCB0aGlzLm5hbWUsIHRoaXMuaWQpO1xuICAgIH1cbiAgICBfZG9BZGRJbnRlcm5hbEhhbmRsZXIobmFtZSwgdmVyYiwgaGFuZGxlciwga2luZCA9IFwiXCIsIGlkID0gXCJcIikge1xuICAgICAgICBjb25zdCBlbmRwb2ludCA9IHt9O1xuICAgICAgICBlbmRwb2ludC5uYW1lID0gbmFtZTtcbiAgICAgICAgZW5kcG9pbnQuc3ViamVjdCA9IFNlcnZpY2VJbXBsLmNvbnRyb2xTdWJqZWN0KHZlcmIsIGtpbmQsIGlkKTtcbiAgICAgICAgZW5kcG9pbnQuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgIHRoaXMuc2V0dXBIYW5kbGVyKGVuZHBvaW50LCB0cnVlKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGNvbnN0IGpjID0gSlNPTkNvZGVjKCk7XG4gICAgICAgIGNvbnN0IHN0YXRzSGFuZGxlciA9IChlcnIsIG1zZyk9PntcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0cygpLnRoZW4oKHMpPT57XG4gICAgICAgICAgICAgICAgbXNnPy5yZXNwb25kKGpjLmVuY29kZShzKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGluZm9IYW5kbGVyID0gKGVyciwgbXNnKT0+e1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1zZz8ucmVzcG9uZChqYy5lbmNvZGUodGhpcy5pbmZvKCkpKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcGluZyA9IGpjLmVuY29kZSh0aGlzLnBpbmcoKSk7XG4gICAgICAgIGNvbnN0IHBpbmdIYW5kbGVyID0gKGVyciwgbXNnKT0+e1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoZXJyKS50aGVuKCkuY2F0Y2goKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1zZy5yZXNwb25kKHBpbmcpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFkZEludGVybmFsSGFuZGxlcihTZXJ2aWNlVmVyYi5QSU5HLCBwaW5nSGFuZGxlcik7XG4gICAgICAgIHRoaXMuYWRkSW50ZXJuYWxIYW5kbGVyKFNlcnZpY2VWZXJiLlNUQVRTLCBzdGF0c0hhbmRsZXIpO1xuICAgICAgICB0aGlzLmFkZEludGVybmFsSGFuZGxlcihTZXJ2aWNlVmVyYi5JTkZPLCBpbmZvSGFuZGxlcik7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMuZm9yRWFjaCgoaCk9PntcbiAgICAgICAgICAgIGNvbnN0IHsgc3ViamVjdCB9ID0gaDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3ViamVjdCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoLmhhbmRsZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldHVwSGFuZGxlcihoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcyk7XG4gICAgfVxuICAgIGNsb3NlKGVycikge1xuICAgICAgICBpZiAodGhpcy5fc3RvcHBlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RvbmU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG4gICAgICAgIGxldCBidWYgPSBbXTtcbiAgICAgICAgaWYgKCF0aGlzLm5jLmlzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgIGJ1ZiA9IHRoaXMuaGFuZGxlcnMuY29uY2F0KHRoaXMuaW50ZXJuYWwpLm1hcCgoaCk9PntcbiAgICAgICAgICAgICAgICByZXR1cm4gaC5zdWIuZHJhaW4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIFByb21pc2UuYWxsU2V0dGxlZChidWYpLnRoZW4oKCk9PntcbiAgICAgICAgICAgIHRoaXMuX2RvbmUucmVzb2x2ZShlcnIgPyBlcnIgOiBudWxsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kb25lO1xuICAgIH1cbiAgICBnZXQgc3RvcHBlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvbmU7XG4gICAgfVxuICAgIGdldCBpc1N0b3BwZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkO1xuICAgIH1cbiAgICBzdG9wKGVycikge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9zZShlcnIpO1xuICAgIH1cbiAgICBwaW5nKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU2VydmljZVJlc3BvbnNlVHlwZS5QSU5HLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICB2ZXJzaW9uOiB0aGlzLnZlcnNpb24sXG4gICAgICAgICAgICBtZXRhZGF0YTogdGhpcy5tZXRhZGF0YVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICBpZiAodGhpcy5oYW5kbGVycykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBoIG9mIHRoaXMuaGFuZGxlcnMpe1xuICAgICAgICAgICAgICAgIGguc3RhdHMucmVzZXQoaC5xaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkR3JvdXAobmFtZSwgcXVldWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXJ2aWNlR3JvdXBJbXBsKHRoaXMsIG5hbWUsIHF1ZXVlKTtcbiAgICB9XG4gICAgYWRkRW5kcG9pbnQobmFtZSwgaGFuZGxlcikge1xuICAgICAgICBjb25zdCBzZyA9IG5ldyBTZXJ2aWNlR3JvdXBJbXBsKHRoaXMpO1xuICAgICAgICByZXR1cm4gc2cuYWRkRW5kcG9pbnQobmFtZSwgaGFuZGxlcik7XG4gICAgfVxuICAgIF9hZGRFbmRwb2ludChlKSB7XG4gICAgICAgIGNvbnN0IHFpID0gbmV3IFF1ZXVlZEl0ZXJhdG9ySW1wbCgpO1xuICAgICAgICBxaS5ub0l0ZXJhdG9yID0gdHlwZW9mIGUuaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgICBpZiAoIXFpLm5vSXRlcmF0b3IpIHtcbiAgICAgICAgICAgIGUuaGFuZGxlciA9IChlcnIsIG1zZyk9PntcbiAgICAgICAgICAgICAgICBlcnIgPyB0aGlzLnN0b3AoZXJyKS5jYXRjaCgpIDogcWkucHVzaChuZXcgU2VydmljZU1zZ0ltcGwobXNnKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcWkuaXRlckNsb3NlZC50aGVuKCgpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpLmNhdGNoKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcyA9IHRoaXMuc2V0dXBIYW5kbGVyKGUsIGZhbHNlKTtcbiAgICAgICAgc3MucWkgPSBxaTtcbiAgICAgICAgdGhpcy5oYW5kbGVycy5wdXNoKHNzKTtcbiAgICAgICAgcmV0dXJuIHFpO1xuICAgIH1cbn1cbmNsYXNzIE5hbWVkRW5kcG9pbnRTdGF0c0ltcGwge1xuICAgIG5hbWU7XG4gICAgc3ViamVjdDtcbiAgICBhdmVyYWdlX3Byb2Nlc3NpbmdfdGltZTtcbiAgICBudW1fcmVxdWVzdHM7XG4gICAgcHJvY2Vzc2luZ190aW1lO1xuICAgIG51bV9lcnJvcnM7XG4gICAgbGFzdF9lcnJvcjtcbiAgICBkYXRhO1xuICAgIG1ldGFkYXRhO1xuICAgIHF1ZXVlO1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHN1YmplY3QsIHF1ZXVlID0gXCJcIil7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IHN1YmplY3Q7XG4gICAgICAgIHRoaXMuYXZlcmFnZV9wcm9jZXNzaW5nX3RpbWUgPSAwO1xuICAgICAgICB0aGlzLm51bV9lcnJvcnMgPSAwO1xuICAgICAgICB0aGlzLm51bV9yZXF1ZXN0cyA9IDA7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ190aW1lID0gMDtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IHF1ZXVlO1xuICAgIH1cbiAgICByZXNldChxaSkge1xuICAgICAgICB0aGlzLm51bV9yZXF1ZXN0cyA9IDA7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ190aW1lID0gMDtcbiAgICAgICAgdGhpcy5hdmVyYWdlX3Byb2Nlc3NpbmdfdGltZSA9IDA7XG4gICAgICAgIHRoaXMubnVtX2Vycm9ycyA9IDA7XG4gICAgICAgIHRoaXMubGFzdF9lcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5kYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBxaWkgPSBxaTtcbiAgICAgICAgaWYgKHFpaSkge1xuICAgICAgICAgICAgcWlpLnRpbWUgPSAwO1xuICAgICAgICAgICAgcWlpLnByb2Nlc3NlZCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY291bnRMYXRlbmN5KHN0YXJ0KSB7XG4gICAgICAgIHRoaXMubnVtX3JlcXVlc3RzKys7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ190aW1lICs9IG5hbm9zKERhdGUubm93KCkgLSBzdGFydCk7XG4gICAgICAgIHRoaXMuYXZlcmFnZV9wcm9jZXNzaW5nX3RpbWUgPSBNYXRoLnJvdW5kKHRoaXMucHJvY2Vzc2luZ190aW1lIC8gdGhpcy5udW1fcmVxdWVzdHMpO1xuICAgIH1cbiAgICBjb3VudEVycm9yKGVycikge1xuICAgICAgICB0aGlzLm51bV9lcnJvcnMrKztcbiAgICAgICAgdGhpcy5sYXN0X2Vycm9yID0gZXJyLm1lc3NhZ2U7XG4gICAgfVxuICAgIF9zdGF0cygpIHtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBzdWJqZWN0LCBhdmVyYWdlX3Byb2Nlc3NpbmdfdGltZSwgbnVtX2Vycm9ycywgbnVtX3JlcXVlc3RzLCBwcm9jZXNzaW5nX3RpbWUsIGxhc3RfZXJyb3IsIGRhdGEsIHF1ZXVlIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHN1YmplY3QsXG4gICAgICAgICAgICBhdmVyYWdlX3Byb2Nlc3NpbmdfdGltZSxcbiAgICAgICAgICAgIG51bV9lcnJvcnMsXG4gICAgICAgICAgICBudW1fcmVxdWVzdHMsXG4gICAgICAgICAgICBwcm9jZXNzaW5nX3RpbWUsXG4gICAgICAgICAgICBsYXN0X2Vycm9yLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHF1ZXVlX2dyb3VwOiBxdWV1ZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0cyhxaSkge1xuICAgICAgICBjb25zdCBxaWkgPSBxaTtcbiAgICAgICAgaWYgKHFpaT8ubm9JdGVyYXRvciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZ190aW1lID0gbmFub3MocWlpLnRpbWUpO1xuICAgICAgICAgICAgdGhpcy5udW1fcmVxdWVzdHMgPSBxaWkucHJvY2Vzc2VkO1xuICAgICAgICAgICAgdGhpcy5hdmVyYWdlX3Byb2Nlc3NpbmdfdGltZSA9IHRoaXMucHJvY2Vzc2luZ190aW1lID4gMCAmJiB0aGlzLm51bV9yZXF1ZXN0cyA+IDAgPyB0aGlzLnByb2Nlc3NpbmdfdGltZSAvIHRoaXMubnVtX3JlcXVlc3RzIDogMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdHMoKTtcbiAgICB9XG59XG5jbGFzcyBTZXJ2aWNlQ2xpZW50SW1wbCB7XG4gICAgbmM7XG4gICAgcHJlZml4O1xuICAgIG9wdHM7XG4gICAgY29uc3RydWN0b3IobmMsIG9wdHMgPSB7XG4gICAgICAgIHN0cmF0ZWd5OiBSZXF1ZXN0U3RyYXRlZ3kuSml0dGVyVGltZXIsXG4gICAgICAgIG1heFdhaXQ6IDIwMDBcbiAgICB9LCBwcmVmaXgpe1xuICAgICAgICB0aGlzLm5jID0gbmM7XG4gICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgIH1cbiAgICBwaW5nKG5hbWUgPSBcIlwiLCBpZCA9IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucShTZXJ2aWNlVmVyYi5QSU5HLCBuYW1lLCBpZCk7XG4gICAgfVxuICAgIHN0YXRzKG5hbWUgPSBcIlwiLCBpZCA9IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucShTZXJ2aWNlVmVyYi5TVEFUUywgbmFtZSwgaWQpO1xuICAgIH1cbiAgICBpbmZvKG5hbWUgPSBcIlwiLCBpZCA9IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucShTZXJ2aWNlVmVyYi5JTkZPLCBuYW1lLCBpZCk7XG4gICAgfVxuICAgIGFzeW5jIHEodiwgbmFtZSA9IFwiXCIsIGlkID0gXCJcIikge1xuICAgICAgICBjb25zdCBpdGVyID0gbmV3IFF1ZXVlZEl0ZXJhdG9ySW1wbCgpO1xuICAgICAgICBjb25zdCBqYyA9IEpTT05Db2RlYygpO1xuICAgICAgICBjb25zdCBzdWJqID0gU2VydmljZUltcGwuY29udHJvbFN1YmplY3QodiwgbmFtZSwgaWQsIHRoaXMucHJlZml4KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgdGhpcy5uYy5yZXF1ZXN0TWFueShzdWJqLCBFbXB0eSwgdGhpcy5vcHRzKTtcbiAgICAgICAgKGFzeW5jICgpPT57XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IG0gb2YgcmVzcG9uc2VzKXtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzID0gamMuZGVjb2RlKG0uZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXIucHVzaChzKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlci5wdXNoKCgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVyLnN0b3AoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlci5wdXNoKCgpPT57XG4gICAgICAgICAgICAgICAgaXRlci5zdG9wKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgaXRlci5zdG9wKGVycik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaXRlcjtcbiAgICB9XG59XG5jbGFzcyBNZXRyaWMge1xuICAgIG5hbWU7XG4gICAgZHVyYXRpb247XG4gICAgZGF0ZTtcbiAgICBwYXlsb2FkO1xuICAgIG1zZ3M7XG4gICAgbGFuZztcbiAgICB2ZXJzaW9uO1xuICAgIGJ5dGVzO1xuICAgIGFzeW5jUmVxdWVzdHM7XG4gICAgbWluO1xuICAgIG1heDtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBkdXJhdGlvbil7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgdGhpcy5kYXRlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5wYXlsb2FkID0gMDtcbiAgICAgICAgdGhpcy5tc2dzID0gMDtcbiAgICAgICAgdGhpcy5ieXRlcyA9IDA7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBzZWMgPSB0aGlzLmR1cmF0aW9uIC8gMTAwMDtcbiAgICAgICAgY29uc3QgbXBzID0gTWF0aC5yb3VuZCh0aGlzLm1zZ3MgLyBzZWMpO1xuICAgICAgICBjb25zdCBsYWJlbCA9IHRoaXMuYXN5bmNSZXF1ZXN0cyA/IFwiYXN5bmNSZXF1ZXN0c1wiIDogXCJcIjtcbiAgICAgICAgbGV0IG1pbm1heCA9IFwiXCI7XG4gICAgICAgIGlmICh0aGlzLm1heCkge1xuICAgICAgICAgICAgbWlubWF4ID0gYCR7dGhpcy5taW59LyR7dGhpcy5tYXh9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSR7bGFiZWwgPyBcIiBbYXN5bmNSZXF1ZXN0c11cIiA6IFwiXCJ9ICR7aHVtYW5pemVOdW1iZXIobXBzKX0gbXNncy9zZWMgLSBbJHtzZWMudG9GaXhlZCgyKX0gc2Vjc10gfiAke3Rocm91Z2hwdXQodGhpcy5ieXRlcywgc2VjKX0gJHttaW5tYXh9YDtcbiAgICB9XG4gICAgdG9Dc3YoKSB7XG4gICAgICAgIHJldHVybiBgXCIke3RoaXMubmFtZX1cIiwke25ldyBEYXRlKHRoaXMuZGF0ZSkudG9JU09TdHJpbmcoKX0sJHt0aGlzLmxhbmd9LCR7dGhpcy52ZXJzaW9ufSwke3RoaXMubXNnc30sJHt0aGlzLnBheWxvYWR9LCR7dGhpcy5ieXRlc30sJHt0aGlzLmR1cmF0aW9ufSwke3RoaXMuYXN5bmNSZXF1ZXN0cyA/IHRoaXMuYXN5bmNSZXF1ZXN0cyA6IGZhbHNlfVxcbmA7XG4gICAgfVxuICAgIHN0YXRpYyBoZWFkZXIoKSB7XG4gICAgICAgIHJldHVybiBgVGVzdCxEYXRlLExhbmcsVmVyc2lvbixDb3VudCxNc2dQYXlsb2FkLEJ5dGVzLE1pbGxpcyxBc3luY1xcbmA7XG4gICAgfVxufVxuY2xhc3MgQmVuY2gge1xuICAgIG5jO1xuICAgIGNhbGxiYWNrcztcbiAgICBtc2dzO1xuICAgIHNpemU7XG4gICAgc3ViamVjdDtcbiAgICBhc3luY1JlcXVlc3RzO1xuICAgIHB1YjtcbiAgICBzdWI7XG4gICAgcmVxO1xuICAgIHJlcDtcbiAgICBwZXJmO1xuICAgIHBheWxvYWQ7XG4gICAgY29uc3RydWN0b3IobmMsIG9wdHMgPSB7XG4gICAgICAgIG1zZ3M6IDEwMDAwMCxcbiAgICAgICAgc2l6ZTogMTI4LFxuICAgICAgICBzdWJqZWN0OiBcIlwiLFxuICAgICAgICBhc3luY1JlcXVlc3RzOiBmYWxzZSxcbiAgICAgICAgcHViOiBmYWxzZSxcbiAgICAgICAgc3ViOiBmYWxzZSxcbiAgICAgICAgcmVxOiBmYWxzZSxcbiAgICAgICAgcmVwOiBmYWxzZVxuICAgIH0pe1xuICAgICAgICB0aGlzLm5jID0gbmM7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gb3B0cy5jYWxsYmFja3MgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMubXNncyA9IG9wdHMubXNncyB8fCAwO1xuICAgICAgICB0aGlzLnNpemUgPSBvcHRzLnNpemUgfHwgMDtcbiAgICAgICAgdGhpcy5zdWJqZWN0ID0gb3B0cy5zdWJqZWN0IHx8IG51aWQubmV4dCgpO1xuICAgICAgICB0aGlzLmFzeW5jUmVxdWVzdHMgPSBvcHRzLmFzeW5jUmVxdWVzdHMgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMucHViID0gb3B0cy5wdWIgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMuc3ViID0gb3B0cy5zdWIgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMucmVxID0gb3B0cy5yZXEgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMucmVwID0gb3B0cy5yZXAgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMucGVyZiA9IG5ldyBQZXJmKCk7XG4gICAgICAgIHRoaXMucGF5bG9hZCA9IHRoaXMuc2l6ZSA/IG5ldyBVaW50OEFycmF5KHRoaXMuc2l6ZSkgOiBFbXB0eTtcbiAgICAgICAgaWYgKCF0aGlzLnB1YiAmJiAhdGhpcy5zdWIgJiYgIXRoaXMucmVxICYmICF0aGlzLnJlcCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gYmVuY2ggb3B0aW9uIHNlbGVjdGVkXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJ1bigpIHtcbiAgICAgICAgdGhpcy5uYy5jbG9zZWQoKS50aGVuKChlcnIpPT57XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5hdHNFcnJvcihgYmVuY2ggY2xvc2VkIHdpdGggYW4gZXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YCwgRXJyb3JDb2RlLlVua25vd24sIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucnVuQ2FsbGJhY2tzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJ1bkFzeW5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc01ldHJpY3MoKTtcbiAgICB9XG4gICAgcHJvY2Vzc01ldHJpY3MoKSB7XG4gICAgICAgIGNvbnN0IG5jID0gdGhpcy5uYztcbiAgICAgICAgY29uc3QgeyBsYW5nLCB2ZXJzaW9uIH0gPSBuYy5wcm90b2NvbC50cmFuc3BvcnQ7XG4gICAgICAgIGlmICh0aGlzLnB1YiAmJiB0aGlzLnN1Yikge1xuICAgICAgICAgICAgdGhpcy5wZXJmLm1lYXN1cmUoXCJwdWJzdWJcIiwgXCJwdWJTdGFydFwiLCBcInN1YlN0b3BcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVxICYmIHRoaXMucmVwKSB7XG4gICAgICAgICAgICB0aGlzLnBlcmYubWVhc3VyZShcInJlcXJlcFwiLCBcInJlcVN0YXJ0XCIsIFwicmVxU3RvcFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZWFzdXJlcyA9IHRoaXMucGVyZi5nZXRFbnRyaWVzKCk7XG4gICAgICAgIGNvbnN0IHB1YnN1YiA9IG1lYXN1cmVzLmZpbmQoKG0pPT5tLm5hbWUgPT09IFwicHVic3ViXCIpO1xuICAgICAgICBjb25zdCByZXFyZXAgPSBtZWFzdXJlcy5maW5kKChtKT0+bS5uYW1lID09PSBcInJlcXJlcFwiKTtcbiAgICAgICAgY29uc3QgcmVxID0gbWVhc3VyZXMuZmluZCgobSk9Pm0ubmFtZSA9PT0gXCJyZXFcIik7XG4gICAgICAgIGNvbnN0IHJlcCA9IG1lYXN1cmVzLmZpbmQoKG0pPT5tLm5hbWUgPT09IFwicmVwXCIpO1xuICAgICAgICBjb25zdCBwdWIgPSBtZWFzdXJlcy5maW5kKChtKT0+bS5uYW1lID09PSBcInB1YlwiKTtcbiAgICAgICAgY29uc3Qgc3ViID0gbWVhc3VyZXMuZmluZCgobSk9Pm0ubmFtZSA9PT0gXCJzdWJcIik7XG4gICAgICAgIGNvbnN0IHN0YXRzID0gdGhpcy5uYy5zdGF0cygpO1xuICAgICAgICBjb25zdCBtZXRyaWNzID0gW107XG4gICAgICAgIGlmIChwdWJzdWIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZSwgZHVyYXRpb24gfSA9IHB1YnN1YjtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBuZXcgTWV0cmljKG5hbWUsIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIG0ubXNncyA9IHRoaXMubXNncyAqIDI7XG4gICAgICAgICAgICBtLmJ5dGVzID0gc3RhdHMuaW5CeXRlcyArIHN0YXRzLm91dEJ5dGVzO1xuICAgICAgICAgICAgbS5sYW5nID0gbGFuZztcbiAgICAgICAgICAgIG0udmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgICBtLnBheWxvYWQgPSB0aGlzLnBheWxvYWQubGVuZ3RoO1xuICAgICAgICAgICAgbWV0cmljcy5wdXNoKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXFyZXApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZSwgZHVyYXRpb24gfSA9IHJlcXJlcDtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBuZXcgTWV0cmljKG5hbWUsIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIG0ubXNncyA9IHRoaXMubXNncyAqIDI7XG4gICAgICAgICAgICBtLmJ5dGVzID0gc3RhdHMuaW5CeXRlcyArIHN0YXRzLm91dEJ5dGVzO1xuICAgICAgICAgICAgbS5sYW5nID0gbGFuZztcbiAgICAgICAgICAgIG0udmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgICBtLnBheWxvYWQgPSB0aGlzLnBheWxvYWQubGVuZ3RoO1xuICAgICAgICAgICAgbWV0cmljcy5wdXNoKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwdWIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZSwgZHVyYXRpb24gfSA9IHB1YjtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBuZXcgTWV0cmljKG5hbWUsIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIG0ubXNncyA9IHRoaXMubXNncztcbiAgICAgICAgICAgIG0uYnl0ZXMgPSBzdGF0cy5vdXRCeXRlcztcbiAgICAgICAgICAgIG0ubGFuZyA9IGxhbmc7XG4gICAgICAgICAgICBtLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICAgICAgbS5wYXlsb2FkID0gdGhpcy5wYXlsb2FkLmxlbmd0aDtcbiAgICAgICAgICAgIG1ldHJpY3MucHVzaChtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3ViKSB7XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUsIGR1cmF0aW9uIH0gPSBzdWI7XG4gICAgICAgICAgICBjb25zdCBtID0gbmV3IE1ldHJpYyhuYW1lLCBkdXJhdGlvbik7XG4gICAgICAgICAgICBtLm1zZ3MgPSB0aGlzLm1zZ3M7XG4gICAgICAgICAgICBtLmJ5dGVzID0gc3RhdHMuaW5CeXRlcztcbiAgICAgICAgICAgIG0ubGFuZyA9IGxhbmc7XG4gICAgICAgICAgICBtLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICAgICAgbS5wYXlsb2FkID0gdGhpcy5wYXlsb2FkLmxlbmd0aDtcbiAgICAgICAgICAgIG1ldHJpY3MucHVzaChtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVwKSB7XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUsIGR1cmF0aW9uIH0gPSByZXA7XG4gICAgICAgICAgICBjb25zdCBtID0gbmV3IE1ldHJpYyhuYW1lLCBkdXJhdGlvbik7XG4gICAgICAgICAgICBtLm1zZ3MgPSB0aGlzLm1zZ3M7XG4gICAgICAgICAgICBtLmJ5dGVzID0gc3RhdHMuaW5CeXRlcyArIHN0YXRzLm91dEJ5dGVzO1xuICAgICAgICAgICAgbS5sYW5nID0gbGFuZztcbiAgICAgICAgICAgIG0udmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgICBtLnBheWxvYWQgPSB0aGlzLnBheWxvYWQubGVuZ3RoO1xuICAgICAgICAgICAgbWV0cmljcy5wdXNoKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXEpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZSwgZHVyYXRpb24gfSA9IHJlcTtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBuZXcgTWV0cmljKG5hbWUsIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIG0ubXNncyA9IHRoaXMubXNncztcbiAgICAgICAgICAgIG0uYnl0ZXMgPSBzdGF0cy5pbkJ5dGVzICsgc3RhdHMub3V0Qnl0ZXM7XG4gICAgICAgICAgICBtLmxhbmcgPSBsYW5nO1xuICAgICAgICAgICAgbS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgICAgIG0ucGF5bG9hZCA9IHRoaXMucGF5bG9hZC5sZW5ndGg7XG4gICAgICAgICAgICBtZXRyaWNzLnB1c2gobSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldHJpY3M7XG4gICAgfVxuICAgIGFzeW5jIHJ1bkNhbGxiYWNrcygpIHtcbiAgICAgICAgY29uc3Qgam9icyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5zdWIpIHtcbiAgICAgICAgICAgIGNvbnN0IGQgPSBkZWZlcnJlZCgpO1xuICAgICAgICAgICAgam9icy5wdXNoKGQpO1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgdGhpcy5uYy5zdWJzY3JpYmUodGhpcy5zdWJqZWN0LCB7XG4gICAgICAgICAgICAgICAgbWF4OiB0aGlzLm1zZ3MsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6ICgpPT57XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tYXJrKFwic3ViU3RhcnRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IHRoaXMubXNncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1hcmsoXCJzdWJTdG9wXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1lYXN1cmUoXCJzdWJcIiwgXCJzdWJTdGFydFwiLCBcInN1YlN0b3BcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlcCkge1xuICAgICAgICAgICAgY29uc3QgZCA9IGRlZmVycmVkKCk7XG4gICAgICAgICAgICBqb2JzLnB1c2goZCk7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICB0aGlzLm5jLnN1YnNjcmliZSh0aGlzLnN1YmplY3QsIHtcbiAgICAgICAgICAgICAgICBtYXg6IHRoaXMubXNncyxcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogKF8sIG0pPT57XG4gICAgICAgICAgICAgICAgICAgIG0ucmVzcG9uZCh0aGlzLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWFyayhcInJlcFN0YXJ0XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSB0aGlzLm1zZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tYXJrKFwicmVwU3RvcFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tZWFzdXJlKFwicmVwXCIsIFwicmVwU3RhcnRcIiwgXCJyZXBTdG9wXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wdWIpIHtcbiAgICAgICAgICAgIGNvbnN0IGpvYiA9IChhc3luYyAoKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tYXJrKFwicHViU3RhcnRcIik7XG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMubXNnczsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYy5wdWJsaXNoKHRoaXMuc3ViamVjdCwgdGhpcy5wYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5uYy5mbHVzaCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tYXJrKFwicHViU3RvcFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWVhc3VyZShcInB1YlwiLCBcInB1YlN0YXJ0XCIsIFwicHViU3RvcFwiKTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBqb2JzLnB1c2goam9iKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXEpIHtcbiAgICAgICAgICAgIGNvbnN0IGpvYiA9IChhc3luYyAoKT0+e1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFzeW5jUmVxdWVzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1hcmsoXCJyZXFTdGFydFwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5tc2dzOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHRoaXMubmMucmVxdWVzdCh0aGlzLnN1YmplY3QsIHRoaXMucGF5bG9hZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IDIwMDAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoYSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tYXJrKFwicmVxU3RvcFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1lYXN1cmUoXCJyZXFcIiwgXCJyZXFTdGFydFwiLCBcInJlcVN0b3BcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1hcmsoXCJyZXFTdGFydFwiKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMubXNnczsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMubmMucmVxdWVzdCh0aGlzLnN1YmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tYXJrKFwicmVxU3RvcFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1lYXN1cmUoXCJyZXFcIiwgXCJyZXFTdGFydFwiLCBcInJlcVN0b3BcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIGpvYnMucHVzaChqb2IpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGpvYnMpO1xuICAgIH1cbiAgICBhc3luYyBydW5Bc3luYygpIHtcbiAgICAgICAgY29uc3Qgam9icyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5yZXApIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3Qgc3ViID0gdGhpcy5uYy5zdWJzY3JpYmUodGhpcy5zdWJqZWN0LCB7XG4gICAgICAgICAgICAgICAgbWF4OiB0aGlzLm1zZ3NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgam9iID0gKGFzeW5jICgpPT57XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBtIG9mIHN1Yil7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tYXJrKFwicmVwU3RhcnRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbS5yZXNwb25kKHRoaXMucGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMubmMuZmx1c2goKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWFyayhcInJlcFN0b3BcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1lYXN1cmUoXCJyZXBcIiwgXCJyZXBTdGFydFwiLCBcInJlcFN0b3BcIik7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgam9icy5wdXNoKGpvYik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3ViKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IHRoaXMubmMuc3Vic2NyaWJlKHRoaXMuc3ViamVjdCwge1xuICAgICAgICAgICAgICAgIG1heDogdGhpcy5tc2dzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGpvYiA9IChhc3luYyAoKT0+e1xuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgX20gb2Ygc3ViKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1hcmsoXCJzdWJTdGFydFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWFyayhcInN1YlN0b3BcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1lYXN1cmUoXCJzdWJcIiwgXCJzdWJTdGFydFwiLCBcInN1YlN0b3BcIik7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgam9icy5wdXNoKGpvYik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHViKSB7XG4gICAgICAgICAgICBjb25zdCBqb2IgPSAoYXN5bmMgKCk9PntcbiAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWFyayhcInB1YlN0YXJ0XCIpO1xuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLm1zZ3M7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmMucHVibGlzaCh0aGlzLnN1YmplY3QsIHRoaXMucGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMubmMuZmx1c2goKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWFyayhcInB1YlN0b3BcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1lYXN1cmUoXCJwdWJcIiwgXCJwdWJTdGFydFwiLCBcInB1YlN0b3BcIik7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgam9icy5wdXNoKGpvYik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVxKSB7XG4gICAgICAgICAgICBjb25zdCBqb2IgPSAoYXN5bmMgKCk9PntcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hc3luY1JlcXVlc3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tYXJrKFwicmVxU3RhcnRcIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMubXNnczsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaCh0aGlzLm5jLnJlcXVlc3QodGhpcy5zdWJqZWN0LCB0aGlzLnBheWxvYWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiAyMDAwMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWFyayhcInJlcVN0b3BcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tZWFzdXJlKFwicmVxXCIsIFwicmVxU3RhcnRcIiwgXCJyZXFTdG9wXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tYXJrKFwicmVxU3RhcnRcIik7XG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLm1zZ3M7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm5jLnJlcXVlc3QodGhpcy5zdWJqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWFyayhcInJlcVN0b3BcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tZWFzdXJlKFwicmVxXCIsIFwicmVxU3RhcnRcIiwgXCJyZXFTdG9wXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBqb2JzLnB1c2goam9iKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChqb2JzKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0aHJvdWdocHV0KGJ5dGVzLCBzZWNvbmRzKSB7XG4gICAgcmV0dXJuIGAke2h1bWFuaXplQnl0ZXMoYnl0ZXMgLyBzZWNvbmRzKX0vc2VjYDtcbn1cbmZ1bmN0aW9uIGh1bWFuaXplQnl0ZXMoYnl0ZXMsIHNpID0gZmFsc2UpIHtcbiAgICBjb25zdCBiYXNlID0gc2kgPyAxMDAwIDogMTAyNDtcbiAgICBjb25zdCBwcmUgPSBzaSA/IFtcbiAgICAgICAgXCJrXCIsXG4gICAgICAgIFwiTVwiLFxuICAgICAgICBcIkdcIixcbiAgICAgICAgXCJUXCIsXG4gICAgICAgIFwiUFwiLFxuICAgICAgICBcIkVcIlxuICAgIF0gOiBbXG4gICAgICAgIFwiS1wiLFxuICAgICAgICBcIk1cIixcbiAgICAgICAgXCJHXCIsXG4gICAgICAgIFwiVFwiLFxuICAgICAgICBcIlBcIixcbiAgICAgICAgXCJFXCJcbiAgICBdO1xuICAgIGNvbnN0IHBvc3QgPSBzaSA/IFwiaUJcIiA6IFwiQlwiO1xuICAgIGlmIChieXRlcyA8IGJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGAke2J5dGVzLnRvRml4ZWQoMil9ICR7cG9zdH1gO1xuICAgIH1cbiAgICBjb25zdCBleHAgPSBwYXJzZUludChNYXRoLmxvZyhieXRlcykgLyBNYXRoLmxvZyhiYXNlKSArIFwiXCIpO1xuICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoZXhwIC0gMSArIFwiXCIpO1xuICAgIHJldHVybiBgJHsoYnl0ZXMgLyBNYXRoLnBvdyhiYXNlLCBleHApKS50b0ZpeGVkKDIpfSAke3ByZVtpbmRleF19JHtwb3N0fWA7XG59XG5mdW5jdGlvbiBodW1hbml6ZU51bWJlcihuKSB7XG4gICAgcmV0dXJuIG4udG9TdHJpbmcoKS5yZXBsYWNlKC9cXEIoPz0oXFxkezN9KSsoPyFcXGQpKS9nLCBcIixcIik7XG59XG5leHBvcnQgeyBiYWNrb2ZmIGFzIGJhY2tvZmYsIEJlbmNoIGFzIEJlbmNoLCBidWlsZEF1dGhlbnRpY2F0b3IgYXMgYnVpbGRBdXRoZW50aWNhdG9yLCBjYW5vbmljYWxNSU1FSGVhZGVyS2V5IGFzIGNhbm9uaWNhbE1JTUVIZWFkZXJLZXksIGNyZWF0ZUluYm94IGFzIGNyZWF0ZUluYm94LCBjcmVkc0F1dGhlbnRpY2F0b3IgYXMgY3JlZHNBdXRoZW50aWNhdG9yLCBkZWFkbGluZSBhcyBkZWFkbGluZSwgRGVidWdFdmVudHMgYXMgRGVidWdFdmVudHMsIGRlZmVycmVkIGFzIGRlZmVycmVkLCBkZWxheSBhcyBkZWxheSwgRW1wdHkgYXMgRW1wdHksIEVycm9yQ29kZSBhcyBFcnJvckNvZGUsIEV2ZW50cyBhcyBFdmVudHMsIGhlYWRlcnMgYXMgaGVhZGVycywgSlNPTkNvZGVjIGFzIEpTT05Db2RlYywgand0QXV0aGVudGljYXRvciBhcyBqd3RBdXRoZW50aWNhdG9yLCBNYXRjaCBhcyBNYXRjaCwgTWV0cmljIGFzIE1ldHJpYywgbWlsbGlzIGFzIG1pbGxpcywgTXNnSGRyc0ltcGwgYXMgTXNnSGRyc0ltcGwsIG5hbm9zIGFzIG5hbm9zLCBOYXRzRXJyb3IgYXMgTmF0c0Vycm9yLCBua2V5QXV0aGVudGljYXRvciBhcyBua2V5QXV0aGVudGljYXRvciwgbW9kIGFzIG5rZXlzLCBOdWlkIGFzIE51aWQsIG51aWQgYXMgbnVpZCwgUmVxdWVzdFN0cmF0ZWd5IGFzIFJlcXVlc3RTdHJhdGVneSwgU2VydmljZUVycm9yIGFzIFNlcnZpY2VFcnJvciwgU2VydmljZUVycm9yQ29kZUhlYWRlciBhcyBTZXJ2aWNlRXJyb3JDb2RlSGVhZGVyLCBTZXJ2aWNlRXJyb3JIZWFkZXIgYXMgU2VydmljZUVycm9ySGVhZGVyLCBTZXJ2aWNlUmVzcG9uc2VUeXBlIGFzIFNlcnZpY2VSZXNwb25zZVR5cGUsIFNlcnZpY2VWZXJiIGFzIFNlcnZpY2VWZXJiLCBTdHJpbmdDb2RlYyBhcyBTdHJpbmdDb2RlYywgc3luY0l0ZXJhdG9yIGFzIHN5bmNJdGVyYXRvciwgdG9rZW5BdXRoZW50aWNhdG9yIGFzIHRva2VuQXV0aGVudGljYXRvciwgdXNlcm5hbWVQYXNzd29yZEF1dGhlbnRpY2F0b3IgYXMgdXNlcm5hbWVQYXNzd29yZEF1dGhlbnRpY2F0b3IgfTtcbmZ1bmN0aW9uIE5vb3BLdkNvZGVjcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBrZXk6IHtcbiAgICAgICAgICAgIGVuY29kZSAoaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBrO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY29kZSAoaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgZW5jb2RlICh2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVjb2RlICh2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gZGVmYXVsdEJ1Y2tldE9wdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVwbGljYXM6IDEsXG4gICAgICAgIGhpc3Rvcnk6IDEsXG4gICAgICAgIHRpbWVvdXQ6IDIwMDAsXG4gICAgICAgIG1heF9ieXRlczogLTEsXG4gICAgICAgIG1heFZhbHVlU2l6ZTogLTEsXG4gICAgICAgIGNvZGVjOiBOb29wS3ZDb2RlY3MoKSxcbiAgICAgICAgc3RvcmFnZTogU3RvcmFnZVR5cGUuRmlsZVxuICAgIH07XG59XG5jb25zdCBrdk9wZXJhdGlvbkhkciA9IFwiS1YtT3BlcmF0aW9uXCI7XG5jb25zdCBrdlN1YmplY3RQcmVmaXggPSBcIiRLVlwiO1xuY29uc3QgdmFsaWRLZXlSZSA9IC9eWy0vPS5cXHddKyQvO1xuY29uc3QgdmFsaWRTZWFyY2hLZXkgPSAvXlstLz0uPipcXHddKyQvO1xuY29uc3QgdmFsaWRCdWNrZXRSZSA9IC9eWy1cXHddKyQvO1xuZnVuY3Rpb24gdmFsaWRhdGVLZXkoaykge1xuICAgIGlmIChrLnN0YXJ0c1dpdGgoXCIuXCIpIHx8IGsuZW5kc1dpdGgoXCIuXCIpIHx8ICF2YWxpZEtleVJlLnRlc3QoaykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGtleTogJHtrfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlU2VhcmNoS2V5KGspIHtcbiAgICBpZiAoay5zdGFydHNXaXRoKFwiLlwiKSB8fCBrLmVuZHNXaXRoKFwiLlwiKSB8fCAhdmFsaWRTZWFyY2hLZXkudGVzdChrKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQga2V5OiAke2t9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzV2lsZGNhcmRzKGspIHtcbiAgICBpZiAoay5zdGFydHNXaXRoKFwiLlwiKSB8fCBrLmVuZHNXaXRoKFwiLlwiKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQga2V5OiAke2t9YCk7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rcyA9IGsuc3BsaXQoXCIuXCIpO1xuICAgIGxldCBoYXNXaWxkY2FyZHMgPSBmYWxzZTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgc3dpdGNoKGNodW5rc1tpXSl7XG4gICAgICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICAgICAgICAgIGhhc1dpbGRjYXJkcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiPlwiOlxuICAgICAgICAgICAgICAgIGlmIChpICE9PSBjaHVua3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQga2V5OiAke2t9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhhc1dpbGRjYXJkcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoYXNXaWxkY2FyZHM7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUJ1Y2tldChuYW1lKSB7XG4gICAgaWYgKCF2YWxpZEJ1Y2tldFJlLnRlc3QobmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGJ1Y2tldCBuYW1lOiAke25hbWV9YCk7XG4gICAgfVxufVxudmFyIFB1YkhlYWRlcnM7XG4oZnVuY3Rpb24oUHViSGVhZGVycykge1xuICAgIFB1YkhlYWRlcnNbXCJNc2dJZEhkclwiXSA9IFwiTmF0cy1Nc2ctSWRcIjtcbiAgICBQdWJIZWFkZXJzW1wiRXhwZWN0ZWRTdHJlYW1IZHJcIl0gPSBcIk5hdHMtRXhwZWN0ZWQtU3RyZWFtXCI7XG4gICAgUHViSGVhZGVyc1tcIkV4cGVjdGVkTGFzdFNlcUhkclwiXSA9IFwiTmF0cy1FeHBlY3RlZC1MYXN0LVNlcXVlbmNlXCI7XG4gICAgUHViSGVhZGVyc1tcIkV4cGVjdGVkTGFzdE1zZ0lkSGRyXCJdID0gXCJOYXRzLUV4cGVjdGVkLUxhc3QtTXNnLUlkXCI7XG4gICAgUHViSGVhZGVyc1tcIkV4cGVjdGVkTGFzdFN1YmplY3RTZXF1ZW5jZUhkclwiXSA9IFwiTmF0cy1FeHBlY3RlZC1MYXN0LVN1YmplY3QtU2VxdWVuY2VcIjtcbn0pKFB1YkhlYWRlcnMgfHwgKFB1YkhlYWRlcnMgPSB7fSkpO1xuY2xhc3MgQnVja2V0IHtcbiAgICBqcztcbiAgICBqc207XG4gICAgc3RyZWFtO1xuICAgIGJ1Y2tldDtcbiAgICBkaXJlY3Q7XG4gICAgY29kZWM7XG4gICAgcHJlZml4O1xuICAgIGVkaXRQcmVmaXg7XG4gICAgdXNlSnNQcmVmaXg7XG4gICAgX3ByZWZpeExlbjtcbiAgICBjb25zdHJ1Y3RvcihidWNrZXQsIGpzLCBqc20pe1xuICAgICAgICB2YWxpZGF0ZUJ1Y2tldChidWNrZXQpO1xuICAgICAgICB0aGlzLmpzID0ganM7XG4gICAgICAgIHRoaXMuanNtID0ganNtO1xuICAgICAgICB0aGlzLmJ1Y2tldCA9IGJ1Y2tldDtcbiAgICAgICAgdGhpcy5wcmVmaXggPSBrdlN1YmplY3RQcmVmaXg7XG4gICAgICAgIHRoaXMuZWRpdFByZWZpeCA9IFwiXCI7XG4gICAgICAgIHRoaXMudXNlSnNQcmVmaXggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJlZml4TGVuID0gMDtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZShqcywgbmFtZSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHZhbGlkYXRlQnVja2V0KG5hbWUpO1xuICAgICAgICBjb25zdCBqc20gPSBhd2FpdCBqcy5qZXRzdHJlYW1NYW5hZ2VyKCk7XG4gICAgICAgIGNvbnN0IGJ1Y2tldCA9IG5ldyBCdWNrZXQobmFtZSwganMsIGpzbSk7XG4gICAgICAgIGF3YWl0IGJ1Y2tldC5pbml0KG9wdHMpO1xuICAgICAgICByZXR1cm4gYnVja2V0O1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgYmluZChqcywgbmFtZSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGpzbSA9IGF3YWl0IGpzLmpldHN0cmVhbU1hbmFnZXIoKTtcbiAgICAgICAgY29uc3QgaW5mbyA9IHtcbiAgICAgICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICAgICAgIGFsbG93X2RpcmVjdDogb3B0cy5hbGxvd19kaXJlY3RcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFsaWRhdGVCdWNrZXQobmFtZSk7XG4gICAgICAgIGNvbnN0IGJ1Y2tldCA9IG5ldyBCdWNrZXQobmFtZSwganMsIGpzbSk7XG4gICAgICAgIGluZm8uY29uZmlnLm5hbWUgPSBvcHRzLnN0cmVhbU5hbWUgPz8gYnVja2V0LmJ1Y2tldE5hbWUoKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihidWNrZXQsIGluZm8pO1xuICAgICAgICBidWNrZXQuc3RyZWFtID0gaW5mby5jb25maWcubmFtZTtcbiAgICAgICAgYnVja2V0LmNvZGVjID0gb3B0cy5jb2RlYyB8fCBOb29wS3ZDb2RlY3MoKTtcbiAgICAgICAgYnVja2V0LmRpcmVjdCA9IGluZm8uY29uZmlnLmFsbG93X2RpcmVjdCA/PyBmYWxzZTtcbiAgICAgICAgYnVja2V0LmluaXRpYWxpemVQcmVmaXhlcyhpbmZvKTtcbiAgICAgICAgcmV0dXJuIGJ1Y2tldDtcbiAgICB9XG4gICAgYXN5bmMgaW5pdChvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3QgYm8gPSBPYmplY3QuYXNzaWduKGRlZmF1bHRCdWNrZXRPcHRzKCksIG9wdHMpO1xuICAgICAgICB0aGlzLmNvZGVjID0gYm8uY29kZWM7XG4gICAgICAgIGNvbnN0IHNjID0ge307XG4gICAgICAgIHRoaXMuc3RyZWFtID0gc2MubmFtZSA9IG9wdHMuc3RyZWFtTmFtZSA/PyB0aGlzLmJ1Y2tldE5hbWUoKTtcbiAgICAgICAgc2MucmV0ZW50aW9uID0gUmV0ZW50aW9uUG9saWN5LkxpbWl0cztcbiAgICAgICAgc2MubWF4X21zZ3NfcGVyX3N1YmplY3QgPSBiby5oaXN0b3J5O1xuICAgICAgICBpZiAoYm8ubWF4QnVja2V0U2l6ZSkge1xuICAgICAgICAgICAgYm8ubWF4X2J5dGVzID0gYm8ubWF4QnVja2V0U2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYm8ubWF4X2J5dGVzKSB7XG4gICAgICAgICAgICBzYy5tYXhfYnl0ZXMgPSBiby5tYXhfYnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgc2MubWF4X21zZ19zaXplID0gYm8ubWF4VmFsdWVTaXplO1xuICAgICAgICBzYy5zdG9yYWdlID0gYm8uc3RvcmFnZTtcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSBvcHRzLnBsYWNlbWVudENsdXN0ZXIgPz8gXCJcIjtcbiAgICAgICAgaWYgKGxvY2F0aW9uKSB7XG4gICAgICAgICAgICBvcHRzLnBsYWNlbWVudCA9IHt9O1xuICAgICAgICAgICAgb3B0cy5wbGFjZW1lbnQuY2x1c3RlciA9IGxvY2F0aW9uO1xuICAgICAgICAgICAgb3B0cy5wbGFjZW1lbnQudGFncyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLnBsYWNlbWVudCkge1xuICAgICAgICAgICAgc2MucGxhY2VtZW50ID0gb3B0cy5wbGFjZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMucmVwdWJsaXNoKSB7XG4gICAgICAgICAgICBzYy5yZXB1Ymxpc2ggPSBvcHRzLnJlcHVibGlzaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgc2MuZGVzY3JpcHRpb24gPSBvcHRzLmRlc2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLm1pcnJvcikge1xuICAgICAgICAgICAgY29uc3QgbWlycm9yID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cy5taXJyb3IpO1xuICAgICAgICAgICAgaWYgKCFtaXJyb3IubmFtZS5zdGFydHNXaXRoKGt2UHJlZml4KSkge1xuICAgICAgICAgICAgICAgIG1pcnJvci5uYW1lID0gYCR7a3ZQcmVmaXh9JHttaXJyb3IubmFtZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2MubWlycm9yID0gbWlycm9yO1xuICAgICAgICAgICAgc2MubWlycm9yX2RpcmVjdCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0cy5zb3VyY2VzKSB7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VzID0gb3B0cy5zb3VyY2VzLm1hcCgocyk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gT2JqZWN0LmFzc2lnbih7fSwgcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3JjQnVja2V0TmFtZSA9IGMubmFtZS5zdGFydHNXaXRoKGt2UHJlZml4KSA/IGMubmFtZS5zdWJzdHJpbmcoa3ZQcmVmaXgubGVuZ3RoKSA6IGMubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoIWMubmFtZS5zdGFydHNXaXRoKGt2UHJlZml4KSkge1xuICAgICAgICAgICAgICAgICAgICBjLm5hbWUgPSBgJHtrdlByZWZpeH0ke2MubmFtZX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXMuZXh0ZXJuYWwgJiYgc3JjQnVja2V0TmFtZSAhPT0gdGhpcy5idWNrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgYy5zdWJqZWN0X3RyYW5zZm9ybXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjOiBgJEtWLiR7c3JjQnVja2V0TmFtZX0uPmAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdDogYCRLVi4ke3RoaXMuYnVja2V0fS4+YFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2Muc291cmNlcyA9IHNvdXJjZXM7XG4gICAgICAgICAgICBzYy5zdWJqZWN0cyA9IFtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YmplY3RGb3JCdWNrZXQoKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNjLnN1YmplY3RzID0gW1xuICAgICAgICAgICAgICAgIHRoaXMuc3ViamVjdEZvckJ1Y2tldCgpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLm1ldGFkYXRhKSB7XG4gICAgICAgICAgICBzYy5tZXRhZGF0YSA9IG9wdHMubWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLmNvbXByZXNzaW9uID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgc2MuY29tcHJlc3Npb24gPSBvcHRzLmNvbXByZXNzaW9uID8gU3RvcmVDb21wcmVzc2lvbi5TMiA6IFN0b3JlQ29tcHJlc3Npb24uTm9uZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuY2kgPSB0aGlzLmpzLm5jO1xuICAgICAgICBjb25zdCBoYXZlID0gbmNpLmdldFNlcnZlclZlcnNpb24oKTtcbiAgICAgICAgY29uc3QgZGlzY2FyZE5ldyA9IGhhdmUgPyBjb21wYXJlKGhhdmUsIHBhcnNlU2VtVmVyKFwiMi43LjJcIikpID49IDAgOiBmYWxzZTtcbiAgICAgICAgc2MuZGlzY2FyZCA9IGRpc2NhcmROZXcgPyBEaXNjYXJkUG9saWN5Lk5ldyA6IERpc2NhcmRQb2xpY3kuT2xkO1xuICAgICAgICBjb25zdCB7IG9rOiBkaXJlY3QsIG1pbiB9ID0gbmNpLmZlYXR1cmVzLmdldChGZWF0dXJlLkpTX0FMTE9XX0RJUkVDVCk7XG4gICAgICAgIGlmICghZGlyZWN0ICYmIG9wdHMuYWxsb3dfZGlyZWN0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gaGF2ZSA/IGAke2hhdmUubWFqb3J9LiR7aGF2ZS5taW5vcn0uJHtoYXZlLm1pY3JvfWAgOiBcInVua25vd25cIjtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYGFsbG93X2RpcmVjdCBpcyBub3QgYXZhaWxhYmxlIG9uIHNlcnZlciB2ZXJzaW9uICR7dn0gLSByZXF1aXJlcyAke21pbn1gKSk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0cy5hbGxvd19kaXJlY3QgPSB0eXBlb2Ygb3B0cy5hbGxvd19kaXJlY3QgPT09IFwiYm9vbGVhblwiID8gb3B0cy5hbGxvd19kaXJlY3QgOiBkaXJlY3Q7XG4gICAgICAgIHNjLmFsbG93X2RpcmVjdCA9IG9wdHMuYWxsb3dfZGlyZWN0O1xuICAgICAgICB0aGlzLmRpcmVjdCA9IHNjLmFsbG93X2RpcmVjdDtcbiAgICAgICAgc2MubnVtX3JlcGxpY2FzID0gYm8ucmVwbGljYXM7XG4gICAgICAgIGlmIChiby50dGwpIHtcbiAgICAgICAgICAgIHNjLm1heF9hZ2UgPSBuYW5vcyhiby50dGwpO1xuICAgICAgICB9XG4gICAgICAgIHNjLmFsbG93X3JvbGx1cF9oZHJzID0gdHJ1ZTtcbiAgICAgICAgbGV0IGluZm87XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpbmZvID0gYXdhaXQgdGhpcy5qc20uc3RyZWFtcy5pbmZvKHNjLm5hbWUpO1xuICAgICAgICAgICAgaWYgKCFpbmZvLmNvbmZpZy5hbGxvd19kaXJlY3QgJiYgdGhpcy5kaXJlY3QgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIubWVzc2FnZSA9PT0gXCJzdHJlYW0gbm90IGZvdW5kXCIpIHtcbiAgICAgICAgICAgICAgICBpbmZvID0gYXdhaXQgdGhpcy5qc20uc3RyZWFtcy5hZGQoc2MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0aWFsaXplUHJlZml4ZXMoaW5mbyk7XG4gICAgfVxuICAgIGluaXRpYWxpemVQcmVmaXhlcyhpbmZvKSB7XG4gICAgICAgIHRoaXMuX3ByZWZpeExlbiA9IDA7XG4gICAgICAgIHRoaXMucHJlZml4ID0gYCRLVi4ke3RoaXMuYnVja2V0fWA7XG4gICAgICAgIHRoaXMudXNlSnNQcmVmaXggPSB0aGlzLmpzLmFwaVByZWZpeCAhPT0gXCIkSlMuQVBJXCI7XG4gICAgICAgIGNvbnN0IHsgbWlycm9yIH0gPSBpbmZvLmNvbmZpZztcbiAgICAgICAgaWYgKG1pcnJvcikge1xuICAgICAgICAgICAgbGV0IG4gPSBtaXJyb3IubmFtZTtcbiAgICAgICAgICAgIGlmIChuLnN0YXJ0c1dpdGgoa3ZQcmVmaXgpKSB7XG4gICAgICAgICAgICAgICAgbiA9IG4uc3Vic3RyaW5nKGt2UHJlZml4Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWlycm9yLmV4dGVybmFsICYmIG1pcnJvci5leHRlcm5hbC5hcGkgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYiA9IG1pcnJvci5uYW1lLnN1YnN0cmluZyhrdlByZWZpeC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRoaXMudXNlSnNQcmVmaXggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnByZWZpeCA9IGAkS1YuJHttYn1gO1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdFByZWZpeCA9IGAke21pcnJvci5leHRlcm5hbC5hcGl9LiRLVi4ke259YDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0UHJlZml4ID0gdGhpcy5wcmVmaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYnVja2V0TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtID8/IGAke2t2UHJlZml4fSR7dGhpcy5idWNrZXR9YDtcbiAgICB9XG4gICAgc3ViamVjdEZvckJ1Y2tldCgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMucHJlZml4fS4ke3RoaXMuYnVja2V0fS4+YDtcbiAgICB9XG4gICAgc3ViamVjdEZvcktleShrLCBlZGl0ID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgYnVpbGRlciA9IFtdO1xuICAgICAgICBpZiAoZWRpdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudXNlSnNQcmVmaXgpIHtcbiAgICAgICAgICAgICAgICBidWlsZGVyLnB1c2godGhpcy5qcy5hcGlQcmVmaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZWRpdFByZWZpeCAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGJ1aWxkZXIucHVzaCh0aGlzLmVkaXRQcmVmaXgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBidWlsZGVyLnB1c2godGhpcy5wcmVmaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJlZml4KSB7XG4gICAgICAgICAgICAgICAgYnVpbGRlci5wdXNoKHRoaXMucHJlZml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBidWlsZGVyLnB1c2goayk7XG4gICAgICAgIHJldHVybiBidWlsZGVyLmpvaW4oXCIuXCIpO1xuICAgIH1cbiAgICBmdWxsS2V5TmFtZShrKSB7XG4gICAgICAgIGlmICh0aGlzLnByZWZpeCAhPT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMucHJlZml4fS4ke2t9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7a3ZTdWJqZWN0UHJlZml4fS4ke3RoaXMuYnVja2V0fS4ke2t9YDtcbiAgICB9XG4gICAgZ2V0IHByZWZpeExlbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByZWZpeExlbiA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fcHJlZml4TGVuID0gdGhpcy5wcmVmaXgubGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJlZml4TGVuO1xuICAgIH1cbiAgICBlbmNvZGVLZXkoa2V5KSB7XG4gICAgICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHQgb2Yga2V5LnNwbGl0KFwiLlwiKSl7XG4gICAgICAgICAgICBzd2l0Y2godCl7XG4gICAgICAgICAgICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICAgICAgICAgICAgICBjaHVua3MucHVzaCh0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzLnB1c2godGhpcy5jb2RlYy5rZXkuZW5jb2RlKHQpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNodW5rcy5qb2luKFwiLlwiKTtcbiAgICB9XG4gICAgZGVjb2RlS2V5KGVrZXkpIHtcbiAgICAgICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgdCBvZiBla2V5LnNwbGl0KFwiLlwiKSl7XG4gICAgICAgICAgICBzd2l0Y2godCl7XG4gICAgICAgICAgICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICAgICAgICAgICAgICBjaHVua3MucHVzaCh0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzLnB1c2godGhpcy5jb2RlYy5rZXkuZGVjb2RlKHQpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNodW5rcy5qb2luKFwiLlwiKTtcbiAgICB9XG4gICAgdmFsaWRhdGVLZXkgPSB2YWxpZGF0ZUtleTtcbiAgICB2YWxpZGF0ZVNlYXJjaEtleSA9IHZhbGlkYXRlU2VhcmNoS2V5O1xuICAgIGhhc1dpbGRjYXJkcyA9IGhhc1dpbGRjYXJkcztcbiAgICBjbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBkYXRhTGVuKGRhdGEsIGgpIHtcbiAgICAgICAgY29uc3Qgc2xlbiA9IGggPyBoLmdldChKc0hlYWRlcnMuTWVzc2FnZVNpemVIZHIpIHx8IFwiXCIgOiBcIlwiO1xuICAgICAgICBpZiAoc2xlbiAhPT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHNsZW4sIDEwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YS5sZW5ndGg7XG4gICAgfVxuICAgIHNtVG9FbnRyeShzbSkge1xuICAgICAgICByZXR1cm4gbmV3IEt2U3RvcmVkRW50cnlJbXBsKHRoaXMuYnVja2V0LCB0aGlzLnByZWZpeExlbiwgc20pO1xuICAgIH1cbiAgICBqbVRvRW50cnkoam0pIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5kZWNvZGVLZXkoam0uc3ViamVjdC5zdWJzdHJpbmcodGhpcy5wcmVmaXhMZW4pKTtcbiAgICAgICAgcmV0dXJuIG5ldyBLdkpzTXNnRW50cnlJbXBsKHRoaXMuYnVja2V0LCBrZXksIGptKTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlKGssIGRhdGEpIHtcbiAgICAgICAgbGV0IGZpcnN0RXJyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbiA9IGF3YWl0IHRoaXMucHV0KGssIGRhdGEsIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1NlcTogMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG4pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGZpcnN0RXJyID0gZXJyO1xuICAgICAgICAgICAgaWYgKGVycj8uYXBpX2Vycm9yPy5lcnJfY29kZSAhPT0gMTAwNzEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcmV2ID0gMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBhd2FpdCB0aGlzLmdldChrKTtcbiAgICAgICAgICAgIGlmIChlPy5vcGVyYXRpb24gPT09IFwiREVMXCIgfHwgZT8ub3BlcmF0aW9uID09PSBcIlBVUkdFXCIpIHtcbiAgICAgICAgICAgICAgICByZXYgPSBlICE9PSBudWxsID8gZS5yZXZpc2lvbiA6IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKGssIGRhdGEsIHJldik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChmaXJzdEVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKGssIGRhdGEsIHZlcnNpb24pIHtcbiAgICAgICAgaWYgKHZlcnNpb24gPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidmVyc2lvbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnB1dChrLCBkYXRhLCB7XG4gICAgICAgICAgICBwcmV2aW91c1NlcTogdmVyc2lvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgcHV0KGssIGRhdGEsIG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCBlayA9IHRoaXMuZW5jb2RlS2V5KGspO1xuICAgICAgICB0aGlzLnZhbGlkYXRlS2V5KGVrKTtcbiAgICAgICAgY29uc3QgbyA9IHt9O1xuICAgICAgICBpZiAob3B0cy5wcmV2aW91c1NlcSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBoID0gaGVhZGVycygpO1xuICAgICAgICAgICAgby5oZWFkZXJzID0gaDtcbiAgICAgICAgICAgIGguc2V0KFB1YkhlYWRlcnMuRXhwZWN0ZWRMYXN0U3ViamVjdFNlcXVlbmNlSGRyLCBgJHtvcHRzLnByZXZpb3VzU2VxfWApO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYSA9IGF3YWl0IHRoaXMuanMucHVibGlzaCh0aGlzLnN1YmplY3RGb3JLZXkoZWssIHRydWUpLCBkYXRhLCBvKTtcbiAgICAgICAgICAgIHJldHVybiBwYS5zZXE7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc3QgbmUgPSBlcnI7XG4gICAgICAgICAgICBpZiAobmUuaXNKZXRTdHJlYW1FcnJvcigpKSB7XG4gICAgICAgICAgICAgICAgbmUubWVzc2FnZSA9IG5lLmFwaV9lcnJvcj8uZGVzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgbmUuY29kZSA9IGAke25lLmFwaV9lcnJvcj8uY29kZX1gO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXQoaywgb3B0cykge1xuICAgICAgICBjb25zdCBlayA9IHRoaXMuZW5jb2RlS2V5KGspO1xuICAgICAgICB0aGlzLnZhbGlkYXRlS2V5KGVrKTtcbiAgICAgICAgbGV0IGFyZyA9IHtcbiAgICAgICAgICAgIGxhc3RfYnlfc3ViajogdGhpcy5zdWJqZWN0Rm9yS2V5KGVrKVxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0cyAmJiBvcHRzLnJldmlzaW9uID4gMCkge1xuICAgICAgICAgICAgYXJnID0ge1xuICAgICAgICAgICAgICAgIHNlcTogb3B0cy5yZXZpc2lvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc207XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXJlY3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3QgPSB0aGlzLmpzbS5kaXJlY3Q7XG4gICAgICAgICAgICAgICAgc20gPSBhd2FpdCBkaXJlY3QuZ2V0TWVzc2FnZSh0aGlzLmJ1Y2tldE5hbWUoKSwgYXJnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc20gPSBhd2FpdCB0aGlzLmpzbS5zdHJlYW1zLmdldE1lc3NhZ2UodGhpcy5idWNrZXROYW1lKCksIGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBrZSA9IHRoaXMuc21Ub0VudHJ5KHNtKTtcbiAgICAgICAgICAgIGlmIChrZS5rZXkgIT09IGVrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2U7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyci5jb2RlID09PSBFcnJvckNvZGUuSmV0U3RyZWFtNDA0Tm9NZXNzYWdlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHB1cmdlKGssIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGV0ZU9yUHVyZ2UoaywgXCJQVVJHRVwiLCBvcHRzKTtcbiAgICB9XG4gICAgZGVsZXRlKGssIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGV0ZU9yUHVyZ2UoaywgXCJERUxcIiwgb3B0cyk7XG4gICAgfVxuICAgIGFzeW5jIHB1cmdlRGVsZXRlcyhvbGRlck1pbGxpcyA9IDMwICogNjAgKiAxMDAwKSB7XG4gICAgICAgIGNvbnN0IGRvbmUgPSBkZWZlcnJlZCgpO1xuICAgICAgICBjb25zdCBidWYgPSBbXTtcbiAgICAgICAgY29uc3QgaSA9IGF3YWl0IHRoaXMud2F0Y2goe1xuICAgICAgICAgICAga2V5OiBcIj5cIixcbiAgICAgICAgICAgIGluaXRpYWxpemVkRm46ICgpPT57XG4gICAgICAgICAgICAgICAgZG9uZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAoYXN5bmMgKCk9PntcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgZSBvZiBpKXtcbiAgICAgICAgICAgICAgICBpZiAoZS5vcGVyYXRpb24gPT09IFwiREVMXCIgfHwgZS5vcGVyYXRpb24gPT09IFwiUFVSR0VcIikge1xuICAgICAgICAgICAgICAgICAgICBidWYucHVzaChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCkudGhlbigpO1xuICAgICAgICBhd2FpdCBkb25lO1xuICAgICAgICBpLnN0b3AoKTtcbiAgICAgICAgY29uc3QgbWluID0gRGF0ZS5ub3coKSAtIG9sZGVyTWlsbGlzO1xuICAgICAgICBjb25zdCBwcm9tcyA9IGJ1Zi5tYXAoKGUpPT57XG4gICAgICAgICAgICBjb25zdCBzdWJqID0gdGhpcy5zdWJqZWN0Rm9yS2V5KGUua2V5KTtcbiAgICAgICAgICAgIGlmIChlLmNyZWF0ZWQuZ2V0VGltZSgpID49IG1pbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmpzbS5zdHJlYW1zLnB1cmdlKHRoaXMuc3RyZWFtLCB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogc3ViaixcbiAgICAgICAgICAgICAgICAgICAga2VlcDogMVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5qc20uc3RyZWFtcy5wdXJnZSh0aGlzLnN0cmVhbSwge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IHN1YmosXG4gICAgICAgICAgICAgICAgICAgIGtlZXA6IDBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHB1cmdlZCA9IGF3YWl0IFByb21pc2UuYWxsKHByb21zKTtcbiAgICAgICAgcHVyZ2VkLnVuc2hpZnQoe1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIHB1cmdlZDogMFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHB1cmdlZC5yZWR1Y2UoKHB2LCBjdik9PntcbiAgICAgICAgICAgIHB2LnB1cmdlZCArPSBjdi5wdXJnZWQ7XG4gICAgICAgICAgICByZXR1cm4gcHY7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfZGVsZXRlT3JQdXJnZShrLCBvcCwgb3B0cykge1xuICAgICAgICBpZiAoIXRoaXMuaGFzV2lsZGNhcmRzKGspKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZG9EZWxldGVPclB1cmdlKGssIG9wLCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpdGVyID0gYXdhaXQgdGhpcy5rZXlzKGspO1xuICAgICAgICBjb25zdCBidWYgPSBbXTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBrIG9mIGl0ZXIpe1xuICAgICAgICAgICAgYnVmLnB1c2godGhpcy5fZG9EZWxldGVPclB1cmdlKGssIG9wKSk7XG4gICAgICAgICAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMTAwKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoYnVmKTtcbiAgICAgICAgICAgICAgICBidWYubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGJ1Zik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2RvRGVsZXRlT3JQdXJnZShrLCBvcCwgb3B0cykge1xuICAgICAgICBjb25zdCBlayA9IHRoaXMuZW5jb2RlS2V5KGspO1xuICAgICAgICB0aGlzLnZhbGlkYXRlS2V5KGVrKTtcbiAgICAgICAgY29uc3QgaCA9IGhlYWRlcnMoKTtcbiAgICAgICAgaC5zZXQoa3ZPcGVyYXRpb25IZHIsIG9wKTtcbiAgICAgICAgaWYgKG9wID09PSBcIlBVUkdFXCIpIHtcbiAgICAgICAgICAgIGguc2V0KEpzSGVhZGVycy5Sb2xsdXBIZHIsIEpzSGVhZGVycy5Sb2xsdXBWYWx1ZVN1YmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzPy5wcmV2aW91c1NlcSkge1xuICAgICAgICAgICAgaC5zZXQoUHViSGVhZGVycy5FeHBlY3RlZExhc3RTdWJqZWN0U2VxdWVuY2VIZHIsIGAke29wdHMucHJldmlvdXNTZXF9YCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5qcy5wdWJsaXNoKHRoaXMuc3ViamVjdEZvcktleShlaywgdHJ1ZSksIEVtcHR5LCB7XG4gICAgICAgICAgICBoZWFkZXJzOiBoXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYnVpbGRDQyhrLCBjb250ZW50LCBvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3QgYSA9ICFBcnJheS5pc0FycmF5KGspID8gW1xuICAgICAgICAgICAga1xuICAgICAgICBdIDogaztcbiAgICAgICAgbGV0IGZpbHRlcl9zdWJqZWN0cyA9IGEubWFwKChrKT0+e1xuICAgICAgICAgICAgY29uc3QgZWsgPSB0aGlzLmVuY29kZUtleShrKTtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVTZWFyY2hLZXkoayk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mdWxsS2V5TmFtZShlayk7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgZGVsaXZlcl9wb2xpY3kgPSBEZWxpdmVyUG9saWN5Lkxhc3RQZXJTdWJqZWN0O1xuICAgICAgICBpZiAoY29udGVudCA9PT0gS3ZXYXRjaEluY2x1ZGUuQWxsSGlzdG9yeSkge1xuICAgICAgICAgICAgZGVsaXZlcl9wb2xpY3kgPSBEZWxpdmVyUG9saWN5LkFsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGVudCA9PT0gS3ZXYXRjaEluY2x1ZGUuVXBkYXRlc09ubHkpIHtcbiAgICAgICAgICAgIGRlbGl2ZXJfcG9saWN5ID0gRGVsaXZlclBvbGljeS5OZXc7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZpbHRlcl9zdWJqZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoZmlsdGVyX3N1YmplY3RzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgZmlsdGVyX3N1YmplY3QgPSBmaWx0ZXJfc3ViamVjdHNbMF07XG4gICAgICAgICAgICBmaWx0ZXJfc3ViamVjdHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgZGVsaXZlcl9wb2xpY3ksXG4gICAgICAgICAgICBcImFja19wb2xpY3lcIjogQWNrUG9saWN5Lk5vbmUsXG4gICAgICAgICAgICBmaWx0ZXJfc3ViamVjdHMsXG4gICAgICAgICAgICBmaWx0ZXJfc3ViamVjdCxcbiAgICAgICAgICAgIFwiZmxvd19jb250cm9sXCI6IHRydWUsXG4gICAgICAgICAgICBcImlkbGVfaGVhcnRiZWF0XCI6IG5hbm9zKDUgKiAxMDAwKVxuICAgICAgICB9LCBvcHRzKTtcbiAgICB9XG4gICAgcmVtb3ZlKGspIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVyZ2Uoayk7XG4gICAgfVxuICAgIGFzeW5jIGhpc3Rvcnkob3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGsgPSBvcHRzLmtleSA/PyBcIj5cIjtcbiAgICAgICAgY29uc3QgcWkgPSBuZXcgUXVldWVkSXRlcmF0b3JJbXBsKCk7XG4gICAgICAgIGNvbnN0IGNvID0ge307XG4gICAgICAgIGNvLmhlYWRlcnNfb25seSA9IG9wdHMuaGVhZGVyc19vbmx5IHx8IGZhbHNlO1xuICAgICAgICBsZXQgZm47XG4gICAgICAgIGZuID0gKCk9PntcbiAgICAgICAgICAgIHFpLnN0b3AoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgY29uc3QgY2MgPSB0aGlzLl9idWlsZENDKGssIEt2V2F0Y2hJbmNsdWRlLkFsbEhpc3RvcnksIGNvKTtcbiAgICAgICAgY29uc3Qgc3ViaiA9IGNjLmZpbHRlcl9zdWJqZWN0O1xuICAgICAgICBjb25zdCBjb3B0cyA9IGNvbnN1bWVyT3B0cyhjYyk7XG4gICAgICAgIGNvcHRzLmJpbmRTdHJlYW0odGhpcy5zdHJlYW0pO1xuICAgICAgICBjb3B0cy5vcmRlcmVkQ29uc3VtZXIoKTtcbiAgICAgICAgY29wdHMuY2FsbGJhY2soKGVyciwgam0pPT57XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcWkuc3RvcChlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqbSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSB0aGlzLmptVG9FbnRyeShqbSk7XG4gICAgICAgICAgICAgICAgcWkucHVzaChlKTtcbiAgICAgICAgICAgICAgICBxaS5yZWNlaXZlZCsrO1xuICAgICAgICAgICAgICAgIGlmIChmbiAmJiBjb3VudCA+IDAgJiYgcWkucmVjZWl2ZWQgPj0gY291bnQgfHwgam0uaW5mby5wZW5kaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHFpLnB1c2goZm4pO1xuICAgICAgICAgICAgICAgICAgICBmbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLmpzLnN1YnNjcmliZShzdWJqLCBjb3B0cyk7XG4gICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgY29uc3QgeyBpbmZvOiB7IGxhc3QgfSB9ID0gc3ViO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ID0gbGFzdC5udW1fcGVuZGluZyArIGxhc3QuZGVsaXZlcmVkLmNvbnN1bWVyX3NlcTtcbiAgICAgICAgICAgIGlmIChleHBlY3QgPT09IDAgfHwgcWkucmVjZWl2ZWQgPj0gZXhwZWN0KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcWkuc3RvcChlcnIpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgICAgICAgICAgZm4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3VudCA9IGV4cGVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxaS5fZGF0YSA9IHN1YjtcbiAgICAgICAgcWkuaXRlckNsb3NlZC50aGVuKCgpPT57XG4gICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN1Yi5jbG9zZWQudGhlbigoKT0+e1xuICAgICAgICAgICAgcWkuc3RvcCgpO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgcWkuc3RvcChlcnIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHFpO1xuICAgIH1cbiAgICBjYW5TZXRXYXRjaGVyTmFtZSgpIHtcbiAgICAgICAgY29uc3QganNpID0gdGhpcy5qcztcbiAgICAgICAgY29uc3QgbmNpID0ganNpLm5jO1xuICAgICAgICBjb25zdCB7IG9rIH0gPSBuY2kuZmVhdHVyZXMuZ2V0KEZlYXR1cmUuSlNfTkVXX0NPTlNVTUVSX0NSRUFURV9BUEkpO1xuICAgICAgICByZXR1cm4gb2s7XG4gICAgfVxuICAgIGFzeW5jIHdhdGNoKG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCBrID0gb3B0cy5rZXkgPz8gXCI+XCI7XG4gICAgICAgIGNvbnN0IHFpID0gbmV3IFF1ZXVlZEl0ZXJhdG9ySW1wbCgpO1xuICAgICAgICBjb25zdCBjbyA9IHt9O1xuICAgICAgICBjby5oZWFkZXJzX29ubHkgPSBvcHRzLmhlYWRlcnNfb25seSB8fCBmYWxzZTtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBLdldhdGNoSW5jbHVkZS5MYXN0VmFsdWU7XG4gICAgICAgIGlmIChvcHRzLmluY2x1ZGUgPT09IEt2V2F0Y2hJbmNsdWRlLkFsbEhpc3RvcnkpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBLdldhdGNoSW5jbHVkZS5BbGxIaXN0b3J5O1xuICAgICAgICB9IGVsc2UgaWYgKG9wdHMuaW5jbHVkZSA9PT0gS3ZXYXRjaEluY2x1ZGUuVXBkYXRlc09ubHkpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBLdldhdGNoSW5jbHVkZS5VcGRhdGVzT25seTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZ25vcmVEZWxldGVzID0gb3B0cy5pZ25vcmVEZWxldGVzID09PSB0cnVlO1xuICAgICAgICBsZXQgZm4gPSBvcHRzLmluaXRpYWxpemVkRm47XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGNvbnN0IGNjID0gdGhpcy5fYnVpbGRDQyhrLCBjb250ZW50LCBjbyk7XG4gICAgICAgIGNvbnN0IHN1YmogPSBjYy5maWx0ZXJfc3ViamVjdDtcbiAgICAgICAgY29uc3QgY29wdHMgPSBjb25zdW1lck9wdHMoY2MpO1xuICAgICAgICBpZiAodGhpcy5jYW5TZXRXYXRjaGVyTmFtZSgpKSB7XG4gICAgICAgICAgICBjb3B0cy5jb25zdW1lck5hbWUobnVpZC5uZXh0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvcHRzLmJpbmRTdHJlYW0odGhpcy5zdHJlYW0pO1xuICAgICAgICBpZiAob3B0cy5yZXN1bWVGcm9tUmV2aXNpb24gJiYgb3B0cy5yZXN1bWVGcm9tUmV2aXNpb24gPiAwKSB7XG4gICAgICAgICAgICBjb3B0cy5zdGFydFNlcXVlbmNlKG9wdHMucmVzdW1lRnJvbVJldmlzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjb3B0cy5vcmRlcmVkQ29uc3VtZXIoKTtcbiAgICAgICAgY29wdHMuY2FsbGJhY2soKGVyciwgam0pPT57XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcWkuc3RvcChlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqbSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSB0aGlzLmptVG9FbnRyeShqbSk7XG4gICAgICAgICAgICAgICAgaWYgKGlnbm9yZURlbGV0ZXMgJiYgZS5vcGVyYXRpb24gPT09IFwiREVMXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBxaS5wdXNoKGUpO1xuICAgICAgICAgICAgICAgIHFpLnJlY2VpdmVkKys7XG4gICAgICAgICAgICAgICAgaWYgKGZuICYmIChjb3VudCA+IDAgJiYgcWkucmVjZWl2ZWQgPj0gY291bnQgfHwgam0uaW5mby5wZW5kaW5nID09PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICBxaS5wdXNoKGZuKTtcbiAgICAgICAgICAgICAgICAgICAgZm4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgdGhpcy5qcy5zdWJzY3JpYmUoc3ViaiwgY29wdHMpO1xuICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaW5mbzogeyBsYXN0IH0gfSA9IHN1YjtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdCA9IGxhc3QubnVtX3BlbmRpbmcgKyBsYXN0LmRlbGl2ZXJlZC5jb25zdW1lcl9zZXE7XG4gICAgICAgICAgICBpZiAoZXhwZWN0ID09PSAwIHx8IHFpLnJlY2VpdmVkID49IGV4cGVjdCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHFpLnN0b3AoZXJyKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICAgICAgICAgIGZuID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY291bnQgPSBleHBlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcWkuX2RhdGEgPSBzdWI7XG4gICAgICAgIHFpLml0ZXJDbG9zZWQudGhlbigoKT0+e1xuICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdWIuY2xvc2VkLnRoZW4oKCk9PntcbiAgICAgICAgICAgIHFpLnN0b3AoKTtcbiAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgIHFpLnN0b3AoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBxaTtcbiAgICB9XG4gICAgYXN5bmMga2V5cyhrID0gXCI+XCIpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IG5ldyBRdWV1ZWRJdGVyYXRvckltcGwoKTtcbiAgICAgICAgY29uc3QgY2MgPSB0aGlzLl9idWlsZENDKGssIEt2V2F0Y2hJbmNsdWRlLkxhc3RWYWx1ZSwge1xuICAgICAgICAgICAgaGVhZGVyc19vbmx5OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzdWJqID0gQXJyYXkuaXNBcnJheShrKSA/IFwiPlwiIDogY2MuZmlsdGVyX3N1YmplY3Q7XG4gICAgICAgIGNvbnN0IGNvcHRzID0gY29uc3VtZXJPcHRzKGNjKTtcbiAgICAgICAgY29wdHMuYmluZFN0cmVhbSh0aGlzLnN0cmVhbSk7XG4gICAgICAgIGNvcHRzLm9yZGVyZWRDb25zdW1lcigpO1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLmpzLnN1YnNjcmliZShzdWJqLCBjb3B0cyk7XG4gICAgICAgIChhc3luYyAoKT0+e1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBqbSBvZiBzdWIpe1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wID0gam0uaGVhZGVycz8uZ2V0KGt2T3BlcmF0aW9uSGRyKTtcbiAgICAgICAgICAgICAgICBpZiAob3AgIT09IFwiREVMXCIgJiYgb3AgIT09IFwiUFVSR0VcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmRlY29kZUtleShqbS5zdWJqZWN0LnN1YnN0cmluZyh0aGlzLnByZWZpeExlbikpO1xuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGptLmluZm8ucGVuZGluZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCkudGhlbigoKT0+e1xuICAgICAgICAgICAga2V5cy5zdG9wKCk7XG4gICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICBrZXlzLnN0b3AoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNpID0gc3ViO1xuICAgICAgICBpZiAoc2kuaW5mby5sYXN0Lm51bV9wZW5kaW5nID09PSAwKSB7XG4gICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9XG4gICAgcHVyZ2VCdWNrZXQob3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5qc20uc3RyZWFtcy5wdXJnZSh0aGlzLmJ1Y2tldE5hbWUoKSwgb3B0cyk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmpzbS5zdHJlYW1zLmRlbGV0ZSh0aGlzLmJ1Y2tldE5hbWUoKSk7XG4gICAgfVxuICAgIGFzeW5jIHN0YXR1cygpIHtcbiAgICAgICAgY29uc3QgbmMgPSB0aGlzLmpzLm5jO1xuICAgICAgICBjb25zdCBjbHVzdGVyID0gbmMuaW5mbz8uY2x1c3RlciA/PyBcIlwiO1xuICAgICAgICBjb25zdCBibiA9IHRoaXMuYnVja2V0TmFtZSgpO1xuICAgICAgICBjb25zdCBzaSA9IGF3YWl0IHRoaXMuanNtLnN0cmVhbXMuaW5mbyhibik7XG4gICAgICAgIHJldHVybiBuZXcgS3ZTdGF0dXNJbXBsKHNpLCBjbHVzdGVyKTtcbiAgICB9XG59XG5jbGFzcyBLdlN0YXR1c0ltcGwge1xuICAgIHNpO1xuICAgIGNsdXN0ZXI7XG4gICAgY29uc3RydWN0b3Ioc2ksIGNsdXN0ZXIgPSBcIlwiKXtcbiAgICAgICAgdGhpcy5zaSA9IHNpO1xuICAgICAgICB0aGlzLmNsdXN0ZXIgPSBjbHVzdGVyO1xuICAgIH1cbiAgICBnZXQgYnVja2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaS5jb25maWcubmFtZS5zdGFydHNXaXRoKGt2UHJlZml4KSA/IHRoaXMuc2kuY29uZmlnLm5hbWUuc3Vic3RyaW5nKGt2UHJlZml4Lmxlbmd0aCkgOiB0aGlzLnNpLmNvbmZpZy5uYW1lO1xuICAgIH1cbiAgICBnZXQgdmFsdWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaS5zdGF0ZS5tZXNzYWdlcztcbiAgICB9XG4gICAgZ2V0IGhpc3RvcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpLmNvbmZpZy5tYXhfbXNnc19wZXJfc3ViamVjdDtcbiAgICB9XG4gICAgZ2V0IHR0bCgpIHtcbiAgICAgICAgcmV0dXJuIG1pbGxpcyh0aGlzLnNpLmNvbmZpZy5tYXhfYWdlKTtcbiAgICB9XG4gICAgZ2V0IGJ1Y2tldF9sb2NhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2x1c3RlcjtcbiAgICB9XG4gICAgZ2V0IGJhY2tpbmdTdG9yZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2kuY29uZmlnLnN0b3JhZ2U7XG4gICAgfVxuICAgIGdldCBzdG9yYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaS5jb25maWcuc3RvcmFnZTtcbiAgICB9XG4gICAgZ2V0IHJlcGxpY2FzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaS5jb25maWcubnVtX3JlcGxpY2FzO1xuICAgIH1cbiAgICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpLmNvbmZpZy5kZXNjcmlwdGlvbiA/PyBcIlwiO1xuICAgIH1cbiAgICBnZXQgbWF4QnVja2V0U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2kuY29uZmlnLm1heF9ieXRlcztcbiAgICB9XG4gICAgZ2V0IG1heFZhbHVlU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2kuY29uZmlnLm1heF9tc2dfc2l6ZTtcbiAgICB9XG4gICAgZ2V0IG1heF9ieXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2kuY29uZmlnLm1heF9ieXRlcztcbiAgICB9XG4gICAgZ2V0IHBsYWNlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2kuY29uZmlnLnBsYWNlbWVudCB8fCB7XG4gICAgICAgICAgICBjbHVzdGVyOiBcIlwiLFxuICAgICAgICAgICAgdGFnczogW11cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IHBsYWNlbWVudENsdXN0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpLmNvbmZpZy5wbGFjZW1lbnQ/LmNsdXN0ZXIgPz8gXCJcIjtcbiAgICB9XG4gICAgZ2V0IHJlcHVibGlzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2kuY29uZmlnLnJlcHVibGlzaCA/PyB7XG4gICAgICAgICAgICBzcmM6IFwiXCIsXG4gICAgICAgICAgICBkZXN0OiBcIlwiXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldCBzdHJlYW1JbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpLnN0YXRlLmJ5dGVzO1xuICAgIH1cbiAgICBnZXQgbWV0YWRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpLmNvbmZpZy5tZXRhZGF0YSA/PyB7fTtcbiAgICB9XG4gICAgZ2V0IGNvbXByZXNzaW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zaS5jb25maWcuY29tcHJlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpLmNvbmZpZy5jb21wcmVzc2lvbiAhPT0gU3RvcmVDb21wcmVzc2lvbi5Ob25lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jb25zdCBvc1ByZWZpeCA9IFwiT0JKX1wiO1xuY29uc3QgZGlnZXN0VHlwZSA9IFwiU0hBLTI1Nj1cIjtcbmZ1bmN0aW9uIG9iamVjdFN0b3JlU3RyZWFtTmFtZShidWNrZXQpIHtcbiAgICB2YWxpZGF0ZUJ1Y2tldChidWNrZXQpO1xuICAgIHJldHVybiBgJHtvc1ByZWZpeH0ke2J1Y2tldH1gO1xufVxuZnVuY3Rpb24gb2JqZWN0U3RvcmVCdWNrZXROYW1lKHN0cmVhbSkge1xuICAgIGlmIChzdHJlYW0uc3RhcnRzV2l0aChvc1ByZWZpeCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5zdWJzdHJpbmcoNCk7XG4gICAgfVxuICAgIHJldHVybiBzdHJlYW07XG59XG5jbGFzcyBPYmplY3RTdG9yZVN0YXR1c0ltcGwge1xuICAgIHNpO1xuICAgIGJhY2tpbmdTdG9yZTtcbiAgICBjb25zdHJ1Y3RvcihzaSl7XG4gICAgICAgIHRoaXMuc2kgPSBzaTtcbiAgICAgICAgdGhpcy5iYWNraW5nU3RvcmUgPSBcIkpldFN0cmVhbVwiO1xuICAgIH1cbiAgICBnZXQgYnVja2V0KCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0U3RvcmVCdWNrZXROYW1lKHRoaXMuc2kuY29uZmlnLm5hbWUpO1xuICAgIH1cbiAgICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpLmNvbmZpZy5kZXNjcmlwdGlvbiA/PyBcIlwiO1xuICAgIH1cbiAgICBnZXQgdHRsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaS5jb25maWcubWF4X2FnZTtcbiAgICB9XG4gICAgZ2V0IHN0b3JhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpLmNvbmZpZy5zdG9yYWdlO1xuICAgIH1cbiAgICBnZXQgcmVwbGljYXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpLmNvbmZpZy5udW1fcmVwbGljYXM7XG4gICAgfVxuICAgIGdldCBzZWFsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpLmNvbmZpZy5zZWFsZWQ7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaS5zdGF0ZS5ieXRlcztcbiAgICB9XG4gICAgZ2V0IHN0cmVhbUluZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpO1xuICAgIH1cbiAgICBnZXQgbWV0YWRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpLmNvbmZpZy5tZXRhZGF0YTtcbiAgICB9XG4gICAgZ2V0IGNvbXByZXNzaW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zaS5jb25maWcuY29tcHJlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpLmNvbmZpZy5jb21wcmVzc2lvbiAhPT0gU3RvcmVDb21wcmVzc2lvbi5Ob25lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0U3RyZWFtU291cmNlRG9tYWluKHMpIHtcbiAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHsgZG9tYWluIH0gPSBzO1xuICAgIGlmIChkb21haW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgY29uc3QgY29weSA9IE9iamVjdC5hc3NpZ24oe30sIHMpO1xuICAgIGRlbGV0ZSBjb3B5LmRvbWFpbjtcbiAgICBpZiAoZG9tYWluID09PSBcIlwiKSB7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICBpZiAoY29weS5leHRlcm5hbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkb21haW4gYW5kIGV4dGVybmFsIGFyZSBib3RoIHNldFwiKTtcbiAgICB9XG4gICAgY29weS5leHRlcm5hbCA9IHtcbiAgICAgICAgYXBpOiBgJEpTLiR7ZG9tYWlufS5BUElgXG4gICAgfTtcbiAgICByZXR1cm4gY29weTtcbn1cbnZhciBQdWxsQ29uc3VtZXJUeXBlO1xuKGZ1bmN0aW9uKFB1bGxDb25zdW1lclR5cGUpIHtcbiAgICBQdWxsQ29uc3VtZXJUeXBlW1B1bGxDb25zdW1lclR5cGVbXCJVbnNldFwiXSA9IC0xXSA9IFwiVW5zZXRcIjtcbiAgICBQdWxsQ29uc3VtZXJUeXBlW1B1bGxDb25zdW1lclR5cGVbXCJDb25zdW1lXCJdID0gMF0gPSBcIkNvbnN1bWVcIjtcbiAgICBQdWxsQ29uc3VtZXJUeXBlW1B1bGxDb25zdW1lclR5cGVbXCJGZXRjaFwiXSA9IDFdID0gXCJGZXRjaFwiO1xufSkoUHVsbENvbnN1bWVyVHlwZSB8fCAoUHVsbENvbnN1bWVyVHlwZSA9IHt9KSk7XG52YXIgQ29uc3VtZXJFdmVudHM7XG4oZnVuY3Rpb24oQ29uc3VtZXJFdmVudHMpIHtcbiAgICBDb25zdW1lckV2ZW50c1tcIkhlYXJ0YmVhdHNNaXNzZWRcIl0gPSBcImhlYXJ0YmVhdHNfbWlzc2VkXCI7XG4gICAgQ29uc3VtZXJFdmVudHNbXCJDb25zdW1lck5vdEZvdW5kXCJdID0gXCJjb25zdW1lcl9ub3RfZm91bmRcIjtcbiAgICBDb25zdW1lckV2ZW50c1tcIlN0cmVhbU5vdEZvdW5kXCJdID0gXCJzdHJlYW1fbm90X2ZvdW5kXCI7XG4gICAgQ29uc3VtZXJFdmVudHNbXCJDb25zdW1lckRlbGV0ZWRcIl0gPSBcImNvbnN1bWVyX2RlbGV0ZWRcIjtcbiAgICBDb25zdW1lckV2ZW50c1tcIk9yZGVyZWRDb25zdW1lclJlY3JlYXRlZFwiXSA9IFwib3JkZXJlZF9jb25zdW1lcl9yZWNyZWF0ZWRcIjtcbiAgICBDb25zdW1lckV2ZW50c1tcIk5vUmVzcG9uZGVyc1wiXSA9IFwibm9fcmVzcG9uZGVyc1wiO1xufSkoQ29uc3VtZXJFdmVudHMgfHwgKENvbnN1bWVyRXZlbnRzID0ge30pKTtcbnZhciBDb25zdW1lckRlYnVnRXZlbnRzO1xuKGZ1bmN0aW9uKENvbnN1bWVyRGVidWdFdmVudHMpIHtcbiAgICBDb25zdW1lckRlYnVnRXZlbnRzW1wiRGVidWdFdmVudFwiXSA9IFwiZGVidWdcIjtcbiAgICBDb25zdW1lckRlYnVnRXZlbnRzW1wiRGlzY2FyZFwiXSA9IFwiZGlzY2FyZFwiO1xuICAgIENvbnN1bWVyRGVidWdFdmVudHNbXCJSZXNldFwiXSA9IFwicmVzZXRcIjtcbiAgICBDb25zdW1lckRlYnVnRXZlbnRzW1wiTmV4dFwiXSA9IFwibmV4dFwiO1xufSkoQ29uc3VtZXJEZWJ1Z0V2ZW50cyB8fCAoQ29uc3VtZXJEZWJ1Z0V2ZW50cyA9IHt9KSk7XG5jb25zdCBBQ0sgPSBVaW50OEFycmF5Lm9mKDQzLCA2NSwgNjcsIDc1KTtcbmNvbnN0IE5BSyA9IFVpbnQ4QXJyYXkub2YoNDUsIDc4LCA2NSwgNzUpO1xuY29uc3QgV1BJID0gVWludDhBcnJheS5vZig0MywgODcsIDgwLCA3Myk7XG5jb25zdCBOWFQgPSBVaW50OEFycmF5Lm9mKDQzLCA3OCwgODgsIDg0KTtcbmNvbnN0IFRFUk0gPSBVaW50OEFycmF5Lm9mKDQzLCA4NCwgNjksIDgyLCA3Nyk7XG5jb25zdCBTUEFDRSA9IFVpbnQ4QXJyYXkub2YoMzIpO1xuZnVuY3Rpb24gdG9Kc01zZyhtLCBhY2tUaW1lb3V0ID0gNTAwMCkge1xuICAgIHJldHVybiBuZXcgSnNNc2dJbXBsKG0sIGFja1RpbWVvdXQpO1xufVxuY2xhc3MgUHVsbENvbnN1bWVyTWVzc2FnZXNJbXBsIGV4dGVuZHMgUXVldWVkSXRlcmF0b3JJbXBsIHtcbiAgICBjb25zdW1lcjtcbiAgICBvcHRzO1xuICAgIHN1YjtcbiAgICBtb25pdG9yO1xuICAgIHBlbmRpbmc7XG4gICAgaW5ib3g7XG4gICAgcmVmaWxsaW5nO1xuICAgIHBvbmc7XG4gICAgY2FsbGJhY2s7XG4gICAgdGltZW91dDtcbiAgICBjbGVhbnVwSGFuZGxlcjtcbiAgICBsaXN0ZW5lcnM7XG4gICAgc3RhdHVzSXRlcmF0b3I7XG4gICAgZm9yT3JkZXJlZENvbnN1bWVyO1xuICAgIHJlc2V0SGFuZGxlcjtcbiAgICBhYm9ydE9uTWlzc2luZ1Jlc291cmNlO1xuICAgIGJpbmQ7XG4gICAgaW5CYWNrT2ZmO1xuICAgIGNvbnN0cnVjdG9yKGMsIG9wdHMsIHJlZmlsbGluZyA9IGZhbHNlKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb25zdW1lciA9IGM7XG4gICAgICAgIGNvbnN0IGNvcHRzID0gb3B0cztcbiAgICAgICAgdGhpcy5vcHRzID0gdGhpcy5wYXJzZU9wdGlvbnMob3B0cywgcmVmaWxsaW5nKTtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNvcHRzLmNhbGxiYWNrIHx8IG51bGw7XG4gICAgICAgIHRoaXMubm9JdGVyYXRvciA9IHR5cGVvZiB0aGlzLmNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgIHRoaXMubW9uaXRvciA9IG51bGw7XG4gICAgICAgIHRoaXMucG9uZyA9IG51bGw7XG4gICAgICAgIHRoaXMucGVuZGluZyA9IHtcbiAgICAgICAgICAgIG1zZ3M6IDAsXG4gICAgICAgICAgICBieXRlczogMCxcbiAgICAgICAgICAgIHJlcXVlc3RzOiAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVmaWxsaW5nID0gcmVmaWxsaW5nO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBudWxsO1xuICAgICAgICB0aGlzLmluYm94ID0gY3JlYXRlSW5ib3goYy5hcGkubmMub3B0aW9ucy5pbmJveFByZWZpeCk7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuZm9yT3JkZXJlZENvbnN1bWVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWJvcnRPbk1pc3NpbmdSZXNvdXJjZSA9IGNvcHRzLmFib3J0X29uX21pc3NpbmdfcmVzb3VyY2UgPT09IHRydWU7XG4gICAgICAgIHRoaXMuYmluZCA9IGNvcHRzLmJpbmQgPT09IHRydWU7XG4gICAgICAgIHRoaXMuaW5CYWNrT2ZmID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGNvbnN0IHsgbWF4X21lc3NhZ2VzLCBtYXhfYnl0ZXMsIGlkbGVfaGVhcnRiZWF0LCB0aHJlc2hvbGRfYnl0ZXMsIHRocmVzaG9sZF9tZXNzYWdlcyB9ID0gdGhpcy5vcHRzO1xuICAgICAgICB0aGlzLmNsb3NlZCgpLnRoZW4oKGVycik9PntcbiAgICAgICAgICAgIGlmICh0aGlzLmNsZWFudXBIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhbnVwSGFuZGxlcihlcnIpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnIpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IHN1YiB9ID0gdGhpcztcbiAgICAgICAgaWYgKHN1Yikge1xuICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWIgPSB0aGlzLmNvbnN1bWVyLmFwaS5uYy5zdWJzY3JpYmUodGhpcy5pbmJveCwge1xuICAgICAgICAgICAgY2FsbGJhY2s6IChlcnIsIG1zZyk9PntcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcChlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubW9uaXRvcj8ud29yaygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUHJvdG9jb2wgPSBtc2cuc3ViamVjdCA9PT0gdGhpcy5pbmJveDtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcm90b2NvbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNIZWFydGJlYXRNc2cobXNnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBtc2cuaGVhZGVycz8uY29kZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBtc2cuaGVhZGVycz8uZGVzY3JpcHRpb24/LnRvTG93ZXJDYXNlKCkgfHwgXCJ1bmtub3duXCI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgbXNnc0xlZnQsIGJ5dGVzTGVmdCB9ID0gdGhpcy5wYXJzZURpc2NhcmQobXNnLmhlYWRlcnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobXNnc0xlZnQgPiAwIHx8IGJ5dGVzTGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZy5tc2dzIC09IG1zZ3NMZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nLmJ5dGVzIC09IGJ5dGVzTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZy5yZXF1ZXN0cy0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnkoQ29uc3VtZXJEZWJ1Z0V2ZW50cy5EaXNjYXJkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXNnc0xlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNMZWZ0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlID09PSA0MDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3AobmV3IE5hdHNFcnJvcihkZXNjcmlwdGlvbiwgYCR7Y29kZX1gKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSA0MDkgJiYgZGVzY3JpcHRpb24gPT09IFwiY29uc3VtZXIgZGVsZXRlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnkoQ29uc3VtZXJFdmVudHMuQ29uc3VtZXJEZWxldGVkLCBgJHtjb2RlfSAke2Rlc2NyaXB0aW9ufWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5yZWZpbGxpbmcgfHwgdGhpcy5hYm9ydE9uTWlzc2luZ1Jlc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IE5hdHNFcnJvcihkZXNjcmlwdGlvbiwgYCR7Y29kZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gNTAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnkoQ29uc3VtZXJFdmVudHMuTm9SZXNwb25kZXJzLCBgJHtjb2RlfSBObyBSZXNwb25kZXJzYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJlZmlsbGluZyB8fCB0aGlzLmFib3J0T25NaXNzaW5nUmVzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgTmF0c0Vycm9yKFwibm8gcmVzcG9uZGVyc1wiLCBgJHtjb2RlfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3AoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeShDb25zdW1lckRlYnVnRXZlbnRzLkRlYnVnRXZlbnQsIGAke2NvZGV9ICR7ZGVzY3JpcHRpb259YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wdXNoKHRvSnNNc2cobXNnLCB0aGlzLmNvbnN1bWVyLmFwaS50aW1lb3V0KSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVjZWl2ZWQrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZy5tc2dzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmcubXNncy0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmcuYnl0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZy5ieXRlcyAtPSBtc2cuc2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmcubXNncyA9PT0gMCAmJiB0aGlzLnBlbmRpbmcuYnl0ZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nLnJlcXVlc3RzID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVmaWxsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXhfbWVzc2FnZXMgJiYgdGhpcy5wZW5kaW5nLm1zZ3MgPD0gdGhyZXNob2xkX21lc3NhZ2VzIHx8IG1heF9ieXRlcyAmJiB0aGlzLnBlbmRpbmcuYnl0ZXMgPD0gdGhyZXNob2xkX2J5dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXRjaCA9IHRoaXMucHVsbE9wdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHVsbChiYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucGVuZGluZy5yZXF1ZXN0cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wdXNoKCgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdWIuY2xvc2VkLnRoZW4oKCk9PntcbiAgICAgICAgICAgIGlmICh0aGlzLnN1Yi5kcmFpbmluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3B1c2goKCk9PntcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaWRsZV9oZWFydGJlYXQpIHtcbiAgICAgICAgICAgIHRoaXMubW9uaXRvciA9IG5ldyBJZGxlSGVhcnRiZWF0TW9uaXRvcihpZGxlX2hlYXJ0YmVhdCwgKGRhdGEpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnkoQ29uc3VtZXJFdmVudHMuSGVhcnRiZWF0c01pc3NlZCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldFBlbmRpbmcoKS50aGVuKCgpPT57fSkuY2F0Y2goKCk9Pnt9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbWF4T3V0OiAyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAoYXN5bmMgKCk9PntcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHRoaXMuY29uc3VtZXIuYXBpLm5jLnN0YXR1cygpO1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNJdGVyYXRvciA9IHN0YXR1cztcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgcyBvZiBzdGF0dXMpe1xuICAgICAgICAgICAgICAgIHN3aXRjaChzLnR5cGUpe1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEV2ZW50cy5EaXNjb25uZWN0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb25pdG9yPy5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEV2ZW50cy5SZWNvbm5lY3Q6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0UGVuZGluZygpLnRoZW4oKG9rKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbml0b3I/LnJlc3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaCgoKT0+e30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgICAgICB0aGlzLnB1bGwodGhpcy5wdWxsT3B0aW9ucygpKTtcbiAgICB9XG4gICAgX3B1c2gocikge1xuICAgICAgICBpZiAoIXRoaXMuY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHN1cGVyLnB1c2gocik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBmbiA9IHR5cGVvZiByID09PSBcImZ1bmN0aW9uXCIgPyByIDogbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrKHIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbm90aWZ5KHR5cGUsIGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICgoKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goKGwpPT57XG4gICAgICAgICAgICAgICAgICAgIGlmICghbC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzZXRQZW5kaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW5kID8gdGhpcy5yZXNldFBlbmRpbmdOb0luZm8oKSA6IHRoaXMucmVzZXRQZW5kaW5nV2l0aEluZm8oKTtcbiAgICB9XG4gICAgcmVzZXRQZW5kaW5nTm9JbmZvKCkge1xuICAgICAgICB0aGlzLnBlbmRpbmcubXNncyA9IDA7XG4gICAgICAgIHRoaXMucGVuZGluZy5ieXRlcyA9IDA7XG4gICAgICAgIHRoaXMucGVuZGluZy5yZXF1ZXN0cyA9IDA7XG4gICAgICAgIHRoaXMucHVsbCh0aGlzLnB1bGxPcHRpb25zKCkpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgIH1cbiAgICBhc3luYyByZXNldFBlbmRpbmdXaXRoSW5mbygpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5CYWNrT2ZmKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vdEZvdW5kID0gMDtcbiAgICAgICAgbGV0IHN0cmVhbU5vdEZvdW5kID0gMDtcbiAgICAgICAgY29uc3QgYm8gPSBiYWNrb2ZmKFtcbiAgICAgICAgICAgIHRoaXMub3B0cy5leHBpcmVzXG4gICAgICAgIF0pO1xuICAgICAgICBsZXQgYXR0ZW1wdCA9IDA7XG4gICAgICAgIHdoaWxlKHRydWUpe1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnN1bWVyLmFwaS5uYy5pc0Nsb3NlZCgpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImFib3J0aW5nIHJlc2V0UGVuZGluZyAtIGNvbm5lY3Rpb24gaXMgY2xvc2VkXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jb25zdW1lci5pbmZvKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbkJhY2tPZmYgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBub3RGb3VuZCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nLm1zZ3MgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZy5ieXRlcyA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nLnJlcXVlc3RzID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnB1bGwodGhpcy5wdWxsT3B0aW9ucygpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIubWVzc2FnZSA9PT0gXCJzdHJlYW0gbm90IGZvdW5kXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtTm90Rm91bmQrKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnkoQ29uc3VtZXJFdmVudHMuU3RyZWFtTm90Rm91bmQsIHN0cmVhbU5vdEZvdW5kKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJlZmlsbGluZyB8fCB0aGlzLmFib3J0T25NaXNzaW5nUmVzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcnIubWVzc2FnZSA9PT0gXCJjb25zdW1lciBub3QgZm91bmRcIikge1xuICAgICAgICAgICAgICAgICAgICBub3RGb3VuZCsrO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeShDb25zdW1lckV2ZW50cy5Db25zdW1lck5vdEZvdW5kLCBub3RGb3VuZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc2V0SGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0SGFuZGxlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoXykge31cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucmVmaWxsaW5nIHx8IHRoaXMuYWJvcnRPbk1pc3NpbmdSZXNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZm9yT3JkZXJlZENvbnN1bWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub3RGb3VuZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbU5vdEZvdW5kID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pbkJhY2tPZmYgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvID0gYm8uYmFja29mZihhdHRlbXB0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZSA9IGRlbGF5KHRvKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgICAgICAgICBkZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lci5hcGkubmMuY2xvc2VkKClcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBkZS5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICBhdHRlbXB0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHVsbChvcHRzKSB7XG4gICAgICAgIHRoaXMucGVuZGluZy5ieXRlcyArPSBvcHRzLm1heF9ieXRlcyA/PyAwO1xuICAgICAgICB0aGlzLnBlbmRpbmcubXNncyArPSBvcHRzLmJhdGNoID8/IDA7XG4gICAgICAgIHRoaXMucGVuZGluZy5yZXF1ZXN0cysrO1xuICAgICAgICBjb25zdCBuYyA9IHRoaXMuY29uc3VtZXIuYXBpLm5jO1xuICAgICAgICB0aGlzLl9wdXNoKCgpPT57XG4gICAgICAgICAgICBuYy5wdWJsaXNoKGAke3RoaXMuY29uc3VtZXIuYXBpLnByZWZpeH0uQ09OU1VNRVIuTVNHLk5FWFQuJHt0aGlzLmNvbnN1bWVyLnN0cmVhbX0uJHt0aGlzLmNvbnN1bWVyLm5hbWV9YCwgdGhpcy5jb25zdW1lci5hcGkuamMuZW5jb2RlKG9wdHMpLCB7XG4gICAgICAgICAgICAgICAgcmVwbHk6IHRoaXMuaW5ib3hcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnkoQ29uc3VtZXJEZWJ1Z0V2ZW50cy5OZXh0LCBvcHRzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHB1bGxPcHRpb25zKCkge1xuICAgICAgICBjb25zdCBiYXRjaCA9IHRoaXMub3B0cy5tYXhfbWVzc2FnZXMgLSB0aGlzLnBlbmRpbmcubXNncztcbiAgICAgICAgY29uc3QgbWF4X2J5dGVzID0gdGhpcy5vcHRzLm1heF9ieXRlcyAtIHRoaXMucGVuZGluZy5ieXRlcztcbiAgICAgICAgY29uc3QgaWRsZV9oZWFydGJlYXQgPSBuYW5vcyh0aGlzLm9wdHMuaWRsZV9oZWFydGJlYXQpO1xuICAgICAgICBjb25zdCBleHBpcmVzID0gbmFub3ModGhpcy5vcHRzLmV4cGlyZXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmF0Y2gsXG4gICAgICAgICAgICBtYXhfYnl0ZXMsXG4gICAgICAgICAgICBpZGxlX2hlYXJ0YmVhdCxcbiAgICAgICAgICAgIGV4cGlyZXNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcGFyc2VEaXNjYXJkKGhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgZGlzY2FyZCA9IHtcbiAgICAgICAgICAgIG1zZ3NMZWZ0OiAwLFxuICAgICAgICAgICAgYnl0ZXNMZWZ0OiAwXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1zZ3NMZWZ0ID0gaGVhZGVycz8uZ2V0KEpzSGVhZGVycy5QZW5kaW5nTWVzc2FnZXNIZHIpO1xuICAgICAgICBpZiAobXNnc0xlZnQpIHtcbiAgICAgICAgICAgIGRpc2NhcmQubXNnc0xlZnQgPSBwYXJzZUludChtc2dzTGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnl0ZXNMZWZ0ID0gaGVhZGVycz8uZ2V0KEpzSGVhZGVycy5QZW5kaW5nQnl0ZXNIZHIpO1xuICAgICAgICBpZiAoYnl0ZXNMZWZ0KSB7XG4gICAgICAgICAgICBkaXNjYXJkLmJ5dGVzTGVmdCA9IHBhcnNlSW50KGJ5dGVzTGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpc2NhcmQ7XG4gICAgfVxuICAgIHRyYWNrVGltZW91dCh0KSB7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHQ7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlckNsb3NlZDtcbiAgICB9XG4gICAgY2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVyQ2xvc2VkO1xuICAgIH1cbiAgICBjbGVhclRpbWVycygpIHtcbiAgICAgICAgdGhpcy5tb25pdG9yPy5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy5tb25pdG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy50aW1lb3V0Py5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgc2V0Q2xlYW51cEhhbmRsZXIoZm4pIHtcbiAgICAgICAgdGhpcy5jbGVhbnVwSGFuZGxlciA9IGZuO1xuICAgIH1cbiAgICBzdG9wKGVycikge1xuICAgICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWI/LnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuY2xlYXJUaW1lcnMoKTtcbiAgICAgICAgdGhpcy5zdGF0dXNJdGVyYXRvcj8uc3RvcCgpO1xuICAgICAgICB0aGlzLl9wdXNoKCgpPT57XG4gICAgICAgICAgICBzdXBlci5zdG9wKGVycik7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKChuKT0+e1xuICAgICAgICAgICAgICAgIG4uc3RvcCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwYXJzZU9wdGlvbnMob3B0cywgcmVmaWxsaW5nID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IG9wdHMgfHwge307XG4gICAgICAgIGFyZ3MubWF4X21lc3NhZ2VzID0gYXJncy5tYXhfbWVzc2FnZXMgfHwgMDtcbiAgICAgICAgYXJncy5tYXhfYnl0ZXMgPSBhcmdzLm1heF9ieXRlcyB8fCAwO1xuICAgICAgICBpZiAoYXJncy5tYXhfbWVzc2FnZXMgIT09IDAgJiYgYXJncy5tYXhfYnl0ZXMgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgb25seSBzcGVjaWZ5IG9uZSBvZiBtYXhfbWVzc2FnZXMgb3IgbWF4X2J5dGVzYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3MubWF4X21lc3NhZ2VzID09PSAwKSB7XG4gICAgICAgICAgICBhcmdzLm1heF9tZXNzYWdlcyA9IDEwMDtcbiAgICAgICAgfVxuICAgICAgICBhcmdzLmV4cGlyZXMgPSBhcmdzLmV4cGlyZXMgfHwgMzBfMDAwO1xuICAgICAgICBpZiAoYXJncy5leHBpcmVzIDwgMTAwMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXhwaXJlcyBzaG91bGQgYmUgYXQgbGVhc3QgMTAwMG1zXCIpO1xuICAgICAgICB9XG4gICAgICAgIGFyZ3MuaWRsZV9oZWFydGJlYXQgPSBhcmdzLmlkbGVfaGVhcnRiZWF0IHx8IGFyZ3MuZXhwaXJlcyAvIDI7XG4gICAgICAgIGFyZ3MuaWRsZV9oZWFydGJlYXQgPSBhcmdzLmlkbGVfaGVhcnRiZWF0ID4gMzBfMDAwID8gMzBfMDAwIDogYXJncy5pZGxlX2hlYXJ0YmVhdDtcbiAgICAgICAgaWYgKHJlZmlsbGluZykge1xuICAgICAgICAgICAgY29uc3QgbWluTXNncyA9IE1hdGgucm91bmQoYXJncy5tYXhfbWVzc2FnZXMgKiAuNzUpIHx8IDE7XG4gICAgICAgICAgICBhcmdzLnRocmVzaG9sZF9tZXNzYWdlcyA9IGFyZ3MudGhyZXNob2xkX21lc3NhZ2VzIHx8IG1pbk1zZ3M7XG4gICAgICAgICAgICBjb25zdCBtaW5CeXRlcyA9IE1hdGgucm91bmQoYXJncy5tYXhfYnl0ZXMgKiAuNzUpIHx8IDE7XG4gICAgICAgICAgICBhcmdzLnRocmVzaG9sZF9ieXRlcyA9IGFyZ3MudGhyZXNob2xkX2J5dGVzIHx8IG1pbkJ5dGVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgIH1cbiAgICBzdGF0dXMoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXIgPSBuZXcgUXVldWVkSXRlcmF0b3JJbXBsKCk7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLnB1c2goaXRlcik7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaXRlcik7XG4gICAgfVxufVxuY2xhc3MgT3JkZXJlZENvbnN1bWVyTWVzc2FnZXMgZXh0ZW5kcyBRdWV1ZWRJdGVyYXRvckltcGwge1xuICAgIHNyYztcbiAgICBsaXN0ZW5lcnM7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICB9XG4gICAgc2V0U291cmNlKHNyYykge1xuICAgICAgICBpZiAodGhpcy5zcmMpIHtcbiAgICAgICAgICAgIHRoaXMuc3JjLnJlc2V0SGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc3JjLnNldENsZWFudXBIYW5kbGVyKCk7XG4gICAgICAgICAgICB0aGlzLnNyYy5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zcmMgPSBzcmM7XG4gICAgICAgIHRoaXMuc3JjLnNldENsZWFudXBIYW5kbGVyKChlcnIpPT57XG4gICAgICAgICAgICB0aGlzLnN0b3AoZXJyIHx8IHVuZGVmaW5lZCk7XG4gICAgICAgIH0pO1xuICAgICAgICAoYXN5bmMgKCk9PntcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IGF3YWl0IHRoaXMuc3JjLnN0YXR1cygpO1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBzIG9mIHN0YXR1cyl7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnkocy50eXBlLCBzLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpLmNhdGNoKCgpPT57fSk7XG4gICAgfVxuICAgIG5vdGlmeSh0eXBlLCBkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAoKCk9PntcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKChsKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWwuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0b3AoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNyYz8uc3RvcChlcnIpO1xuICAgICAgICBzdXBlci5zdG9wKGVycik7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goKG4pPT57XG4gICAgICAgICAgICBuLnN0b3AoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlckNsb3NlZDtcbiAgICB9XG4gICAgY2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVyQ2xvc2VkO1xuICAgIH1cbiAgICBzdGF0dXMoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXIgPSBuZXcgUXVldWVkSXRlcmF0b3JJbXBsKCk7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLnB1c2goaXRlcik7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaXRlcik7XG4gICAgfVxufVxuY2xhc3MgUHVsbENvbnN1bWVySW1wbCB7XG4gICAgYXBpO1xuICAgIF9pbmZvO1xuICAgIHN0cmVhbTtcbiAgICBuYW1lO1xuICAgIGNvbnN0cnVjdG9yKGFwaSwgaW5mbyl7XG4gICAgICAgIHRoaXMuYXBpID0gYXBpO1xuICAgICAgICB0aGlzLl9pbmZvID0gaW5mbztcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBpbmZvLnN0cmVhbV9uYW1lO1xuICAgICAgICB0aGlzLm5hbWUgPSBpbmZvLm5hbWU7XG4gICAgfVxuICAgIGNvbnN1bWUob3B0cyA9IHtcbiAgICAgICAgbWF4X21lc3NhZ2VzOiAxMDAsXG4gICAgICAgIGV4cGlyZXM6IDMwXzAwMFxuICAgIH0pIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgUHVsbENvbnN1bWVyTWVzc2FnZXNJbXBsKHRoaXMsIG9wdHMsIHRydWUpKTtcbiAgICB9XG4gICAgZmV0Y2gob3B0cyA9IHtcbiAgICAgICAgbWF4X21lc3NhZ2VzOiAxMDAsXG4gICAgICAgIGV4cGlyZXM6IDMwXzAwMFxuICAgIH0pIHtcbiAgICAgICAgY29uc3QgbSA9IG5ldyBQdWxsQ29uc3VtZXJNZXNzYWdlc0ltcGwodGhpcywgb3B0cywgZmFsc2UpO1xuICAgICAgICBjb25zdCB0byA9IE1hdGgucm91bmQobS5vcHRzLmV4cGlyZXMgKiAxLjA1KTtcbiAgICAgICAgY29uc3QgdGltZXIgPSB0aW1lb3V0KHRvKTtcbiAgICAgICAgbS5jbG9zZWQoKS5jYXRjaCgoKT0+e30pLmZpbmFsbHkoKCk9PntcbiAgICAgICAgICAgIHRpbWVyLmNhbmNlbCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGltZXIuY2F0Y2goKCk9PntcbiAgICAgICAgICAgIG0uY2xvc2UoKS5jYXRjaCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgbS50cmFja1RpbWVvdXQodGltZXIpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG0pO1xuICAgIH1cbiAgICBuZXh0KG9wdHMgPSB7XG4gICAgICAgIGV4cGlyZXM6IDMwXzAwMFxuICAgIH0pIHtcbiAgICAgICAgY29uc3QgZCA9IGRlZmVycmVkKCk7XG4gICAgICAgIGNvbnN0IGZvcHRzID0gb3B0cztcbiAgICAgICAgZm9wdHMubWF4X21lc3NhZ2VzID0gMTtcbiAgICAgICAgY29uc3QgaXRlciA9IG5ldyBQdWxsQ29uc3VtZXJNZXNzYWdlc0ltcGwodGhpcywgZm9wdHMsIGZhbHNlKTtcbiAgICAgICAgY29uc3QgdG8gPSBNYXRoLnJvdW5kKGl0ZXIub3B0cy5leHBpcmVzICogMS4wNSk7XG4gICAgICAgIGlmICh0byA+PSA2MF8wMDApIHtcbiAgICAgICAgICAgIChhc3luYyAoKT0+e1xuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgcyBvZiAoYXdhaXQgaXRlci5zdGF0dXMoKSkpe1xuICAgICAgICAgICAgICAgICAgICBpZiAocy50eXBlID09PSBDb25zdW1lckV2ZW50cy5IZWFydGJlYXRzTWlzc2VkICYmIHMuZGF0YSA+PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkLnJlamVjdChuZXcgRXJyb3IoXCJjb25zdW1lciBtaXNzZWQgaGVhcnRiZWF0c1wiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCkuY2F0Y2goKTtcbiAgICAgICAgfVxuICAgICAgICAoYXN5bmMgKCk9PntcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgbSBvZiBpdGVyKXtcbiAgICAgICAgICAgICAgICBkLnJlc29sdmUobSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCkuY2F0Y2goKCk9Pnt9KTtcbiAgICAgICAgY29uc3QgdGltZXIgPSB0aW1lb3V0KHRvKTtcbiAgICAgICAgaXRlci5jbG9zZWQoKS50aGVuKChlcnIpPT57XG4gICAgICAgICAgICBlcnIgPyBkLnJlamVjdChlcnIpIDogZC5yZXNvbHZlKG51bGwpO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgZC5yZWplY3QoZXJyKTtcbiAgICAgICAgfSkuZmluYWxseSgoKT0+e1xuICAgICAgICAgICAgdGltZXIuY2FuY2VsKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aW1lci5jYXRjaCgoX2Vycik9PntcbiAgICAgICAgICAgIGQucmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgIGl0ZXIuY2xvc2UoKS5jYXRjaCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaXRlci50cmFja1RpbWVvdXQodGltZXIpO1xuICAgICAgICByZXR1cm4gZDtcbiAgICB9XG4gICAgZGVsZXRlKCkge1xuICAgICAgICBjb25zdCB7IHN0cmVhbV9uYW1lLCBuYW1lIH0gPSB0aGlzLl9pbmZvO1xuICAgICAgICByZXR1cm4gdGhpcy5hcGkuZGVsZXRlKHN0cmVhbV9uYW1lLCBuYW1lKTtcbiAgICB9XG4gICAgaW5mbyhjYWNoZWQgPSBmYWxzZSkge1xuICAgICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2luZm8pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3RyZWFtX25hbWUsIG5hbWUgfSA9IHRoaXMuX2luZm87XG4gICAgICAgIHJldHVybiB0aGlzLmFwaS5pbmZvKHN0cmVhbV9uYW1lLCBuYW1lKS50aGVuKChjaSk9PntcbiAgICAgICAgICAgIHRoaXMuX2luZm8gPSBjaTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbmZvO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBPcmRlcmVkUHVsbENvbnN1bWVySW1wbCB7XG4gICAgYXBpO1xuICAgIGNvbnN1bWVyT3B0cztcbiAgICBjb25zdW1lcjtcbiAgICBvcHRzO1xuICAgIGN1cnNvcjtcbiAgICBzdHJlYW07XG4gICAgbmFtZVByZWZpeDtcbiAgICBzZXJpYWw7XG4gICAgY3VycmVudENvbnN1bWVyO1xuICAgIHVzZXJDYWxsYmFjaztcbiAgICBpdGVyO1xuICAgIHR5cGU7XG4gICAgc3RhcnRTZXE7XG4gICAgbWF4SW5pdGlhbFJlc2V0O1xuICAgIGNvbnN0cnVjdG9yKGFwaSwgc3RyZWFtLCBvcHRzID0ge30pe1xuICAgICAgICB0aGlzLmFwaSA9IGFwaTtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIHRoaXMuY3Vyc29yID0ge1xuICAgICAgICAgICAgc3RyZWFtX3NlcTogMSxcbiAgICAgICAgICAgIGRlbGl2ZXJfc2VxOiAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubmFtZVByZWZpeCA9IG51aWQubmV4dCgpO1xuICAgICAgICBpZiAodHlwZW9mIG9wdHMubmFtZV9wcmVmaXggPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG1pblZhbGlkYXRpb24oXCJuYW1lX3ByZWZpeFwiLCBvcHRzLm5hbWVfcHJlZml4KTtcbiAgICAgICAgICAgIHRoaXMubmFtZVByZWZpeCA9IG9wdHMubmFtZV9wcmVmaXggKyB0aGlzLm5hbWVQcmVmaXg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXJpYWwgPSAwO1xuICAgICAgICB0aGlzLmN1cnJlbnRDb25zdW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMudXNlckNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5pdGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy50eXBlID0gUHVsbENvbnN1bWVyVHlwZS5VbnNldDtcbiAgICAgICAgdGhpcy5jb25zdW1lck9wdHMgPSBvcHRzO1xuICAgICAgICB0aGlzLm1heEluaXRpYWxSZXNldCA9IDMwO1xuICAgICAgICB0aGlzLnN0YXJ0U2VxID0gdGhpcy5jb25zdW1lck9wdHMub3B0X3N0YXJ0X3NlcSB8fCAwO1xuICAgICAgICB0aGlzLmN1cnNvci5zdHJlYW1fc2VxID0gdGhpcy5zdGFydFNlcSA+IDAgPyB0aGlzLnN0YXJ0U2VxIC0gMSA6IDA7XG4gICAgfVxuICAgIGdldENvbnN1bWVyT3B0cyhzZXEpIHtcbiAgICAgICAgdGhpcy5zZXJpYWwrKztcbiAgICAgICAgY29uc3QgbmFtZSA9IGAke3RoaXMubmFtZVByZWZpeH1fJHt0aGlzLnNlcmlhbH1gO1xuICAgICAgICBzZXEgPSBzZXEgPT09IDAgPyAxIDogc2VxO1xuICAgICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZGVsaXZlcl9wb2xpY3k6IERlbGl2ZXJQb2xpY3kuU3RhcnRTZXF1ZW5jZSxcbiAgICAgICAgICAgIG9wdF9zdGFydF9zZXE6IHNlcSxcbiAgICAgICAgICAgIGFja19wb2xpY3k6IEFja1BvbGljeS5Ob25lLFxuICAgICAgICAgICAgaW5hY3RpdmVfdGhyZXNob2xkOiBuYW5vcyg1ICogNjAgKiAxMDAwKSxcbiAgICAgICAgICAgIG51bV9yZXBsaWNhczogMVxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5jb25zdW1lck9wdHMuaGVhZGVyc19vbmx5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb25maWcuaGVhZGVyc19vbmx5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmNvbnN1bWVyT3B0cy5maWx0ZXJTdWJqZWN0cykpIHtcbiAgICAgICAgICAgIGNvbmZpZy5maWx0ZXJfc3ViamVjdHMgPSB0aGlzLmNvbnN1bWVyT3B0cy5maWx0ZXJTdWJqZWN0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29uc3VtZXJPcHRzLmZpbHRlclN1YmplY3RzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25maWcuZmlsdGVyX3N1YmplY3QgPSB0aGlzLmNvbnN1bWVyT3B0cy5maWx0ZXJTdWJqZWN0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25zdW1lck9wdHMucmVwbGF5X3BvbGljeSkge1xuICAgICAgICAgICAgY29uZmlnLnJlcGxheV9wb2xpY3kgPSB0aGlzLmNvbnN1bWVyT3B0cy5yZXBsYXlfcG9saWN5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXEgPT09IHRoaXMuc3RhcnRTZXEgKyAxKSB7XG4gICAgICAgICAgICBjb25maWcuZGVsaXZlcl9wb2xpY3kgPSB0aGlzLmNvbnN1bWVyT3B0cy5kZWxpdmVyX3BvbGljeSB8fCBEZWxpdmVyUG9saWN5LlN0YXJ0U2VxdWVuY2U7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25zdW1lck9wdHMuZGVsaXZlcl9wb2xpY3kgPT09IERlbGl2ZXJQb2xpY3kuTGFzdFBlclN1YmplY3QgfHwgdGhpcy5jb25zdW1lck9wdHMuZGVsaXZlcl9wb2xpY3kgPT09IERlbGl2ZXJQb2xpY3kuTmV3IHx8IHRoaXMuY29uc3VtZXJPcHRzLmRlbGl2ZXJfcG9saWN5ID09PSBEZWxpdmVyUG9saWN5Lkxhc3QpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgY29uZmlnLm9wdF9zdGFydF9zZXE7XG4gICAgICAgICAgICAgICAgY29uZmlnLmRlbGl2ZXJfcG9saWN5ID0gdGhpcy5jb25zdW1lck9wdHMuZGVsaXZlcl9wb2xpY3k7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnLmRlbGl2ZXJfcG9saWN5ID09PSBEZWxpdmVyUG9saWN5Lkxhc3RQZXJTdWJqZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25maWcuZmlsdGVyX3N1YmplY3RzID09PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBjb25maWcuZmlsdGVyX3N1YmplY3QgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmZpbHRlcl9zdWJqZWN0ID0gXCI+XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uc3VtZXJPcHRzLm9wdF9zdGFydF90aW1lKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5vcHRfc3RhcnRfc2VxO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5kZWxpdmVyX3BvbGljeSA9IERlbGl2ZXJQb2xpY3kuU3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5vcHRfc3RhcnRfdGltZSA9IHRoaXMuY29uc3VtZXJPcHRzLm9wdF9zdGFydF90aW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uc3VtZXJPcHRzLmluYWN0aXZlX3RocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5pbmFjdGl2ZV90aHJlc2hvbGQgPSBuYW5vcyh0aGlzLmNvbnN1bWVyT3B0cy5pbmFjdGl2ZV90aHJlc2hvbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuICAgIGFzeW5jIHJlc2V0Q29uc3VtZXIoc2VxID0gMCkge1xuICAgICAgICBudWlkLm5leHQoKTtcbiAgICAgICAgY29uc3QgaXNOZXcgPSB0aGlzLnNlcmlhbCA9PT0gMDtcbiAgICAgICAgdGhpcy5jb25zdW1lcj8uZGVsZXRlKCkuY2F0Y2goKCk9Pnt9KTtcbiAgICAgICAgc2VxID0gc2VxID09PSAwID8gMSA6IHNlcTtcbiAgICAgICAgdGhpcy5jdXJzb3IuZGVsaXZlcl9zZXEgPSAwO1xuICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLmdldENvbnN1bWVyT3B0cyhzZXEpO1xuICAgICAgICBjb25maWcubWF4X2RlbGl2ZXIgPSAxO1xuICAgICAgICBjb25maWcubWVtX3N0b3JhZ2UgPSB0cnVlO1xuICAgICAgICBjb25zdCBibyA9IGJhY2tvZmYoW1xuICAgICAgICAgICAgdGhpcy5vcHRzPy5leHBpcmVzIHx8IDMwXzAwMFxuICAgICAgICBdKTtcbiAgICAgICAgbGV0IGNpO1xuICAgICAgICBmb3IobGV0IGkgPSAwOzsgaSsrKXtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2kgPSBhd2FpdCB0aGlzLmFwaS5hZGQodGhpcy5zdHJlYW0sIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVyPy5ub3RpZnkoQ29uc3VtZXJFdmVudHMuT3JkZXJlZENvbnN1bWVyUmVjcmVhdGVkLCBjaS5uYW1lKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIubWVzc2FnZSA9PT0gXCJzdHJlYW0gbm90IGZvdW5kXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVyPy5ub3RpZnkoQ29uc3VtZXJFdmVudHMuU3RyZWFtTm90Rm91bmQsIGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSBQdWxsQ29uc3VtZXJUeXBlLkZldGNoIHx8IHRoaXMub3B0cy5hYm9ydF9vbl9taXNzaW5nX3Jlc291cmNlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZXI/LnN0b3AoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc05ldyAmJiBpID49IHRoaXMubWF4SW5pdGlhbFJlc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBkZWxheShiby5iYWNrb2ZmKGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaTtcbiAgICB9XG4gICAgaW50ZXJuYWxIYW5kbGVyKHNlcmlhbCkge1xuICAgICAgICByZXR1cm4gKG0pPT57XG4gICAgICAgICAgICBpZiAodGhpcy5zZXJpYWwgIT09IHNlcmlhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRzZXEgPSBtLmluZm8uZGVsaXZlcnlTZXF1ZW5jZTtcbiAgICAgICAgICAgIGlmIChkc2VxICE9PSB0aGlzLmN1cnNvci5kZWxpdmVyX3NlcSArIDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeU9yZGVyZWRSZXNldEFuZFJlc2V0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXJzb3IuZGVsaXZlcl9zZXEgPSBkc2VxO1xuICAgICAgICAgICAgdGhpcy5jdXJzb3Iuc3RyZWFtX3NlcSA9IG0uaW5mby5zdHJlYW1TZXF1ZW5jZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnVzZXJDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMudXNlckNhbGxiYWNrKG0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLml0ZXI/LnB1c2gobSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHJlc2V0KG9wdHMgPSB7XG4gICAgICAgIG1heF9tZXNzYWdlczogMTAwLFxuICAgICAgICBleHBpcmVzOiAzMF8wMDBcbiAgICB9LCBpbmZvKSB7XG4gICAgICAgIGluZm8gPSBpbmZvIHx8IHt9O1xuICAgICAgICBjb25zdCBmcm9tRmV0Y2ggPSBpbmZvLmZyb21GZXRjaCB8fCBmYWxzZTtcbiAgICAgICAgY29uc3Qgb3JkZXJlZFJlc2V0ID0gaW5mby5vcmRlcmVkUmVzZXQgfHwgZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFB1bGxDb25zdW1lclR5cGUuRmV0Y2ggJiYgb3JkZXJlZFJlc2V0KSB7XG4gICAgICAgICAgICB0aGlzLml0ZXI/LnNyYy5zdG9wKCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLml0ZXI/LmNsb3NlZCgpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29uc3VtZXIgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRDb25zdW1lciA9PT0gbnVsbCB8fCBvcmRlcmVkUmVzZXQpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENvbnN1bWVyID0gYXdhaXQgdGhpcy5yZXNldENvbnN1bWVyKHRoaXMuY3Vyc29yLnN0cmVhbV9zZXEgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pdGVyID09PSBudWxsIHx8IGZyb21GZXRjaCkge1xuICAgICAgICAgICAgdGhpcy5pdGVyID0gbmV3IE9yZGVyZWRDb25zdW1lck1lc3NhZ2VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25zdW1lciA9IG5ldyBQdWxsQ29uc3VtZXJJbXBsKHRoaXMuYXBpLCB0aGlzLmN1cnJlbnRDb25zdW1lcik7XG4gICAgICAgIGNvbnN0IGNvcHRzID0gb3B0cztcbiAgICAgICAgY29wdHMuY2FsbGJhY2sgPSB0aGlzLmludGVybmFsSGFuZGxlcih0aGlzLnNlcmlhbCk7XG4gICAgICAgIGxldCBtc2dzID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gUHVsbENvbnN1bWVyVHlwZS5GZXRjaCAmJiBmcm9tRmV0Y2gpIHtcbiAgICAgICAgICAgIG1zZ3MgPSBhd2FpdCB0aGlzLmNvbnN1bWVyLmZldGNoKG9wdHMpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gUHVsbENvbnN1bWVyVHlwZS5Db25zdW1lKSB7XG4gICAgICAgICAgICBtc2dzID0gYXdhaXQgdGhpcy5jb25zdW1lci5jb25zdW1lKG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1zZ3NJbXBsID0gbXNncztcbiAgICAgICAgbXNnc0ltcGwuZm9yT3JkZXJlZENvbnN1bWVyID0gdHJ1ZTtcbiAgICAgICAgbXNnc0ltcGwucmVzZXRIYW5kbGVyID0gKCk9PntcbiAgICAgICAgICAgIHRoaXMubm90aWZ5T3JkZXJlZFJlc2V0QW5kUmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pdGVyLnNldFNvdXJjZShtc2dzSW1wbCk7XG4gICAgfVxuICAgIG5vdGlmeU9yZGVyZWRSZXNldEFuZFJlc2V0KCkge1xuICAgICAgICB0aGlzLml0ZXI/Lm5vdGlmeShDb25zdW1lckRlYnVnRXZlbnRzLlJlc2V0LCBcIlwiKTtcbiAgICAgICAgdGhpcy5yZXNldCh0aGlzLm9wdHMsIHtcbiAgICAgICAgICAgIG9yZGVyZWRSZXNldDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgY29uc3VtZShvcHRzID0ge1xuICAgICAgICBtYXhfbWVzc2FnZXM6IDEwMCxcbiAgICAgICAgZXhwaXJlczogMzBfMDAwXG4gICAgfSkge1xuICAgICAgICBjb25zdCBjb3B0cyA9IG9wdHM7XG4gICAgICAgIGlmIChjb3B0cy5iaW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiYmluZCBpcyBub3Qgc3VwcG9ydGVkXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50eXBlID09PSBQdWxsQ29uc3VtZXJUeXBlLkZldGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwib3JkZXJlZCBjb25zdW1lciBpbml0aWFsaXplZCBhcyBmZXRjaFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gUHVsbENvbnN1bWVyVHlwZS5Db25zdW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwib3JkZXJlZCBjb25zdW1lciBkb2Vzbid0IHN1cHBvcnQgY29uY3VycmVudCBjb25zdW1lXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNhbGxiYWNrIH0gPSBvcHRzO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMudXNlckNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50eXBlID0gUHVsbENvbnN1bWVyVHlwZS5Db25zdW1lO1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgICBhd2FpdCB0aGlzLnJlc2V0KG9wdHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVyO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaChvcHRzID0ge1xuICAgICAgICBtYXhfbWVzc2FnZXM6IDEwMCxcbiAgICAgICAgZXhwaXJlczogMzBfMDAwXG4gICAgfSkge1xuICAgICAgICBjb25zdCBjb3B0cyA9IG9wdHM7XG4gICAgICAgIGlmIChjb3B0cy5iaW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiYmluZCBpcyBub3Qgc3VwcG9ydGVkXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50eXBlID09PSBQdWxsQ29uc3VtZXJUeXBlLkNvbnN1bWUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJvcmRlcmVkIGNvbnN1bWVyIGFscmVhZHkgaW5pdGlhbGl6ZWQgYXMgY29uc3VtZVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXRlcj8uZG9uZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJvcmRlcmVkIGNvbnN1bWVyIGRvZXNuJ3Qgc3VwcG9ydCBjb25jdXJyZW50IGZldGNoXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNhbGxiYWNrIH0gPSBvcHRzO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMudXNlckNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50eXBlID0gUHVsbENvbnN1bWVyVHlwZS5GZXRjaDtcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICAgICAgYXdhaXQgdGhpcy5yZXNldChvcHRzLCB7XG4gICAgICAgICAgICBmcm9tRmV0Y2g6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZXI7XG4gICAgfVxuICAgIGFzeW5jIG5leHQob3B0cyA9IHtcbiAgICAgICAgZXhwaXJlczogMzBfMDAwXG4gICAgfSkge1xuICAgICAgICBjb25zdCBjb3B0cyA9IG9wdHM7XG4gICAgICAgIGlmIChjb3B0cy5iaW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiYmluZCBpcyBub3Qgc3VwcG9ydGVkXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb3B0cy5tYXhfbWVzc2FnZXMgPSAxO1xuICAgICAgICBjb25zdCBkID0gZGVmZXJyZWQoKTtcbiAgICAgICAgY29wdHMuY2FsbGJhY2sgPSAobSk9PntcbiAgICAgICAgICAgIHRoaXMudXNlckNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgIGQucmVzb2x2ZShtKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaXRlciA9IGF3YWl0IHRoaXMuZmV0Y2goY29wdHMpO1xuICAgICAgICBpdGVyLml0ZXJDbG9zZWQudGhlbigoZXJyKT0+e1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGQucmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkLnJlc29sdmUobnVsbCk7XG4gICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICBkLnJlamVjdChlcnIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuICAgIGRlbGV0ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRDb25zdW1lcikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpLmRlbGV0ZSh0aGlzLnN0cmVhbSwgdGhpcy5jdXJyZW50Q29uc3VtZXIubmFtZSkudGhlbigodGYpPT57XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRmKTtcbiAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICB9KS5maW5hbGx5KCgpPT57XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDb25zdW1lciA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBpbmZvKGNhY2hlZCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50Q29uc3VtZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29uc3VtZXIgPSBhd2FpdCB0aGlzLnJlc2V0Q29uc3VtZXIodGhpcy5zdGFydFNlcSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuY3VycmVudENvbnN1bWVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FjaGVkICYmIHRoaXMuY3VycmVudENvbnN1bWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuY3VycmVudENvbnN1bWVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hcGkuaW5mbyh0aGlzLnN0cmVhbSwgdGhpcy5jdXJyZW50Q29uc3VtZXIubmFtZSk7XG4gICAgfVxufVxuY2xhc3MgQ29uc3VtZXJzSW1wbCB7XG4gICAgYXBpO1xuICAgIG5vdGlmaWVkO1xuICAgIGNvbnN0cnVjdG9yKGFwaSl7XG4gICAgICAgIHRoaXMuYXBpID0gYXBpO1xuICAgICAgICB0aGlzLm5vdGlmaWVkID0gZmFsc2U7XG4gICAgfVxuICAgIGNoZWNrVmVyc2lvbigpIHtcbiAgICAgICAgY29uc3QgZnYgPSB0aGlzLmFwaS5uYy5mZWF0dXJlcy5nZXQoRmVhdHVyZS5KU19TSU1QTElGSUNBVElPTik7XG4gICAgICAgIGlmICghZnYub2spIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYGNvbnN1bWVycyBmcmFtZXdvcmsgaXMgb25seSBzdXBwb3J0ZWQgb24gc2VydmVycyAke2Z2Lm1pbn0gb3IgYmV0dGVyYCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZ2V0UHVsbENvbnN1bWVyRm9yKGNpKSB7XG4gICAgICAgIGlmIChjaS5jb25maWcuZGVsaXZlcl9zdWJqZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInB1c2ggY29uc3VtZXIgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFB1bGxDb25zdW1lckltcGwodGhpcy5hcGksIGNpKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0KHN0cmVhbSwgbmFtZSA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3JkZXJlZChzdHJlYW0sIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuY2hlY2tWZXJzaW9uKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmFwaS5pbmZvKHN0cmVhbSwgbmFtZSkudGhlbigoY2kpPT57XG4gICAgICAgICAgICBpZiAoY2kuY29uZmlnLmRlbGl2ZXJfc3ViamVjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInB1c2ggY29uc3VtZXIgbm90IHN1cHBvcnRlZFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFB1bGxDb25zdW1lckltcGwodGhpcy5hcGksIGNpKTtcbiAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgb3JkZXJlZChzdHJlYW0sIG9wdHMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5jaGVja1ZlcnNpb24oKTtcbiAgICAgICAgY29uc3QgaW1wbCA9IHRoaXMuYXBpO1xuICAgICAgICBjb25zdCBzYXBpID0gbmV3IFN0cmVhbUFQSUltcGwoaW1wbC5uYywgaW1wbC5vcHRzKTtcbiAgICAgICAgcmV0dXJuIHNhcGkuaW5mbyhzdHJlYW0pLnRoZW4oKF9zaSk9PntcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IE9yZGVyZWRQdWxsQ29uc3VtZXJJbXBsKHRoaXMuYXBpLCBzdHJlYW0sIG9wdHMpKTtcbiAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBTdHJlYW1JbXBsIHtcbiAgICBhcGk7XG4gICAgX2luZm87XG4gICAgY29uc3RydWN0b3IoYXBpLCBpbmZvKXtcbiAgICAgICAgdGhpcy5hcGkgPSBhcGk7XG4gICAgICAgIHRoaXMuX2luZm8gPSBpbmZvO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZm8uY29uZmlnLm5hbWU7XG4gICAgfVxuICAgIGFsdGVybmF0ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZm8oKS50aGVuKChzaSk9PntcbiAgICAgICAgICAgIHJldHVybiBzaS5hbHRlcm5hdGVzID8gc2kuYWx0ZXJuYXRlcyA6IFtdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgYmVzdCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbmZvKCk7XG4gICAgICAgIGlmICh0aGlzLl9pbmZvLmFsdGVybmF0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFzaSA9IGF3YWl0IHRoaXMuYXBpLmluZm8odGhpcy5faW5mby5hbHRlcm5hdGVzWzBdLm5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1JbXBsKHRoaXMuYXBpLCBhc2kpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5mbyhjYWNoZWQgPSBmYWxzZSwgb3B0cykge1xuICAgICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2luZm8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFwaS5pbmZvKHRoaXMubmFtZSwgb3B0cykudGhlbigoc2kpPT57XG4gICAgICAgICAgICB0aGlzLl9pbmZvID0gc2k7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5mbztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldENvbnN1bWVyRnJvbUluZm8oY2kpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb25zdW1lcnNJbXBsKG5ldyBDb25zdW1lckFQSUltcGwodGhpcy5hcGkubmMsIHRoaXMuYXBpLm9wdHMpKS5nZXRQdWxsQ29uc3VtZXJGb3IoY2kpO1xuICAgIH1cbiAgICBnZXRDb25zdW1lcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29uc3VtZXJzSW1wbChuZXcgQ29uc3VtZXJBUElJbXBsKHRoaXMuYXBpLm5jLCB0aGlzLmFwaS5vcHRzKSkuZ2V0KHRoaXMubmFtZSwgbmFtZSk7XG4gICAgfVxuICAgIGdldE1lc3NhZ2UocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpLmdldE1lc3NhZ2UodGhpcy5uYW1lLCBxdWVyeSk7XG4gICAgfVxuICAgIGRlbGV0ZU1lc3NhZ2Uoc2VxLCBlcmFzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcGkuZGVsZXRlTWVzc2FnZSh0aGlzLm5hbWUsIHNlcSwgZXJhc2UpO1xuICAgIH1cbn1cbmNsYXNzIFN0cmVhbUFQSUltcGwgZXh0ZW5kcyBCYXNlQXBpQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYywgb3B0cyl7XG4gICAgICAgIHN1cGVyKG5jLCBvcHRzKTtcbiAgICB9XG4gICAgY2hlY2tTdHJlYW1Db25maWdWZXJzaW9ucyhjZmcpIHtcbiAgICAgICAgY29uc3QgbmNpID0gdGhpcy5uYztcbiAgICAgICAgaWYgKGNmZy5tZXRhZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgeyBtaW4sIG9rIH0gPSBuY2kuZmVhdHVyZXMuZ2V0KEZlYXR1cmUuSlNfU1RSRUFNX0NPTlNVTUVSX01FVEFEQVRBKTtcbiAgICAgICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN0cmVhbSAnbWV0YWRhdGEnIHJlcXVpcmVzIHNlcnZlciAke21pbn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ZnLmZpcnN0X3NlcSkge1xuICAgICAgICAgICAgY29uc3QgeyBtaW4sIG9rIH0gPSBuY2kuZmVhdHVyZXMuZ2V0KEZlYXR1cmUuSlNfU1RSRUFNX0ZJUlNUX1NFUSk7XG4gICAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdHJlYW0gJ2ZpcnN0X3NlcScgcmVxdWlyZXMgc2VydmVyICR7bWlufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjZmcuc3ViamVjdF90cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbWluLCBvayB9ID0gbmNpLmZlYXR1cmVzLmdldChGZWF0dXJlLkpTX1NUUkVBTV9TVUJKRUNUX1RSQU5TRk9STSk7XG4gICAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdHJlYW0gJ3N1YmplY3RfdHJhbnNmb3JtJyByZXF1aXJlcyBzZXJ2ZXIgJHttaW59YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNmZy5jb21wcmVzc2lvbikge1xuICAgICAgICAgICAgY29uc3QgeyBtaW4sIG9rIH0gPSBuY2kuZmVhdHVyZXMuZ2V0KEZlYXR1cmUuSlNfU1RSRUFNX0NPTVBSRVNTSU9OKTtcbiAgICAgICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN0cmVhbSAnY29tcHJlc3Npb24nIHJlcXVpcmVzIHNlcnZlciAke21pbn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ZnLmNvbnN1bWVyX2xpbWl0cykge1xuICAgICAgICAgICAgY29uc3QgeyBtaW4sIG9rIH0gPSBuY2kuZmVhdHVyZXMuZ2V0KEZlYXR1cmUuSlNfREVGQVVMVF9DT05TVU1FUl9MSU1JVFMpO1xuICAgICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc3RyZWFtICdjb25zdW1lcl9saW1pdHMnIHJlcXVpcmVzIHNlcnZlciAke21pbn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZVN0cmVhbVNvdXJjZShjb250ZXh0LCBzcmMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gc3JjPy5zdWJqZWN0X3RyYW5zZm9ybXM/Lmxlbmd0aCB8fCAwO1xuICAgICAgICAgICAgaWYgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbWluLCBvayB9ID0gbmNpLmZlYXR1cmVzLmdldChGZWF0dXJlLkpTX1NUUkVBTV9TT1VSQ0VfU1VCSkVDVF9UUkFOU0ZPUk0pO1xuICAgICAgICAgICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnRleHR9ICdzdWJqZWN0X3RyYW5zZm9ybXMnIHJlcXVpcmVzIHNlcnZlciAke21pbn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNmZy5zb3VyY2VzKSB7XG4gICAgICAgICAgICBjZmcuc291cmNlcy5mb3JFYWNoKChzcmMpPT57XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVTdHJlYW1Tb3VyY2UoXCJzdHJlYW0gc291cmNlc1wiLCBzcmMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNmZy5taXJyb3IpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlU3RyZWFtU291cmNlKFwic3RyZWFtIG1pcnJvclwiLCBjZmcubWlycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBhZGQoY2ZnID0ge30pIHtcbiAgICAgICAgdGhpcy5jaGVja1N0cmVhbUNvbmZpZ1ZlcnNpb25zKGNmZyk7XG4gICAgICAgIHZhbGlkYXRlU3RyZWFtTmFtZShjZmcubmFtZSk7XG4gICAgICAgIGNmZy5taXJyb3IgPSBjb252ZXJ0U3RyZWFtU291cmNlRG9tYWluKGNmZy5taXJyb3IpO1xuICAgICAgICBjZmcuc291cmNlcyA9IGNmZy5zb3VyY2VzPy5tYXAoY29udmVydFN0cmVhbVNvdXJjZURvbWFpbik7XG4gICAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLl9yZXF1ZXN0KGAke3RoaXMucHJlZml4fS5TVFJFQU0uQ1JFQVRFLiR7Y2ZnLm5hbWV9YCwgY2ZnKTtcbiAgICAgICAgY29uc3Qgc2kgPSByO1xuICAgICAgICB0aGlzLl9maXhJbmZvKHNpKTtcbiAgICAgICAgcmV0dXJuIHNpO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGUoc3RyZWFtKSB7XG4gICAgICAgIHZhbGlkYXRlU3RyZWFtTmFtZShzdHJlYW0pO1xuICAgICAgICBjb25zdCByID0gYXdhaXQgdGhpcy5fcmVxdWVzdChgJHt0aGlzLnByZWZpeH0uU1RSRUFNLkRFTEVURS4ke3N0cmVhbX1gKTtcbiAgICAgICAgY29uc3QgY3IgPSByO1xuICAgICAgICByZXR1cm4gY3Iuc3VjY2VzcztcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlKG5hbWUsIGNmZyA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29uc3Qgc2MgPSBuYW1lO1xuICAgICAgICAgICAgbmFtZSA9IHNjLm5hbWU7XG4gICAgICAgICAgICBjZmcgPSBzYztcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoYFxcdTAwMUJbMzNtID4+IHN0cmVhbXMudXBkYXRlKGNvbmZpZzogU3RyZWFtQ29uZmlnKSBhcGkgY2hhbmdlZCB0byBzdHJlYW1zLnVwZGF0ZShuYW1lOiBzdHJpbmcsIGNvbmZpZzogU3RyZWFtVXBkYXRlQ29uZmlnKSAtIHRoaXMgc2hpbSB3aWxsIGJlIHJlbW92ZWQgLSB1cGRhdGUgeW91ciBjb2RlLiAgXFx1MDAxQlswbWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tTdHJlYW1Db25maWdWZXJzaW9ucyhjZmcpO1xuICAgICAgICB2YWxpZGF0ZVN0cmVhbU5hbWUobmFtZSk7XG4gICAgICAgIGNvbnN0IG9sZCA9IGF3YWl0IHRoaXMuaW5mbyhuYW1lKTtcbiAgICAgICAgY29uc3QgdXBkYXRlID0gT2JqZWN0LmFzc2lnbihvbGQuY29uZmlnLCBjZmcpO1xuICAgICAgICB1cGRhdGUubWlycm9yID0gY29udmVydFN0cmVhbVNvdXJjZURvbWFpbih1cGRhdGUubWlycm9yKTtcbiAgICAgICAgdXBkYXRlLnNvdXJjZXMgPSB1cGRhdGUuc291cmNlcz8ubWFwKGNvbnZlcnRTdHJlYW1Tb3VyY2VEb21haW4pO1xuICAgICAgICBjb25zdCByID0gYXdhaXQgdGhpcy5fcmVxdWVzdChgJHt0aGlzLnByZWZpeH0uU1RSRUFNLlVQREFURS4ke25hbWV9YCwgdXBkYXRlKTtcbiAgICAgICAgY29uc3Qgc2kgPSByO1xuICAgICAgICB0aGlzLl9maXhJbmZvKHNpKTtcbiAgICAgICAgcmV0dXJuIHNpO1xuICAgIH1cbiAgICBhc3luYyBpbmZvKG5hbWUsIGRhdGEpIHtcbiAgICAgICAgdmFsaWRhdGVTdHJlYW1OYW1lKG5hbWUpO1xuICAgICAgICBjb25zdCBzdWJqID0gYCR7dGhpcy5wcmVmaXh9LlNUUkVBTS5JTkZPLiR7bmFtZX1gO1xuICAgICAgICBjb25zdCByID0gYXdhaXQgdGhpcy5fcmVxdWVzdChzdWJqLCBkYXRhKTtcbiAgICAgICAgbGV0IHNpID0gcjtcbiAgICAgICAgbGV0IHsgdG90YWwsIGxpbWl0IH0gPSBzaTtcbiAgICAgICAgbGV0IGhhdmUgPSBzaS5zdGF0ZS5zdWJqZWN0cyA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNpLnN0YXRlLnN1YmplY3RzKS5sZW5ndGggOiAxO1xuICAgICAgICBpZiAodG90YWwgJiYgdG90YWwgPiBoYXZlKSB7XG4gICAgICAgICAgICBjb25zdCBpbmZvcyA9IFtcbiAgICAgICAgICAgICAgICBzaVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbnN0IHBhZ2VkID0gZGF0YSB8fCB7fTtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlKHRvdGFsID4gaGF2ZSl7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIHBhZ2VkLm9mZnNldCA9IGxpbWl0ICogaTtcbiAgICAgICAgICAgICAgICBjb25zdCByID0gYXdhaXQgdGhpcy5fcmVxdWVzdChzdWJqLCBwYWdlZCk7XG4gICAgICAgICAgICAgICAgdG90YWwgPSByLnRvdGFsO1xuICAgICAgICAgICAgICAgIGluZm9zLnB1c2gocik7XG4gICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhyLnN0YXRlLnN1YmplY3RzKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaGF2ZSArPSBjb3VudDtcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPCBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3ViamVjdHMgPSB7fTtcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBpbmZvcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgc2kgPSBpbmZvc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoc2kuc3RhdGUuc3ViamVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViamVjdHMgPSBPYmplY3QuYXNzaWduKHN1YmplY3RzLCBzaS5zdGF0ZS5zdWJqZWN0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2kub2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHNpLnRvdGFsID0gMDtcbiAgICAgICAgICAgIHNpLmxpbWl0ID0gMDtcbiAgICAgICAgICAgIHNpLnN0YXRlLnN1YmplY3RzID0gc3ViamVjdHM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZml4SW5mbyhzaSk7XG4gICAgICAgIHJldHVybiBzaTtcbiAgICB9XG4gICAgbGlzdChzdWJqZWN0ID0gXCJcIikge1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gc3ViamVjdD8ubGVuZ3RoID8ge1xuICAgICAgICAgICAgc3ViamVjdFxuICAgICAgICB9IDoge307XG4gICAgICAgIGNvbnN0IGxpc3RlckZpbHRlciA9ICh2KT0+e1xuICAgICAgICAgICAgY29uc3Qgc2xyID0gdjtcbiAgICAgICAgICAgIHNsci5zdHJlYW1zLmZvckVhY2goKHNpKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpeEluZm8oc2kpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc2xyLnN0cmVhbXM7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN1YmogPSBgJHt0aGlzLnByZWZpeH0uU1RSRUFNLkxJU1RgO1xuICAgICAgICByZXR1cm4gbmV3IExpc3RlckltcGwoc3ViaiwgbGlzdGVyRmlsdGVyLCB0aGlzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgX2ZpeEluZm8oc2kpIHtcbiAgICAgICAgc2kuY29uZmlnLnNlYWxlZCA9IHNpLmNvbmZpZy5zZWFsZWQgfHwgZmFsc2U7XG4gICAgICAgIHNpLmNvbmZpZy5kZW55X2RlbGV0ZSA9IHNpLmNvbmZpZy5kZW55X2RlbGV0ZSB8fCBmYWxzZTtcbiAgICAgICAgc2kuY29uZmlnLmRlbnlfcHVyZ2UgPSBzaS5jb25maWcuZGVueV9wdXJnZSB8fCBmYWxzZTtcbiAgICAgICAgc2kuY29uZmlnLmFsbG93X3JvbGx1cF9oZHJzID0gc2kuY29uZmlnLmFsbG93X3JvbGx1cF9oZHJzIHx8IGZhbHNlO1xuICAgIH1cbiAgICBhc3luYyBwdXJnZShuYW1lLCBvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzKSB7XG4gICAgICAgICAgICBjb25zdCB7IGtlZXAsIHNlcSB9ID0gb3B0cztcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2VlcCA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2Ygc2VxID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FuIHNwZWNpZnkgb25lIG9mIGtlZXAgb3Igc2VxXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhbGlkYXRlU3RyZWFtTmFtZShuYW1lKTtcbiAgICAgICAgY29uc3QgdiA9IGF3YWl0IHRoaXMuX3JlcXVlc3QoYCR7dGhpcy5wcmVmaXh9LlNUUkVBTS5QVVJHRS4ke25hbWV9YCwgb3B0cyk7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVNZXNzYWdlKHN0cmVhbSwgc2VxLCBlcmFzZSA9IHRydWUpIHtcbiAgICAgICAgdmFsaWRhdGVTdHJlYW1OYW1lKHN0cmVhbSk7XG4gICAgICAgIGNvbnN0IGRyID0ge1xuICAgICAgICAgICAgc2VxXG4gICAgICAgIH07XG4gICAgICAgIGlmICghZXJhc2UpIHtcbiAgICAgICAgICAgIGRyLm5vX2VyYXNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByID0gYXdhaXQgdGhpcy5fcmVxdWVzdChgJHt0aGlzLnByZWZpeH0uU1RSRUFNLk1TRy5ERUxFVEUuJHtzdHJlYW19YCwgZHIpO1xuICAgICAgICBjb25zdCBjciA9IHI7XG4gICAgICAgIHJldHVybiBjci5zdWNjZXNzO1xuICAgIH1cbiAgICBhc3luYyBnZXRNZXNzYWdlKHN0cmVhbSwgcXVlcnkpIHtcbiAgICAgICAgdmFsaWRhdGVTdHJlYW1OYW1lKHN0cmVhbSk7XG4gICAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLl9yZXF1ZXN0KGAke3RoaXMucHJlZml4fS5TVFJFQU0uTVNHLkdFVC4ke3N0cmVhbX1gLCBxdWVyeSk7XG4gICAgICAgIGNvbnN0IHNtID0gcjtcbiAgICAgICAgcmV0dXJuIG5ldyBTdG9yZWRNc2dJbXBsKHNtKTtcbiAgICB9XG4gICAgZmluZChzdWJqZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRTdHJlYW0oc3ViamVjdCk7XG4gICAgfVxuICAgIGxpc3RLdnMoKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9ICh2KT0+e1xuICAgICAgICAgICAgY29uc3Qgc2xyID0gdjtcbiAgICAgICAgICAgIGNvbnN0IGt2U3RyZWFtcyA9IHNsci5zdHJlYW1zLmZpbHRlcigodik9PntcbiAgICAgICAgICAgICAgICByZXR1cm4gdi5jb25maWcubmFtZS5zdGFydHNXaXRoKGt2UHJlZml4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAga3ZTdHJlYW1zLmZvckVhY2goKHNpKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpeEluZm8oc2kpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgY2x1c3RlciA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoa3ZTdHJlYW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNsdXN0ZXIgPSB0aGlzLm5jLmluZm8/LmNsdXN0ZXIgPz8gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IGt2U3RyZWFtcy5tYXAoKHNpKT0+e1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgS3ZTdGF0dXNJbXBsKHNpLCBjbHVzdGVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3ViaiA9IGAke3RoaXMucHJlZml4fS5TVFJFQU0uTElTVGA7XG4gICAgICAgIHJldHVybiBuZXcgTGlzdGVySW1wbChzdWJqLCBmaWx0ZXIsIHRoaXMpO1xuICAgIH1cbiAgICBsaXN0T2JqZWN0U3RvcmVzKCkge1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSAodik9PntcbiAgICAgICAgICAgIGNvbnN0IHNsciA9IHY7XG4gICAgICAgICAgICBjb25zdCBvYmpTdHJlYW1zID0gc2xyLnN0cmVhbXMuZmlsdGVyKCh2KT0+e1xuICAgICAgICAgICAgICAgIHJldHVybiB2LmNvbmZpZy5uYW1lLnN0YXJ0c1dpdGgob3NQcmVmaXgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvYmpTdHJlYW1zLmZvckVhY2goKHNpKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpeEluZm8oc2kpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBvYmpTdHJlYW1zLm1hcCgoc2kpPT57XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBPYmplY3RTdG9yZVN0YXR1c0ltcGwoc2kpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdWJqID0gYCR7dGhpcy5wcmVmaXh9LlNUUkVBTS5MSVNUYDtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXN0ZXJJbXBsKHN1YmosIGZpbHRlciwgdGhpcyk7XG4gICAgfVxuICAgIG5hbWVzKHN1YmplY3QgPSBcIlwiKSB7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBzdWJqZWN0Py5sZW5ndGggPyB7XG4gICAgICAgICAgICBzdWJqZWN0XG4gICAgICAgIH0gOiB7fTtcbiAgICAgICAgY29uc3QgbGlzdGVyRmlsdGVyID0gKHYpPT57XG4gICAgICAgICAgICBjb25zdCBzciA9IHY7XG4gICAgICAgICAgICByZXR1cm4gc3Iuc3RyZWFtcztcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3ViaiA9IGAke3RoaXMucHJlZml4fS5TVFJFQU0uTkFNRVNgO1xuICAgICAgICByZXR1cm4gbmV3IExpc3RlckltcGwoc3ViaiwgbGlzdGVyRmlsdGVyLCB0aGlzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0KG5hbWUpIHtcbiAgICAgICAgY29uc3Qgc2kgPSBhd2FpdCB0aGlzLmluZm8obmFtZSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IFN0cmVhbUltcGwodGhpcywgc2kpKTtcbiAgICB9XG59XG5jbGFzcyBEaXJlY3RTdHJlYW1BUElJbXBsIGV4dGVuZHMgQmFzZUFwaUNsaWVudCB7XG4gICAgY29uc3RydWN0b3IobmMsIG9wdHMpe1xuICAgICAgICBzdXBlcihuYywgb3B0cyk7XG4gICAgfVxuICAgIGFzeW5jIGdldE1lc3NhZ2Uoc3RyZWFtLCBxdWVyeSkge1xuICAgICAgICB2YWxpZGF0ZVN0cmVhbU5hbWUoc3RyZWFtKTtcbiAgICAgICAgbGV0IHFxID0gcXVlcnk7XG4gICAgICAgIGNvbnN0IHsgbGFzdF9ieV9zdWJqIH0gPSBxcTtcbiAgICAgICAgaWYgKGxhc3RfYnlfc3Viaikge1xuICAgICAgICAgICAgcXEgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBxcSA/IHRoaXMuamMuZW5jb2RlKHFxKSA6IEVtcHR5O1xuICAgICAgICBjb25zdCBwcmUgPSB0aGlzLm9wdHMuYXBpUHJlZml4IHx8IFwiJEpTLkFQSVwiO1xuICAgICAgICBjb25zdCBzdWJqID0gbGFzdF9ieV9zdWJqID8gYCR7cHJlfS5ESVJFQ1QuR0VULiR7c3RyZWFtfS4ke2xhc3RfYnlfc3Vian1gIDogYCR7cHJlfS5ESVJFQ1QuR0VULiR7c3RyZWFtfWA7XG4gICAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLm5jLnJlcXVlc3Qoc3ViaiwgcGF5bG9hZCwge1xuICAgICAgICAgICAgdGltZW91dDogdGhpcy50aW1lb3V0XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBlcnIgPSBjaGVja0pzRXJyb3Iocik7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRtID0gbmV3IERpcmVjdE1zZ0ltcGwocik7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZG0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRCYXRjaChzdHJlYW0sIG9wdHMpIHtcbiAgICAgICAgdmFsaWRhdGVTdHJlYW1OYW1lKHN0cmVhbSk7XG4gICAgICAgIGNvbnN0IHByZSA9IHRoaXMub3B0cy5hcGlQcmVmaXggfHwgXCIkSlMuQVBJXCI7XG4gICAgICAgIGNvbnN0IHN1YmogPSBgJHtwcmV9LkRJUkVDVC5HRVQuJHtzdHJlYW19YDtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdHMubXVsdGlfbGFzdCkgfHwgb3B0cy5tdWx0aV9sYXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwibXVsdGlfbGFzdCBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkob3B0cywgKGtleSwgdmFsdWUpPT57XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcInVwX3RvX3RpbWVcIiAmJiB2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGl0ZXIgPSBuZXcgUXVldWVkSXRlcmF0b3JJbXBsKCk7XG4gICAgICAgIGNvbnN0IHJhdyA9IGF3YWl0IHRoaXMubmMucmVxdWVzdE1hbnkoc3ViaiwgcGF5bG9hZCwge1xuICAgICAgICAgICAgc3RyYXRlZ3k6IFJlcXVlc3RTdHJhdGVneS5TZW50aW5lbE1zZ1xuICAgICAgICB9KTtcbiAgICAgICAgKGFzeW5jICgpPT57XG4gICAgICAgICAgICBsZXQgZ290Rmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBiYWRTZXJ2ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBiYWRSZXF1ZXN0O1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBtIG9mIHJhdyl7XG4gICAgICAgICAgICAgICAgaWYgKCFnb3RGaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICBnb3RGaXJzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBtLmhlYWRlcnM/LmNvZGUgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgIT09IDAgJiYgY29kZSA8IDIwMCB8fCBjb2RlID4gMjk5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYWRSZXF1ZXN0ID0gbS5oZWFkZXJzPy5kZXNjcmlwdGlvbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IG0uaGVhZGVycz8uZ2V0KFwiTmF0cy1OdW0tUGVuZGluZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhZFNlcnZlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobS5kYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXRlci5wdXNoKG5ldyBEaXJlY3RNc2dJbXBsKG0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZXIucHVzaCgoKT0+e1xuICAgICAgICAgICAgICAgIGlmIChiYWRTZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmF0Y2ggZGlyZWN0IGdldCBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBzZXJ2ZXJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChiYWRSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmFkIHJlcXVlc3Q6ICR7YmFkUmVxdWVzdH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXRlci5zdG9wKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShpdGVyKTtcbiAgICB9XG59XG5jbGFzcyBEaXJlY3RNc2dJbXBsIHtcbiAgICBkYXRhO1xuICAgIGhlYWRlcjtcbiAgICBzdGF0aWMgamM7XG4gICAgY29uc3RydWN0b3IobSl7XG4gICAgICAgIGlmICghbS5oZWFkZXJzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJoZWFkZXJzIGV4cGVjdGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YSA9IG0uZGF0YTtcbiAgICAgICAgdGhpcy5oZWFkZXIgPSBtLmhlYWRlcnM7XG4gICAgfVxuICAgIGdldCBzdWJqZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXIubGFzdChEaXJlY3RNc2dIZWFkZXJzLlN1YmplY3QpO1xuICAgIH1cbiAgICBnZXQgc2VxKCkge1xuICAgICAgICBjb25zdCB2ID0gdGhpcy5oZWFkZXIubGFzdChEaXJlY3RNc2dIZWFkZXJzLlNlcXVlbmNlKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2ID09PSBcInN0cmluZ1wiID8gcGFyc2VJbnQodikgOiAwO1xuICAgIH1cbiAgICBnZXQgdGltZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUucGFyc2UodGhpcy50aW1lc3RhbXApKTtcbiAgICB9XG4gICAgZ2V0IHRpbWVzdGFtcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyLmxhc3QoRGlyZWN0TXNnSGVhZGVycy5UaW1lU3RhbXApO1xuICAgIH1cbiAgICBnZXQgc3RyZWFtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXIubGFzdChEaXJlY3RNc2dIZWFkZXJzLlN0cmVhbSk7XG4gICAgfVxuICAgIGpzb24ocmV2aXZlcikge1xuICAgICAgICByZXR1cm4gSlNPTkNvZGVjKHJldml2ZXIpLmRlY29kZSh0aGlzLmRhdGEpO1xuICAgIH1cbiAgICBzdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBURC5kZWNvZGUodGhpcy5kYXRhKTtcbiAgICB9XG59XG5jbGFzcyBKZXRTdHJlYW1NYW5hZ2VySW1wbCBleHRlbmRzIEJhc2VBcGlDbGllbnQge1xuICAgIHN0cmVhbXM7XG4gICAgY29uc3VtZXJzO1xuICAgIGRpcmVjdDtcbiAgICBjb25zdHJ1Y3RvcihuYywgb3B0cyl7XG4gICAgICAgIHN1cGVyKG5jLCBvcHRzKTtcbiAgICAgICAgdGhpcy5zdHJlYW1zID0gbmV3IFN0cmVhbUFQSUltcGwobmMsIG9wdHMpO1xuICAgICAgICB0aGlzLmNvbnN1bWVycyA9IG5ldyBDb25zdW1lckFQSUltcGwobmMsIG9wdHMpO1xuICAgICAgICB0aGlzLmRpcmVjdCA9IG5ldyBEaXJlY3RTdHJlYW1BUElJbXBsKG5jLCBvcHRzKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QWNjb3VudEluZm8oKSB7XG4gICAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLl9yZXF1ZXN0KGAke3RoaXMucHJlZml4fS5JTkZPYCk7XG4gICAgICAgIHJldHVybiByO1xuICAgIH1cbiAgICBqZXRzdHJlYW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5jLmpldHN0cmVhbSh0aGlzLmdldE9wdGlvbnMoKSk7XG4gICAgfVxuICAgIGFkdmlzb3JpZXMoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXIgPSBuZXcgUXVldWVkSXRlcmF0b3JJbXBsKCk7XG4gICAgICAgIHRoaXMubmMuc3Vic2NyaWJlKGAkSlMuRVZFTlQuQURWSVNPUlkuPmAsIHtcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoZXJyLCBtc2cpPT57XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGQgPSB0aGlzLnBhcnNlSnNSZXNwb25zZShtc2cpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVua3MgPSBkLnR5cGUuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBraW5kID0gY2h1bmtzW2NodW5rcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaXRlci5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpdGVyLnN0b3AoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaXRlcjtcbiAgICB9XG59XG5jbGFzcyBTdG9yZWRNc2dJbXBsIHtcbiAgICBfaGVhZGVyO1xuICAgIHNtcjtcbiAgICBzdGF0aWMgamM7XG4gICAgY29uc3RydWN0b3Ioc21yKXtcbiAgICAgICAgdGhpcy5zbXIgPSBzbXI7XG4gICAgfVxuICAgIGdldCBzdWJqZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbXIubWVzc2FnZS5zdWJqZWN0O1xuICAgIH1cbiAgICBnZXQgc2VxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbXIubWVzc2FnZS5zZXE7XG4gICAgfVxuICAgIGdldCB0aW1lc3RhbXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNtci5tZXNzYWdlLnRpbWU7XG4gICAgfVxuICAgIGdldCB0aW1lKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5wYXJzZSh0aGlzLnRpbWVzdGFtcCkpO1xuICAgIH1cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc21yLm1lc3NhZ2UuZGF0YSA/IHRoaXMuX3BhcnNlKHRoaXMuc21yLm1lc3NhZ2UuZGF0YSkgOiBFbXB0eTtcbiAgICB9XG4gICAgZ2V0IGhlYWRlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNtci5tZXNzYWdlLmhkcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZCA9IHRoaXMuX3BhcnNlKHRoaXMuc21yLm1lc3NhZ2UuaGRycyk7XG4gICAgICAgICAgICAgICAgdGhpcy5faGVhZGVyID0gTXNnSGRyc0ltcGwuZGVjb2RlKGhkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGVhZGVyID0gaGVhZGVycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXI7XG4gICAgfVxuICAgIF9wYXJzZShzKSB7XG4gICAgICAgIGNvbnN0IGJzID0gYXRvYihzKTtcbiAgICAgICAgY29uc3QgbGVuID0gYnMubGVuZ3RoO1xuICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgICAgICBieXRlc1tpXSA9IGJzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgICBqc29uKHJldml2ZXIpIHtcbiAgICAgICAgcmV0dXJuIEpTT05Db2RlYyhyZXZpdmVyKS5kZWNvZGUodGhpcy5kYXRhKTtcbiAgICB9XG4gICAgc3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gVEQuZGVjb2RlKHRoaXMuZGF0YSk7XG4gICAgfVxufVxuY2xhc3MgU3RyZWFtc0ltcGwge1xuICAgIGFwaTtcbiAgICBjb25zdHJ1Y3RvcihhcGkpe1xuICAgICAgICB0aGlzLmFwaSA9IGFwaTtcbiAgICB9XG4gICAgZ2V0KHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcGkuaW5mbyhzdHJlYW0pLnRoZW4oKHNpKT0+e1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1JbXBsKHRoaXMuYXBpLCBzaSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIE9iamVjdEluZm9JbXBsIHtcbiAgICBpbmZvO1xuICAgIGhkcnM7XG4gICAgY29uc3RydWN0b3Iob2kpe1xuICAgICAgICB0aGlzLmluZm8gPSBvaTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZm8ubmFtZTtcbiAgICB9XG4gICAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmZvLmRlc2NyaXB0aW9uID8/IFwiXCI7XG4gICAgfVxuICAgIGdldCBoZWFkZXJzKCkge1xuICAgICAgICBpZiAoIXRoaXMuaGRycykge1xuICAgICAgICAgICAgdGhpcy5oZHJzID0gTXNnSGRyc0ltcGwuZnJvbVJlY29yZCh0aGlzLmluZm8uaGVhZGVycyB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaGRycztcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZm8ub3B0aW9ucztcbiAgICB9XG4gICAgZ2V0IGJ1Y2tldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5mby5idWNrZXQ7XG4gICAgfVxuICAgIGdldCBjaHVua3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZm8uY2h1bmtzO1xuICAgIH1cbiAgICBnZXQgZGVsZXRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5mby5kZWxldGVkID8/IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgZGlnZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmZvLmRpZ2VzdDtcbiAgICB9XG4gICAgZ2V0IG10aW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmZvLm10aW1lO1xuICAgIH1cbiAgICBnZXQgbnVpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5mby5udWlkO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5mby5zaXplO1xuICAgIH1cbiAgICBnZXQgcmV2aXNpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZm8ucmV2aXNpb247XG4gICAgfVxuICAgIGdldCBtZXRhZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5mby5tZXRhZGF0YSB8fCB7fTtcbiAgICB9XG4gICAgaXNMaW5rKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmZvLm9wdGlvbnM/LmxpbmsgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmluZm8ub3B0aW9ucz8ubGluayAhPT0gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiB0b1NlcnZlck9iamVjdFN0b3JlTWV0YShtZXRhKSB7XG4gICAgY29uc3QgdiA9IHtcbiAgICAgICAgbmFtZTogbWV0YS5uYW1lLFxuICAgICAgICBkZXNjcmlwdGlvbjogbWV0YS5kZXNjcmlwdGlvbiA/PyBcIlwiLFxuICAgICAgICBvcHRpb25zOiBtZXRhLm9wdGlvbnMsXG4gICAgICAgIG1ldGFkYXRhOiBtZXRhLm1ldGFkYXRhXG4gICAgfTtcbiAgICBpZiAobWV0YS5oZWFkZXJzKSB7XG4gICAgICAgIGNvbnN0IG1oaSA9IG1ldGEuaGVhZGVycztcbiAgICAgICAgdi5oZWFkZXJzID0gbWhpLnRvUmVjb3JkKCk7XG4gICAgfVxuICAgIHJldHVybiB2O1xufVxuZnVuY3Rpb24gZW1wdHlSZWFkYWJsZVN0cmVhbSgpIHtcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgcHVsbCAoYykge1xuICAgICAgICAgICAgYy5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KDApKTtcbiAgICAgICAgICAgIGMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuY2xhc3MgT2JqZWN0U3RvcmVJbXBsIHtcbiAgICBqc207XG4gICAganM7XG4gICAgc3RyZWFtO1xuICAgIG5hbWU7XG4gICAgY29uc3RydWN0b3IobmFtZSwganNtLCBqcyl7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuanNtID0ganNtO1xuICAgICAgICB0aGlzLmpzID0ganM7XG4gICAgfVxuICAgIF9jaGVja05vdEVtcHR5KG5hbWUpIHtcbiAgICAgICAgaWYgKCFuYW1lIHx8IG5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihcIm5hbWUgY2Fubm90IGJlIGVtcHR5XCIpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGluZm8obmFtZSkge1xuICAgICAgICBjb25zdCBpbmZvID0gYXdhaXQgdGhpcy5yYXdJbmZvKG5hbWUpO1xuICAgICAgICByZXR1cm4gaW5mbyA/IG5ldyBPYmplY3RJbmZvSW1wbChpbmZvKSA6IG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGxpc3QoKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IFtdO1xuICAgICAgICBjb25zdCBpdGVyID0gYXdhaXQgdGhpcy53YXRjaCh7XG4gICAgICAgICAgICBpZ25vcmVEZWxldGVzOiB0cnVlLFxuICAgICAgICAgICAgaW5jbHVkZUhpc3Rvcnk6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgaW5mbyBvZiBpdGVyKXtcbiAgICAgICAgICAgIGlmIChpbmZvID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWYucHVzaChpbmZvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGJ1Zik7XG4gICAgfVxuICAgIGFzeW5jIHJhd0luZm8obmFtZSkge1xuICAgICAgICBjb25zdCB7IG5hbWU6IG9iaiwgZXJyb3IgfSA9IHRoaXMuX2NoZWNrTm90RW1wdHkobmFtZSk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fbWV0YVN1YmplY3Qob2JqKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBhd2FpdCB0aGlzLmpzbS5zdHJlYW1zLmdldE1lc3NhZ2UodGhpcy5zdHJlYW0sIHtcbiAgICAgICAgICAgICAgICBsYXN0X2J5X3N1Ymo6IG1ldGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgamMgPSBKU09OQ29kZWMoKTtcbiAgICAgICAgICAgIGNvbnN0IHNvaSA9IGpjLmRlY29kZShtLmRhdGEpO1xuICAgICAgICAgICAgc29pLnJldmlzaW9uID0gbS5zZXE7XG4gICAgICAgICAgICByZXR1cm4gc29pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gXCI0MDRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX3NpKG9wdHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmpzbS5zdHJlYW1zLmluZm8odGhpcy5zdHJlYW0sIG9wdHMpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5lcnIgPSBlcnI7XG4gICAgICAgICAgICBpZiAobmVyci5jb2RlID09PSBcIjQwNFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzZWFsKCkge1xuICAgICAgICBsZXQgaW5mbyA9IGF3YWl0IHRoaXMuX3NpKCk7XG4gICAgICAgIGlmIChpbmZvID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwib2JqZWN0IHN0b3JlIG5vdCBmb3VuZFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5mby5jb25maWcuc2VhbGVkID0gdHJ1ZTtcbiAgICAgICAgaW5mbyA9IGF3YWl0IHRoaXMuanNtLnN0cmVhbXMudXBkYXRlKHRoaXMuc3RyZWFtLCBpbmZvLmNvbmZpZyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IE9iamVjdFN0b3JlU3RhdHVzSW1wbChpbmZvKSk7XG4gICAgfVxuICAgIGFzeW5jIHN0YXR1cyhvcHRzKSB7XG4gICAgICAgIGNvbnN0IGluZm8gPSBhd2FpdCB0aGlzLl9zaShvcHRzKTtcbiAgICAgICAgaWYgKGluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJvYmplY3Qgc3RvcmUgbm90IGZvdW5kXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBPYmplY3RTdG9yZVN0YXR1c0ltcGwoaW5mbykpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qc20uc3RyZWFtcy5kZWxldGUodGhpcy5zdHJlYW0pO1xuICAgIH1cbiAgICBhc3luYyBfcHV0KG1ldGEsIHJzLCBvcHRzKSB7XG4gICAgICAgIGNvbnN0IGpzb3B0cyA9IHRoaXMuanMuZ2V0T3B0aW9ucygpO1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7XG4gICAgICAgICAgICB0aW1lb3V0OiBqc29wdHMudGltZW91dFxuICAgICAgICB9O1xuICAgICAgICBvcHRzLnRpbWVvdXQgPSBvcHRzLnRpbWVvdXQgfHwganNvcHRzLnRpbWVvdXQ7XG4gICAgICAgIG9wdHMucHJldmlvdXNSZXZpc2lvbiA9IG9wdHMucHJldmlvdXNSZXZpc2lvbiA/PyB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHsgdGltZW91dCwgcHJldmlvdXNSZXZpc2lvbiB9ID0gb3B0cztcbiAgICAgICAgY29uc3Qgc2kgPSB0aGlzLmpzLm5jLmluZm87XG4gICAgICAgIGNvbnN0IG1heFBheWxvYWQgPSBzaT8ubWF4X3BheWxvYWQgfHwgMTAyNDtcbiAgICAgICAgbWV0YSA9IG1ldGEgfHwge307XG4gICAgICAgIG1ldGEub3B0aW9ucyA9IG1ldGEub3B0aW9ucyB8fCB7fTtcbiAgICAgICAgbGV0IG1heENodW5rID0gbWV0YS5vcHRpb25zPy5tYXhfY2h1bmtfc2l6ZSB8fCAxMjggKiAxMDI0O1xuICAgICAgICBtYXhDaHVuayA9IG1heENodW5rID4gbWF4UGF5bG9hZCA/IG1heFBheWxvYWQgOiBtYXhDaHVuaztcbiAgICAgICAgbWV0YS5vcHRpb25zLm1heF9jaHVua19zaXplID0gbWF4Q2h1bms7XG4gICAgICAgIGNvbnN0IG9sZCA9IGF3YWl0IHRoaXMuaW5mbyhtZXRhLm5hbWUpO1xuICAgICAgICBjb25zdCB7IG5hbWU6IG4sIGVycm9yIH0gPSB0aGlzLl9jaGVja05vdEVtcHR5KG1ldGEubmFtZSk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZCA9IG51aWQubmV4dCgpO1xuICAgICAgICBjb25zdCBjaHVua1N1YmogPSB0aGlzLl9jaHVua1N1YmplY3QoaWQpO1xuICAgICAgICBjb25zdCBtZXRhU3ViaiA9IHRoaXMuX21ldGFTdWJqZWN0KG4pO1xuICAgICAgICBjb25zdCBpbmZvID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBidWNrZXQ6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIG51aWQ6IGlkLFxuICAgICAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgICAgIGNodW5rczogMFxuICAgICAgICB9LCB0b1NlcnZlck9iamVjdFN0b3JlTWV0YShtZXRhKSk7XG4gICAgICAgIGNvbnN0IGQgPSBkZWZlcnJlZCgpO1xuICAgICAgICBjb25zdCBwcm9tcyA9IFtdO1xuICAgICAgICBjb25zdCBkYiA9IG5ldyBEYXRhQnVmZmVyKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSBycyA/IHJzLmdldFJlYWRlcigpIDogbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHNoYSA9IEouY3JlYXRlKCk7XG4gICAgICAgICAgICB3aGlsZSh0cnVlKXtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSByZWFkZXIgPyBhd2FpdCByZWFkZXIucmVhZCgpIDoge1xuICAgICAgICAgICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGIuc2l6ZSgpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGRiLmRyYWluKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGEudXBkYXRlKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5jaHVua3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm8uc2l6ZSArPSBwYXlsb2FkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21zLnB1c2godGhpcy5qcy5wdWJsaXNoKGNodW5rU3ViaiwgcGF5bG9hZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9tcyk7XG4gICAgICAgICAgICAgICAgICAgIHByb21zLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGluZm8ubXRpbWUgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpZ2VzdCA9IEJhc2U2NFVybFBhZGRlZENvZGVjLmVuY29kZShzaGEuZGlnZXN0KCkpO1xuICAgICAgICAgICAgICAgICAgICBpbmZvLmRpZ2VzdCA9IGAke2RpZ2VzdFR5cGV9JHtkaWdlc3R9YDtcbiAgICAgICAgICAgICAgICAgICAgaW5mby5kZWxldGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGggPSBoZWFkZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJldmlvdXNSZXZpc2lvbiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaC5zZXQoUHViSGVhZGVycy5FeHBlY3RlZExhc3RTdWJqZWN0U2VxdWVuY2VIZHIsIGAke3ByZXZpb3VzUmV2aXNpb259YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaC5zZXQoSnNIZWFkZXJzLlJvbGx1cEhkciwgSnNIZWFkZXJzLlJvbGx1cFZhbHVlU3ViamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhID0gYXdhaXQgdGhpcy5qcy5wdWJsaXNoKG1ldGFTdWJqLCBKU09OQ29kZWMoKS5lbmNvZGUoaW5mbyksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpbmZvLnJldmlzaW9uID0gcGEuc2VxO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuanNtLnN0cmVhbXMucHVyZ2UodGhpcy5zdHJlYW0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBgJE8uJHt0aGlzLm5hbWV9LkMuJHtvbGQubnVpZH1gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChfZXJyKSB7fVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGQucmVzb2x2ZShuZXcgT2JqZWN0SW5mb0ltcGwoaW5mbykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRiLmZpbGwodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZShkYi5zaXplKCkgPiBtYXhDaHVuayl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZvLmNodW5rcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5zaXplICs9IG1heENodW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGRiLmRyYWluKG1ldGEub3B0aW9ucy5tYXhfY2h1bmtfc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGEudXBkYXRlKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbXMucHVzaCh0aGlzLmpzLnB1Ymxpc2goY2h1bmtTdWJqLCBwYXlsb2FkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuanNtLnN0cmVhbXMucHVyZ2UodGhpcy5zdHJlYW0sIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IGNodW5rU3VialxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkLnJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkO1xuICAgIH1cbiAgICBwdXRCbG9iKG1ldGEsIGRhdGEsIG9wdHMpIHtcbiAgICAgICAgZnVuY3Rpb24gcmVhZGFibGVTdHJlYW1Gcm9tKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgICAgIHB1bGwgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wdXQobWV0YSwgcmVhZGFibGVTdHJlYW1Gcm9tKGRhdGEpLCBvcHRzKTtcbiAgICB9XG4gICAgcHV0KG1ldGEsIHJzLCBvcHRzKSB7XG4gICAgICAgIGlmIChtZXRhPy5vcHRpb25zPy5saW5rKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwibGluayBjYW5ub3QgYmUgc2V0IHdoZW4gcHV0dGluZyB0aGUgb2JqZWN0IGluIGJ1Y2tldFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1dChtZXRhLCBycywgb3B0cyk7XG4gICAgfVxuICAgIGFzeW5jIGdldEJsb2IobmFtZSkge1xuICAgICAgICBhc3luYyBmdW5jdGlvbiBmcm9tUmVhZGFibGVTdHJlYW0ocnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZiA9IG5ldyBEYXRhQnVmZmVyKCk7XG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSBycy5nZXRSZWFkZXIoKTtcbiAgICAgICAgICAgIHdoaWxlKHRydWUpe1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1Zi5kcmFpbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1Zi5maWxsKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgciA9IGF3YWl0IHRoaXMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAociA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2cyA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHIuZXJyb3IsXG4gICAgICAgICAgICBmcm9tUmVhZGFibGVTdHJlYW0oci5kYXRhKVxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKHZzWzBdKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodnNbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2c1sxXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0KG5hbWUpIHtcbiAgICAgICAgY29uc3QgaW5mbyA9IGF3YWl0IHRoaXMucmF3SW5mbyhuYW1lKTtcbiAgICAgICAgaWYgKGluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZm8uZGVsZXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5mby5vcHRpb25zICYmIGluZm8ub3B0aW9ucy5saW5rKSB7XG4gICAgICAgICAgICBjb25zdCBsbiA9IGluZm8ub3B0aW9ucy5saW5rLm5hbWUgfHwgXCJcIjtcbiAgICAgICAgICAgIGlmIChsbiA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImxpbmsgaXMgYSBidWNrZXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvcyA9IGluZm8ub3B0aW9ucy5saW5rLmJ1Y2tldCAhPT0gdGhpcy5uYW1lID8gYXdhaXQgT2JqZWN0U3RvcmVJbXBsLmNyZWF0ZSh0aGlzLmpzLCBpbmZvLm9wdGlvbnMubGluay5idWNrZXQpIDogdGhpcztcbiAgICAgICAgICAgIHJldHVybiBvcy5nZXQobG4pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaW5mby5kaWdlc3Quc3RhcnRzV2l0aChkaWdlc3RUeXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgdW5rbm93biBkaWdlc3QgdHlwZTogJHtpbmZvLmRpZ2VzdH1gKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlnZXN0ID0gcGFyc2VTaGEyNTYoaW5mby5kaWdlc3Quc3Vic3RyaW5nKDgpKTtcbiAgICAgICAgaWYgKGRpZ2VzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgdW5hYmxlIHRvIHBhcnNlIGRpZ2VzdDogJHtpbmZvLmRpZ2VzdH1gKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZCA9IGRlZmVycmVkKCk7XG4gICAgICAgIGNvbnN0IHIgPSB7XG4gICAgICAgICAgICBpbmZvOiBuZXcgT2JqZWN0SW5mb0ltcGwoaW5mbyksXG4gICAgICAgICAgICBlcnJvcjogZFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaW5mby5zaXplID09PSAwKSB7XG4gICAgICAgICAgICByLmRhdGEgPSBlbXB0eVJlYWRhYmxlU3RyZWFtKCk7XG4gICAgICAgICAgICBkLnJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb250cm9sbGVyO1xuICAgICAgICBjb25zdCBvYyA9IGNvbnN1bWVyT3B0cygpO1xuICAgICAgICBvYy5vcmRlcmVkQ29uc3VtZXIoKTtcbiAgICAgICAgY29uc3Qgc2hhID0gSi5jcmVhdGUoKTtcbiAgICAgICAgY29uc3Qgc3ViaiA9IGAkTy4ke3RoaXMubmFtZX0uQy4ke2luZm8ubnVpZH1gO1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLmpzLnN1YnNjcmliZShzdWJqLCBvYyk7XG4gICAgICAgIChhc3luYyAoKT0+e1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBqbSBvZiBzdWIpe1xuICAgICAgICAgICAgICAgIGlmIChqbS5kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhLnVwZGF0ZShqbS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGptLmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoam0uaW5mby5wZW5kaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hlY2tTaGEyNTYoZGlnZXN0LCBzaGEuZGlnZXN0KCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKG5ldyBFcnJvcihgcmVjZWl2ZWQgYSBjb3JydXB0IG9iamVjdCwgZGlnZXN0cyBkbyBub3QgbWF0Y2ggcmVjZWl2ZWQ6ICR7aW5mby5kaWdlc3R9IGNhbGN1bGF0ZWQgJHtkaWdlc3R9YCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKS50aGVuKCgpPT57XG4gICAgICAgICAgICBkLnJlc29sdmUoKTtcbiAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIGQucmVqZWN0KGVycik7XG4gICAgICAgIH0pO1xuICAgICAgICByLmRhdGEgPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgc3RhcnQgKGMpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyID0gYztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYW5jZWwgKCkge1xuICAgICAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGxpbmtTdG9yZShuYW1lLCBidWNrZXQpIHtcbiAgICAgICAgaWYgKCEoYnVja2V0IGluc3RhbmNlb2YgT2JqZWN0U3RvcmVJbXBsKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiYnVja2V0IHJlcXVpcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9zaSA9IGJ1Y2tldDtcbiAgICAgICAgY29uc3QgeyBuYW1lOiBuLCBlcnJvciB9ID0gdGhpcy5fY2hlY2tOb3RFbXB0eShuYW1lKTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiBuLFxuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIGxpbms6IHtcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0OiBvc2kubmFtZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1dChtZXRhLCBudWxsKTtcbiAgICB9XG4gICAgYXN5bmMgbGluayhuYW1lLCBpbmZvKSB7XG4gICAgICAgIGNvbnN0IHsgbmFtZTogbiwgZXJyb3IgfSA9IHRoaXMuX2NoZWNrTm90RW1wdHkobmFtZSk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5mby5kZWxldGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwic3JjIG9iamVjdCBpcyBkZWxldGVkXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5mby5pc0xpbmsoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInNyYyBvYmplY3QgaXMgYSBsaW5rXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZXN0ID0gYXdhaXQgdGhpcy5yYXdJbmZvKG5hbWUpO1xuICAgICAgICBpZiAoZGVzdCAhPT0gbnVsbCAmJiAhZGVzdC5kZWxldGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiYW4gb2JqZWN0IGFscmVhZHkgZXhpc3RzIHdpdGggdGhhdCBuYW1lXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaW5rID0ge1xuICAgICAgICAgICAgYnVja2V0OiBpbmZvLmJ1Y2tldCxcbiAgICAgICAgICAgIG5hbWU6IGluZm8ubmFtZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtbSA9IHtcbiAgICAgICAgICAgIG5hbWU6IG4sXG4gICAgICAgICAgICBidWNrZXQ6IGluZm8uYnVja2V0LFxuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIGxpbms6IGxpbmtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYXdhaXQgdGhpcy5qcy5wdWJsaXNoKHRoaXMuX21ldGFTdWJqZWN0KG5hbWUpLCBKU09OLnN0cmluZ2lmeShtbSkpO1xuICAgICAgICBjb25zdCBpID0gYXdhaXQgdGhpcy5pbmZvKG5hbWUpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGkpO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGUobmFtZSkge1xuICAgICAgICBjb25zdCBpbmZvID0gYXdhaXQgdGhpcy5yYXdJbmZvKG5hbWUpO1xuICAgICAgICBpZiAoaW5mbyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgcHVyZ2VkOiAwLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpbmZvLmRlbGV0ZWQgPSB0cnVlO1xuICAgICAgICBpbmZvLnNpemUgPSAwO1xuICAgICAgICBpbmZvLmNodW5rcyA9IDA7XG4gICAgICAgIGluZm8uZGlnZXN0ID0gXCJcIjtcbiAgICAgICAgY29uc3QgamMgPSBKU09OQ29kZWMoKTtcbiAgICAgICAgY29uc3QgaCA9IGhlYWRlcnMoKTtcbiAgICAgICAgaC5zZXQoSnNIZWFkZXJzLlJvbGx1cEhkciwgSnNIZWFkZXJzLlJvbGx1cFZhbHVlU3ViamVjdCk7XG4gICAgICAgIGF3YWl0IHRoaXMuanMucHVibGlzaCh0aGlzLl9tZXRhU3ViamVjdChpbmZvLm5hbWUpLCBqYy5lbmNvZGUoaW5mbyksIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IGhcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmpzbS5zdHJlYW1zLnB1cmdlKHRoaXMuc3RyZWFtLCB7XG4gICAgICAgICAgICBmaWx0ZXI6IHRoaXMuX2NodW5rU3ViamVjdChpbmZvLm51aWQpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGUobmFtZSwgbWV0YSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGluZm8gPSBhd2FpdCB0aGlzLnJhd0luZm8obmFtZSk7XG4gICAgICAgIGlmIChpbmZvID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwib2JqZWN0IG5vdCBmb3VuZFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZm8uZGVsZXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImNhbm5vdCB1cGRhdGUgbWV0YSBmb3IgYSBkZWxldGVkIG9iamVjdFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgbWV0YS5uYW1lID0gbWV0YS5uYW1lID8/IGluZm8ubmFtZTtcbiAgICAgICAgY29uc3QgeyBuYW1lOiBuLCBlcnJvciB9ID0gdGhpcy5fY2hlY2tOb3RFbXB0eShtZXRhLm5hbWUpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgIT09IG1ldGEubmFtZSkge1xuICAgICAgICAgICAgY29uc3QgaSA9IGF3YWl0IHRoaXMuaW5mbyhtZXRhLm5hbWUpO1xuICAgICAgICAgICAgaWYgKGkgJiYgIWkuZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJhbiBvYmplY3QgYWxyZWFkeSBleGlzdHMgd2l0aCB0aGF0IG5hbWVcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1ldGEubmFtZSA9IG47XG4gICAgICAgIGNvbnN0IGlpID0gT2JqZWN0LmFzc2lnbih7fSwgaW5mbywgdG9TZXJ2ZXJPYmplY3RTdG9yZU1ldGEobWV0YSkpO1xuICAgICAgICBjb25zdCBhY2sgPSBhd2FpdCB0aGlzLmpzLnB1Ymxpc2godGhpcy5fbWV0YVN1YmplY3QoaWkubmFtZSksIEpTT04uc3RyaW5naWZ5KGlpKSk7XG4gICAgICAgIGlmIChuYW1lICE9PSBtZXRhLm5hbWUpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuanNtLnN0cmVhbXMucHVyZ2UodGhpcy5zdHJlYW0sIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IHRoaXMuX21ldGFTdWJqZWN0KG5hbWUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGFjayk7XG4gICAgfVxuICAgIGFzeW5jIHdhdGNoKG9wdHMgPSB7fSkge1xuICAgICAgICBvcHRzLmluY2x1ZGVIaXN0b3J5ID0gb3B0cy5pbmNsdWRlSGlzdG9yeSA/PyBmYWxzZTtcbiAgICAgICAgb3B0cy5pZ25vcmVEZWxldGVzID0gb3B0cy5pZ25vcmVEZWxldGVzID8/IGZhbHNlO1xuICAgICAgICBsZXQgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgcWkgPSBuZXcgUXVldWVkSXRlcmF0b3JJbXBsKCk7XG4gICAgICAgIGNvbnN0IHN1YmogPSB0aGlzLl9tZXRhU3ViamVjdEFsbCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5qc20uc3RyZWFtcy5nZXRNZXNzYWdlKHRoaXMuc3RyZWFtLCB7XG4gICAgICAgICAgICAgICAgbGFzdF9ieV9zdWJqOiBzdWJqXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09IFwiNDA0XCIpIHtcbiAgICAgICAgICAgICAgICBxaS5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcWkuc3RvcChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGpjID0gSlNPTkNvZGVjKCk7XG4gICAgICAgIGNvbnN0IGNvcHRzID0gY29uc3VtZXJPcHRzKCk7XG4gICAgICAgIGNvcHRzLm9yZGVyZWRDb25zdW1lcigpO1xuICAgICAgICBpZiAob3B0cy5pbmNsdWRlSGlzdG9yeSkge1xuICAgICAgICAgICAgY29wdHMuZGVsaXZlckxhc3RQZXJTdWJqZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICBjb3B0cy5kZWxpdmVyTmV3KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29wdHMuY2FsbGJhY2soKGVyciwgam0pPT57XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcWkuc3RvcChlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqbSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9pID0gamMuZGVjb2RlKGptLmRhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChvaS5kZWxldGVkICYmIG9wdHMuaWdub3JlRGVsZXRlcyA9PT0gdHJ1ZSkge30gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHFpLnB1c2gob2kpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoam0uaW5mbz8ucGVuZGluZyA9PT0gMCAmJiAhaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBxaS5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuanMuc3Vic2NyaWJlKHN1YmosIGNvcHRzKTtcbiAgICAgICAgcWkuX2RhdGEgPSBzdWI7XG4gICAgICAgIHFpLml0ZXJDbG9zZWQudGhlbigoKT0+e1xuICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdWIuY2xvc2VkLnRoZW4oKCk9PntcbiAgICAgICAgICAgIHFpLnN0b3AoKTtcbiAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgIHFpLnN0b3AoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBxaTtcbiAgICB9XG4gICAgX2NodW5rU3ViamVjdChpZCkge1xuICAgICAgICByZXR1cm4gYCRPLiR7dGhpcy5uYW1lfS5DLiR7aWR9YDtcbiAgICB9XG4gICAgX21ldGFTdWJqZWN0KG4pIHtcbiAgICAgICAgcmV0dXJuIGAkTy4ke3RoaXMubmFtZX0uTS4ke0Jhc2U2NFVybFBhZGRlZENvZGVjLmVuY29kZShuKX1gO1xuICAgIH1cbiAgICBfbWV0YVN1YmplY3RBbGwoKSB7XG4gICAgICAgIHJldHVybiBgJE8uJHt0aGlzLm5hbWV9Lk0uPmA7XG4gICAgfVxuICAgIGFzeW5jIGluaXQob3B0cyA9IHt9KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbSA9IG9iamVjdFN0b3JlU3RyZWFtTmFtZSh0aGlzLm5hbWUpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1heF9hZ2UgPSBvcHRzPy50dGwgfHwgMDtcbiAgICAgICAgZGVsZXRlIG9wdHMudHRsO1xuICAgICAgICBjb25zdCBzYyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgbWF4X2FnZVxuICAgICAgICB9LCBvcHRzKTtcbiAgICAgICAgc2MubmFtZSA9IHRoaXMuc3RyZWFtO1xuICAgICAgICBzYy5udW1fcmVwbGljYXMgPSBvcHRzLnJlcGxpY2FzID8/IDE7XG4gICAgICAgIHNjLmFsbG93X2RpcmVjdCA9IHRydWU7XG4gICAgICAgIHNjLmFsbG93X3JvbGx1cF9oZHJzID0gdHJ1ZTtcbiAgICAgICAgc2MuZGlzY2FyZCA9IERpc2NhcmRQb2xpY3kuTmV3O1xuICAgICAgICBzYy5zdWJqZWN0cyA9IFtcbiAgICAgICAgICAgIGAkTy4ke3RoaXMubmFtZX0uQy4+YCxcbiAgICAgICAgICAgIGAkTy4ke3RoaXMubmFtZX0uTS4+YFxuICAgICAgICBdO1xuICAgICAgICBpZiAob3B0cy5wbGFjZW1lbnQpIHtcbiAgICAgICAgICAgIHNjLnBsYWNlbWVudCA9IG9wdHMucGxhY2VtZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLm1ldGFkYXRhKSB7XG4gICAgICAgICAgICBzYy5tZXRhZGF0YSA9IG9wdHMubWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLmNvbXByZXNzaW9uID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgc2MuY29tcHJlc3Npb24gPSBvcHRzLmNvbXByZXNzaW9uID8gU3RvcmVDb21wcmVzc2lvbi5TMiA6IFN0b3JlQ29tcHJlc3Npb24uTm9uZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5qc20uc3RyZWFtcy5pbmZvKHNjLm5hbWUpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIubWVzc2FnZSA9PT0gXCJzdHJlYW0gbm90IGZvdW5kXCIpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmpzbS5zdHJlYW1zLmFkZChzYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZShqcywgbmFtZSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGpzbSA9IGF3YWl0IGpzLmpldHN0cmVhbU1hbmFnZXIoKTtcbiAgICAgICAgY29uc3Qgb3MgPSBuZXcgT2JqZWN0U3RvcmVJbXBsKG5hbWUsIGpzbSwganMpO1xuICAgICAgICBhd2FpdCBvcy5pbml0KG9wdHMpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG9zKTtcbiAgICB9XG59XG5jbGFzcyBWaWV3c0ltcGwge1xuICAgIGpzO1xuICAgIGNvbnN0cnVjdG9yKGpzKXtcbiAgICAgICAgdGhpcy5qcyA9IGpzO1xuICAgIH1cbiAgICBrdihuYW1lLCBvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3QganNpID0gdGhpcy5qcztcbiAgICAgICAgY29uc3QgeyBvaywgbWluIH0gPSBqc2kubmMuZmVhdHVyZXMuZ2V0KEZlYXR1cmUuSlNfS1YpO1xuICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBrdiBpcyBvbmx5IHN1cHBvcnRlZCBvbiBzZXJ2ZXJzICR7bWlufSBvciBiZXR0ZXJgKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuYmluZE9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybiBCdWNrZXQuYmluZCh0aGlzLmpzLCBuYW1lLCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQnVja2V0LmNyZWF0ZSh0aGlzLmpzLCBuYW1lLCBvcHRzKTtcbiAgICB9XG4gICAgb3MobmFtZSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgY3J5cHRvPy5zdWJ0bGU/LmRpZ2VzdCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwib2JqZWN0c3RvcmU6IHVuYWJsZSB0byBjYWxjdWxhdGUgaGFzaGVzIC0gY3J5cHRvLnN1YnRsZS5kaWdlc3Qgd2l0aCBzaGEyNTYgc3VwcG9ydCBpcyByZXF1aXJlZFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QganNpID0gdGhpcy5qcztcbiAgICAgICAgY29uc3QgeyBvaywgbWluIH0gPSBqc2kubmMuZmVhdHVyZXMuZ2V0KEZlYXR1cmUuSlNfT0JKRUNUU1RPUkUpO1xuICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBvYmplY3RzdG9yZSBpcyBvbmx5IHN1cHBvcnRlZCBvbiBzZXJ2ZXJzICR7bWlufSBvciBiZXR0ZXJgKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdFN0b3JlSW1wbC5jcmVhdGUodGhpcy5qcywgbmFtZSwgb3B0cyk7XG4gICAgfVxufVxuY2xhc3MgSmV0U3RyZWFtQ2xpZW50SW1wbCBleHRlbmRzIEJhc2VBcGlDbGllbnQge1xuICAgIGNvbnN1bWVycztcbiAgICBzdHJlYW1zO1xuICAgIGNvbnN1bWVyQVBJO1xuICAgIHN0cmVhbUFQSTtcbiAgICBjb25zdHJ1Y3RvcihuYywgb3B0cyl7XG4gICAgICAgIHN1cGVyKG5jLCBvcHRzKTtcbiAgICAgICAgdGhpcy5jb25zdW1lckFQSSA9IG5ldyBDb25zdW1lckFQSUltcGwobmMsIG9wdHMpO1xuICAgICAgICB0aGlzLnN0cmVhbUFQSSA9IG5ldyBTdHJlYW1BUElJbXBsKG5jLCBvcHRzKTtcbiAgICAgICAgdGhpcy5jb25zdW1lcnMgPSBuZXcgQ29uc3VtZXJzSW1wbCh0aGlzLmNvbnN1bWVyQVBJKTtcbiAgICAgICAgdGhpcy5zdHJlYW1zID0gbmV3IFN0cmVhbXNJbXBsKHRoaXMuc3RyZWFtQVBJKTtcbiAgICB9XG4gICAgamV0c3RyZWFtTWFuYWdlcihjaGVja0FQSSkge1xuICAgICAgICBpZiAoY2hlY2tBUEkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2hlY2tBUEkgPSB0aGlzLm9wdHMuY2hlY2tBUEk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0cywge1xuICAgICAgICAgICAgY2hlY2tBUElcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLm5jLmpldHN0cmVhbU1hbmFnZXIob3B0cyk7XG4gICAgfVxuICAgIGdldCBhcGlQcmVmaXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZWZpeDtcbiAgICB9XG4gICAgZ2V0IHZpZXdzKCkge1xuICAgICAgICByZXR1cm4gbmV3IFZpZXdzSW1wbCh0aGlzKTtcbiAgICB9XG4gICAgYXN5bmMgcHVibGlzaChzdWJqLCBkYXRhID0gRW1wdHksIG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIG9wdHMuZXhwZWN0ID0gb3B0cy5leHBlY3QgfHwge307XG4gICAgICAgIGNvbnN0IG1oID0gb3B0cz8uaGVhZGVycyB8fCBoZWFkZXJzKCk7XG4gICAgICAgIGlmIChvcHRzKSB7XG4gICAgICAgICAgICBpZiAob3B0cy5tc2dJRCkge1xuICAgICAgICAgICAgICAgIG1oLnNldChQdWJIZWFkZXJzLk1zZ0lkSGRyLCBvcHRzLm1zZ0lEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLmV4cGVjdC5sYXN0TXNnSUQpIHtcbiAgICAgICAgICAgICAgICBtaC5zZXQoUHViSGVhZGVycy5FeHBlY3RlZExhc3RNc2dJZEhkciwgb3B0cy5leHBlY3QubGFzdE1zZ0lEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLmV4cGVjdC5zdHJlYW1OYW1lKSB7XG4gICAgICAgICAgICAgICAgbWguc2V0KFB1YkhlYWRlcnMuRXhwZWN0ZWRTdHJlYW1IZHIsIG9wdHMuZXhwZWN0LnN0cmVhbU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRzLmV4cGVjdC5sYXN0U2VxdWVuY2UgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBtaC5zZXQoUHViSGVhZGVycy5FeHBlY3RlZExhc3RTZXFIZHIsIGAke29wdHMuZXhwZWN0Lmxhc3RTZXF1ZW5jZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0cy5leHBlY3QubGFzdFN1YmplY3RTZXF1ZW5jZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIG1oLnNldChQdWJIZWFkZXJzLkV4cGVjdGVkTGFzdFN1YmplY3RTZXF1ZW5jZUhkciwgYCR7b3B0cy5leHBlY3QubGFzdFN1YmplY3RTZXF1ZW5jZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0byA9IG9wdHMudGltZW91dCB8fCB0aGlzLnRpbWVvdXQ7XG4gICAgICAgIGNvbnN0IHJvID0ge307XG4gICAgICAgIGlmICh0bykge1xuICAgICAgICAgICAgcm8udGltZW91dCA9IHRvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzKSB7XG4gICAgICAgICAgICByby5oZWFkZXJzID0gbWg7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgcmV0cmllcywgcmV0cnlfZGVsYXkgfSA9IG9wdHM7XG4gICAgICAgIHJldHJpZXMgPSByZXRyaWVzIHx8IDE7XG4gICAgICAgIHJldHJ5X2RlbGF5ID0gcmV0cnlfZGVsYXkgfHwgMjUwO1xuICAgICAgICBsZXQgcjtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHJldHJpZXM7IGkrKyl7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHIgPSBhd2FpdCB0aGlzLm5jLnJlcXVlc3Qoc3ViaiwgZGF0YSwgcm8pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmUgPSBlcnI7XG4gICAgICAgICAgICAgICAgaWYgKG5lLmNvZGUgPT09IFwiNTAzXCIgJiYgaSArIDEgPCByZXRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGRlbGF5KHJldHJ5X2RlbGF5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhID0gdGhpcy5wYXJzZUpzUmVzcG9uc2Uocik7XG4gICAgICAgIGlmIChwYS5zdHJlYW0gPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHRocm93IE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLkpldFN0cmVhbUludmFsaWRBY2spO1xuICAgICAgICB9XG4gICAgICAgIHBhLmR1cGxpY2F0ZSA9IHBhLmR1cGxpY2F0ZSA/IHBhLmR1cGxpY2F0ZSA6IGZhbHNlO1xuICAgICAgICByZXR1cm4gcGE7XG4gICAgfVxuICAgIGFzeW5jIHB1bGwoc3RyZWFtLCBkdXJhYmxlLCBleHBpcmVzID0gMCkge1xuICAgICAgICB2YWxpZGF0ZVN0cmVhbU5hbWUoc3RyZWFtKTtcbiAgICAgICAgdmFsaWRhdGVEdXJhYmxlTmFtZShkdXJhYmxlKTtcbiAgICAgICAgbGV0IHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gICAgICAgIGlmIChleHBpcmVzID4gdGltZW91dCkge1xuICAgICAgICAgICAgdGltZW91dCA9IGV4cGlyZXM7XG4gICAgICAgIH1cbiAgICAgICAgZXhwaXJlcyA9IGV4cGlyZXMgPCAwID8gMCA6IG5hbm9zKGV4cGlyZXMpO1xuICAgICAgICBjb25zdCBwdWxsT3B0cyA9IHtcbiAgICAgICAgICAgIGJhdGNoOiAxLFxuICAgICAgICAgICAgbm9fd2FpdDogZXhwaXJlcyA9PT0gMCxcbiAgICAgICAgICAgIGV4cGlyZXNcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbXNnID0gYXdhaXQgdGhpcy5uYy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fS5DT05TVU1FUi5NU0cuTkVYVC4ke3N0cmVhbX0uJHtkdXJhYmxlfWAsIHRoaXMuamMuZW5jb2RlKHB1bGxPcHRzKSwge1xuICAgICAgICAgICAgbm9NdXg6IHRydWUsXG4gICAgICAgICAgICB0aW1lb3V0XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBlcnIgPSBjaGVja0pzRXJyb3IobXNnKTtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0pzTXNnKG1zZywgdGhpcy50aW1lb3V0KTtcbiAgICB9XG4gICAgZmV0Y2goc3RyZWFtLCBkdXJhYmxlLCBvcHRzID0ge30pIHtcbiAgICAgICAgdmFsaWRhdGVTdHJlYW1OYW1lKHN0cmVhbSk7XG4gICAgICAgIHZhbGlkYXRlRHVyYWJsZU5hbWUoZHVyYWJsZSk7XG4gICAgICAgIGxldCB0aW1lciA9IG51bGw7XG4gICAgICAgIGNvbnN0IHRyYWNrQnl0ZXMgPSAob3B0cy5tYXhfYnl0ZXMgPz8gMCkgPiAwO1xuICAgICAgICBsZXQgcmVjZWl2ZWRCeXRlcyA9IDA7XG4gICAgICAgIGNvbnN0IG1heF9ieXRlcyA9IHRyYWNrQnl0ZXMgPyBvcHRzLm1heF9ieXRlcyA6IDA7XG4gICAgICAgIGxldCBtb25pdG9yID0gbnVsbDtcbiAgICAgICAgY29uc3QgYXJncyA9IHt9O1xuICAgICAgICBhcmdzLmJhdGNoID0gb3B0cy5iYXRjaCB8fCAxO1xuICAgICAgICBpZiAobWF4X2J5dGVzKSB7XG4gICAgICAgICAgICBjb25zdCBmdiA9IHRoaXMubmMuZmVhdHVyZXMuZ2V0KEZlYXR1cmUuSlNfUFVMTF9NQVhfQllURVMpO1xuICAgICAgICAgICAgaWYgKCFmdi5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbWF4X2J5dGVzIGlzIG9ubHkgc3VwcG9ydGVkIG9uIHNlcnZlcnMgJHtmdi5taW59IG9yIGJldHRlcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJncy5tYXhfYnl0ZXMgPSBtYXhfYnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgYXJncy5ub193YWl0ID0gb3B0cy5ub193YWl0IHx8IGZhbHNlO1xuICAgICAgICBpZiAoYXJncy5ub193YWl0ICYmIGFyZ3MuZXhwaXJlcykge1xuICAgICAgICAgICAgYXJncy5leHBpcmVzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHBpcmVzID0gb3B0cy5leHBpcmVzIHx8IDA7XG4gICAgICAgIGlmIChleHBpcmVzKSB7XG4gICAgICAgICAgICBhcmdzLmV4cGlyZXMgPSBuYW5vcyhleHBpcmVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwaXJlcyA9PT0gMCAmJiBhcmdzLm5vX3dhaXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHBpcmVzIG9yIG5vX3dhaXQgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGIgPSBvcHRzLmlkbGVfaGVhcnRiZWF0IHx8IDA7XG4gICAgICAgIGlmIChoYikge1xuICAgICAgICAgICAgYXJncy5pZGxlX2hlYXJ0YmVhdCA9IG5hbm9zKGhiKTtcbiAgICAgICAgICAgIGlmIChvcHRzLmRlbGF5X2hlYXJ0YmVhdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGFyZ3MuaWRsZV9oZWFydGJlYXQgPSBuYW5vcyhoYiAqIDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHFpID0gbmV3IFF1ZXVlZEl0ZXJhdG9ySW1wbCgpO1xuICAgICAgICBjb25zdCB3YW50cyA9IGFyZ3MuYmF0Y2g7XG4gICAgICAgIGxldCByZWNlaXZlZCA9IDA7XG4gICAgICAgIHFpLnByb3RvY29sRmlsdGVyRm4gPSAoam0sIF9pbmdlc3QgPSBmYWxzZSk9PntcbiAgICAgICAgICAgIGNvbnN0IGpzbWkgPSBqbTtcbiAgICAgICAgICAgIGlmIChpc0hlYXJ0YmVhdE1zZyhqc21pLm1zZykpIHtcbiAgICAgICAgICAgICAgICBtb25pdG9yPy53b3JrKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHFpLmRpc3BhdGNoZWRGbiA9IChtKT0+e1xuICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tCeXRlcykge1xuICAgICAgICAgICAgICAgICAgICByZWNlaXZlZEJ5dGVzICs9IG0uZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY2VpdmVkKys7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVyICYmIG0uaW5mby5wZW5kaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHFpLmdldFBlbmRpbmcoKSA9PT0gMSAmJiBtLmluZm8ucGVuZGluZyA9PT0gMCB8fCB3YW50cyA9PT0gcmVjZWl2ZWQgfHwgbWF4X2J5dGVzID4gMCAmJiByZWNlaXZlZEJ5dGVzID49IG1heF9ieXRlcykge1xuICAgICAgICAgICAgICAgICAgICBxaS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBpbmJveCA9IGNyZWF0ZUluYm94KHRoaXMubmMub3B0aW9ucy5pbmJveFByZWZpeCk7XG4gICAgICAgIGNvbnN0IHN1YiA9IHRoaXMubmMuc3Vic2NyaWJlKGluYm94LCB7XG4gICAgICAgICAgICBtYXg6IG9wdHMuYmF0Y2gsXG4gICAgICAgICAgICBjYWxsYmFjazogKGVyciwgbXNnKT0+e1xuICAgICAgICAgICAgICAgIGlmIChlcnIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyID0gY2hlY2tKc0Vycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lci5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYXRzRXJyb3IoZXJyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcWkuc3RvcChoaWRlTm9uVGVybWluYWxKc0Vycm9ycyhlcnIpID09PSBudWxsID8gdW5kZWZpbmVkIDogZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHFpLnN0b3AoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1vbml0b3I/LndvcmsoKTtcbiAgICAgICAgICAgICAgICAgICAgcWkucmVjZWl2ZWQrKztcbiAgICAgICAgICAgICAgICAgICAgcWkucHVzaCh0b0pzTXNnKG1zZywgdGhpcy50aW1lb3V0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGV4cGlyZXMpIHtcbiAgICAgICAgICAgIHRpbWVyID0gdGltZW91dChleHBpcmVzKTtcbiAgICAgICAgICAgIHRpbWVyLmNhdGNoKCgpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFzdWIuaXNDbG9zZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBzdWIuZHJhaW4oKS5jYXRjaCgoKT0+e30pO1xuICAgICAgICAgICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtb25pdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vbml0b3IuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgKGFzeW5jICgpPT57XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChoYikge1xuICAgICAgICAgICAgICAgICAgICBtb25pdG9yID0gbmV3IElkbGVIZWFydGJlYXRNb25pdG9yKGhiLCAodik9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIHFpLnB1c2goKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxaS5lcnIgPSBuZXcgTmF0c0Vycm9yKGAke0pzNDA5RXJyb3JzLklkbGVIZWFydGJlYXRNaXNzZWR9OiAke3Z9YCwgRXJyb3JDb2RlLkpldFN0cmVhbUlkbGVIZWFydEJlYXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoX2Vycikge31cbiAgICAgICAgICAgIGF3YWl0IHN1Yi5jbG9zZWQ7XG4gICAgICAgICAgICBpZiAodGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aW1lci5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW9uaXRvcikge1xuICAgICAgICAgICAgICAgIG1vbml0b3IuY2FuY2VsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxaS5zdG9wKCk7XG4gICAgICAgIH0pKCkuY2F0Y2goKTtcbiAgICAgICAgdGhpcy5uYy5wdWJsaXNoKGAke3RoaXMucHJlZml4fS5DT05TVU1FUi5NU0cuTkVYVC4ke3N0cmVhbX0uJHtkdXJhYmxlfWAsIHRoaXMuamMuZW5jb2RlKGFyZ3MpLCB7XG4gICAgICAgICAgICByZXBseTogaW5ib3hcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBxaTtcbiAgICB9XG4gICAgYXN5bmMgcHVsbFN1YnNjcmliZShzdWJqZWN0LCBvcHRzID0gY29uc3VtZXJPcHRzKCkpIHtcbiAgICAgICAgY29uc3QgY3NvID0gYXdhaXQgdGhpcy5fcHJvY2Vzc09wdGlvbnMoc3ViamVjdCwgb3B0cyk7XG4gICAgICAgIGlmIChjc28ub3JkZXJlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHVsbCBzdWJzY3JpYmVycyBjYW5ub3QgYmUgYmUgb3JkZXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3NvLmNvbmZpZy5kZWxpdmVyX3N1YmplY3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbnN1bWVyIGluZm8gc3BlY2lmaWVzIGRlbGl2ZXJfc3ViamVjdCAtIHB1bGwgY29uc3VtZXJzIGNhbm5vdCBoYXZlIGRlbGl2ZXJfc3ViamVjdCBzZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWNrUG9saWN5ID0gY3NvLmNvbmZpZy5hY2tfcG9saWN5O1xuICAgICAgICBpZiAoYWNrUG9saWN5ID09PSBBY2tQb2xpY3kuTm9uZSB8fCBhY2tQb2xpY3kgPT09IEFja1BvbGljeS5BbGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFjayBwb2xpY3kgZm9yIHB1bGwgY29uc3VtZXJzIG11c3QgYmUgZXhwbGljaXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc28gPSB0aGlzLl9idWlsZFR5cGVkU3Vic2NyaXB0aW9uT3B0cyhjc28pO1xuICAgICAgICBjb25zdCBzdWIgPSBuZXcgSmV0U3RyZWFtUHVsbFN1YnNjcmlwdGlvbkltcGwodGhpcywgY3NvLmRlbGl2ZXIsIHNvKTtcbiAgICAgICAgc3ViLmluZm8gPSBjc287XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9tYXliZUNyZWF0ZUNvbnN1bWVyKGNzbyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YjtcbiAgICB9XG4gICAgYXN5bmMgc3Vic2NyaWJlKHN1YmplY3QsIG9wdHMgPSBjb25zdW1lck9wdHMoKSkge1xuICAgICAgICBjb25zdCBjc28gPSBhd2FpdCB0aGlzLl9wcm9jZXNzT3B0aW9ucyhzdWJqZWN0LCBvcHRzKTtcbiAgICAgICAgaWYgKCFjc28uaXNCaW5kICYmICFjc28uY29uZmlnLmRlbGl2ZXJfc3ViamVjdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHVzaCBjb25zdW1lciByZXF1aXJlcyBkZWxpdmVyX3N1YmplY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc28gPSB0aGlzLl9idWlsZFR5cGVkU3Vic2NyaXB0aW9uT3B0cyhjc28pO1xuICAgICAgICBjb25zdCBzdWIgPSBuZXcgSmV0U3RyZWFtU3Vic2NyaXB0aW9uSW1wbCh0aGlzLCBjc28uZGVsaXZlciwgc28pO1xuICAgICAgICBzdWIuaW5mbyA9IGNzbztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX21heWJlQ3JlYXRlQ29uc3VtZXIoY3NvKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBzdWIuX21heWJlU2V0dXBIYk1vbml0b3JpbmcoKTtcbiAgICAgICAgcmV0dXJuIHN1YjtcbiAgICB9XG4gICAgYXN5bmMgX3Byb2Nlc3NPcHRpb25zKHN1YmplY3QsIG9wdHMgPSBjb25zdW1lck9wdHMoKSkge1xuICAgICAgICBjb25zdCBqc2kgPSBpc0NvbnN1bWVyT3B0c0J1aWxkZXIob3B0cykgPyBvcHRzLmdldE9wdHMoKSA6IG9wdHM7XG4gICAgICAgIGpzaS5pc0JpbmQgPSBpc0NvbnN1bWVyT3B0c0J1aWxkZXIob3B0cykgPyBvcHRzLmlzQmluZCA6IGZhbHNlO1xuICAgICAgICBqc2kuZmxvd19jb250cm9sID0ge1xuICAgICAgICAgICAgaGVhcnRiZWF0X2NvdW50OiAwLFxuICAgICAgICAgICAgZmNfY291bnQ6IDAsXG4gICAgICAgICAgICBjb25zdW1lcl9yZXN0YXJ0czogMFxuICAgICAgICB9O1xuICAgICAgICBpZiAoanNpLm9yZGVyZWQpIHtcbiAgICAgICAgICAgIGpzaS5vcmRlcmVkX2NvbnN1bWVyX3NlcXVlbmNlID0ge1xuICAgICAgICAgICAgICAgIHN0cmVhbV9zZXE6IDAsXG4gICAgICAgICAgICAgICAgZGVsaXZlcnlfc2VxOiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGpzaS5jb25maWcuYWNrX3BvbGljeSAhPT0gQWNrUG9saWN5Lk5vdFNldCAmJiBqc2kuY29uZmlnLmFja19wb2xpY3kgIT09IEFja1BvbGljeS5Ob25lKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5hdHNFcnJvcihcIm9yZGVyZWQgY29uc3VtZXI6IGFja19wb2xpY3kgY2FuIG9ubHkgYmUgc2V0IHRvICdub25lJ1wiLCBFcnJvckNvZGUuQXBpRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGpzaS5jb25maWcuZHVyYWJsZV9uYW1lICYmIGpzaS5jb25maWcuZHVyYWJsZV9uYW1lLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTmF0c0Vycm9yKFwib3JkZXJlZCBjb25zdW1lcjogZHVyYWJsZV9uYW1lIGNhbm5vdCBiZSBzZXRcIiwgRXJyb3JDb2RlLkFwaUVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqc2kuY29uZmlnLmRlbGl2ZXJfc3ViamVjdCAmJiBqc2kuY29uZmlnLmRlbGl2ZXJfc3ViamVjdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5hdHNFcnJvcihcIm9yZGVyZWQgY29uc3VtZXI6IGRlbGl2ZXJfc3ViamVjdCBjYW5ub3QgYmUgc2V0XCIsIEVycm9yQ29kZS5BcGlFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoanNpLmNvbmZpZy5tYXhfZGVsaXZlciAhPT0gdW5kZWZpbmVkICYmIGpzaS5jb25maWcubWF4X2RlbGl2ZXIgPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5hdHNFcnJvcihcIm9yZGVyZWQgY29uc3VtZXI6IG1heF9kZWxpdmVyIGNhbm5vdCBiZSBzZXRcIiwgRXJyb3JDb2RlLkFwaUVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqc2kuY29uZmlnLmRlbGl2ZXJfZ3JvdXAgJiYganNpLmNvbmZpZy5kZWxpdmVyX2dyb3VwLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTmF0c0Vycm9yKFwib3JkZXJlZCBjb25zdW1lcjogZGVsaXZlcl9ncm91cCBjYW5ub3QgYmUgc2V0XCIsIEVycm9yQ29kZS5BcGlFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBqc2kuY29uZmlnLmRlbGl2ZXJfc3ViamVjdCA9IGNyZWF0ZUluYm94KHRoaXMubmMub3B0aW9ucy5pbmJveFByZWZpeCk7XG4gICAgICAgICAgICBqc2kuY29uZmlnLmFja19wb2xpY3kgPSBBY2tQb2xpY3kuTm9uZTtcbiAgICAgICAgICAgIGpzaS5jb25maWcubWF4X2RlbGl2ZXIgPSAxO1xuICAgICAgICAgICAganNpLmNvbmZpZy5mbG93X2NvbnRyb2wgPSB0cnVlO1xuICAgICAgICAgICAganNpLmNvbmZpZy5pZGxlX2hlYXJ0YmVhdCA9IGpzaS5jb25maWcuaWRsZV9oZWFydGJlYXQgfHwgbmFub3MoNTAwMCk7XG4gICAgICAgICAgICBqc2kuY29uZmlnLmFja193YWl0ID0gbmFub3MoMjIgKiA2MCAqIDYwICogMTAwMCk7XG4gICAgICAgICAgICBqc2kuY29uZmlnLm1lbV9zdG9yYWdlID0gdHJ1ZTtcbiAgICAgICAgICAgIGpzaS5jb25maWcubnVtX3JlcGxpY2FzID0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoanNpLmNvbmZpZy5hY2tfcG9saWN5ID09PSBBY2tQb2xpY3kuTm90U2V0KSB7XG4gICAgICAgICAgICBqc2kuY29uZmlnLmFja19wb2xpY3kgPSBBY2tQb2xpY3kuQWxsO1xuICAgICAgICB9XG4gICAgICAgIGpzaS5hcGkgPSB0aGlzO1xuICAgICAgICBqc2kuY29uZmlnID0ganNpLmNvbmZpZyB8fCB7fTtcbiAgICAgICAganNpLnN0cmVhbSA9IGpzaS5zdHJlYW0gPyBqc2kuc3RyZWFtIDogYXdhaXQgdGhpcy5maW5kU3RyZWFtKHN1YmplY3QpO1xuICAgICAgICBqc2kuYXR0YWNoZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGpzaS5jb25maWcuZHVyYWJsZV9uYW1lKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZm8gPSBhd2FpdCB0aGlzLmNvbnN1bWVyQVBJLmluZm8oanNpLnN0cmVhbSwganNpLmNvbmZpZy5kdXJhYmxlX25hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmZvLmNvbmZpZy5maWx0ZXJfc3ViamVjdCAmJiBpbmZvLmNvbmZpZy5maWx0ZXJfc3ViamVjdCAhPT0gc3ViamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3ViamVjdCBkb2VzIG5vdCBtYXRjaCBjb25zdW1lclwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBxbiA9IGpzaS5jb25maWcuZGVsaXZlcl9ncm91cCA/PyBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAocW4gPT09IFwiXCIgJiYgaW5mby5wdXNoX2JvdW5kID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZSBzdWJzY3JpcHRpb25gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBycW4gPSBpbmZvLmNvbmZpZy5kZWxpdmVyX2dyb3VwID8/IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxbiAhPT0gcnFuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnFuID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkdXJhYmxlIHJlcXVpcmVzIG5vIHF1ZXVlIGdyb3VwYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZHVyYWJsZSByZXF1aXJlcyBxdWV1ZSBncm91cCAnJHtycW59J2ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGpzaS5sYXN0ID0gaW5mbztcbiAgICAgICAgICAgICAgICAgICAganNpLmNvbmZpZyA9IGluZm8uY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICBqc2kuYXR0YWNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWpzaS5jb25maWcuZHVyYWJsZV9uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqc2kubmFtZSA9IGluZm8ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIuY29kZSAhPT0gXCI0MDRcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghanNpLmF0dGFjaGVkICYmIGpzaS5jb25maWcuZmlsdGVyX3N1YmplY3QgPT09IHVuZGVmaW5lZCAmJiBqc2kuY29uZmlnLmZpbHRlcl9zdWJqZWN0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBqc2kuY29uZmlnLmZpbHRlcl9zdWJqZWN0ID0gc3ViamVjdDtcbiAgICAgICAgfVxuICAgICAgICBqc2kuZGVsaXZlciA9IGpzaS5jb25maWcuZGVsaXZlcl9zdWJqZWN0IHx8IGNyZWF0ZUluYm94KHRoaXMubmMub3B0aW9ucy5pbmJveFByZWZpeCk7XG4gICAgICAgIHJldHVybiBqc2k7XG4gICAgfVxuICAgIF9idWlsZFR5cGVkU3Vic2NyaXB0aW9uT3B0cyhqc2kpIHtcbiAgICAgICAgY29uc3Qgc28gPSB7fTtcbiAgICAgICAgc28uYWRhcHRlciA9IG1zZ0FkYXB0ZXIoanNpLmNhbGxiYWNrRm4gPT09IHVuZGVmaW5lZCwgdGhpcy50aW1lb3V0KTtcbiAgICAgICAgc28uaW5nZXN0aW9uRmlsdGVyRm4gPSBKZXRTdHJlYW1DbGllbnRJbXBsLmluZ2VzdGlvbkZuKGpzaS5vcmRlcmVkKTtcbiAgICAgICAgc28ucHJvdG9jb2xGaWx0ZXJGbiA9IChqbSwgaW5nZXN0ID0gZmFsc2UpPT57XG4gICAgICAgICAgICBjb25zdCBqc21pID0gam07XG4gICAgICAgICAgICBpZiAoaXNGbG93Q29udHJvbE1zZyhqc21pLm1zZykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWluZ2VzdCkge1xuICAgICAgICAgICAgICAgICAgICBqc21pLm1zZy5yZXNwb25kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIWpzaS5tYWNrICYmIGpzaS5jb25maWcuYWNrX3BvbGljeSAhPT0gQWNrUG9saWN5Lk5vbmUpIHtcbiAgICAgICAgICAgIHNvLmRpc3BhdGNoZWRGbiA9IGF1dG9BY2tKc01zZztcbiAgICAgICAgfVxuICAgICAgICBpZiAoanNpLmNhbGxiYWNrRm4pIHtcbiAgICAgICAgICAgIHNvLmNhbGxiYWNrID0ganNpLmNhbGxiYWNrRm47XG4gICAgICAgIH1cbiAgICAgICAgc28ubWF4ID0ganNpLm1heCB8fCAwO1xuICAgICAgICBzby5xdWV1ZSA9IGpzaS5xdWV1ZTtcbiAgICAgICAgcmV0dXJuIHNvO1xuICAgIH1cbiAgICBhc3luYyBfbWF5YmVDcmVhdGVDb25zdW1lcihqc2kpIHtcbiAgICAgICAgaWYgKGpzaS5hdHRhY2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqc2kuaXNCaW5kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuYWJsZSB0byBiaW5kIC0gZHVyYWJsZSBjb25zdW1lciAke2pzaS5jb25maWcuZHVyYWJsZV9uYW1lfSBkb2Vzbid0IGV4aXN0IGluICR7anNpLnN0cmVhbX1gKTtcbiAgICAgICAgfVxuICAgICAgICBqc2kuY29uZmlnID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBkZWxpdmVyX3BvbGljeTogRGVsaXZlclBvbGljeS5BbGwsXG4gICAgICAgICAgICBhY2tfcG9saWN5OiBBY2tQb2xpY3kuRXhwbGljaXQsXG4gICAgICAgICAgICBhY2tfd2FpdDogbmFub3MoMzAgKiAxMDAwKSxcbiAgICAgICAgICAgIHJlcGxheV9wb2xpY3k6IFJlcGxheVBvbGljeS5JbnN0YW50XG4gICAgICAgIH0sIGpzaS5jb25maWcpO1xuICAgICAgICBjb25zdCBjaSA9IGF3YWl0IHRoaXMuY29uc3VtZXJBUEkuYWRkKGpzaS5zdHJlYW0sIGpzaS5jb25maWcpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShqc2kuY29uZmlnLmZpbHRlcl9zdWJqZWN0cyAmJiAhQXJyYXkuaXNBcnJheShjaS5jb25maWcuZmlsdGVyX3N1YmplY3RzKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgamV0c3RyZWFtIHNlcnZlciBkb2Vzbid0IHN1cHBvcnQgY29uc3VtZXJzIHdpdGggbXVsdGlwbGUgZmlsdGVyIHN1YmplY3RzYCk7XG4gICAgICAgIH1cbiAgICAgICAganNpLm5hbWUgPSBjaS5uYW1lO1xuICAgICAgICBqc2kuY29uZmlnID0gY2kuY29uZmlnO1xuICAgICAgICBqc2kubGFzdCA9IGNpO1xuICAgIH1cbiAgICBzdGF0aWMgaW5nZXN0aW9uRm4ob3JkZXJlZCkge1xuICAgICAgICByZXR1cm4gKGptLCBjdHgpPT57XG4gICAgICAgICAgICBjb25zdCBqc3ViID0gY3R4O1xuICAgICAgICAgICAgaWYgKCFqbSkgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpbmdlc3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHByb3RvY29sOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGptaSA9IGptO1xuICAgICAgICAgICAgaWYgKCFjaGVja0pzRXJyb3Ioam1pLm1zZykpIHtcbiAgICAgICAgICAgICAgICBqc3ViLm1vbml0b3I/LndvcmsoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0hlYXJ0YmVhdE1zZyhqbWkubXNnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZ2VzdCA9IG9yZGVyZWQgPyBqc3ViLl9jaGVja0hiT3JkZXJDb25zdW1lcihqbWkubXNnKSA6IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKCFvcmRlcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGpzdWIuaW5mby5mbG93X2NvbnRyb2wuaGVhcnRiZWF0X2NvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGluZ2VzdCxcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2w6IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0Zsb3dDb250cm9sTXNnKGptaS5tc2cpKSB7XG4gICAgICAgICAgICAgICAganN1Yi5pbmZvLmZsb3dfY29udHJvbC5mY19jb3VudCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGluZ2VzdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2w6IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW5nZXN0ID0gb3JkZXJlZCA/IGpzdWIuX2NoZWNrT3JkZXJlZENvbnN1bWVyKGptKSA6IHRydWU7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGluZ2VzdCxcbiAgICAgICAgICAgICAgICBwcm90b2NvbDogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxufVxuY2xhc3MgTmF0c0Nvbm5lY3Rpb25JbXBsIHtcbiAgICBvcHRpb25zO1xuICAgIHByb3RvY29sO1xuICAgIGRyYWluaW5nO1xuICAgIGxpc3RlbmVycztcbiAgICBfc2VydmljZXM7XG4gICAgY29uc3RydWN0b3Iob3B0cyl7XG4gICAgICAgIHRoaXMuZHJhaW5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdHMpO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgIH1cbiAgICBzdGF0aWMgY29ubmVjdChvcHRzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgICAgICBjb25zdCBuYyA9IG5ldyBOYXRzQ29ubmVjdGlvbkltcGwob3B0cyk7XG4gICAgICAgICAgICBQcm90b2NvbEhhbmRsZXIuY29ubmVjdChuYy5vcHRpb25zLCBuYykudGhlbigocGgpPT57XG4gICAgICAgICAgICAgICAgbmMucHJvdG9jb2wgPSBwaDtcbiAgICAgICAgICAgICAgICAoYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgcyBvZiBwaC5zdGF0dXMoKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYy5saXN0ZW5lcnMuZm9yRWFjaCgobCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsLnB1c2gocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShuYyk7XG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3RvY29sLmNsb3NlZDtcbiAgICB9XG4gICAgYXN5bmMgY2xvc2UoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucHJvdG9jb2wuY2xvc2UoKTtcbiAgICB9XG4gICAgX2NoZWNrKHN1YmplY3QsIHN1YiwgcHViKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgIHRocm93IE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLkNvbm5lY3Rpb25DbG9zZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWIgJiYgdGhpcy5pc0RyYWluaW5nKCkpIHtcbiAgICAgICAgICAgIHRocm93IE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLkNvbm5lY3Rpb25EcmFpbmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHB1YiAmJiB0aGlzLnByb3RvY29sLm5vTW9yZVB1Ymxpc2hpbmcpIHtcbiAgICAgICAgICAgIHRocm93IE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLkNvbm5lY3Rpb25EcmFpbmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgc3ViamVjdCA9IHN1YmplY3QgfHwgXCJcIjtcbiAgICAgICAgaWYgKHN1YmplY3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBOYXRzRXJyb3IuZXJyb3JGb3JDb2RlKEVycm9yQ29kZS5CYWRTdWJqZWN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdWJsaXNoKHN1YmplY3QsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fY2hlY2soc3ViamVjdCwgZmFsc2UsIHRydWUpO1xuICAgICAgICB0aGlzLnByb3RvY29sLnB1Ymxpc2goc3ViamVjdCwgZGF0YSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHB1Ymxpc2hNZXNzYWdlKG1zZykge1xuICAgICAgICByZXR1cm4gdGhpcy5wdWJsaXNoKG1zZy5zdWJqZWN0LCBtc2cuZGF0YSwge1xuICAgICAgICAgICAgcmVwbHk6IG1zZy5yZXBseSxcbiAgICAgICAgICAgIGhlYWRlcnM6IG1zZy5oZWFkZXJzXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXNwb25kTWVzc2FnZShtc2cpIHtcbiAgICAgICAgaWYgKG1zZy5yZXBseSkge1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKG1zZy5yZXBseSwgbXNnLmRhdGEsIHtcbiAgICAgICAgICAgICAgICByZXBseTogbXNnLnJlcGx5LFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IG1zZy5oZWFkZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3Vic2NyaWJlKHN1YmplY3QsIG9wdHMgPSB7fSkge1xuICAgICAgICB0aGlzLl9jaGVjayhzdWJqZWN0LCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IHN1YiA9IG5ldyBTdWJzY3JpcHRpb25JbXBsKHRoaXMucHJvdG9jb2wsIHN1YmplY3QsIG9wdHMpO1xuICAgICAgICB0aGlzLnByb3RvY29sLnN1YnNjcmliZShzdWIpO1xuICAgICAgICByZXR1cm4gc3ViO1xuICAgIH1cbiAgICBfcmVzdWIocywgc3ViamVjdCwgbWF4KSB7XG4gICAgICAgIHRoaXMuX2NoZWNrKHN1YmplY3QsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgY29uc3Qgc2kgPSBzO1xuICAgICAgICBzaS5tYXggPSBtYXg7XG4gICAgICAgIGlmIChtYXgpIHtcbiAgICAgICAgICAgIHNpLm1heCA9IG1heCArIHNpLnJlY2VpdmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvdG9jb2wucmVzdWIoc2ksIHN1YmplY3QpO1xuICAgIH1cbiAgICByZXF1ZXN0TWFueShzdWJqZWN0LCBkYXRhID0gRW1wdHksIG9wdHMgPSB7XG4gICAgICAgIG1heFdhaXQ6IDEwMDAsXG4gICAgICAgIG1heE1lc3NhZ2VzOiAtMVxuICAgIH0pIHtcbiAgICAgICAgY29uc3QgYXN5bmNUcmFjZXMgPSAhKHRoaXMucHJvdG9jb2wub3B0aW9ucy5ub0FzeW5jVHJhY2VzIHx8IGZhbHNlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrKHN1YmplY3QsIHRydWUsIHRydWUpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIG9wdHMuc3RyYXRlZ3kgPSBvcHRzLnN0cmF0ZWd5IHx8IFJlcXVlc3RTdHJhdGVneS5UaW1lcjtcbiAgICAgICAgb3B0cy5tYXhXYWl0ID0gb3B0cy5tYXhXYWl0IHx8IDEwMDA7XG4gICAgICAgIGlmIChvcHRzLm1heFdhaXQgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IE5hdHNFcnJvcihcInRpbWVvdXRcIiwgRXJyb3JDb2RlLkludmFsaWRPcHRpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxaSA9IG5ldyBRdWV1ZWRJdGVyYXRvckltcGwoKTtcbiAgICAgICAgZnVuY3Rpb24gc3RvcChlcnIpIHtcbiAgICAgICAgICAgIHFpLnB1c2goKCk9PntcbiAgICAgICAgICAgICAgICBxaS5zdG9wKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjYWxsYmFjayhlcnIsIG1zZykge1xuICAgICAgICAgICAgaWYgKGVyciB8fCBtc2cgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdG9wKGVyciA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHFpLnB1c2gobXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5ub011eCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSBhc3luY1RyYWNlcyA/IG5ldyBFcnJvcigpLnN0YWNrIDogbnVsbDtcbiAgICAgICAgICAgIGxldCBtYXggPSB0eXBlb2Ygb3B0cy5tYXhNZXNzYWdlcyA9PT0gXCJudW1iZXJcIiAmJiBvcHRzLm1heE1lc3NhZ2VzID4gMCA/IG9wdHMubWF4TWVzc2FnZXMgOiAtMTtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IHRoaXMuc3Vic2NyaWJlKGNyZWF0ZUluYm94KHRoaXMub3B0aW9ucy5pbmJveFByZWZpeCksIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogKGVyciwgbXNnKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAobXNnPy5kYXRhPy5sZW5ndGggPT09IDAgJiYgbXNnPy5oZWFkZXJzPy5zdGF0dXMgPT09IEVycm9yQ29kZS5Ob1Jlc3BvbmRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLk5vUmVzcG9uZGVycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLnN0YWNrICs9IGBcXG5cXG4ke3N0YWNrfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWwoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBtc2cpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5zdHJhdGVneSA9PT0gUmVxdWVzdFN0cmF0ZWd5LkNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXgtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5zdHJhdGVneSA9PT0gUmVxdWVzdFN0cmF0ZWd5LkppdHRlclRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAzMDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLnN0cmF0ZWd5ID09PSBSZXF1ZXN0U3RyYXRlZ3kuU2VudGluZWxNc2cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtc2cgJiYgbXNnLmRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN1Yi5yZXF1ZXN0U3ViamVjdCA9IHN1YmplY3Q7XG4gICAgICAgICAgICBzdWIuY2xvc2VkLnRoZW4oKCk9PntcbiAgICAgICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgICAgIHFpLnN0b3AoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsID0gKGVycik9PntcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHFpLnB1c2goKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsZWFyVGltZXJzKCk7XG4gICAgICAgICAgICAgICAgc3ViLmRyYWluKCkudGhlbigoKT0+e1xuICAgICAgICAgICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goKF9lcnIpPT57XG4gICAgICAgICAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBxaS5pdGVyQ2xvc2VkLnRoZW4oKCk9PntcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVycygpO1xuICAgICAgICAgICAgICAgIHN1Yj8udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKChfZXJyKT0+e1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZXJzKCk7XG4gICAgICAgICAgICAgICAgc3ViPy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaChzdWJqZWN0LCBkYXRhLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGx5OiBzdWIuZ2V0U3ViamVjdCgpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWwoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0aW1lciA9IHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgICAgIH0sIG9wdHMubWF4V2FpdCk7XG4gICAgICAgICAgICBjb25zdCBjbGVhclRpbWVycyA9ICgpPT57XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJtbyA9IG9wdHM7XG4gICAgICAgICAgICBybW8uY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgICAgIHFpLml0ZXJDbG9zZWQudGhlbigoKT0+e1xuICAgICAgICAgICAgICAgIHIuY2FuY2VsKCk7XG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgICAgIHIuY2FuY2VsKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBuZXcgUmVxdWVzdE1hbnkodGhpcy5wcm90b2NvbC5tdXhTdWJzY3JpcHRpb25zLCBzdWJqZWN0LCBybW8pO1xuICAgICAgICAgICAgdGhpcy5wcm90b2NvbC5yZXF1ZXN0KHIpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2goc3ViamVjdCwgZGF0YSwge1xuICAgICAgICAgICAgICAgICAgICByZXBseTogYCR7dGhpcy5wcm90b2NvbC5tdXhTdWJzY3JpcHRpb25zLmJhc2VJbmJveH0ke3IudG9rZW59YCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogb3B0cy5oZWFkZXJzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByLmNhbmNlbChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocWkpO1xuICAgIH1cbiAgICByZXF1ZXN0KHN1YmplY3QsIGRhdGEsIG9wdHMgPSB7XG4gICAgICAgIHRpbWVvdXQ6IDEwMDAsXG4gICAgICAgIG5vTXV4OiBmYWxzZVxuICAgIH0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrKHN1YmplY3QsIHRydWUsIHRydWUpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFzeW5jVHJhY2VzID0gISh0aGlzLnByb3RvY29sLm9wdGlvbnMubm9Bc3luY1RyYWNlcyB8fCBmYWxzZSk7XG4gICAgICAgIG9wdHMudGltZW91dCA9IG9wdHMudGltZW91dCB8fCAxMDAwO1xuICAgICAgICBpZiAob3B0cy50aW1lb3V0IDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBOYXRzRXJyb3IoXCJ0aW1lb3V0XCIsIEVycm9yQ29kZS5JbnZhbGlkT3B0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRzLm5vTXV4ICYmIG9wdHMucmVwbHkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgTmF0c0Vycm9yKFwicmVwbHkgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIG5vTXV4XCIsIEVycm9yQ29kZS5JbnZhbGlkT3B0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMubm9NdXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGluYm94ID0gb3B0cy5yZXBseSA/IG9wdHMucmVwbHkgOiBjcmVhdGVJbmJveCh0aGlzLm9wdGlvbnMuaW5ib3hQcmVmaXgpO1xuICAgICAgICAgICAgY29uc3QgZCA9IGRlZmVycmVkKCk7XG4gICAgICAgICAgICBjb25zdCBlcnJDdHggPSBhc3luY1RyYWNlcyA/IG5ldyBFcnJvcigpIDogbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IHRoaXMuc3Vic2NyaWJlKGluYm94LCB7XG4gICAgICAgICAgICAgICAgbWF4OiAxLFxuICAgICAgICAgICAgICAgIHRpbWVvdXQ6IG9wdHMudGltZW91dCxcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogKGVyciwgbXNnKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyQ3R4ICYmIGVyci5jb2RlICE9PSBFcnJvckNvZGUuVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyci5zdGFjayArPSBgXFxuXFxuJHtlcnJDdHguc3RhY2t9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IGlzUmVxdWVzdEVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyckN0eCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIuc3RhY2sgKz0gYFxcblxcbiR7ZXJyQ3R4LnN0YWNrfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQucmVzb2x2ZShtc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdWIucmVxdWVzdFN1YmplY3QgPSBzdWJqZWN0O1xuICAgICAgICAgICAgdGhpcy5wcm90b2NvbC5wdWJsaXNoKHN1YmplY3QsIGRhdGEsIHtcbiAgICAgICAgICAgICAgICByZXBseTogaW5ib3gsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogb3B0cy5oZWFkZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgciA9IG5ldyBSZXF1ZXN0T25lKHRoaXMucHJvdG9jb2wubXV4U3Vic2NyaXB0aW9ucywgc3ViamVjdCwgb3B0cywgYXN5bmNUcmFjZXMpO1xuICAgICAgICAgICAgdGhpcy5wcm90b2NvbC5yZXF1ZXN0KHIpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2goc3ViamVjdCwgZGF0YSwge1xuICAgICAgICAgICAgICAgICAgICByZXBseTogYCR7dGhpcy5wcm90b2NvbC5tdXhTdWJzY3JpcHRpb25zLmJhc2VJbmJveH0ke3IudG9rZW59YCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogb3B0cy5oZWFkZXJzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByLmNhbmNlbChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcCA9IFByb21pc2UucmFjZShbXG4gICAgICAgICAgICAgICAgci50aW1lcixcbiAgICAgICAgICAgICAgICByLmRlZmVycmVkXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHAuY2F0Y2goKCk9PntcbiAgICAgICAgICAgICAgICByLmNhbmNlbCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmbHVzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLkNvbm5lY3Rpb25DbG9zZWQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm90b2NvbC5mbHVzaCgpO1xuICAgIH1cbiAgICBkcmFpbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLkNvbm5lY3Rpb25DbG9zZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0RyYWluaW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChOYXRzRXJyb3IuZXJyb3JGb3JDb2RlKEVycm9yQ29kZS5Db25uZWN0aW9uRHJhaW5pbmcpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYWluaW5nID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdG9jb2wuZHJhaW4oKTtcbiAgICB9XG4gICAgaXNDbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3RvY29sLmlzQ2xvc2VkKCk7XG4gICAgfVxuICAgIGlzRHJhaW5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYWluaW5nO1xuICAgIH1cbiAgICBnZXRTZXJ2ZXIoKSB7XG4gICAgICAgIGNvbnN0IHNydiA9IHRoaXMucHJvdG9jb2wuZ2V0U2VydmVyKCk7XG4gICAgICAgIHJldHVybiBzcnYgPyBzcnYubGlzdGVuIDogXCJcIjtcbiAgICB9XG4gICAgc3RhdHVzKCkge1xuICAgICAgICBjb25zdCBpdGVyID0gbmV3IFF1ZXVlZEl0ZXJhdG9ySW1wbCgpO1xuICAgICAgICBpdGVyLml0ZXJDbG9zZWQudGhlbigoKT0+e1xuICAgICAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5saXN0ZW5lcnMuaW5kZXhPZihpdGVyKTtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaChpdGVyKTtcbiAgICAgICAgcmV0dXJuIGl0ZXI7XG4gICAgfVxuICAgIGdldCBpbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm90b2NvbC5pc0Nsb3NlZCgpID8gdW5kZWZpbmVkIDogdGhpcy5wcm90b2NvbC5pbmZvO1xuICAgIH1cbiAgICBhc3luYyBjb250ZXh0KCkge1xuICAgICAgICBjb25zdCByID0gYXdhaXQgdGhpcy5yZXF1ZXN0KGAkU1lTLlJFUS5VU0VSLklORk9gKTtcbiAgICAgICAgcmV0dXJuIHIuanNvbigoa2V5LCB2YWx1ZSk9PntcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwidGltZVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUucGFyc2UodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5CeXRlczogdGhpcy5wcm90b2NvbC5pbkJ5dGVzLFxuICAgICAgICAgICAgb3V0Qnl0ZXM6IHRoaXMucHJvdG9jb2wub3V0Qnl0ZXMsXG4gICAgICAgICAgICBpbk1zZ3M6IHRoaXMucHJvdG9jb2wuaW5Nc2dzLFxuICAgICAgICAgICAgb3V0TXNnczogdGhpcy5wcm90b2NvbC5vdXRNc2dzXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGpldHN0cmVhbU1hbmFnZXIob3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGFkbSA9IG5ldyBKZXRTdHJlYW1NYW5hZ2VySW1wbCh0aGlzLCBvcHRzKTtcbiAgICAgICAgaWYgKG9wdHMuY2hlY2tBUEkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGFkbS5nZXRBY2NvdW50SW5mbygpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmUgPSBlcnI7XG4gICAgICAgICAgICAgICAgaWYgKG5lLmNvZGUgPT09IEVycm9yQ29kZS5Ob1Jlc3BvbmRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbmUuY29kZSA9IEVycm9yQ29kZS5KZXRTdHJlYW1Ob3RFbmFibGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRtO1xuICAgIH1cbiAgICBqZXRzdHJlYW0ob3B0cyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBuZXcgSmV0U3RyZWFtQ2xpZW50SW1wbCh0aGlzLCBvcHRzKTtcbiAgICB9XG4gICAgZ2V0U2VydmVyVmVyc2lvbigpIHtcbiAgICAgICAgY29uc3QgaW5mbyA9IHRoaXMuaW5mbztcbiAgICAgICAgcmV0dXJuIGluZm8gPyBwYXJzZVNlbVZlcihpbmZvLnZlcnNpb24pIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBhc3luYyBydHQoKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm90b2NvbC5fY2xvc2VkICYmICF0aGlzLnByb3RvY29sLmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgdGhyb3cgTmF0c0Vycm9yLmVycm9yRm9yQ29kZShFcnJvckNvZGUuRGlzY29ubmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICBhd2FpdCB0aGlzLmZsdXNoKCk7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gc3RhcnQ7XG4gICAgfVxuICAgIGdldCBmZWF0dXJlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdG9jb2wuZmVhdHVyZXM7XG4gICAgfVxuICAgIGdldCBzZXJ2aWNlcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zZXJ2aWNlcykge1xuICAgICAgICAgICAgdGhpcy5fc2VydmljZXMgPSBuZXcgU2VydmljZXNGYWN0b3J5KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXJ2aWNlcztcbiAgICB9XG4gICAgcmVjb25uZWN0KCkge1xuICAgICAgICBpZiAodGhpcy5pc0Nsb3NlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoTmF0c0Vycm9yLmVycm9yRm9yQ29kZShFcnJvckNvZGUuQ29ubmVjdGlvbkNsb3NlZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzRHJhaW5pbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLkNvbm5lY3Rpb25EcmFpbmluZykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb3RvY29sLnJlY29ubmVjdCgpO1xuICAgIH1cbn1cbmNsYXNzIFNlcnZpY2VzRmFjdG9yeSB7XG4gICAgbmM7XG4gICAgY29uc3RydWN0b3IobmMpe1xuICAgICAgICB0aGlzLm5jID0gbmM7XG4gICAgfVxuICAgIGFkZChjb25maWcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHMgPSBuZXcgU2VydmljZUltcGwodGhpcy5uYywgY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybiBzLnN0YXJ0KCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xpZW50KG9wdHMsIHByZWZpeCkge1xuICAgICAgICByZXR1cm4gbmV3IFNlcnZpY2VDbGllbnRJbXBsKHRoaXMubmMsIG9wdHMsIHByZWZpeCk7XG4gICAgfVxufVxuY2xhc3MgS3ZTdG9yZWRFbnRyeUltcGwge1xuICAgIGJ1Y2tldDtcbiAgICBzbTtcbiAgICBwcmVmaXhMZW47XG4gICAgY29uc3RydWN0b3IoYnVja2V0LCBwcmVmaXhMZW4sIHNtKXtcbiAgICAgICAgdGhpcy5idWNrZXQgPSBidWNrZXQ7XG4gICAgICAgIHRoaXMucHJlZml4TGVuID0gcHJlZml4TGVuO1xuICAgICAgICB0aGlzLnNtID0gc207XG4gICAgfVxuICAgIGdldCBrZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNtLnN1YmplY3Quc3Vic3RyaW5nKHRoaXMucHJlZml4TGVuKTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbS5kYXRhO1xuICAgIH1cbiAgICBnZXQgZGVsdGEoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBnZXQgY3JlYXRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc20udGltZTtcbiAgICB9XG4gICAgZ2V0IHJldmlzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbS5zZXE7XG4gICAgfVxuICAgIGdldCBvcGVyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNtLmhlYWRlci5nZXQoa3ZPcGVyYXRpb25IZHIpIHx8IFwiUFVUXCI7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIGNvbnN0IHNsZW4gPSB0aGlzLnNtLmhlYWRlci5nZXQoSnNIZWFkZXJzLk1lc3NhZ2VTaXplSGRyKSB8fCBcIlwiO1xuICAgICAgICBpZiAoc2xlbiAhPT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHNsZW4sIDEwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zbS5kYXRhLmxlbmd0aDtcbiAgICB9XG4gICAganNvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc20uanNvbigpO1xuICAgIH1cbiAgICBzdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNtLnN0cmluZygpO1xuICAgIH1cbn1cbmNsYXNzIEt2SnNNc2dFbnRyeUltcGwge1xuICAgIGJ1Y2tldDtcbiAgICBrZXk7XG4gICAgc207XG4gICAgY29uc3RydWN0b3IoYnVja2V0LCBrZXksIHNtKXtcbiAgICAgICAgdGhpcy5idWNrZXQgPSBidWNrZXQ7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnNtID0gc207XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc20uZGF0YTtcbiAgICB9XG4gICAgZ2V0IGNyZWF0ZWQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShtaWxsaXModGhpcy5zbS5pbmZvLnRpbWVzdGFtcE5hbm9zKSk7XG4gICAgfVxuICAgIGdldCByZXZpc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc20uc2VxO1xuICAgIH1cbiAgICBnZXQgb3BlcmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbS5oZWFkZXJzPy5nZXQoa3ZPcGVyYXRpb25IZHIpIHx8IFwiUFVUXCI7XG4gICAgfVxuICAgIGdldCBkZWx0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc20uaW5mby5wZW5kaW5nO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICBjb25zdCBzbGVuID0gdGhpcy5zbS5oZWFkZXJzPy5nZXQoSnNIZWFkZXJzLk1lc3NhZ2VTaXplSGRyKSB8fCBcIlwiO1xuICAgICAgICBpZiAoc2xlbiAhPT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHNsZW4sIDEwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zbS5kYXRhLmxlbmd0aDtcbiAgICB9XG4gICAganNvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc20uanNvbigpO1xuICAgIH1cbiAgICBzdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNtLnN0cmluZygpO1xuICAgIH1cbn1cbmNsYXNzIEpldFN0cmVhbVN1YnNjcmlwdGlvbkltcGwgZXh0ZW5kcyBUeXBlZFN1YnNjcmlwdGlvbiB7XG4gICAganM7XG4gICAgbW9uaXRvcjtcbiAgICBjb25zdHJ1Y3Rvcihqcywgc3ViamVjdCwgb3B0cyl7XG4gICAgICAgIHN1cGVyKGpzLm5jLCBzdWJqZWN0LCBvcHRzKTtcbiAgICAgICAgdGhpcy5qcyA9IGpzO1xuICAgICAgICB0aGlzLm1vbml0b3IgPSBudWxsO1xuICAgICAgICB0aGlzLnN1Yi5jbG9zZWQudGhlbigoKT0+e1xuICAgICAgICAgICAgaWYgKHRoaXMubW9uaXRvcikge1xuICAgICAgICAgICAgICAgIHRoaXMubW9uaXRvci5jYW5jZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldCBpbmZvKGluZm8pIHtcbiAgICAgICAgdGhpcy5zdWIuaW5mbyA9IGluZm87XG4gICAgfVxuICAgIGdldCBpbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIuaW5mbztcbiAgICB9XG4gICAgX3Jlc2V0T3JkZXJlZENvbnN1bWVyKHNzZXEpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5mbyA9PT0gbnVsbCB8fCB0aGlzLnN1Yi5pc0Nsb3NlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3RGVsaXZlciA9IGNyZWF0ZUluYm94KHRoaXMuanMubmMub3B0aW9ucy5pbmJveFByZWZpeCk7XG4gICAgICAgIGNvbnN0IG5jaSA9IHRoaXMuanMubmM7XG4gICAgICAgIG5jaS5fcmVzdWIodGhpcy5zdWIsIG5ld0RlbGl2ZXIpO1xuICAgICAgICBjb25zdCBpbmZvID0gdGhpcy5pbmZvO1xuICAgICAgICBpbmZvLmNvbmZpZy5uYW1lID0gbnVpZC5uZXh0KCk7XG4gICAgICAgIGluZm8ub3JkZXJlZF9jb25zdW1lcl9zZXF1ZW5jZS5kZWxpdmVyeV9zZXEgPSAwO1xuICAgICAgICBpbmZvLmZsb3dfY29udHJvbC5oZWFydGJlYXRfY291bnQgPSAwO1xuICAgICAgICBpbmZvLmZsb3dfY29udHJvbC5mY19jb3VudCA9IDA7XG4gICAgICAgIGluZm8uZmxvd19jb250cm9sLmNvbnN1bWVyX3Jlc3RhcnRzKys7XG4gICAgICAgIGluZm8uZGVsaXZlciA9IG5ld0RlbGl2ZXI7XG4gICAgICAgIGluZm8uY29uZmlnLmRlbGl2ZXJfc3ViamVjdCA9IG5ld0RlbGl2ZXI7XG4gICAgICAgIGluZm8uY29uZmlnLmRlbGl2ZXJfcG9saWN5ID0gRGVsaXZlclBvbGljeS5TdGFydFNlcXVlbmNlO1xuICAgICAgICBpbmZvLmNvbmZpZy5vcHRfc3RhcnRfc2VxID0gc3NlcTtcbiAgICAgICAgY29uc3QgcmVxID0ge307XG4gICAgICAgIHJlcS5zdHJlYW1fbmFtZSA9IHRoaXMuaW5mby5zdHJlYW07XG4gICAgICAgIHJlcS5jb25maWcgPSBpbmZvLmNvbmZpZztcbiAgICAgICAgY29uc3Qgc3ViaiA9IGAke2luZm8uYXBpLnByZWZpeH0uQ09OU1VNRVIuQ1JFQVRFLiR7aW5mby5zdHJlYW19YDtcbiAgICAgICAgdGhpcy5qcy5fcmVxdWVzdChzdWJqLCByZXEsIHtcbiAgICAgICAgICAgIHJldHJpZXM6IC0xXG4gICAgICAgIH0pLnRoZW4oKHYpPT57XG4gICAgICAgICAgICBjb25zdCBjaSA9IHY7XG4gICAgICAgICAgICBjb25zdCBqaW5mbyA9IHRoaXMuc3ViLmluZm87XG4gICAgICAgICAgICBqaW5mby5sYXN0ID0gY2k7XG4gICAgICAgICAgICB0aGlzLmluZm8uY29uZmlnID0gY2kuY29uZmlnO1xuICAgICAgICAgICAgdGhpcy5pbmZvLm5hbWUgPSBjaS5uYW1lO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgY29uc3QgbmVyciA9IG5ldyBOYXRzRXJyb3IoYHVuYWJsZSB0byByZWNyZWF0ZSBvcmRlcmVkIGNvbnN1bWVyICR7aW5mby5zdHJlYW19IGF0IHNlcSAke3NzZXF9YCwgRXJyb3JDb2RlLlJlcXVlc3RFcnJvciwgZXJyKTtcbiAgICAgICAgICAgIHRoaXMuc3ViLmNhbGxiYWNrKG5lcnIsIHt9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9tYXliZVNldHVwSGJNb25pdG9yaW5nKCkge1xuICAgICAgICBjb25zdCBucyA9IHRoaXMuaW5mbz8uY29uZmlnPy5pZGxlX2hlYXJ0YmVhdCB8fCAwO1xuICAgICAgICBpZiAobnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldHVwSGJNb25pdG9yaW5nKG1pbGxpcyhucykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9zZXR1cEhiTW9uaXRvcmluZyhtaWxsaXMsIGNhbmNlbEFmdGVyID0gMCkge1xuICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgICAgY2FuY2VsQWZ0ZXI6IDAsXG4gICAgICAgICAgICBtYXhPdXQ6IDJcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGNhbmNlbEFmdGVyKSB7XG4gICAgICAgICAgICBvcHRzLmNhbmNlbEFmdGVyID0gY2FuY2VsQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3ViID0gdGhpcy5zdWI7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSAodik9PntcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IG5ld0pzRXJyb3JNc2coNDA5LCBgJHtKczQwOUVycm9ycy5JZGxlSGVhcnRiZWF0TWlzc2VkfTogJHt2fWAsIHRoaXMuc3ViLnN1YmplY3QpO1xuICAgICAgICAgICAgY29uc3Qgb3JkZXJlZCA9IHRoaXMuaW5mbz8ub3JkZXJlZDtcbiAgICAgICAgICAgIGlmICghb3JkZXJlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3ViLmNhbGxiYWNrKG51bGwsIG1zZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5qcy5uYy5wcm90b2NvbC5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzZXEgPSB0aGlzLmluZm8/Lm9yZGVyZWRfY29uc3VtZXJfc2VxdWVuY2U/LnN0cmVhbV9zZXEgfHwgMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNldE9yZGVyZWRDb25zdW1lcihzZXEgKyAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vbml0b3I/LnJlc3RhcnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gIXN1Yi5ub0l0ZXJhdG9yO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1vbml0b3IgPSBuZXcgSWRsZUhlYXJ0YmVhdE1vbml0b3IobWlsbGlzLCBoYW5kbGVyLCBvcHRzKTtcbiAgICB9XG4gICAgX2NoZWNrSGJPcmRlckNvbnN1bWVyKG1zZykge1xuICAgICAgICBjb25zdCBybSA9IG1zZy5oZWFkZXJzLmdldChKc0hlYWRlcnMuQ29uc3VtZXJTdGFsbGVkSGRyKTtcbiAgICAgICAgaWYgKHJtICE9PSBcIlwiKSB7XG4gICAgICAgICAgICBjb25zdCBuY2kgPSB0aGlzLmpzLm5jO1xuICAgICAgICAgICAgbmNpLnB1Ymxpc2gocm0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhc3REZWxpdmVyZWQgPSBwYXJzZUludChtc2cuaGVhZGVycy5nZXQoSnNIZWFkZXJzLkxhc3RDb25zdW1lclNlcUhkciksIDEwKTtcbiAgICAgICAgY29uc3Qgb3JkZXJlZCA9IHRoaXMuaW5mby5vcmRlcmVkX2NvbnN1bWVyX3NlcXVlbmNlO1xuICAgICAgICB0aGlzLmluZm8uZmxvd19jb250cm9sLmhlYXJ0YmVhdF9jb3VudCsrO1xuICAgICAgICBpZiAobGFzdERlbGl2ZXJlZCAhPT0gb3JkZXJlZC5kZWxpdmVyeV9zZXEpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0T3JkZXJlZENvbnN1bWVyKG9yZGVyZWQuc3RyZWFtX3NlcSArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX2NoZWNrT3JkZXJlZENvbnN1bWVyKGptKSB7XG4gICAgICAgIGNvbnN0IG9yZGVyZWQgPSB0aGlzLmluZm8ub3JkZXJlZF9jb25zdW1lcl9zZXF1ZW5jZTtcbiAgICAgICAgY29uc3Qgc3NlcSA9IGptLmluZm8uc3RyZWFtU2VxdWVuY2U7XG4gICAgICAgIGNvbnN0IGRzZXEgPSBqbS5pbmZvLmRlbGl2ZXJ5U2VxdWVuY2U7XG4gICAgICAgIGlmIChkc2VxICE9IG9yZGVyZWQuZGVsaXZlcnlfc2VxICsgMSkge1xuICAgICAgICAgICAgdGhpcy5fcmVzZXRPcmRlcmVkQ29uc3VtZXIob3JkZXJlZC5zdHJlYW1fc2VxICsgMSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgb3JkZXJlZC5kZWxpdmVyeV9zZXEgPSBkc2VxO1xuICAgICAgICBvcmRlcmVkLnN0cmVhbV9zZXEgPSBzc2VxO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYXN5bmMgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZHJhaW4oKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBqaW5mbyA9IHRoaXMuc3ViLmluZm87XG4gICAgICAgIGNvbnN0IG5hbWUgPSBqaW5mby5jb25maWcuZHVyYWJsZV9uYW1lIHx8IGppbmZvLm5hbWU7XG4gICAgICAgIGNvbnN0IHN1YmogPSBgJHtqaW5mby5hcGkucHJlZml4fS5DT05TVU1FUi5ERUxFVEUuJHtqaW5mby5zdHJlYW19LiR7bmFtZX1gO1xuICAgICAgICBhd2FpdCBqaW5mby5hcGkuX3JlcXVlc3Qoc3Viaik7XG4gICAgfVxuICAgIGFzeW5jIGNvbnN1bWVySW5mbygpIHtcbiAgICAgICAgY29uc3QgamluZm8gPSB0aGlzLnN1Yi5pbmZvO1xuICAgICAgICBjb25zdCBuYW1lID0gamluZm8uY29uZmlnLmR1cmFibGVfbmFtZSB8fCBqaW5mby5uYW1lO1xuICAgICAgICBjb25zdCBzdWJqID0gYCR7amluZm8uYXBpLnByZWZpeH0uQ09OU1VNRVIuSU5GTy4ke2ppbmZvLnN0cmVhbX0uJHtuYW1lfWA7XG4gICAgICAgIGNvbnN0IGNpID0gYXdhaXQgamluZm8uYXBpLl9yZXF1ZXN0KHN1YmopO1xuICAgICAgICBqaW5mby5sYXN0ID0gY2k7XG4gICAgICAgIHJldHVybiBjaTtcbiAgICB9XG59XG5jbGFzcyBKZXRTdHJlYW1QdWxsU3Vic2NyaXB0aW9uSW1wbCBleHRlbmRzIEpldFN0cmVhbVN1YnNjcmlwdGlvbkltcGwge1xuICAgIGNvbnN0cnVjdG9yKGpzLCBzdWJqZWN0LCBvcHRzKXtcbiAgICAgICAgc3VwZXIoanMsIHN1YmplY3QsIG9wdHMpO1xuICAgIH1cbiAgICBwdWxsKG9wdHMgPSB7XG4gICAgICAgIGJhdGNoOiAxXG4gICAgfSkge1xuICAgICAgICBjb25zdCB7IHN0cmVhbSwgY29uZmlnLCBuYW1lIH0gPSB0aGlzLnN1Yi5pbmZvO1xuICAgICAgICBjb25zdCBjb25zdW1lciA9IGNvbmZpZy5kdXJhYmxlX25hbWUgPz8gbmFtZTtcbiAgICAgICAgY29uc3QgYXJncyA9IHt9O1xuICAgICAgICBhcmdzLmJhdGNoID0gb3B0cy5iYXRjaCB8fCAxO1xuICAgICAgICBhcmdzLm5vX3dhaXQgPSBvcHRzLm5vX3dhaXQgfHwgZmFsc2U7XG4gICAgICAgIGlmICgob3B0cy5tYXhfYnl0ZXMgPz8gMCkgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBmdiA9IHRoaXMuanMubmMuZmVhdHVyZXMuZ2V0KEZlYXR1cmUuSlNfUFVMTF9NQVhfQllURVMpO1xuICAgICAgICAgICAgaWYgKCFmdi5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbWF4X2J5dGVzIGlzIG9ubHkgc3VwcG9ydGVkIG9uIHNlcnZlcnMgJHtmdi5taW59IG9yIGJldHRlcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJncy5tYXhfYnl0ZXMgPSBvcHRzLm1heF9ieXRlcztcbiAgICAgICAgfVxuICAgICAgICBsZXQgZXhwaXJlcyA9IDA7XG4gICAgICAgIGlmIChvcHRzLmV4cGlyZXMgJiYgb3B0cy5leHBpcmVzID4gMCkge1xuICAgICAgICAgICAgZXhwaXJlcyA9IG9wdHMuZXhwaXJlcztcbiAgICAgICAgICAgIGFyZ3MuZXhwaXJlcyA9IG5hbm9zKGV4cGlyZXMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBoYiA9IDA7XG4gICAgICAgIGlmIChvcHRzLmlkbGVfaGVhcnRiZWF0ICYmIG9wdHMuaWRsZV9oZWFydGJlYXQgPiAwKSB7XG4gICAgICAgICAgICBoYiA9IG9wdHMuaWRsZV9oZWFydGJlYXQ7XG4gICAgICAgICAgICBhcmdzLmlkbGVfaGVhcnRiZWF0ID0gbmFub3MoaGIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYiAmJiBleHBpcmVzID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpZGxlX2hlYXJ0YmVhdCByZXF1aXJlcyBleHBpcmVzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYiA+IGV4cGlyZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4cGlyZXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gaWRsZV9oZWFydGJlYXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5mbykge1xuICAgICAgICAgICAgaWYgKHRoaXMubW9uaXRvcikge1xuICAgICAgICAgICAgICAgIHRoaXMubW9uaXRvci5jYW5jZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHBpcmVzICYmIGhiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1vbml0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0dXBIYk1vbml0b3JpbmcoaGIsIGV4cGlyZXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9uaXRvci5fY2hhbmdlKGhiLCBleHBpcmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcGkgPSB0aGlzLmluZm8uYXBpO1xuICAgICAgICAgICAgY29uc3Qgc3ViaiA9IGAke2FwaS5wcmVmaXh9LkNPTlNVTUVSLk1TRy5ORVhULiR7c3RyZWFtfS4ke2NvbnN1bWVyfWA7XG4gICAgICAgICAgICBjb25zdCByZXBseSA9IHRoaXMuc3ViLnN1YmplY3Q7XG4gICAgICAgICAgICBhcGkubmMucHVibGlzaChzdWJqLCBhcGkuamMuZW5jb2RlKGFyZ3MpLCB7XG4gICAgICAgICAgICAgICAgcmVwbHk6IHJlcGx5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG1zZ0FkYXB0ZXIoaXRlcmF0b3IsIGFja1RpbWVvdXQpIHtcbiAgICBpZiAoaXRlcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJNc2dBZGFwdGVyKGFja1RpbWVvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjYk1zZ0FkYXB0ZXIoYWNrVGltZW91dCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2JNc2dBZGFwdGVyKGFja1RpbWVvdXQpIHtcbiAgICByZXR1cm4gKGVyciwgbXNnKT0+e1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGVyciA9IGNoZWNrSnNFcnJvcihtc2cpO1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgdG9Kc01zZyhtc2csIGFja1RpbWVvdXQpXG4gICAgICAgIF07XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGl0ZXJNc2dBZGFwdGVyKGFja1RpbWVvdXQpIHtcbiAgICByZXR1cm4gKGVyciwgbXNnKT0+e1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5lID0gY2hlY2tKc0Vycm9yKG1zZyk7XG4gICAgICAgIGlmIChuZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBoaWRlTm9uVGVybWluYWxKc0Vycm9ycyhuZSksXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHRvSnNNc2cobXNnLCBhY2tUaW1lb3V0KVxuICAgICAgICBdO1xuICAgIH07XG59XG5mdW5jdGlvbiBoaWRlTm9uVGVybWluYWxKc0Vycm9ycyhuZSkge1xuICAgIGlmIChuZSAhPT0gbnVsbCkge1xuICAgICAgICBzd2l0Y2gobmUuY29kZSl7XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5KZXRTdHJlYW00MDROb01lc3NhZ2VzOlxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuSmV0U3RyZWFtNDA4UmVxdWVzdFRpbWVvdXQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5KZXRTdHJlYW00MDk6XG4gICAgICAgICAgICAgICAgaWYgKGlzVGVybWluYWw0MDkobmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBuZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGF1dG9BY2tKc01zZyhkYXRhKSB7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgZGF0YS5hY2soKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZUluZm8ocykge1xuICAgIGNvbnN0IHRva2VucyA9IHMuc3BsaXQoXCIuXCIpO1xuICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSA5KSB7XG4gICAgICAgIHRva2Vucy5zcGxpY2UoMiwgMCwgXCJfXCIsIFwiXCIpO1xuICAgIH1cbiAgICBpZiAodG9rZW5zLmxlbmd0aCA8IDExIHx8IHRva2Vuc1swXSAhPT0gXCIkSlNcIiB8fCB0b2tlbnNbMV0gIT09IFwiQUNLXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBub3QganMgbWVzc2FnZWApO1xuICAgIH1cbiAgICBjb25zdCBkaSA9IHt9O1xuICAgIGRpLmRvbWFpbiA9IHRva2Vuc1syXSA9PT0gXCJfXCIgPyBcIlwiIDogdG9rZW5zWzJdO1xuICAgIGRpLmFjY291bnRfaGFzaCA9IHRva2Vuc1szXTtcbiAgICBkaS5zdHJlYW0gPSB0b2tlbnNbNF07XG4gICAgZGkuY29uc3VtZXIgPSB0b2tlbnNbNV07XG4gICAgZGkuZGVsaXZlcnlDb3VudCA9IHBhcnNlSW50KHRva2Vuc1s2XSwgMTApO1xuICAgIGRpLnJlZGVsaXZlcnlDb3VudCA9IGRpLmRlbGl2ZXJ5Q291bnQ7XG4gICAgZGkucmVkZWxpdmVyZWQgPSBkaS5kZWxpdmVyeUNvdW50ID4gMTtcbiAgICBkaS5zdHJlYW1TZXF1ZW5jZSA9IHBhcnNlSW50KHRva2Vuc1s3XSwgMTApO1xuICAgIGRpLmRlbGl2ZXJ5U2VxdWVuY2UgPSBwYXJzZUludCh0b2tlbnNbOF0sIDEwKTtcbiAgICBkaS50aW1lc3RhbXBOYW5vcyA9IHBhcnNlSW50KHRva2Vuc1s5XSwgMTApO1xuICAgIGRpLnBlbmRpbmcgPSBwYXJzZUludCh0b2tlbnNbMTBdLCAxMCk7XG4gICAgcmV0dXJuIGRpO1xufVxuY2xhc3MgSnNNc2dJbXBsIHtcbiAgICBtc2c7XG4gICAgZGk7XG4gICAgZGlkQWNrO1xuICAgIHRpbWVvdXQ7XG4gICAgY29uc3RydWN0b3IobXNnLCB0aW1lb3V0KXtcbiAgICAgICAgdGhpcy5tc2cgPSBtc2c7XG4gICAgICAgIHRoaXMuZGlkQWNrID0gZmFsc2U7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgfVxuICAgIGdldCBzdWJqZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tc2cuc3ViamVjdDtcbiAgICB9XG4gICAgZ2V0IHNpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXNnLnNpZDtcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1zZy5kYXRhO1xuICAgIH1cbiAgICBnZXQgaGVhZGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXNnLmhlYWRlcnM7XG4gICAgfVxuICAgIGdldCBpbmZvKCkge1xuICAgICAgICBpZiAoIXRoaXMuZGkpIHtcbiAgICAgICAgICAgIHRoaXMuZGkgPSBwYXJzZUluZm8odGhpcy5yZXBseSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGk7XG4gICAgfVxuICAgIGdldCByZWRlbGl2ZXJlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5mby5kZWxpdmVyeUNvdW50ID4gMTtcbiAgICB9XG4gICAgZ2V0IHJlcGx5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tc2cucmVwbHkgfHwgXCJcIjtcbiAgICB9XG4gICAgZ2V0IHNlcSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5mby5zdHJlYW1TZXF1ZW5jZTtcbiAgICB9XG4gICAgZG9BY2socGF5bG9hZCkge1xuICAgICAgICBpZiAoIXRoaXMuZGlkQWNrKSB7XG4gICAgICAgICAgICB0aGlzLmRpZEFjayA9ICF0aGlzLmlzV0lQKHBheWxvYWQpO1xuICAgICAgICAgICAgdGhpcy5tc2cucmVzcG9uZChwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1dJUChwKSB7XG4gICAgICAgIHJldHVybiBwLmxlbmd0aCA9PT0gNCAmJiBwWzBdID09PSBXUElbMF0gJiYgcFsxXSA9PT0gV1BJWzFdICYmIHBbMl0gPT09IFdQSVsyXSAmJiBwWzNdID09PSBXUElbM107XG4gICAgfVxuICAgIGFzeW5jIGFja0FjayhvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICBvcHRzLnRpbWVvdXQgPSBvcHRzLnRpbWVvdXQgfHwgdGhpcy50aW1lb3V0O1xuICAgICAgICBjb25zdCBkID0gZGVmZXJyZWQoKTtcbiAgICAgICAgaWYgKCF0aGlzLmRpZEFjaykge1xuICAgICAgICAgICAgdGhpcy5kaWRBY2sgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMubXNnLnJlcGx5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWkgPSB0aGlzLm1zZztcbiAgICAgICAgICAgICAgICBjb25zdCBwcm90byA9IG1pLnB1Ymxpc2hlcjtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFjZSA9ICEocHJvdG8ub3B0aW9ucz8ubm9Bc3luY1RyYWNlcyB8fCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IG5ldyBSZXF1ZXN0T25lKHByb3RvLm11eFN1YnNjcmlwdGlvbnMsIHRoaXMubXNnLnJlcGx5LCB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IG9wdHMudGltZW91dFxuICAgICAgICAgICAgICAgIH0sIHRyYWNlKTtcbiAgICAgICAgICAgICAgICBwcm90by5yZXF1ZXN0KHIpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3RvLnB1Ymxpc2godGhpcy5tc2cucmVwbHksIEFDSywge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHk6IGAke3Byb3RvLm11eFN1YnNjcmlwdGlvbnMuYmFzZUluYm94fSR7ci50b2tlbn1gXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByLmNhbmNlbChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgICAgICAgICAgICAgci50aW1lcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHIuZGVmZXJyZWRcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIGQucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgci5jYW5jZWwoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgZC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGQucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkO1xuICAgIH1cbiAgICBhY2soKSB7XG4gICAgICAgIHRoaXMuZG9BY2soQUNLKTtcbiAgICB9XG4gICAgbmFrKG1pbGxpcykge1xuICAgICAgICBsZXQgcGF5bG9hZCA9IE5BSztcbiAgICAgICAgaWYgKG1pbGxpcykge1xuICAgICAgICAgICAgcGF5bG9hZCA9IFN0cmluZ0NvZGVjKCkuZW5jb2RlKGAtTkFLICR7SlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIGRlbGF5OiBuYW5vcyhtaWxsaXMpXG4gICAgICAgICAgICB9KX1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvQWNrKHBheWxvYWQpO1xuICAgIH1cbiAgICB3b3JraW5nKCkge1xuICAgICAgICB0aGlzLmRvQWNrKFdQSSk7XG4gICAgfVxuICAgIG5leHQoc3Viaiwgb3B0cyA9IHtcbiAgICAgICAgYmF0Y2g6IDFcbiAgICB9KSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB7fTtcbiAgICAgICAgYXJncy5iYXRjaCA9IG9wdHMuYmF0Y2ggfHwgMTtcbiAgICAgICAgYXJncy5ub193YWl0ID0gb3B0cy5ub193YWl0IHx8IGZhbHNlO1xuICAgICAgICBpZiAob3B0cy5leHBpcmVzICYmIG9wdHMuZXhwaXJlcyA+IDApIHtcbiAgICAgICAgICAgIGFyZ3MuZXhwaXJlcyA9IG5hbm9zKG9wdHMuZXhwaXJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IEpTT05Db2RlYygpLmVuY29kZShhcmdzKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IERhdGFCdWZmZXIuY29uY2F0KE5YVCwgU1BBQ0UsIGRhdGEpO1xuICAgICAgICBjb25zdCByZXFPcHRzID0gc3ViaiA/IHtcbiAgICAgICAgICAgIHJlcGx5OiBzdWJqXG4gICAgICAgIH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubXNnLnJlc3BvbmQocGF5bG9hZCwgcmVxT3B0cyk7XG4gICAgfVxuICAgIHRlcm0ocmVhc29uID0gXCJcIikge1xuICAgICAgICBsZXQgdGVybSA9IFRFUk07XG4gICAgICAgIGlmIChyZWFzb24/Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRlcm0gPSBTdHJpbmdDb2RlYygpLmVuY29kZShgK1RFUk0gJHtyZWFzb259YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb0Fjayh0ZXJtKTtcbiAgICB9XG4gICAganNvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXNnLmpzb24oKTtcbiAgICB9XG4gICAgc3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tc2cuc3RyaW5nKCk7XG4gICAgfVxufVxuZXhwb3J0IHsgY2hlY2tKc0Vycm9yIGFzIGNoZWNrSnNFcnJvciwgaXNGbG93Q29udHJvbE1zZyBhcyBpc0Zsb3dDb250cm9sTXNnLCBpc0hlYXJ0YmVhdE1zZyBhcyBpc0hlYXJ0YmVhdE1zZyB9O1xuZXhwb3J0IHsgQWNrUG9saWN5IGFzIEFja1BvbGljeSwgQWR2aXNvcnlLaW5kIGFzIEFkdmlzb3J5S2luZCwgQ29uc3VtZXJEZWJ1Z0V2ZW50cyBhcyBDb25zdW1lckRlYnVnRXZlbnRzLCBDb25zdW1lckV2ZW50cyBhcyBDb25zdW1lckV2ZW50cywgRGVsaXZlclBvbGljeSBhcyBEZWxpdmVyUG9saWN5LCBEaXJlY3RNc2dIZWFkZXJzIGFzIERpcmVjdE1zZ0hlYWRlcnMsIERpc2NhcmRQb2xpY3kgYXMgRGlzY2FyZFBvbGljeSwgSnNIZWFkZXJzIGFzIEpzSGVhZGVycywgS3ZXYXRjaEluY2x1ZGUgYXMgS3ZXYXRjaEluY2x1ZGUsIFJlcGxheVBvbGljeSBhcyBSZXBsYXlQb2xpY3ksIFJlcHVibGlzaEhlYWRlcnMgYXMgUmVwdWJsaXNoSGVhZGVycywgUmV0ZW50aW9uUG9saWN5IGFzIFJldGVudGlvblBvbGljeSwgU3RvcmFnZVR5cGUgYXMgU3RvcmFnZVR5cGUsIFN0b3JlQ29tcHJlc3Npb24gYXMgU3RvcmVDb21wcmVzc2lvbiB9O1xuZXhwb3J0IHsgY29uc3VtZXJPcHRzIGFzIGNvbnN1bWVyT3B0cyB9O1xuY29uc3QgVkVSU0lPTiA9IFwiMS4zMC4zXCI7XG5jb25zdCBMQU5HID0gXCJuYXRzLndzXCI7XG5jbGFzcyBXc1RyYW5zcG9ydCB7XG4gICAgdmVyc2lvbjtcbiAgICBsYW5nO1xuICAgIGNsb3NlRXJyb3I7XG4gICAgY29ubmVjdGVkO1xuICAgIGRvbmU7XG4gICAgc29ja2V0O1xuICAgIG9wdGlvbnM7XG4gICAgc29ja2V0Q2xvc2VkO1xuICAgIGVuY3J5cHRlZDtcbiAgICBwZWVrZWQ7XG4gICAgeWllbGRzO1xuICAgIHNpZ25hbDtcbiAgICBjbG9zZWROb3RpZmljYXRpb247XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gVkVSU0lPTjtcbiAgICAgICAgdGhpcy5sYW5nID0gTEFORztcbiAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc29ja2V0Q2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW5jcnlwdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGVla2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMueWllbGRzID0gW107XG4gICAgICAgIHRoaXMuc2lnbmFsID0gZGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy5jbG9zZWROb3RpZmljYXRpb24gPSBkZWZlcnJlZCgpO1xuICAgIH1cbiAgICBhc3luYyBjb25uZWN0KHNlcnZlciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY29ubkxvY2sgPSBkZWZlcnJlZCgpO1xuICAgICAgICBpZiAob3B0aW9ucy50bHMpIHtcbiAgICAgICAgICAgIGNvbm5Mb2NrLnJlamVjdChuZXcgTmF0c0Vycm9yKFwidGxzXCIsIEVycm9yQ29kZS5JbnZhbGlkT3B0aW9uKSk7XG4gICAgICAgICAgICByZXR1cm4gY29ubkxvY2s7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgdSA9IHNlcnZlci5zcmM7XG4gICAgICAgIGlmIChvcHRpb25zLndzRmFjdG9yeSkge1xuICAgICAgICAgICAgY29uc3QgeyBzb2NrZXQsIGVuY3J5cHRlZCB9ID0gYXdhaXQgb3B0aW9ucy53c0ZhY3Rvcnkoc2VydmVyLnNyYywgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgICAgICAgICAgIHRoaXMuZW5jcnlwdGVkID0gZW5jcnlwdGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbmNyeXB0ZWQgPSB1LmluZGV4T2YoXCJ3c3M6Ly9cIikgPT09IDA7XG4gICAgICAgICAgICB0aGlzLnNvY2tldCA9IG5ldyBXZWJTb2NrZXQodSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbiAgICAgICAgdGhpcy5zb2NrZXQub25vcGVuID0gKCk9PntcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRGlzY2FyZGVkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc29ja2V0Lm9ubWVzc2FnZSA9IChtZSk9PntcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRGlzY2FyZGVkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnlpZWxkcy5wdXNoKG5ldyBVaW50OEFycmF5KG1lLmRhdGEpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlZWtlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2lnbmFsLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0ID0gRGF0YUJ1ZmZlci5jb25jYXQoLi4udGhpcy55aWVsZHMpO1xuICAgICAgICAgICAgY29uc3QgcG0gPSBleHRyYWN0UHJvdG9jb2xNZXNzYWdlKHQpO1xuICAgICAgICAgICAgaWYgKHBtICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IElORk8uZXhlYyhwbSk7XG4gICAgICAgICAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiISEhXCIsIHJlbmRlcih0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29ubkxvY2sucmVqZWN0KG5ldyBFcnJvcihcInVuZXhwZWN0ZWQgcmVzcG9uc2UgZnJvbSBzZXJ2ZXJcIikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZm8gPSBKU09OLnBhcnNlKG1bMV0pO1xuICAgICAgICAgICAgICAgICAgICBjaGVja09wdGlvbnMoaW5mbywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZWVrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2lnbmFsLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgY29ubkxvY2sucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25uTG9jay5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zb2NrZXQub25jbG9zZSA9IChldnQpPT57XG4gICAgICAgICAgICBpZiAodGhpcy5pc0Rpc2NhcmRlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zb2NrZXRDbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IHJlYXNvbjtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbmUpIHJldHVybjtcbiAgICAgICAgICAgIGlmICghZXZ0Lndhc0NsZWFuKSB7XG4gICAgICAgICAgICAgICAgcmVhc29uID0gbmV3IEVycm9yKGV2dC5yZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY2xvc2VkKHJlYXNvbik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uZXJyb3IgPSAoZSk9PntcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRGlzY2FyZGVkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBldnQgPSBlO1xuICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IE5hdHNFcnJvcihldnQubWVzc2FnZSwgRXJyb3JDb2RlLlVua25vd24sIG5ldyBFcnJvcihldnQuZXJyb3IpKTtcbiAgICAgICAgICAgIGlmICghY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgY29ubkxvY2sucmVqZWN0KGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlZChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY29ubkxvY2s7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuX2Nsb3NlZCh1bmRlZmluZWQsIHRydWUpO1xuICAgIH1cbiAgICBhc3luYyBfY2xvc2VkKGVyciwgaW50ZXJuYWwgPSB0cnVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGlzY2FyZGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY29ubmVjdGVkKSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLmRvbmUpIHJldHVybjtcbiAgICAgICAgdGhpcy5jbG9zZUVycm9yID0gZXJyO1xuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgd2hpbGUoIXRoaXMuc29ja2V0Q2xvc2VkICYmIHRoaXMuc29ja2V0LmJ1ZmZlcmVkQW1vdW50ID4gMCl7XG4gICAgICAgICAgICAgICAgYXdhaXQgZGVsYXkoMTAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQuY2xvc2UoZXJyID8gMTAwMiA6IDEwMDAsIGVyciA/IGVyci5tZXNzYWdlIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICBpZiAoaW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VkTm90aWZpY2F0aW9uLnJlc29sdmUoZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXNDbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvbmU7XG4gICAgfVxuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZXJhdGUoKTtcbiAgICB9XG4gICAgYXN5bmMgKml0ZXJhdGUoKSB7XG4gICAgICAgIHdoaWxlKHRydWUpe1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEaXNjYXJkZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnlpZWxkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNpZ25hbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHlpZWxkcyA9IHRoaXMueWllbGRzO1xuICAgICAgICAgICAgdGhpcy55aWVsZHMgPSBbXTtcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB5aWVsZHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKGA+ICR7cmVuZGVyKHlpZWxkc1tpXSl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy55aWVsZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgeWllbGRzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy55aWVsZHMgPSB5aWVsZHM7XG4gICAgICAgICAgICAgICAgdGhpcy5zaWduYWwgPSBkZWZlcnJlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlzRW5jcnlwdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0ZWQgJiYgdGhpcy5lbmNyeXB0ZWQ7XG4gICAgfVxuICAgIHNlbmQoZnJhbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEaXNjYXJkZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5zZW5kKGZyYW1lLmJ1ZmZlcik7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKGA8ICR7cmVuZGVyKGZyYW1lKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgISEhICR7cmVuZGVyKGZyYW1lKX06ICR7ZXJyfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNsb3NlKGVycikge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvc2VkKGVyciwgZmFsc2UpO1xuICAgIH1cbiAgICBjbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlZE5vdGlmaWNhdGlvbjtcbiAgICB9XG4gICAgaXNEaXNjYXJkZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzY2FyZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkaXNjYXJkKCkge1xuICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQ/LmNsb3NlKCk7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnIpIHt9XG4gICAgfVxufVxuZnVuY3Rpb24gd3NVcmxQYXJzZUZuKHUsIGVuY3J5cHRlZCkge1xuICAgIGNvbnN0IHV0ID0gL14oLio6XFwvXFwvKSguKikvO1xuICAgIGlmICghdXQudGVzdCh1KSkge1xuICAgICAgICBpZiAodHlwZW9mIGVuY3J5cHRlZCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHUgPSBgJHtlbmNyeXB0ZWQgPT09IHRydWUgPyBcImh0dHBzXCIgOiBcImh0dHBcIn06Ly8ke3V9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHUgPSBgaHR0cHM6Ly8ke3V9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgdXJsID0gbmV3IFVSTCh1KTtcbiAgICBjb25zdCBzcmNQcm90byA9IHVybC5wcm90b2NvbC50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChzcmNQcm90byA9PT0gXCJ3czpcIikge1xuICAgICAgICBlbmNyeXB0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHNyY1Byb3RvID09PSBcIndzczpcIikge1xuICAgICAgICBlbmNyeXB0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoc3JjUHJvdG8gIT09IFwiaHR0cHM6XCIgJiYgc3JjUHJvdG8gIT09IFwiaHR0cFwiKSB7XG4gICAgICAgIHUgPSB1LnJlcGxhY2UoL14oLio6XFwvXFwvKSguKikvZ20sIFwiJDJcIik7XG4gICAgICAgIHVybCA9IG5ldyBVUkwoYGh0dHA6Ly8ke3V9YCk7XG4gICAgfVxuICAgIGxldCBwcm90b2NvbDtcbiAgICBsZXQgcG9ydDtcbiAgICBjb25zdCBob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgIGNvbnN0IHBhdGggPSB1cmwucGF0aG5hbWU7XG4gICAgY29uc3Qgc2VhcmNoID0gdXJsLnNlYXJjaCB8fCBcIlwiO1xuICAgIHN3aXRjaChzcmNQcm90byl7XG4gICAgICAgIGNhc2UgXCJodHRwOlwiOlxuICAgICAgICBjYXNlIFwid3M6XCI6XG4gICAgICAgIGNhc2UgXCJuYXRzOlwiOlxuICAgICAgICAgICAgcG9ydCA9IHVybC5wb3J0IHx8IFwiODBcIjtcbiAgICAgICAgICAgIHByb3RvY29sID0gXCJ3czpcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaHR0cHM6XCI6XG4gICAgICAgIGNhc2UgXCJ3c3M6XCI6XG4gICAgICAgIGNhc2UgXCJ0bHM6XCI6XG4gICAgICAgICAgICBwb3J0ID0gdXJsLnBvcnQgfHwgXCI0NDNcIjtcbiAgICAgICAgICAgIHByb3RvY29sID0gXCJ3c3M6XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHBvcnQgPSB1cmwucG9ydCB8fCBlbmNyeXB0ZWQgPT09IHRydWUgPyBcIjQ0M1wiIDogXCI4MFwiO1xuICAgICAgICAgICAgcHJvdG9jb2wgPSBlbmNyeXB0ZWQgPT09IHRydWUgPyBcIndzczpcIiA6IFwid3M6XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGAke3Byb3RvY29sfS8vJHtob3N0fToke3BvcnR9JHtwYXRofSR7c2VhcmNofWA7XG59XG5mdW5jdGlvbiBjb25uZWN0KG9wdHMgPSB7fSkge1xuICAgIHNldFRyYW5zcG9ydEZhY3Rvcnkoe1xuICAgICAgICBkZWZhdWx0UG9ydDogNDQzLFxuICAgICAgICB1cmxQYXJzZUZuOiB3c1VybFBhcnNlRm4sXG4gICAgICAgIGZhY3Rvcnk6ICgpPT57XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdzVHJhbnNwb3J0KCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gTmF0c0Nvbm5lY3Rpb25JbXBsLmNvbm5lY3Qob3B0cyk7XG59XG5leHBvcnQgeyBjb25uZWN0IGFzIGNvbm5lY3QgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/nats.ws/esm/nats.js\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fixcsoft%2F%C3%81rea%20de%20trabalho%2Frealtime-chat-project%2Ffrontend%2Fapp%2Fdashboard%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);
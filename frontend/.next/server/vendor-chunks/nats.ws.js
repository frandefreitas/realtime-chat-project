"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/nats.ws";
exports.ids = ["vendor-chunks/nats.ws"];
exports.modules = {

/***/ "(ssr)/./node_modules/nats.ws/esm/nats.js":
/*!******************************************!*\
  !*** ./node_modules/nats.ws/esm/nats.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AckPolicy: () => (/* binding */ AckPolicy),\n/* harmony export */   AdvisoryKind: () => (/* binding */ AdvisoryKind),\n/* harmony export */   Bench: () => (/* binding */ Bench),\n/* harmony export */   ConsumerDebugEvents: () => (/* binding */ ConsumerDebugEvents),\n/* harmony export */   ConsumerEvents: () => (/* binding */ ConsumerEvents),\n/* harmony export */   DebugEvents: () => (/* binding */ DebugEvents),\n/* harmony export */   DeliverPolicy: () => (/* binding */ DeliverPolicy),\n/* harmony export */   DirectMsgHeaders: () => (/* binding */ DirectMsgHeaders),\n/* harmony export */   DiscardPolicy: () => (/* binding */ DiscardPolicy),\n/* harmony export */   Empty: () => (/* binding */ Empty),\n/* harmony export */   ErrorCode: () => (/* binding */ ErrorCode),\n/* harmony export */   Events: () => (/* binding */ Events),\n/* harmony export */   JSONCodec: () => (/* binding */ JSONCodec),\n/* harmony export */   JsHeaders: () => (/* binding */ JsHeaders),\n/* harmony export */   KvWatchInclude: () => (/* binding */ KvWatchInclude),\n/* harmony export */   Match: () => (/* binding */ Match),\n/* harmony export */   Metric: () => (/* binding */ Metric),\n/* harmony export */   MsgHdrsImpl: () => (/* binding */ MsgHdrsImpl),\n/* harmony export */   NatsError: () => (/* binding */ NatsError),\n/* harmony export */   Nuid: () => (/* binding */ Nuid),\n/* harmony export */   ReplayPolicy: () => (/* binding */ ReplayPolicy),\n/* harmony export */   RepublishHeaders: () => (/* binding */ RepublishHeaders),\n/* harmony export */   RequestStrategy: () => (/* binding */ RequestStrategy),\n/* harmony export */   RetentionPolicy: () => (/* binding */ RetentionPolicy),\n/* harmony export */   ServiceError: () => (/* binding */ ServiceError),\n/* harmony export */   ServiceErrorCodeHeader: () => (/* binding */ ServiceErrorCodeHeader),\n/* harmony export */   ServiceErrorHeader: () => (/* binding */ ServiceErrorHeader),\n/* harmony export */   ServiceResponseType: () => (/* binding */ ServiceResponseType),\n/* harmony export */   ServiceVerb: () => (/* binding */ ServiceVerb),\n/* harmony export */   StorageType: () => (/* binding */ StorageType),\n/* harmony export */   StoreCompression: () => (/* binding */ StoreCompression),\n/* harmony export */   StringCodec: () => (/* binding */ StringCodec),\n/* harmony export */   backoff: () => (/* binding */ backoff),\n/* harmony export */   buildAuthenticator: () => (/* binding */ buildAuthenticator),\n/* harmony export */   canonicalMIMEHeaderKey: () => (/* binding */ canonicalMIMEHeaderKey),\n/* harmony export */   checkJsError: () => (/* binding */ checkJsError),\n/* harmony export */   connect: () => (/* binding */ connect),\n/* harmony export */   consumerOpts: () => (/* binding */ consumerOpts),\n/* harmony export */   createInbox: () => (/* binding */ createInbox),\n/* harmony export */   credsAuthenticator: () => (/* binding */ credsAuthenticator),\n/* harmony export */   deadline: () => (/* binding */ deadline),\n/* harmony export */   deferred: () => (/* binding */ deferred),\n/* harmony export */   delay: () => (/* binding */ delay),\n/* harmony export */   headers: () => (/* binding */ headers),\n/* harmony export */   isFlowControlMsg: () => (/* binding */ isFlowControlMsg),\n/* harmony export */   isHeartbeatMsg: () => (/* binding */ isHeartbeatMsg),\n/* harmony export */   jwtAuthenticator: () => (/* binding */ jwtAuthenticator),\n/* harmony export */   millis: () => (/* binding */ millis),\n/* harmony export */   nanos: () => (/* binding */ nanos),\n/* harmony export */   nkeyAuthenticator: () => (/* binding */ nkeyAuthenticator),\n/* harmony export */   nkeys: () => (/* binding */ mod),\n/* harmony export */   nuid: () => (/* binding */ nuid),\n/* harmony export */   syncIterator: () => (/* binding */ syncIterator),\n/* harmony export */   tokenAuthenticator: () => (/* binding */ tokenAuthenticator),\n/* harmony export */   usernamePasswordAuthenticator: () => (/* binding */ usernamePasswordAuthenticator)\n/* harmony export */ });\n// deno-fmt-ignore-file\n// deno-lint-ignore-file\n// This code was bundled using `deno bundle` and it's not recommended to edit it manually\n\nconst Empty = new Uint8Array(0);\nconst TE = new TextEncoder();\nconst TD = new TextDecoder();\nfunction concat(...bufs) {\n    let max = 0;\n    for(let i = 0; i < bufs.length; i++){\n        max += bufs[i].length;\n    }\n    const out = new Uint8Array(max);\n    let index = 0;\n    for(let i = 0; i < bufs.length; i++){\n        out.set(bufs[i], index);\n        index += bufs[i].length;\n    }\n    return out;\n}\nfunction encode(...a) {\n    const bufs = [];\n    for(let i = 0; i < a.length; i++){\n        bufs.push(TE.encode(a[i]));\n    }\n    if (bufs.length === 0) {\n        return Empty;\n    }\n    if (bufs.length === 1) {\n        return bufs[0];\n    }\n    return concat(...bufs);\n}\nfunction decode(a) {\n    if (!a || a.length === 0) {\n        return \"\";\n    }\n    return TD.decode(a);\n}\n\"use strict\";\nconst digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nconst base = 36;\nconst maxSeq = 3656158440062976;\nconst minInc = 33;\nconst maxInc = 333;\nconst totalLen = 12 + 10;\nfunction _getRandomValues(a) {\n    for(let i = 0; i < a.length; i++){\n        a[i] = Math.floor(Math.random() * 255);\n    }\n}\nfunction fillRandom(a) {\n    if (globalThis?.crypto?.getRandomValues) {\n        globalThis.crypto.getRandomValues(a);\n    } else {\n        _getRandomValues(a);\n    }\n}\nclass Nuid {\n    buf;\n    seq;\n    inc;\n    inited;\n    constructor(){\n        this.buf = new Uint8Array(totalLen);\n        this.inited = false;\n    }\n    init() {\n        this.inited = true;\n        this.setPre();\n        this.initSeqAndInc();\n        this.fillSeq();\n    }\n    initSeqAndInc() {\n        this.seq = Math.floor(Math.random() * maxSeq);\n        this.inc = Math.floor(Math.random() * (maxInc - minInc) + minInc);\n    }\n    setPre() {\n        const cbuf = new Uint8Array(12);\n        fillRandom(cbuf);\n        for(let i = 0; i < 12; i++){\n            const di = cbuf[i] % 36;\n            this.buf[i] = digits.charCodeAt(di);\n        }\n    }\n    fillSeq() {\n        let n = this.seq;\n        for(let i = totalLen - 1; i >= 12; i--){\n            this.buf[i] = digits.charCodeAt(n % base);\n            n = Math.floor(n / base);\n        }\n    }\n    next() {\n        if (!this.inited) {\n            this.init();\n        }\n        this.seq += this.inc;\n        if (this.seq > 3656158440062976) {\n            this.setPre();\n            this.initSeqAndInc();\n        }\n        this.fillSeq();\n        return String.fromCharCode.apply(String, this.buf);\n    }\n    reset() {\n        this.init();\n    }\n}\nconst nuid = new Nuid();\nvar Events;\n(function(Events) {\n    Events[\"Disconnect\"] = \"disconnect\";\n    Events[\"Reconnect\"] = \"reconnect\";\n    Events[\"Update\"] = \"update\";\n    Events[\"LDM\"] = \"ldm\";\n    Events[\"Error\"] = \"error\";\n})(Events || (Events = {}));\nvar DebugEvents;\n(function(DebugEvents) {\n    DebugEvents[\"Reconnecting\"] = \"reconnecting\";\n    DebugEvents[\"PingTimer\"] = \"pingTimer\";\n    DebugEvents[\"StaleConnection\"] = \"staleConnection\";\n    DebugEvents[\"ClientInitiatedReconnect\"] = \"client initiated reconnect\";\n})(DebugEvents || (DebugEvents = {}));\nvar ErrorCode;\n(function(ErrorCode) {\n    ErrorCode[\"ApiError\"] = \"BAD API\";\n    ErrorCode[\"BadAuthentication\"] = \"BAD_AUTHENTICATION\";\n    ErrorCode[\"BadCreds\"] = \"BAD_CREDS\";\n    ErrorCode[\"BadHeader\"] = \"BAD_HEADER\";\n    ErrorCode[\"BadJson\"] = \"BAD_JSON\";\n    ErrorCode[\"BadPayload\"] = \"BAD_PAYLOAD\";\n    ErrorCode[\"BadSubject\"] = \"BAD_SUBJECT\";\n    ErrorCode[\"Cancelled\"] = \"CANCELLED\";\n    ErrorCode[\"ConnectionClosed\"] = \"CONNECTION_CLOSED\";\n    ErrorCode[\"ConnectionDraining\"] = \"CONNECTION_DRAINING\";\n    ErrorCode[\"ConnectionRefused\"] = \"CONNECTION_REFUSED\";\n    ErrorCode[\"ConnectionTimeout\"] = \"CONNECTION_TIMEOUT\";\n    ErrorCode[\"Disconnect\"] = \"DISCONNECT\";\n    ErrorCode[\"InvalidOption\"] = \"INVALID_OPTION\";\n    ErrorCode[\"InvalidPayload\"] = \"INVALID_PAYLOAD\";\n    ErrorCode[\"MaxPayloadExceeded\"] = \"MAX_PAYLOAD_EXCEEDED\";\n    ErrorCode[\"NoResponders\"] = \"503\";\n    ErrorCode[\"NotFunction\"] = \"NOT_FUNC\";\n    ErrorCode[\"RequestError\"] = \"REQUEST_ERROR\";\n    ErrorCode[\"ServerOptionNotAvailable\"] = \"SERVER_OPT_NA\";\n    ErrorCode[\"SubClosed\"] = \"SUB_CLOSED\";\n    ErrorCode[\"SubDraining\"] = \"SUB_DRAINING\";\n    ErrorCode[\"Timeout\"] = \"TIMEOUT\";\n    ErrorCode[\"Tls\"] = \"TLS\";\n    ErrorCode[\"Unknown\"] = \"UNKNOWN_ERROR\";\n    ErrorCode[\"WssRequired\"] = \"WSS_REQUIRED\";\n    ErrorCode[\"JetStreamInvalidAck\"] = \"JESTREAM_INVALID_ACK\";\n    ErrorCode[\"JetStream404NoMessages\"] = \"404\";\n    ErrorCode[\"JetStream408RequestTimeout\"] = \"408\";\n    ErrorCode[\"JetStream409MaxAckPendingExceeded\"] = \"409\";\n    ErrorCode[\"JetStream409\"] = \"409\";\n    ErrorCode[\"JetStreamNotEnabled\"] = \"503\";\n    ErrorCode[\"JetStreamIdleHeartBeat\"] = \"IDLE_HEARTBEAT\";\n    ErrorCode[\"AuthorizationViolation\"] = \"AUTHORIZATION_VIOLATION\";\n    ErrorCode[\"AuthenticationExpired\"] = \"AUTHENTICATION_EXPIRED\";\n    ErrorCode[\"ProtocolError\"] = \"NATS_PROTOCOL_ERR\";\n    ErrorCode[\"PermissionsViolation\"] = \"PERMISSIONS_VIOLATION\";\n    ErrorCode[\"AuthenticationTimeout\"] = \"AUTHENTICATION_TIMEOUT\";\n    ErrorCode[\"AccountExpired\"] = \"ACCOUNT_EXPIRED\";\n})(ErrorCode || (ErrorCode = {}));\nfunction isNatsError(err) {\n    return typeof err.code === \"string\";\n}\nclass Messages {\n    messages;\n    constructor(){\n        this.messages = new Map();\n        this.messages.set(ErrorCode.InvalidPayload, \"Invalid payload type - payloads can be 'binary', 'string', or 'json'\");\n        this.messages.set(ErrorCode.BadJson, \"Bad JSON\");\n        this.messages.set(ErrorCode.WssRequired, \"TLS is required, therefore a secure websocket connection is also required\");\n    }\n    static getMessage(s) {\n        return messages.getMessage(s);\n    }\n    getMessage(s) {\n        return this.messages.get(s) || s;\n    }\n}\nconst messages = new Messages();\nclass NatsError extends Error {\n    name;\n    message;\n    code;\n    permissionContext;\n    chainedError;\n    api_error;\n    constructor(message, code, chainedError){\n        super(message);\n        this.name = \"NatsError\";\n        this.message = message;\n        this.code = code;\n        this.chainedError = chainedError;\n    }\n    static errorForCode(code, chainedError) {\n        const m = Messages.getMessage(code);\n        return new NatsError(m, code, chainedError);\n    }\n    isAuthError() {\n        return this.code === ErrorCode.AuthenticationExpired || this.code === ErrorCode.AuthorizationViolation || this.code === ErrorCode.AccountExpired;\n    }\n    isAuthTimeout() {\n        return this.code === ErrorCode.AuthenticationTimeout;\n    }\n    isPermissionError() {\n        return this.code === ErrorCode.PermissionsViolation;\n    }\n    isProtocolError() {\n        return this.code === ErrorCode.ProtocolError;\n    }\n    isJetStreamError() {\n        return this.api_error !== undefined;\n    }\n    jsError() {\n        return this.api_error ? this.api_error : null;\n    }\n}\nvar Match;\n(function(Match) {\n    Match[Match[\"Exact\"] = 0] = \"Exact\";\n    Match[Match[\"CanonicalMIME\"] = 1] = \"CanonicalMIME\";\n    Match[Match[\"IgnoreCase\"] = 2] = \"IgnoreCase\";\n})(Match || (Match = {}));\nvar RequestStrategy;\n(function(RequestStrategy) {\n    RequestStrategy[\"Timer\"] = \"timer\";\n    RequestStrategy[\"Count\"] = \"count\";\n    RequestStrategy[\"JitterTimer\"] = \"jitterTimer\";\n    RequestStrategy[\"SentinelMsg\"] = \"sentinelMsg\";\n})(RequestStrategy || (RequestStrategy = {}));\nfunction syncIterator(src) {\n    const iter = src[Symbol.asyncIterator]();\n    return {\n        async next () {\n            const m = await iter.next();\n            if (m.done) {\n                return Promise.resolve(null);\n            }\n            return Promise.resolve(m.value);\n        }\n    };\n}\nvar ServiceResponseType;\n(function(ServiceResponseType) {\n    ServiceResponseType[\"STATS\"] = \"io.nats.micro.v1.stats_response\";\n    ServiceResponseType[\"INFO\"] = \"io.nats.micro.v1.info_response\";\n    ServiceResponseType[\"PING\"] = \"io.nats.micro.v1.ping_response\";\n})(ServiceResponseType || (ServiceResponseType = {}));\nconst ServiceErrorHeader = \"Nats-Service-Error\";\nconst ServiceErrorCodeHeader = \"Nats-Service-Error-Code\";\nclass ServiceError extends Error {\n    code;\n    constructor(code, message){\n        super(message);\n        this.code = code;\n    }\n    static isServiceError(msg) {\n        return ServiceError.toServiceError(msg) !== null;\n    }\n    static toServiceError(msg) {\n        const scode = msg?.headers?.get(ServiceErrorCodeHeader) || \"\";\n        if (scode !== \"\") {\n            const code = parseInt(scode) || 400;\n            const description = msg?.headers?.get(ServiceErrorHeader) || \"\";\n            return new ServiceError(code, description.length ? description : scode);\n        }\n        return null;\n    }\n}\nfunction createInbox(prefix = \"\") {\n    prefix = prefix || \"_INBOX\";\n    if (typeof prefix !== \"string\") {\n        throw new Error(\"prefix must be a string\");\n    }\n    prefix.split(\".\").forEach((v)=>{\n        if (v === \"*\" || v === \">\") {\n            throw new Error(`inbox prefixes cannot have wildcards '${prefix}'`);\n        }\n    });\n    return `${prefix}.${nuid.next()}`;\n}\nconst DEFAULT_HOST = \"127.0.0.1\";\nvar ServiceVerb;\n(function(ServiceVerb) {\n    ServiceVerb[\"PING\"] = \"PING\";\n    ServiceVerb[\"STATS\"] = \"STATS\";\n    ServiceVerb[\"INFO\"] = \"INFO\";\n})(ServiceVerb || (ServiceVerb = {}));\nfunction extend(a, ...b) {\n    for(let i = 0; i < b.length; i++){\n        const o = b[i];\n        Object.keys(o).forEach(function(k) {\n            a[k] = o[k];\n        });\n    }\n    return a;\n}\nfunction render(frame) {\n    const cr = \"␍\";\n    const lf = \"␊\";\n    return TD.decode(frame).replace(/\\n/g, lf).replace(/\\r/g, cr);\n}\nfunction timeout(ms, asyncTraces = true) {\n    const err = asyncTraces ? NatsError.errorForCode(ErrorCode.Timeout) : null;\n    let methods;\n    let timer;\n    const p = new Promise((_resolve, reject)=>{\n        const cancel = ()=>{\n            if (timer) {\n                clearTimeout(timer);\n            }\n        };\n        methods = {\n            cancel\n        };\n        timer = setTimeout(()=>{\n            if (err === null) {\n                reject(NatsError.errorForCode(ErrorCode.Timeout));\n            } else {\n                reject(err);\n            }\n        }, ms);\n    });\n    return Object.assign(p, methods);\n}\nfunction delay(ms = 0) {\n    let methods;\n    const p = new Promise((resolve)=>{\n        const timer = setTimeout(()=>{\n            resolve();\n        }, ms);\n        const cancel = ()=>{\n            if (timer) {\n                clearTimeout(timer);\n            }\n        };\n        methods = {\n            cancel\n        };\n    });\n    return Object.assign(p, methods);\n}\nfunction deadline(p, millis = 1000) {\n    const err = new Error(`deadline exceeded`);\n    const d = deferred();\n    const timer = setTimeout(()=>d.reject(err), millis);\n    return Promise.race([\n        p,\n        d\n    ]).finally(()=>clearTimeout(timer));\n}\nfunction deferred() {\n    let methods = {};\n    const p = new Promise((resolve, reject)=>{\n        methods = {\n            resolve,\n            reject\n        };\n    });\n    return Object.assign(p, methods);\n}\nfunction shuffle(a) {\n    for(let i = a.length - 1; i > 0; i--){\n        const j = Math.floor(Math.random() * (i + 1));\n        [a[i], a[j]] = [\n            a[j],\n            a[i]\n        ];\n    }\n    return a;\n}\nclass Perf {\n    timers;\n    measures;\n    constructor(){\n        this.timers = new Map();\n        this.measures = new Map();\n    }\n    mark(key) {\n        this.timers.set(key, performance.now());\n    }\n    measure(key, startKey, endKey) {\n        const s = this.timers.get(startKey);\n        if (s === undefined) {\n            throw new Error(`${startKey} is not defined`);\n        }\n        const e = this.timers.get(endKey);\n        if (e === undefined) {\n            throw new Error(`${endKey} is not defined`);\n        }\n        this.measures.set(key, e - s);\n    }\n    getEntries() {\n        const values = [];\n        this.measures.forEach((v, k)=>{\n            values.push({\n                name: k,\n                duration: v\n            });\n        });\n        return values;\n    }\n}\nfunction jitter(n) {\n    if (n === 0) {\n        return 0;\n    }\n    return Math.floor(n / 2 + Math.random() * n);\n}\nfunction backoff(policy = [\n    0,\n    250,\n    250,\n    500,\n    500,\n    3000,\n    5000\n]) {\n    if (!Array.isArray(policy)) {\n        policy = [\n            0,\n            250,\n            250,\n            500,\n            500,\n            3000,\n            5000\n        ];\n    }\n    const max = policy.length - 1;\n    return {\n        backoff (attempt) {\n            return jitter(attempt > max ? policy[max] : policy[attempt]);\n        }\n    };\n}\nfunction nanos(millis) {\n    return millis * 1000000;\n}\nfunction millis(ns) {\n    return Math.floor(ns / 1000000);\n}\nfunction canonicalMIMEHeaderKey(k) {\n    const dash = 45;\n    const toLower = 97 - 65;\n    let upper = true;\n    const buf = new Array(k.length);\n    for(let i = 0; i < k.length; i++){\n        let c = k.charCodeAt(i);\n        if (c === 58 || c < 33 || c > 126) {\n            throw new NatsError(`'${k[i]}' is not a valid character for a header key`, ErrorCode.BadHeader);\n        }\n        if (upper && 97 <= c && c <= 122) {\n            c -= toLower;\n        } else if (!upper && 65 <= c && c <= 90) {\n            c += toLower;\n        }\n        buf[i] = c;\n        upper = c == dash;\n    }\n    return String.fromCharCode(...buf);\n}\nfunction headers(code = 0, description = \"\") {\n    if (code === 0 && description !== \"\" || code > 0 && description === \"\") {\n        throw new Error(\"setting status requires both code and description\");\n    }\n    return new MsgHdrsImpl(code, description);\n}\nconst HEADER = \"NATS/1.0\";\nclass MsgHdrsImpl {\n    _code;\n    headers;\n    _description;\n    constructor(code = 0, description = \"\"){\n        this._code = code;\n        this._description = description;\n        this.headers = new Map();\n    }\n    [Symbol.iterator]() {\n        return this.headers.entries();\n    }\n    size() {\n        return this.headers.size;\n    }\n    equals(mh) {\n        if (mh && this.headers.size === mh.headers.size && this._code === mh._code) {\n            for (const [k, v] of this.headers){\n                const a = mh.values(k);\n                if (v.length !== a.length) {\n                    return false;\n                }\n                const vv = [\n                    ...v\n                ].sort();\n                const aa = [\n                    ...a\n                ].sort();\n                for(let i = 0; i < vv.length; i++){\n                    if (vv[i] !== aa[i]) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    static decode(a) {\n        const mh = new MsgHdrsImpl();\n        const s = TD.decode(a);\n        const lines = s.split(\"\\r\\n\");\n        const h = lines[0];\n        if (h !== HEADER) {\n            let str = h.replace(HEADER, \"\").trim();\n            if (str.length > 0) {\n                mh._code = parseInt(str, 10);\n                if (isNaN(mh._code)) {\n                    mh._code = 0;\n                }\n                const scode = mh._code.toString();\n                str = str.replace(scode, \"\");\n                mh._description = str.trim();\n            }\n        }\n        if (lines.length >= 1) {\n            lines.slice(1).map((s)=>{\n                if (s) {\n                    const idx = s.indexOf(\":\");\n                    if (idx > -1) {\n                        const k = s.slice(0, idx);\n                        const v = s.slice(idx + 1).trim();\n                        mh.append(k, v);\n                    }\n                }\n            });\n        }\n        return mh;\n    }\n    toString() {\n        if (this.headers.size === 0 && this._code === 0) {\n            return \"\";\n        }\n        let s = HEADER;\n        if (this._code > 0 && this._description !== \"\") {\n            s += ` ${this._code} ${this._description}`;\n        }\n        for (const [k, v] of this.headers){\n            for(let i = 0; i < v.length; i++){\n                s = `${s}\\r\\n${k}: ${v[i]}`;\n            }\n        }\n        return `${s}\\r\\n\\r\\n`;\n    }\n    encode() {\n        return TE.encode(this.toString());\n    }\n    static validHeaderValue(k) {\n        const inv = /[\\r\\n]/;\n        if (inv.test(k)) {\n            throw new NatsError(\"invalid header value - \\\\r and \\\\n are not allowed.\", ErrorCode.BadHeader);\n        }\n        return k.trim();\n    }\n    keys() {\n        const keys = [];\n        for (const sk of this.headers.keys()){\n            keys.push(sk);\n        }\n        return keys;\n    }\n    findKeys(k, match = Match.Exact) {\n        const keys = this.keys();\n        switch(match){\n            case Match.Exact:\n                return keys.filter((v)=>{\n                    return v === k;\n                });\n            case Match.CanonicalMIME:\n                k = canonicalMIMEHeaderKey(k);\n                return keys.filter((v)=>{\n                    return v === k;\n                });\n            default:\n                {\n                    const lci = k.toLowerCase();\n                    return keys.filter((v)=>{\n                        return lci === v.toLowerCase();\n                    });\n                }\n        }\n    }\n    get(k, match = Match.Exact) {\n        const keys = this.findKeys(k, match);\n        if (keys.length) {\n            const v = this.headers.get(keys[0]);\n            if (v) {\n                return Array.isArray(v) ? v[0] : v;\n            }\n        }\n        return \"\";\n    }\n    last(k, match = Match.Exact) {\n        const keys = this.findKeys(k, match);\n        if (keys.length) {\n            const v = this.headers.get(keys[0]);\n            if (v) {\n                return Array.isArray(v) ? v[v.length - 1] : v;\n            }\n        }\n        return \"\";\n    }\n    has(k, match = Match.Exact) {\n        return this.findKeys(k, match).length > 0;\n    }\n    set(k, v, match = Match.Exact) {\n        this.delete(k, match);\n        this.append(k, v, match);\n    }\n    append(k, v, match = Match.Exact) {\n        const ck = canonicalMIMEHeaderKey(k);\n        if (match === Match.CanonicalMIME) {\n            k = ck;\n        }\n        const keys = this.findKeys(k, match);\n        k = keys.length > 0 ? keys[0] : k;\n        const value = MsgHdrsImpl.validHeaderValue(v);\n        let a = this.headers.get(k);\n        if (!a) {\n            a = [];\n            this.headers.set(k, a);\n        }\n        a.push(value);\n    }\n    values(k, match = Match.Exact) {\n        const buf = [];\n        const keys = this.findKeys(k, match);\n        keys.forEach((v)=>{\n            const values = this.headers.get(v);\n            if (values) {\n                buf.push(...values);\n            }\n        });\n        return buf;\n    }\n    delete(k, match = Match.Exact) {\n        const keys = this.findKeys(k, match);\n        keys.forEach((v)=>{\n            this.headers.delete(v);\n        });\n    }\n    get hasError() {\n        return this._code >= 300;\n    }\n    get status() {\n        return `${this._code} ${this._description}`.trim();\n    }\n    toRecord() {\n        const data = {};\n        this.keys().forEach((v)=>{\n            data[v] = this.values(v);\n        });\n        return data;\n    }\n    get code() {\n        return this._code;\n    }\n    get description() {\n        return this._description;\n    }\n    static fromRecord(r) {\n        const h = new MsgHdrsImpl();\n        for(const k in r){\n            h.headers.set(k, r[k]);\n        }\n        return h;\n    }\n}\nfunction StringCodec() {\n    return {\n        encode (d) {\n            return TE.encode(d);\n        },\n        decode (a) {\n            return TD.decode(a);\n        }\n    };\n}\nfunction JSONCodec(reviver) {\n    return {\n        encode (d) {\n            try {\n                if (d === undefined) {\n                    d = null;\n                }\n                return TE.encode(JSON.stringify(d));\n            } catch (err) {\n                throw NatsError.errorForCode(ErrorCode.BadJson, err);\n            }\n        },\n        decode (a) {\n            try {\n                return JSON.parse(TD.decode(a), reviver);\n            } catch (err) {\n                throw NatsError.errorForCode(ErrorCode.BadJson, err);\n            }\n        }\n    };\n}\nfunction isRequestError(msg) {\n    if (msg && msg.data.length === 0 && msg.headers?.code === 503) {\n        return NatsError.errorForCode(ErrorCode.NoResponders);\n    }\n    return null;\n}\nclass MsgImpl {\n    _headers;\n    _msg;\n    _rdata;\n    _reply;\n    _subject;\n    publisher;\n    static jc;\n    constructor(msg, data, publisher){\n        this._msg = msg;\n        this._rdata = data;\n        this.publisher = publisher;\n    }\n    get subject() {\n        if (this._subject) {\n            return this._subject;\n        }\n        this._subject = TD.decode(this._msg.subject);\n        return this._subject;\n    }\n    get reply() {\n        if (this._reply) {\n            return this._reply;\n        }\n        this._reply = TD.decode(this._msg.reply);\n        return this._reply;\n    }\n    get sid() {\n        return this._msg.sid;\n    }\n    get headers() {\n        if (this._msg.hdr > -1 && !this._headers) {\n            const buf = this._rdata.subarray(0, this._msg.hdr);\n            this._headers = MsgHdrsImpl.decode(buf);\n        }\n        return this._headers;\n    }\n    get data() {\n        if (!this._rdata) {\n            return new Uint8Array(0);\n        }\n        return this._msg.hdr > -1 ? this._rdata.subarray(this._msg.hdr) : this._rdata;\n    }\n    respond(data = Empty, opts) {\n        if (this.reply) {\n            this.publisher.publish(this.reply, data, opts);\n            return true;\n        }\n        return false;\n    }\n    size() {\n        const subj = this._msg.subject.length;\n        const reply = this._msg.reply?.length || 0;\n        const payloadAndHeaders = this._msg.size === -1 ? 0 : this._msg.size;\n        return subj + reply + payloadAndHeaders;\n    }\n    json(reviver) {\n        return JSONCodec(reviver).decode(this.data);\n    }\n    string() {\n        return TD.decode(this.data);\n    }\n    requestInfo() {\n        const v = this.headers?.get(\"Nats-Request-Info\");\n        if (v) {\n            return JSON.parse(v, function(key, value) {\n                if ((key === \"start\" || key === \"stop\") && value !== \"\") {\n                    return new Date(Date.parse(value));\n                }\n                return value;\n            });\n        }\n        return null;\n    }\n}\nfunction validateDurableName(name) {\n    return minValidation(\"durable\", name);\n}\nfunction validateStreamName(name) {\n    return minValidation(\"stream\", name);\n}\nfunction minValidation(context, name = \"\") {\n    if (name === \"\") {\n        throw Error(`${context} name required`);\n    }\n    const bad = [\n        \".\",\n        \"*\",\n        \">\",\n        \"/\",\n        \"\\\\\",\n        \" \",\n        \"\\t\",\n        \"\\n\",\n        \"\\r\"\n    ];\n    bad.forEach((v)=>{\n        if (name.indexOf(v) !== -1) {\n            switch(v){\n                case \"\\n\":\n                    v = \"\\\\n\";\n                    break;\n                case \"\\r\":\n                    v = \"\\\\r\";\n                    break;\n                case \"\\t\":\n                    v = \"\\\\t\";\n                    break;\n                default:\n            }\n            throw Error(`invalid ${context} name - ${context} name cannot contain '${v}'`);\n        }\n    });\n    return \"\";\n}\nfunction validateName(context, name = \"\") {\n    if (name === \"\") {\n        throw Error(`${context} name required`);\n    }\n    const m = validName(name);\n    if (m.length) {\n        throw new Error(`invalid ${context} name - ${context} name ${m}`);\n    }\n}\nfunction validName(name = \"\") {\n    if (name === \"\") {\n        throw Error(`name required`);\n    }\n    const RE = /^[-\\w]+$/g;\n    const m = name.match(RE);\n    if (m === null) {\n        for (const c of name.split(\"\")){\n            const mm = c.match(RE);\n            if (mm === null) {\n                return `cannot contain '${c}'`;\n            }\n        }\n    }\n    return \"\";\n}\nfunction isFlowControlMsg(msg) {\n    if (msg.data.length > 0) {\n        return false;\n    }\n    const h = msg.headers;\n    if (!h) {\n        return false;\n    }\n    return h.code >= 100 && h.code < 200;\n}\nfunction isHeartbeatMsg(msg) {\n    return isFlowControlMsg(msg) && msg.headers?.description === \"Idle Heartbeat\";\n}\nfunction newJsErrorMsg(code, description, subject) {\n    const h = headers(code, description);\n    const arg = {\n        hdr: 1,\n        sid: 0,\n        size: 0\n    };\n    const msg = new MsgImpl(arg, Empty, {});\n    msg._headers = h;\n    msg._subject = subject;\n    return msg;\n}\nfunction checkJsError(msg) {\n    if (msg.data.length !== 0) {\n        return null;\n    }\n    const h = msg.headers;\n    if (!h) {\n        return null;\n    }\n    return checkJsErrorCode(h.code, h.description);\n}\nvar Js409Errors;\n(function(Js409Errors) {\n    Js409Errors[\"MaxBatchExceeded\"] = \"exceeded maxrequestbatch of\";\n    Js409Errors[\"MaxExpiresExceeded\"] = \"exceeded maxrequestexpires of\";\n    Js409Errors[\"MaxBytesExceeded\"] = \"exceeded maxrequestmaxbytes of\";\n    Js409Errors[\"MaxMessageSizeExceeded\"] = \"message size exceeds maxbytes\";\n    Js409Errors[\"PushConsumer\"] = \"consumer is push based\";\n    Js409Errors[\"MaxWaitingExceeded\"] = \"exceeded maxwaiting\";\n    Js409Errors[\"IdleHeartbeatMissed\"] = \"idle heartbeats missed\";\n    Js409Errors[\"ConsumerDeleted\"] = \"consumer deleted\";\n})(Js409Errors || (Js409Errors = {}));\nlet MAX_WAITING_FAIL = false;\nfunction isTerminal409(err) {\n    if (err.code !== ErrorCode.JetStream409) {\n        return false;\n    }\n    const fatal = [\n        Js409Errors.MaxBatchExceeded,\n        Js409Errors.MaxExpiresExceeded,\n        Js409Errors.MaxBytesExceeded,\n        Js409Errors.MaxMessageSizeExceeded,\n        Js409Errors.PushConsumer,\n        Js409Errors.IdleHeartbeatMissed,\n        Js409Errors.ConsumerDeleted\n    ];\n    if (MAX_WAITING_FAIL) {\n        fatal.push(Js409Errors.MaxWaitingExceeded);\n    }\n    return fatal.find((s)=>{\n        return err.message.indexOf(s) !== -1;\n    }) !== undefined;\n}\nfunction checkJsErrorCode(code, description = \"\") {\n    if (code < 300) {\n        return null;\n    }\n    description = description.toLowerCase();\n    switch(code){\n        case 404:\n            return new NatsError(description, ErrorCode.JetStream404NoMessages);\n        case 408:\n            return new NatsError(description, ErrorCode.JetStream408RequestTimeout);\n        case 409:\n            {\n                const ec = description.startsWith(Js409Errors.IdleHeartbeatMissed) ? ErrorCode.JetStreamIdleHeartBeat : ErrorCode.JetStream409;\n                return new NatsError(description, ec);\n            }\n        case 503:\n            return NatsError.errorForCode(ErrorCode.JetStreamNotEnabled, new Error(description));\n        default:\n            if (description === \"\") {\n                description = ErrorCode.Unknown;\n            }\n            return new NatsError(description, `${code}`);\n    }\n}\nclass QueuedIteratorImpl {\n    inflight;\n    processed;\n    received;\n    noIterator;\n    iterClosed;\n    done;\n    signal;\n    yields;\n    filtered;\n    pendingFiltered;\n    ingestionFilterFn;\n    protocolFilterFn;\n    dispatchedFn;\n    ctx;\n    _data;\n    err;\n    time;\n    yielding;\n    constructor(){\n        this.inflight = 0;\n        this.filtered = 0;\n        this.pendingFiltered = 0;\n        this.processed = 0;\n        this.received = 0;\n        this.noIterator = false;\n        this.done = false;\n        this.signal = deferred();\n        this.yields = [];\n        this.iterClosed = deferred();\n        this.time = 0;\n        this.yielding = false;\n    }\n    [Symbol.asyncIterator]() {\n        return this.iterate();\n    }\n    push(v) {\n        if (this.done) {\n            return;\n        }\n        if (typeof v === \"function\") {\n            this.yields.push(v);\n            this.signal.resolve();\n            return;\n        }\n        const { ingest, protocol } = this.ingestionFilterFn ? this.ingestionFilterFn(v, this.ctx || this) : {\n            ingest: true,\n            protocol: false\n        };\n        if (ingest) {\n            if (protocol) {\n                this.filtered++;\n                this.pendingFiltered++;\n            }\n            this.yields.push(v);\n            this.signal.resolve();\n        }\n    }\n    async *iterate() {\n        if (this.noIterator) {\n            throw new NatsError(\"unsupported iterator\", ErrorCode.ApiError);\n        }\n        if (this.yielding) {\n            throw new NatsError(\"already yielding\", ErrorCode.ApiError);\n        }\n        this.yielding = true;\n        try {\n            while(true){\n                if (this.yields.length === 0) {\n                    await this.signal;\n                }\n                if (this.err) {\n                    throw this.err;\n                }\n                const yields = this.yields;\n                this.inflight = yields.length;\n                this.yields = [];\n                for(let i = 0; i < yields.length; i++){\n                    if (typeof yields[i] === \"function\") {\n                        const fn = yields[i];\n                        try {\n                            fn();\n                        } catch (err) {\n                            throw err;\n                        }\n                        if (this.err) {\n                            throw this.err;\n                        }\n                        continue;\n                    }\n                    const ok = this.protocolFilterFn ? this.protocolFilterFn(yields[i]) : true;\n                    if (ok) {\n                        this.processed++;\n                        const start = Date.now();\n                        yield yields[i];\n                        this.time = Date.now() - start;\n                        if (this.dispatchedFn && yields[i]) {\n                            this.dispatchedFn(yields[i]);\n                        }\n                    } else {\n                        this.pendingFiltered--;\n                    }\n                    this.inflight--;\n                }\n                if (this.done) {\n                    break;\n                } else if (this.yields.length === 0) {\n                    yields.length = 0;\n                    this.yields = yields;\n                    this.signal = deferred();\n                }\n            }\n        } finally{\n            this.stop();\n        }\n    }\n    stop(err) {\n        if (this.done) {\n            return;\n        }\n        this.err = err;\n        this.done = true;\n        this.signal.resolve();\n        this.iterClosed.resolve(err);\n    }\n    getProcessed() {\n        return this.noIterator ? this.received : this.processed;\n    }\n    getPending() {\n        return this.yields.length + this.inflight - this.pendingFiltered;\n    }\n    getReceived() {\n        return this.received - this.filtered;\n    }\n}\nclass IdleHeartbeatMonitor {\n    interval;\n    maxOut;\n    cancelAfter;\n    timer;\n    autoCancelTimer;\n    last;\n    missed;\n    count;\n    callback;\n    constructor(interval, cb, opts = {\n        maxOut: 2\n    }){\n        this.interval = interval;\n        this.maxOut = opts?.maxOut || 2;\n        this.cancelAfter = opts?.cancelAfter || 0;\n        this.last = Date.now();\n        this.missed = 0;\n        this.count = 0;\n        this.callback = cb;\n        this._schedule();\n    }\n    cancel() {\n        if (this.autoCancelTimer) {\n            clearTimeout(this.autoCancelTimer);\n        }\n        if (this.timer) {\n            clearInterval(this.timer);\n        }\n        this.timer = 0;\n        this.autoCancelTimer = 0;\n        this.missed = 0;\n    }\n    work() {\n        this.last = Date.now();\n        this.missed = 0;\n    }\n    _change(interval, cancelAfter = 0, maxOut = 2) {\n        this.interval = interval;\n        this.maxOut = maxOut;\n        this.cancelAfter = cancelAfter;\n        this.restart();\n    }\n    restart() {\n        this.cancel();\n        this._schedule();\n    }\n    _schedule() {\n        if (this.cancelAfter > 0) {\n            this.autoCancelTimer = setTimeout(()=>{\n                this.cancel();\n            }, this.cancelAfter);\n        }\n        this.timer = setInterval(()=>{\n            this.count++;\n            if (Date.now() - this.last > this.interval) {\n                this.missed++;\n            }\n            if (this.missed >= this.maxOut) {\n                try {\n                    if (this.callback(this.missed) === true) {\n                        this.cancel();\n                    }\n                } catch (err) {\n                    console.log(err);\n                }\n            }\n        }, this.interval);\n    }\n}\nvar RetentionPolicy;\n(function(RetentionPolicy) {\n    RetentionPolicy[\"Limits\"] = \"limits\";\n    RetentionPolicy[\"Interest\"] = \"interest\";\n    RetentionPolicy[\"Workqueue\"] = \"workqueue\";\n})(RetentionPolicy || (RetentionPolicy = {}));\nvar DiscardPolicy;\n(function(DiscardPolicy) {\n    DiscardPolicy[\"Old\"] = \"old\";\n    DiscardPolicy[\"New\"] = \"new\";\n})(DiscardPolicy || (DiscardPolicy = {}));\nvar StorageType;\n(function(StorageType) {\n    StorageType[\"File\"] = \"file\";\n    StorageType[\"Memory\"] = \"memory\";\n})(StorageType || (StorageType = {}));\nvar DeliverPolicy;\n(function(DeliverPolicy) {\n    DeliverPolicy[\"All\"] = \"all\";\n    DeliverPolicy[\"Last\"] = \"last\";\n    DeliverPolicy[\"New\"] = \"new\";\n    DeliverPolicy[\"StartSequence\"] = \"by_start_sequence\";\n    DeliverPolicy[\"StartTime\"] = \"by_start_time\";\n    DeliverPolicy[\"LastPerSubject\"] = \"last_per_subject\";\n})(DeliverPolicy || (DeliverPolicy = {}));\nvar AckPolicy;\n(function(AckPolicy) {\n    AckPolicy[\"None\"] = \"none\";\n    AckPolicy[\"All\"] = \"all\";\n    AckPolicy[\"Explicit\"] = \"explicit\";\n    AckPolicy[\"NotSet\"] = \"\";\n})(AckPolicy || (AckPolicy = {}));\nvar ReplayPolicy;\n(function(ReplayPolicy) {\n    ReplayPolicy[\"Instant\"] = \"instant\";\n    ReplayPolicy[\"Original\"] = \"original\";\n})(ReplayPolicy || (ReplayPolicy = {}));\nvar StoreCompression;\n(function(StoreCompression) {\n    StoreCompression[\"None\"] = \"none\";\n    StoreCompression[\"S2\"] = \"s2\";\n})(StoreCompression || (StoreCompression = {}));\nvar ConsumerApiAction;\n(function(ConsumerApiAction) {\n    ConsumerApiAction[\"CreateOrUpdate\"] = \"\";\n    ConsumerApiAction[\"Update\"] = \"update\";\n    ConsumerApiAction[\"Create\"] = \"create\";\n})(ConsumerApiAction || (ConsumerApiAction = {}));\nfunction defaultConsumer(name, opts = {}) {\n    return Object.assign({\n        name: name,\n        deliver_policy: DeliverPolicy.All,\n        ack_policy: AckPolicy.Explicit,\n        ack_wait: nanos(30 * 1000),\n        replay_policy: ReplayPolicy.Instant\n    }, opts);\n}\nvar AdvisoryKind;\n(function(AdvisoryKind) {\n    AdvisoryKind[\"API\"] = \"api_audit\";\n    AdvisoryKind[\"StreamAction\"] = \"stream_action\";\n    AdvisoryKind[\"ConsumerAction\"] = \"consumer_action\";\n    AdvisoryKind[\"SnapshotCreate\"] = \"snapshot_create\";\n    AdvisoryKind[\"SnapshotComplete\"] = \"snapshot_complete\";\n    AdvisoryKind[\"RestoreCreate\"] = \"restore_create\";\n    AdvisoryKind[\"RestoreComplete\"] = \"restore_complete\";\n    AdvisoryKind[\"MaxDeliver\"] = \"max_deliver\";\n    AdvisoryKind[\"Terminated\"] = \"terminated\";\n    AdvisoryKind[\"Ack\"] = \"consumer_ack\";\n    AdvisoryKind[\"StreamLeaderElected\"] = \"stream_leader_elected\";\n    AdvisoryKind[\"StreamQuorumLost\"] = \"stream_quorum_lost\";\n    AdvisoryKind[\"ConsumerLeaderElected\"] = \"consumer_leader_elected\";\n    AdvisoryKind[\"ConsumerQuorumLost\"] = \"consumer_quorum_lost\";\n})(AdvisoryKind || (AdvisoryKind = {}));\nvar JsHeaders;\n(function(JsHeaders) {\n    JsHeaders[\"StreamSourceHdr\"] = \"Nats-Stream-Source\";\n    JsHeaders[\"LastConsumerSeqHdr\"] = \"Nats-Last-Consumer\";\n    JsHeaders[\"LastStreamSeqHdr\"] = \"Nats-Last-Stream\";\n    JsHeaders[\"ConsumerStalledHdr\"] = \"Nats-Consumer-Stalled\";\n    JsHeaders[\"MessageSizeHdr\"] = \"Nats-Msg-Size\";\n    JsHeaders[\"RollupHdr\"] = \"Nats-Rollup\";\n    JsHeaders[\"RollupValueSubject\"] = \"sub\";\n    JsHeaders[\"RollupValueAll\"] = \"all\";\n    JsHeaders[\"PendingMessagesHdr\"] = \"Nats-Pending-Messages\";\n    JsHeaders[\"PendingBytesHdr\"] = \"Nats-Pending-Bytes\";\n})(JsHeaders || (JsHeaders = {}));\nvar KvWatchInclude;\n(function(KvWatchInclude) {\n    KvWatchInclude[\"LastValue\"] = \"\";\n    KvWatchInclude[\"AllHistory\"] = \"history\";\n    KvWatchInclude[\"UpdatesOnly\"] = \"updates\";\n})(KvWatchInclude || (KvWatchInclude = {}));\nvar DirectMsgHeaders;\n(function(DirectMsgHeaders) {\n    DirectMsgHeaders[\"Stream\"] = \"Nats-Stream\";\n    DirectMsgHeaders[\"Sequence\"] = \"Nats-Sequence\";\n    DirectMsgHeaders[\"TimeStamp\"] = \"Nats-Time-Stamp\";\n    DirectMsgHeaders[\"Subject\"] = \"Nats-Subject\";\n})(DirectMsgHeaders || (DirectMsgHeaders = {}));\nvar RepublishHeaders;\n(function(RepublishHeaders) {\n    RepublishHeaders[\"Stream\"] = \"Nats-Stream\";\n    RepublishHeaders[\"Subject\"] = \"Nats-Subject\";\n    RepublishHeaders[\"Sequence\"] = \"Nats-Sequence\";\n    RepublishHeaders[\"LastSequence\"] = \"Nats-Last-Sequence\";\n    RepublishHeaders[\"Size\"] = \"Nats-Msg-Size\";\n})(RepublishHeaders || (RepublishHeaders = {}));\nconst kvPrefix = \"KV_\";\nclass ConsumerOptsBuilderImpl {\n    config;\n    ordered;\n    mack;\n    stream;\n    callbackFn;\n    max;\n    qname;\n    isBind;\n    filters;\n    constructor(opts){\n        this.stream = \"\";\n        this.mack = false;\n        this.ordered = false;\n        this.config = defaultConsumer(\"\", opts || {});\n    }\n    getOpts() {\n        const o = {};\n        o.config = Object.assign({}, this.config);\n        if (o.config.filter_subject) {\n            this.filterSubject(o.config.filter_subject);\n            o.config.filter_subject = undefined;\n        }\n        if (o.config.filter_subjects) {\n            o.config.filter_subjects?.forEach((v)=>{\n                this.filterSubject(v);\n            });\n            o.config.filter_subjects = undefined;\n        }\n        o.mack = this.mack;\n        o.stream = this.stream;\n        o.callbackFn = this.callbackFn;\n        o.max = this.max;\n        o.queue = this.qname;\n        o.ordered = this.ordered;\n        o.config.ack_policy = o.ordered ? AckPolicy.None : o.config.ack_policy;\n        o.isBind = o.isBind || false;\n        if (this.filters) {\n            switch(this.filters.length){\n                case 0:\n                    break;\n                case 1:\n                    o.config.filter_subject = this.filters[0];\n                    break;\n                default:\n                    o.config.filter_subjects = this.filters;\n            }\n        }\n        return o;\n    }\n    description(description) {\n        this.config.description = description;\n        return this;\n    }\n    deliverTo(subject) {\n        this.config.deliver_subject = subject;\n        return this;\n    }\n    durable(name) {\n        validateDurableName(name);\n        this.config.durable_name = name;\n        return this;\n    }\n    startSequence(seq) {\n        if (seq <= 0) {\n            throw new Error(\"sequence must be greater than 0\");\n        }\n        this.config.deliver_policy = DeliverPolicy.StartSequence;\n        this.config.opt_start_seq = seq;\n        return this;\n    }\n    startTime(time) {\n        this.config.deliver_policy = DeliverPolicy.StartTime;\n        this.config.opt_start_time = time.toISOString();\n        return this;\n    }\n    deliverAll() {\n        this.config.deliver_policy = DeliverPolicy.All;\n        return this;\n    }\n    deliverLastPerSubject() {\n        this.config.deliver_policy = DeliverPolicy.LastPerSubject;\n        return this;\n    }\n    deliverLast() {\n        this.config.deliver_policy = DeliverPolicy.Last;\n        return this;\n    }\n    deliverNew() {\n        this.config.deliver_policy = DeliverPolicy.New;\n        return this;\n    }\n    startAtTimeDelta(millis) {\n        this.startTime(new Date(Date.now() - millis));\n        return this;\n    }\n    headersOnly() {\n        this.config.headers_only = true;\n        return this;\n    }\n    ackNone() {\n        this.config.ack_policy = AckPolicy.None;\n        return this;\n    }\n    ackAll() {\n        this.config.ack_policy = AckPolicy.All;\n        return this;\n    }\n    ackExplicit() {\n        this.config.ack_policy = AckPolicy.Explicit;\n        return this;\n    }\n    ackWait(millis) {\n        this.config.ack_wait = nanos(millis);\n        return this;\n    }\n    maxDeliver(max) {\n        this.config.max_deliver = max;\n        return this;\n    }\n    filterSubject(s) {\n        this.filters = this.filters || [];\n        this.filters.push(s);\n        return this;\n    }\n    replayInstantly() {\n        this.config.replay_policy = ReplayPolicy.Instant;\n        return this;\n    }\n    replayOriginal() {\n        this.config.replay_policy = ReplayPolicy.Original;\n        return this;\n    }\n    sample(n) {\n        n = Math.trunc(n);\n        if (n < 0 || n > 100) {\n            throw new Error(`value must be between 0-100`);\n        }\n        this.config.sample_freq = `${n}%`;\n        return this;\n    }\n    limit(n) {\n        this.config.rate_limit_bps = n;\n        return this;\n    }\n    maxWaiting(max) {\n        this.config.max_waiting = max;\n        return this;\n    }\n    maxAckPending(max) {\n        this.config.max_ack_pending = max;\n        return this;\n    }\n    idleHeartbeat(millis) {\n        this.config.idle_heartbeat = nanos(millis);\n        return this;\n    }\n    flowControl() {\n        this.config.flow_control = true;\n        return this;\n    }\n    deliverGroup(name) {\n        this.queue(name);\n        return this;\n    }\n    manualAck() {\n        this.mack = true;\n        return this;\n    }\n    maxMessages(max) {\n        this.max = max;\n        return this;\n    }\n    callback(fn) {\n        this.callbackFn = fn;\n        return this;\n    }\n    queue(n) {\n        this.qname = n;\n        this.config.deliver_group = n;\n        return this;\n    }\n    orderedConsumer() {\n        this.ordered = true;\n        return this;\n    }\n    bind(stream, durable) {\n        this.stream = stream;\n        this.config.durable_name = durable;\n        this.isBind = true;\n        return this;\n    }\n    bindStream(stream) {\n        this.stream = stream;\n        return this;\n    }\n    inactiveEphemeralThreshold(millis) {\n        this.config.inactive_threshold = nanos(millis);\n        return this;\n    }\n    maxPullBatch(n) {\n        this.config.max_batch = n;\n        return this;\n    }\n    maxPullRequestExpires(millis) {\n        this.config.max_expires = nanos(millis);\n        return this;\n    }\n    memory() {\n        this.config.mem_storage = true;\n        return this;\n    }\n    numReplicas(n) {\n        this.config.num_replicas = n;\n        return this;\n    }\n    consumerName(n) {\n        this.config.name = n;\n        return this;\n    }\n}\nfunction consumerOpts(opts) {\n    return new ConsumerOptsBuilderImpl(opts);\n}\nfunction isConsumerOptsBuilder(o) {\n    return typeof o.getOpts === \"function\";\n}\nclass Base64Codec {\n    static encode(bytes) {\n        if (typeof bytes === \"string\") {\n            return btoa(bytes);\n        }\n        const a = Array.from(bytes);\n        return btoa(String.fromCharCode(...a));\n    }\n    static decode(s, binary = false) {\n        const bin = atob(s);\n        if (!binary) {\n            return bin;\n        }\n        return Uint8Array.from(bin, (c)=>c.charCodeAt(0));\n    }\n}\nclass Base64UrlPaddedCodec {\n    static encode(bytes) {\n        return Base64UrlPaddedCodec.toB64URLEncoding(Base64Codec.encode(bytes));\n    }\n    static decode(s, binary = false) {\n        return Base64UrlPaddedCodec.decode(Base64UrlPaddedCodec.fromB64URLEncoding(s), binary);\n    }\n    static toB64URLEncoding(b64str) {\n        return b64str.replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n    }\n    static fromB64URLEncoding(b64str) {\n        return b64str.replace(/_/g, \"/\").replace(/-/g, \"+\");\n    }\n}\nclass DataBuffer {\n    buffers;\n    byteLength;\n    constructor(){\n        this.buffers = [];\n        this.byteLength = 0;\n    }\n    static concat(...bufs) {\n        let max = 0;\n        for(let i = 0; i < bufs.length; i++){\n            max += bufs[i].length;\n        }\n        const out = new Uint8Array(max);\n        let index = 0;\n        for(let i = 0; i < bufs.length; i++){\n            out.set(bufs[i], index);\n            index += bufs[i].length;\n        }\n        return out;\n    }\n    static fromAscii(m) {\n        if (!m) {\n            m = \"\";\n        }\n        return TE.encode(m);\n    }\n    static toAscii(a) {\n        return TD.decode(a);\n    }\n    reset() {\n        this.buffers.length = 0;\n        this.byteLength = 0;\n    }\n    pack() {\n        if (this.buffers.length > 1) {\n            const v = new Uint8Array(this.byteLength);\n            let index = 0;\n            for(let i = 0; i < this.buffers.length; i++){\n                v.set(this.buffers[i], index);\n                index += this.buffers[i].length;\n            }\n            this.buffers.length = 0;\n            this.buffers.push(v);\n        }\n    }\n    shift() {\n        if (this.buffers.length) {\n            const a = this.buffers.shift();\n            if (a) {\n                this.byteLength -= a.length;\n                return a;\n            }\n        }\n        return new Uint8Array(0);\n    }\n    drain(n) {\n        if (this.buffers.length) {\n            this.pack();\n            const v = this.buffers.pop();\n            if (v) {\n                const max = this.byteLength;\n                if (n === undefined || n > max) {\n                    n = max;\n                }\n                const d = v.subarray(0, n);\n                if (max > n) {\n                    this.buffers.push(v.subarray(n));\n                }\n                this.byteLength = max - n;\n                return d;\n            }\n        }\n        return new Uint8Array(0);\n    }\n    fill(a, ...bufs) {\n        if (a) {\n            this.buffers.push(a);\n            this.byteLength += a.length;\n        }\n        for(let i = 0; i < bufs.length; i++){\n            if (bufs[i] && bufs[i].length) {\n                this.buffers.push(bufs[i]);\n                this.byteLength += bufs[i].length;\n            }\n        }\n    }\n    peek() {\n        if (this.buffers.length) {\n            this.pack();\n            return this.buffers[0];\n        }\n        return new Uint8Array(0);\n    }\n    size() {\n        return this.byteLength;\n    }\n    length() {\n        return this.buffers.length;\n    }\n}\nfunction t(t, e) {\n    return e.forEach(function(e) {\n        e && \"string\" != typeof e && !Array.isArray(e) && Object.keys(e).forEach(function(r) {\n            if (\"default\" !== r && !(r in t)) {\n                var i = Object.getOwnPropertyDescriptor(e, r);\n                Object.defineProperty(t, r, i.get ? i : {\n                    enumerable: !0,\n                    get: function() {\n                        return e[r];\n                    }\n                });\n            }\n        });\n    }), Object.freeze(t);\n}\nvar e = \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : {};\nfunction r() {\n    throw new Error(\"setTimeout has not been defined\");\n}\nfunction i() {\n    throw new Error(\"clearTimeout has not been defined\");\n}\nvar h = r, s = i;\nfunction n(t) {\n    if (h === setTimeout) return setTimeout(t, 0);\n    if ((h === r || !h) && setTimeout) return h = setTimeout, setTimeout(t, 0);\n    try {\n        return h(t, 0);\n    } catch (e) {\n        try {\n            return h.call(null, t, 0);\n        } catch (e) {\n            return h.call(this, t, 0);\n        }\n    }\n}\n\"function\" == typeof e.setTimeout && (h = setTimeout), \"function\" == typeof e.clearTimeout && (s = clearTimeout);\nvar o, a = [], f = !1, u = -1;\nfunction c() {\n    f && o && (f = !1, o.length ? a = o.concat(a) : u = -1, a.length && l());\n}\nfunction l() {\n    if (!f) {\n        var t = n(c);\n        f = !0;\n        for(var e = a.length; e;){\n            for(o = a, a = []; ++u < e;)o && o[u].run();\n            u = -1, e = a.length;\n        }\n        o = null, f = !1, function(t) {\n            if (s === clearTimeout) return clearTimeout(t);\n            if ((s === i || !s) && clearTimeout) return s = clearTimeout, clearTimeout(t);\n            try {\n                return s(t);\n            } catch (e) {\n                try {\n                    return s.call(null, t);\n                } catch (e) {\n                    return s.call(this, t);\n                }\n            }\n        }(t);\n    }\n}\nfunction y(t, e) {\n    this.fun = t, this.array = e;\n}\ny.prototype.run = function() {\n    this.fun.apply(null, this.array);\n};\nfunction p() {}\nvar d = p, w = p, b = p, v = p, A = p, g = p, _ = p;\nvar m = e.performance || {}, O = m.now || m.mozNow || m.msNow || m.oNow || m.webkitNow || function() {\n    return (new Date).getTime();\n};\nvar B = new Date;\nvar E = {\n    nextTick: function(t) {\n        var e = new Array(arguments.length - 1);\n        if (arguments.length > 1) for(var r = 1; r < arguments.length; r++)e[r - 1] = arguments[r];\n        a.push(new y(t, e)), 1 !== a.length || f || n(l);\n    },\n    title: \"browser\",\n    browser: !0,\n    env: {},\n    argv: [],\n    version: \"\",\n    versions: {},\n    on: d,\n    addListener: w,\n    once: b,\n    off: v,\n    removeListener: A,\n    removeAllListeners: g,\n    emit: _,\n    binding: function(t) {\n        throw new Error(\"process.binding is not supported\");\n    },\n    cwd: function() {\n        return \"/\";\n    },\n    chdir: function(t) {\n        throw new Error(\"process.chdir is not supported\");\n    },\n    umask: function() {\n        return 0;\n    },\n    hrtime: function(t) {\n        var e = .001 * O.call(m), r = Math.floor(e), i = Math.floor(e % 1 * 1e9);\n        return t && (r -= t[0], (i -= t[1]) < 0 && (r--, i += 1e9)), [\n            r,\n            i\n        ];\n    },\n    platform: \"browser\",\n    release: {},\n    config: {},\n    uptime: function() {\n        return (new Date - B) / 1e3;\n    }\n}, S = \"undefined\" != typeof globalThis ? globalThis : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : {};\nfunction T(t) {\n    if (t.__esModule) return t;\n    var e = Object.defineProperty({}, \"__esModule\", {\n        value: !0\n    });\n    return Object.keys(t).forEach(function(r) {\n        var i = Object.getOwnPropertyDescriptor(t, r);\n        Object.defineProperty(e, r, i.get ? i : {\n            enumerable: !0,\n            get: function() {\n                return t[r];\n            }\n        });\n    }), e;\n}\nvar k, x = {\n    exports: {}\n}, j = {}, N = T(t({\n    __proto__: null,\n    default: j\n}, [\n    j\n]));\nk = x, function() {\n    var t = \"input is invalid type\", e = \"object\" == typeof window, r = e ? window : {};\n    r.JS_SHA256_NO_WINDOW && (e = !1);\n    var i = !e && \"object\" == typeof self, h = !r.JS_SHA256_NO_NODE_JS && E.versions && E.versions.node;\n    h ? r = S : i && (r = self);\n    var s = !r.JS_SHA256_NO_COMMON_JS && k.exports, n = !r.JS_SHA256_NO_ARRAY_BUFFER && \"undefined\" != typeof ArrayBuffer, o = \"0123456789abcdef\".split(\"\"), a = [\n        -2147483648,\n        8388608,\n        32768,\n        128\n    ], f = [\n        24,\n        16,\n        8,\n        0\n    ], u = [\n        1116352408,\n        1899447441,\n        3049323471,\n        3921009573,\n        961987163,\n        1508970993,\n        2453635748,\n        2870763221,\n        3624381080,\n        310598401,\n        607225278,\n        1426881987,\n        1925078388,\n        2162078206,\n        2614888103,\n        3248222580,\n        3835390401,\n        4022224774,\n        264347078,\n        604807628,\n        770255983,\n        1249150122,\n        1555081692,\n        1996064986,\n        2554220882,\n        2821834349,\n        2952996808,\n        3210313671,\n        3336571891,\n        3584528711,\n        113926993,\n        338241895,\n        666307205,\n        773529912,\n        1294757372,\n        1396182291,\n        1695183700,\n        1986661051,\n        2177026350,\n        2456956037,\n        2730485921,\n        2820302411,\n        3259730800,\n        3345764771,\n        3516065817,\n        3600352804,\n        4094571909,\n        275423344,\n        430227734,\n        506948616,\n        659060556,\n        883997877,\n        958139571,\n        1322822218,\n        1537002063,\n        1747873779,\n        1955562222,\n        2024104815,\n        2227730452,\n        2361852424,\n        2428436474,\n        2756734187,\n        3204031479,\n        3329325298\n    ], c = [\n        \"hex\",\n        \"array\",\n        \"digest\",\n        \"arrayBuffer\"\n    ], l = [];\n    !r.JS_SHA256_NO_NODE_JS && Array.isArray || (Array.isArray = function(t) {\n        return \"[object Array]\" === Object.prototype.toString.call(t);\n    }), !n || !r.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function(t) {\n        return \"object\" == typeof t && t.buffer && t.buffer.constructor === ArrayBuffer;\n    });\n    var y = function(t, e) {\n        return function(r) {\n            return new v(e, !0).update(r)[t]();\n        };\n    }, p = function(t) {\n        var e = y(\"hex\", t);\n        h && (e = d(e, t)), e.create = function() {\n            return new v(t);\n        }, e.update = function(t) {\n            return e.create().update(t);\n        };\n        for(var r = 0; r < c.length; ++r){\n            var i = c[r];\n            e[i] = y(i, t);\n        }\n        return e;\n    }, d = function(e, i) {\n        var h, s = N, n = N.Buffer, o = i ? \"sha224\" : \"sha256\";\n        return h = n.from && !r.JS_SHA256_NO_BUFFER_FROM ? n.from : function(t) {\n            return new n(t);\n        }, function(r) {\n            if (\"string\" == typeof r) return s.createHash(o).update(r, \"utf8\").digest(\"hex\");\n            if (null == r) throw new Error(t);\n            return r.constructor === ArrayBuffer && (r = new Uint8Array(r)), Array.isArray(r) || ArrayBuffer.isView(r) || r.constructor === n ? s.createHash(o).update(h(r)).digest(\"hex\") : e(r);\n        };\n    }, w = function(t, e) {\n        return function(r, i) {\n            return new A(r, e, !0).update(i)[t]();\n        };\n    }, b = function(t) {\n        var e = w(\"hex\", t);\n        e.create = function(e) {\n            return new A(e, t);\n        }, e.update = function(t, r) {\n            return e.create(t).update(r);\n        };\n        for(var r = 0; r < c.length; ++r){\n            var i = c[r];\n            e[i] = w(i, t);\n        }\n        return e;\n    };\n    function v(t, e) {\n        e ? (l[0] = l[16] = l[1] = l[2] = l[3] = l[4] = l[5] = l[6] = l[7] = l[8] = l[9] = l[10] = l[11] = l[12] = l[13] = l[14] = l[15] = 0, this.blocks = l) : this.blocks = [\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0\n        ], t ? (this.h0 = 3238371032, this.h1 = 914150663, this.h2 = 812702999, this.h3 = 4144912697, this.h4 = 4290775857, this.h5 = 1750603025, this.h6 = 1694076839, this.h7 = 3204075428) : (this.h0 = 1779033703, this.h1 = 3144134277, this.h2 = 1013904242, this.h3 = 2773480762, this.h4 = 1359893119, this.h5 = 2600822924, this.h6 = 528734635, this.h7 = 1541459225), this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0, this.is224 = t;\n    }\n    function A(e, r, i) {\n        var h, s = typeof e;\n        if (\"string\" === s) {\n            var o, a = [], f = e.length, u = 0;\n            for(h = 0; h < f; ++h)(o = e.charCodeAt(h)) < 128 ? a[u++] = o : o < 2048 ? (a[u++] = 192 | o >>> 6, a[u++] = 128 | 63 & o) : o < 55296 || o >= 57344 ? (a[u++] = 224 | o >>> 12, a[u++] = 128 | o >>> 6 & 63, a[u++] = 128 | 63 & o) : (o = 65536 + ((1023 & o) << 10 | 1023 & e.charCodeAt(++h)), a[u++] = 240 | o >>> 18, a[u++] = 128 | o >>> 12 & 63, a[u++] = 128 | o >>> 6 & 63, a[u++] = 128 | 63 & o);\n            e = a;\n        } else {\n            if (\"object\" !== s) throw new Error(t);\n            if (null === e) throw new Error(t);\n            if (n && e.constructor === ArrayBuffer) e = new Uint8Array(e);\n            else if (!(Array.isArray(e) || n && ArrayBuffer.isView(e))) throw new Error(t);\n        }\n        e.length > 64 && (e = new v(r, !0).update(e).array());\n        var c = [], l = [];\n        for(h = 0; h < 64; ++h){\n            var y = e[h] || 0;\n            c[h] = 92 ^ y, l[h] = 54 ^ y;\n        }\n        v.call(this, r, i), this.update(l), this.oKeyPad = c, this.inner = !0, this.sharedMemory = i;\n    }\n    v.prototype.update = function(e) {\n        if (!this.finalized) {\n            var r, i = typeof e;\n            if (\"string\" !== i) {\n                if (\"object\" !== i) throw new Error(t);\n                if (null === e) throw new Error(t);\n                if (n && e.constructor === ArrayBuffer) e = new Uint8Array(e);\n                else if (!(Array.isArray(e) || n && ArrayBuffer.isView(e))) throw new Error(t);\n                r = !0;\n            }\n            for(var h, s, o = 0, a = e.length, u = this.blocks; o < a;){\n                if (this.hashed && (this.hashed = !1, u[0] = this.block, this.block = u[16] = u[1] = u[2] = u[3] = u[4] = u[5] = u[6] = u[7] = u[8] = u[9] = u[10] = u[11] = u[12] = u[13] = u[14] = u[15] = 0), r) for(s = this.start; o < a && s < 64; ++o)u[s >>> 2] |= e[o] << f[3 & s++];\n                else for(s = this.start; o < a && s < 64; ++o)(h = e.charCodeAt(o)) < 128 ? u[s >>> 2] |= h << f[3 & s++] : h < 2048 ? (u[s >>> 2] |= (192 | h >>> 6) << f[3 & s++], u[s >>> 2] |= (128 | 63 & h) << f[3 & s++]) : h < 55296 || h >= 57344 ? (u[s >>> 2] |= (224 | h >>> 12) << f[3 & s++], u[s >>> 2] |= (128 | h >>> 6 & 63) << f[3 & s++], u[s >>> 2] |= (128 | 63 & h) << f[3 & s++]) : (h = 65536 + ((1023 & h) << 10 | 1023 & e.charCodeAt(++o)), u[s >>> 2] |= (240 | h >>> 18) << f[3 & s++], u[s >>> 2] |= (128 | h >>> 12 & 63) << f[3 & s++], u[s >>> 2] |= (128 | h >>> 6 & 63) << f[3 & s++], u[s >>> 2] |= (128 | 63 & h) << f[3 & s++]);\n                this.lastByteIndex = s, this.bytes += s - this.start, s >= 64 ? (this.block = u[16], this.start = s - 64, this.hash(), this.hashed = !0) : this.start = s;\n            }\n            return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 | 0, this.bytes = this.bytes % 4294967296), this;\n        }\n    }, v.prototype.finalize = function() {\n        if (!this.finalized) {\n            this.finalized = !0;\n            var t = this.blocks, e = this.lastByteIndex;\n            t[16] = this.block, t[e >>> 2] |= a[3 & e], this.block = t[16], e >= 56 && (this.hashed || this.hash(), t[0] = this.block, t[16] = t[1] = t[2] = t[3] = t[4] = t[5] = t[6] = t[7] = t[8] = t[9] = t[10] = t[11] = t[12] = t[13] = t[14] = t[15] = 0), t[14] = this.hBytes << 3 | this.bytes >>> 29, t[15] = this.bytes << 3, this.hash();\n        }\n    }, v.prototype.hash = function() {\n        var t, e, r, i, h, s, n, o, a, f = this.h0, c = this.h1, l = this.h2, y = this.h3, p = this.h4, d = this.h5, w = this.h6, b = this.h7, v = this.blocks;\n        for(t = 16; t < 64; ++t)e = ((h = v[t - 15]) >>> 7 | h << 25) ^ (h >>> 18 | h << 14) ^ h >>> 3, r = ((h = v[t - 2]) >>> 17 | h << 15) ^ (h >>> 19 | h << 13) ^ h >>> 10, v[t] = v[t - 16] + e + v[t - 7] + r | 0;\n        for(a = c & l, t = 0; t < 64; t += 4)this.first ? (this.is224 ? (s = 300032, b = (h = v[0] - 1413257819) - 150054599 | 0, y = h + 24177077 | 0) : (s = 704751109, b = (h = v[0] - 210244248) - 1521486534 | 0, y = h + 143694565 | 0), this.first = !1) : (e = (f >>> 2 | f << 30) ^ (f >>> 13 | f << 19) ^ (f >>> 22 | f << 10), i = (s = f & c) ^ f & l ^ a, b = y + (h = b + (r = (p >>> 6 | p << 26) ^ (p >>> 11 | p << 21) ^ (p >>> 25 | p << 7)) + (p & d ^ ~p & w) + u[t] + v[t]) | 0, y = h + (e + i) | 0), e = (y >>> 2 | y << 30) ^ (y >>> 13 | y << 19) ^ (y >>> 22 | y << 10), i = (n = y & f) ^ y & c ^ s, w = l + (h = w + (r = (b >>> 6 | b << 26) ^ (b >>> 11 | b << 21) ^ (b >>> 25 | b << 7)) + (b & p ^ ~b & d) + u[t + 1] + v[t + 1]) | 0, e = ((l = h + (e + i) | 0) >>> 2 | l << 30) ^ (l >>> 13 | l << 19) ^ (l >>> 22 | l << 10), i = (o = l & y) ^ l & f ^ n, d = c + (h = d + (r = (w >>> 6 | w << 26) ^ (w >>> 11 | w << 21) ^ (w >>> 25 | w << 7)) + (w & b ^ ~w & p) + u[t + 2] + v[t + 2]) | 0, e = ((c = h + (e + i) | 0) >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10), i = (a = c & l) ^ c & y ^ o, p = f + (h = p + (r = (d >>> 6 | d << 26) ^ (d >>> 11 | d << 21) ^ (d >>> 25 | d << 7)) + (d & w ^ ~d & b) + u[t + 3] + v[t + 3]) | 0, f = h + (e + i) | 0, this.chromeBugWorkAround = !0;\n        this.h0 = this.h0 + f | 0, this.h1 = this.h1 + c | 0, this.h2 = this.h2 + l | 0, this.h3 = this.h3 + y | 0, this.h4 = this.h4 + p | 0, this.h5 = this.h5 + d | 0, this.h6 = this.h6 + w | 0, this.h7 = this.h7 + b | 0;\n    }, v.prototype.hex = function() {\n        this.finalize();\n        var t = this.h0, e = this.h1, r = this.h2, i = this.h3, h = this.h4, s = this.h5, n = this.h6, a = this.h7, f = o[t >>> 28 & 15] + o[t >>> 24 & 15] + o[t >>> 20 & 15] + o[t >>> 16 & 15] + o[t >>> 12 & 15] + o[t >>> 8 & 15] + o[t >>> 4 & 15] + o[15 & t] + o[e >>> 28 & 15] + o[e >>> 24 & 15] + o[e >>> 20 & 15] + o[e >>> 16 & 15] + o[e >>> 12 & 15] + o[e >>> 8 & 15] + o[e >>> 4 & 15] + o[15 & e] + o[r >>> 28 & 15] + o[r >>> 24 & 15] + o[r >>> 20 & 15] + o[r >>> 16 & 15] + o[r >>> 12 & 15] + o[r >>> 8 & 15] + o[r >>> 4 & 15] + o[15 & r] + o[i >>> 28 & 15] + o[i >>> 24 & 15] + o[i >>> 20 & 15] + o[i >>> 16 & 15] + o[i >>> 12 & 15] + o[i >>> 8 & 15] + o[i >>> 4 & 15] + o[15 & i] + o[h >>> 28 & 15] + o[h >>> 24 & 15] + o[h >>> 20 & 15] + o[h >>> 16 & 15] + o[h >>> 12 & 15] + o[h >>> 8 & 15] + o[h >>> 4 & 15] + o[15 & h] + o[s >>> 28 & 15] + o[s >>> 24 & 15] + o[s >>> 20 & 15] + o[s >>> 16 & 15] + o[s >>> 12 & 15] + o[s >>> 8 & 15] + o[s >>> 4 & 15] + o[15 & s] + o[n >>> 28 & 15] + o[n >>> 24 & 15] + o[n >>> 20 & 15] + o[n >>> 16 & 15] + o[n >>> 12 & 15] + o[n >>> 8 & 15] + o[n >>> 4 & 15] + o[15 & n];\n        return this.is224 || (f += o[a >>> 28 & 15] + o[a >>> 24 & 15] + o[a >>> 20 & 15] + o[a >>> 16 & 15] + o[a >>> 12 & 15] + o[a >>> 8 & 15] + o[a >>> 4 & 15] + o[15 & a]), f;\n    }, v.prototype.toString = v.prototype.hex, v.prototype.digest = function() {\n        this.finalize();\n        var t = this.h0, e = this.h1, r = this.h2, i = this.h3, h = this.h4, s = this.h5, n = this.h6, o = this.h7, a = [\n            t >>> 24 & 255,\n            t >>> 16 & 255,\n            t >>> 8 & 255,\n            255 & t,\n            e >>> 24 & 255,\n            e >>> 16 & 255,\n            e >>> 8 & 255,\n            255 & e,\n            r >>> 24 & 255,\n            r >>> 16 & 255,\n            r >>> 8 & 255,\n            255 & r,\n            i >>> 24 & 255,\n            i >>> 16 & 255,\n            i >>> 8 & 255,\n            255 & i,\n            h >>> 24 & 255,\n            h >>> 16 & 255,\n            h >>> 8 & 255,\n            255 & h,\n            s >>> 24 & 255,\n            s >>> 16 & 255,\n            s >>> 8 & 255,\n            255 & s,\n            n >>> 24 & 255,\n            n >>> 16 & 255,\n            n >>> 8 & 255,\n            255 & n\n        ];\n        return this.is224 || a.push(o >>> 24 & 255, o >>> 16 & 255, o >>> 8 & 255, 255 & o), a;\n    }, v.prototype.array = v.prototype.digest, v.prototype.arrayBuffer = function() {\n        this.finalize();\n        var t = new ArrayBuffer(this.is224 ? 28 : 32), e = new DataView(t);\n        return e.setUint32(0, this.h0), e.setUint32(4, this.h1), e.setUint32(8, this.h2), e.setUint32(12, this.h3), e.setUint32(16, this.h4), e.setUint32(20, this.h5), e.setUint32(24, this.h6), this.is224 || e.setUint32(28, this.h7), t;\n    }, A.prototype = new v, A.prototype.finalize = function() {\n        if (v.prototype.finalize.call(this), this.inner) {\n            this.inner = !1;\n            var t = this.array();\n            v.call(this, this.is224, this.sharedMemory), this.update(this.oKeyPad), this.update(t), v.prototype.finalize.call(this);\n        }\n    };\n    var g = p();\n    g.sha256 = g, g.sha224 = p(!0), g.sha256.hmac = b(), g.sha224.hmac = b(!0), s ? k.exports = g : (r.sha256 = g.sha256, r.sha224 = g.sha224);\n}();\nvar U = x.exports, z = x.exports.sha224, J = x.exports.sha256;\nfunction parseSha256(s) {\n    return toByteArray(s);\n}\nfunction isHex(s) {\n    const hexRegex = /^[0-9A-Fa-f]+$/;\n    if (!hexRegex.test(s)) {\n        return false;\n    }\n    const isAllUpperCase = /^[0-9A-F]+$/.test(s);\n    const isAllLowerCase = /^[0-9a-f]+$/.test(s);\n    if (!(isAllUpperCase || isAllLowerCase)) {\n        return false;\n    }\n    return s.length % 2 === 0;\n}\nfunction isBase64(s) {\n    return /^[A-Za-z0-9\\-_]*(={0,2})?$/.test(s) || /^[A-Za-z0-9+/]*(={0,2})?$/.test(s);\n}\nfunction detectEncoding(input) {\n    if (isHex(input)) {\n        return \"hex\";\n    } else if (isBase64(input)) {\n        return \"b64\";\n    }\n    return \"\";\n}\nfunction hexToByteArray(s) {\n    if (s.length % 2 !== 0) {\n        throw new Error(\"hex string must have an even length\");\n    }\n    const a = new Uint8Array(s.length / 2);\n    for(let i = 0; i < s.length; i += 2){\n        a[i / 2] = parseInt(s.substring(i, i + 2), 16);\n    }\n    return a;\n}\nfunction base64ToByteArray(s) {\n    s = s.replace(/-/g, \"+\");\n    s = s.replace(/_/g, \"/\");\n    const sbin = atob(s);\n    return Uint8Array.from(sbin, (c)=>c.charCodeAt(0));\n}\nfunction toByteArray(input) {\n    const encoding = detectEncoding(input);\n    switch(encoding){\n        case \"hex\":\n            return hexToByteArray(input);\n        case \"b64\":\n            return base64ToByteArray(input);\n    }\n    return null;\n}\nfunction checkSha256(a, b) {\n    const aBytes = typeof a === \"string\" ? parseSha256(a) : a;\n    const bBytes = typeof b === \"string\" ? parseSha256(b) : b;\n    if (aBytes === null || bBytes === null) {\n        return false;\n    }\n    if (aBytes.length !== bBytes.length) {\n        return false;\n    }\n    for(let i = 0; i < aBytes.length; i++){\n        if (aBytes[i] !== bBytes[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nclass BaseRequest {\n    token;\n    received;\n    ctx;\n    requestSubject;\n    mux;\n    constructor(mux, requestSubject, asyncTraces = true){\n        this.mux = mux;\n        this.requestSubject = requestSubject;\n        this.received = 0;\n        this.token = nuid.next();\n        if (asyncTraces) {\n            this.ctx = new Error();\n        }\n    }\n}\nclass RequestMany extends BaseRequest {\n    callback;\n    done;\n    timer;\n    max;\n    opts;\n    constructor(mux, requestSubject, opts = {\n        maxWait: 1000\n    }){\n        super(mux, requestSubject);\n        this.opts = opts;\n        if (typeof this.opts.callback !== \"function\") {\n            throw new Error(\"callback is required\");\n        }\n        this.callback = this.opts.callback;\n        this.max = typeof opts.maxMessages === \"number\" && opts.maxMessages > 0 ? opts.maxMessages : -1;\n        this.done = deferred();\n        this.done.then(()=>{\n            this.callback(null, null);\n        });\n        this.timer = setTimeout(()=>{\n            this.cancel();\n        }, opts.maxWait);\n    }\n    cancel(err) {\n        if (err) {\n            this.callback(err, null);\n        }\n        clearTimeout(this.timer);\n        this.mux.cancel(this);\n        this.done.resolve();\n    }\n    resolver(err, msg) {\n        if (err) {\n            if (this.ctx) {\n                err.stack += `\\n\\n${this.ctx.stack}`;\n            }\n            this.cancel(err);\n        } else {\n            this.callback(null, msg);\n            if (this.opts.strategy === RequestStrategy.Count) {\n                this.max--;\n                if (this.max === 0) {\n                    this.cancel();\n                }\n            }\n            if (this.opts.strategy === RequestStrategy.JitterTimer) {\n                clearTimeout(this.timer);\n                this.timer = setTimeout(()=>{\n                    this.cancel();\n                }, this.opts.jitter || 300);\n            }\n            if (this.opts.strategy === RequestStrategy.SentinelMsg) {\n                if (msg && msg.data.length === 0) {\n                    this.cancel();\n                }\n            }\n        }\n    }\n}\nclass RequestOne extends BaseRequest {\n    deferred;\n    timer;\n    constructor(mux, requestSubject, opts = {\n        timeout: 1000\n    }, asyncTraces = true){\n        super(mux, requestSubject, asyncTraces);\n        this.deferred = deferred();\n        this.timer = timeout(opts.timeout, asyncTraces);\n    }\n    resolver(err, msg) {\n        if (this.timer) {\n            this.timer.cancel();\n        }\n        if (err) {\n            if (this.ctx) {\n                err.stack += `\\n\\n${this.ctx.stack}`;\n            }\n            this.deferred.reject(err);\n        } else {\n            this.deferred.resolve(msg);\n        }\n        this.cancel();\n    }\n    cancel(err) {\n        if (this.timer) {\n            this.timer.cancel();\n        }\n        this.mux.cancel(this);\n        this.deferred.reject(err ? err : NatsError.errorForCode(ErrorCode.Cancelled));\n    }\n}\nconst defaultPrefix = \"$JS.API\";\nfunction defaultJsOptions(opts) {\n    opts = opts || {};\n    if (opts.domain) {\n        opts.apiPrefix = `$JS.${opts.domain}.API`;\n        delete opts.domain;\n    }\n    return extend({\n        apiPrefix: defaultPrefix,\n        timeout: 5000\n    }, opts);\n}\nclass BaseApiClient {\n    nc;\n    opts;\n    prefix;\n    timeout;\n    jc;\n    constructor(nc, opts){\n        this.nc = nc;\n        this.opts = defaultJsOptions(opts);\n        this._parseOpts();\n        this.prefix = this.opts.apiPrefix;\n        this.timeout = this.opts.timeout;\n        this.jc = JSONCodec();\n    }\n    getOptions() {\n        return Object.assign({}, this.opts);\n    }\n    _parseOpts() {\n        let prefix = this.opts.apiPrefix;\n        if (!prefix || prefix.length === 0) {\n            throw new Error(\"invalid empty prefix\");\n        }\n        const c = prefix[prefix.length - 1];\n        if (c === \".\") {\n            prefix = prefix.substr(0, prefix.length - 1);\n        }\n        this.opts.apiPrefix = prefix;\n    }\n    async _request(subj, data = null, opts) {\n        opts = opts || {};\n        opts.timeout = this.timeout;\n        let a = Empty;\n        if (data) {\n            a = this.jc.encode(data);\n        }\n        let { retries } = opts;\n        retries = retries || 1;\n        retries = retries === -1 ? Number.MAX_SAFE_INTEGER : retries;\n        const bo = backoff();\n        for(let i = 0; i < retries; i++){\n            try {\n                const m = await this.nc.request(subj, a, opts);\n                return this.parseJsResponse(m);\n            } catch (err) {\n                const ne = err;\n                if ((ne.code === \"503\" || ne.code === ErrorCode.Timeout) && i + 1 < retries) {\n                    await delay(bo.backoff(i));\n                } else {\n                    throw err;\n                }\n            }\n        }\n    }\n    async findStream(subject) {\n        const q = {\n            subject\n        };\n        const r = await this._request(`${this.prefix}.STREAM.NAMES`, q);\n        const names = r;\n        if (!names.streams || names.streams.length !== 1) {\n            throw new Error(\"no stream matches subject\");\n        }\n        return names.streams[0];\n    }\n    getConnection() {\n        return this.nc;\n    }\n    parseJsResponse(m) {\n        const v = this.jc.decode(m.data);\n        const r = v;\n        if (r.error) {\n            const err = checkJsErrorCode(r.error.code, r.error.description);\n            if (err !== null) {\n                err.api_error = r.error;\n                throw err;\n            }\n        }\n        return v;\n    }\n}\nclass ListerImpl {\n    err;\n    offset;\n    pageInfo;\n    subject;\n    jsm;\n    filter;\n    payload;\n    constructor(subject, filter, jsm, payload){\n        if (!subject) {\n            throw new Error(\"subject is required\");\n        }\n        this.subject = subject;\n        this.jsm = jsm;\n        this.offset = 0;\n        this.pageInfo = {};\n        this.filter = filter;\n        this.payload = payload || {};\n    }\n    async next() {\n        if (this.err) {\n            return [];\n        }\n        if (this.pageInfo && this.offset >= this.pageInfo.total) {\n            return [];\n        }\n        const offset = {\n            offset: this.offset\n        };\n        if (this.payload) {\n            Object.assign(offset, this.payload);\n        }\n        try {\n            const r = await this.jsm._request(this.subject, offset, {\n                timeout: this.jsm.timeout\n            });\n            this.pageInfo = r;\n            const count = this.countResponse(r);\n            if (count === 0) {\n                return [];\n            }\n            this.offset += count;\n            const a = this.filter(r);\n            return a;\n        } catch (err) {\n            this.err = err;\n            throw err;\n        }\n    }\n    countResponse(r) {\n        switch(r?.type){\n            case \"io.nats.jetstream.api.v1.stream_names_response\":\n            case \"io.nats.jetstream.api.v1.stream_list_response\":\n                return r.streams?.length || 0;\n            case \"io.nats.jetstream.api.v1.consumer_list_response\":\n                return r.consumers?.length || 0;\n            default:\n                console.error(`jslister.ts: unknown API response for paged output: ${r?.type}`);\n                return r.streams?.length || 0;\n        }\n        return 0;\n    }\n    async *[Symbol.asyncIterator]() {\n        let page = await this.next();\n        while(page.length > 0){\n            for (const item of page){\n                yield item;\n            }\n            page = await this.next();\n        }\n    }\n}\nfunction parseSemVer(s = \"\") {\n    const m = s.match(/(\\d+).(\\d+).(\\d+)/);\n    if (m) {\n        return {\n            major: parseInt(m[1]),\n            minor: parseInt(m[2]),\n            micro: parseInt(m[3])\n        };\n    }\n    throw new Error(`'${s}' is not a semver value`);\n}\nfunction compare(a, b) {\n    if (a.major < b.major) return -1;\n    if (a.major > b.major) return 1;\n    if (a.minor < b.minor) return -1;\n    if (a.minor > b.minor) return 1;\n    if (a.micro < b.micro) return -1;\n    if (a.micro > b.micro) return 1;\n    return 0;\n}\nvar Feature;\n(function(Feature) {\n    Feature[\"JS_KV\"] = \"js_kv\";\n    Feature[\"JS_OBJECTSTORE\"] = \"js_objectstore\";\n    Feature[\"JS_PULL_MAX_BYTES\"] = \"js_pull_max_bytes\";\n    Feature[\"JS_NEW_CONSUMER_CREATE_API\"] = \"js_new_consumer_create\";\n    Feature[\"JS_ALLOW_DIRECT\"] = \"js_allow_direct\";\n    Feature[\"JS_MULTIPLE_CONSUMER_FILTER\"] = \"js_multiple_consumer_filter\";\n    Feature[\"JS_SIMPLIFICATION\"] = \"js_simplification\";\n    Feature[\"JS_STREAM_CONSUMER_METADATA\"] = \"js_stream_consumer_metadata\";\n    Feature[\"JS_CONSUMER_FILTER_SUBJECTS\"] = \"js_consumer_filter_subjects\";\n    Feature[\"JS_STREAM_FIRST_SEQ\"] = \"js_stream_first_seq\";\n    Feature[\"JS_STREAM_SUBJECT_TRANSFORM\"] = \"js_stream_subject_transform\";\n    Feature[\"JS_STREAM_SOURCE_SUBJECT_TRANSFORM\"] = \"js_stream_source_subject_transform\";\n    Feature[\"JS_STREAM_COMPRESSION\"] = \"js_stream_compression\";\n    Feature[\"JS_DEFAULT_CONSUMER_LIMITS\"] = \"js_default_consumer_limits\";\n    Feature[\"JS_BATCH_DIRECT_GET\"] = \"js_batch_direct_get\";\n})(Feature || (Feature = {}));\nclass Features {\n    server;\n    features;\n    disabled;\n    constructor(v){\n        this.features = new Map();\n        this.disabled = [];\n        this.update(v);\n    }\n    resetDisabled() {\n        this.disabled.length = 0;\n        this.update(this.server);\n    }\n    disable(f) {\n        this.disabled.push(f);\n        this.update(this.server);\n    }\n    isDisabled(f) {\n        return this.disabled.indexOf(f) !== -1;\n    }\n    update(v) {\n        if (typeof v === \"string\") {\n            v = parseSemVer(v);\n        }\n        this.server = v;\n        this.set(Feature.JS_KV, \"2.6.2\");\n        this.set(Feature.JS_OBJECTSTORE, \"2.6.3\");\n        this.set(Feature.JS_PULL_MAX_BYTES, \"2.8.3\");\n        this.set(Feature.JS_NEW_CONSUMER_CREATE_API, \"2.9.0\");\n        this.set(Feature.JS_ALLOW_DIRECT, \"2.9.0\");\n        this.set(Feature.JS_MULTIPLE_CONSUMER_FILTER, \"2.10.0\");\n        this.set(Feature.JS_SIMPLIFICATION, \"2.9.4\");\n        this.set(Feature.JS_STREAM_CONSUMER_METADATA, \"2.10.0\");\n        this.set(Feature.JS_CONSUMER_FILTER_SUBJECTS, \"2.10.0\");\n        this.set(Feature.JS_STREAM_FIRST_SEQ, \"2.10.0\");\n        this.set(Feature.JS_STREAM_SUBJECT_TRANSFORM, \"2.10.0\");\n        this.set(Feature.JS_STREAM_SOURCE_SUBJECT_TRANSFORM, \"2.10.0\");\n        this.set(Feature.JS_STREAM_COMPRESSION, \"2.10.0\");\n        this.set(Feature.JS_DEFAULT_CONSUMER_LIMITS, \"2.10.0\");\n        this.set(Feature.JS_BATCH_DIRECT_GET, \"2.11.0\");\n        this.disabled.forEach((f)=>{\n            this.features.delete(f);\n        });\n    }\n    set(f, requires) {\n        this.features.set(f, {\n            min: requires,\n            ok: compare(this.server, parseSemVer(requires)) >= 0\n        });\n    }\n    get(f) {\n        return this.features.get(f) || {\n            min: \"unknown\",\n            ok: false\n        };\n    }\n    supports(f) {\n        return this.get(f)?.ok || false;\n    }\n    require(v) {\n        if (typeof v === \"string\") {\n            v = parseSemVer(v);\n        }\n        return compare(this.server, v) >= 0;\n    }\n}\nclass ConsumerAPIImpl extends BaseApiClient {\n    constructor(nc, opts){\n        super(nc, opts);\n    }\n    async add(stream, cfg, action = ConsumerApiAction.Create) {\n        validateStreamName(stream);\n        if (cfg.deliver_group && cfg.flow_control) {\n            throw new Error(\"jetstream flow control is not supported with queue groups\");\n        }\n        if (cfg.deliver_group && cfg.idle_heartbeat) {\n            throw new Error(\"jetstream idle heartbeat is not supported with queue groups\");\n        }\n        const cr = {};\n        cr.config = cfg;\n        cr.stream_name = stream;\n        cr.action = action;\n        if (cr.config.durable_name) {\n            validateDurableName(cr.config.durable_name);\n        }\n        const nci = this.nc;\n        let { min, ok: newAPI } = nci.features.get(Feature.JS_NEW_CONSUMER_CREATE_API);\n        const name = cfg.name === \"\" ? undefined : cfg.name;\n        if (name && !newAPI) {\n            throw new Error(`consumer 'name' requires server ${min}`);\n        }\n        if (name) {\n            try {\n                minValidation(\"name\", name);\n            } catch (err) {\n                const m = err.message;\n                const idx = m.indexOf(\"cannot contain\");\n                if (idx !== -1) {\n                    throw new Error(`consumer 'name' ${m.substring(idx)}`);\n                }\n                throw err;\n            }\n        }\n        let subj;\n        let consumerName = \"\";\n        if (Array.isArray(cfg.filter_subjects)) {\n            const { min, ok } = nci.features.get(Feature.JS_MULTIPLE_CONSUMER_FILTER);\n            if (!ok) {\n                throw new Error(`consumer 'filter_subjects' requires server ${min}`);\n            }\n            newAPI = false;\n        }\n        if (cfg.metadata) {\n            const { min, ok } = nci.features.get(Feature.JS_STREAM_CONSUMER_METADATA);\n            if (!ok) {\n                throw new Error(`consumer 'metadata' requires server ${min}`);\n            }\n        }\n        if (newAPI) {\n            consumerName = cfg.name ?? cfg.durable_name ?? \"\";\n        }\n        if (consumerName !== \"\") {\n            let fs = cfg.filter_subject ?? undefined;\n            if (fs === \">\") {\n                fs = undefined;\n            }\n            subj = fs !== undefined ? `${this.prefix}.CONSUMER.CREATE.${stream}.${consumerName}.${fs}` : `${this.prefix}.CONSUMER.CREATE.${stream}.${consumerName}`;\n        } else {\n            subj = cfg.durable_name ? `${this.prefix}.CONSUMER.DURABLE.CREATE.${stream}.${cfg.durable_name}` : `${this.prefix}.CONSUMER.CREATE.${stream}`;\n        }\n        const r = await this._request(subj, cr);\n        return r;\n    }\n    async update(stream, durable, cfg) {\n        const ci = await this.info(stream, durable);\n        const changable = cfg;\n        return this.add(stream, Object.assign(ci.config, changable), ConsumerApiAction.Update);\n    }\n    async info(stream, name) {\n        validateStreamName(stream);\n        validateDurableName(name);\n        const r = await this._request(`${this.prefix}.CONSUMER.INFO.${stream}.${name}`);\n        return r;\n    }\n    async delete(stream, name) {\n        validateStreamName(stream);\n        validateDurableName(name);\n        const r = await this._request(`${this.prefix}.CONSUMER.DELETE.${stream}.${name}`);\n        const cr = r;\n        return cr.success;\n    }\n    list(stream) {\n        validateStreamName(stream);\n        const filter = (v)=>{\n            const clr = v;\n            return clr.consumers;\n        };\n        const subj = `${this.prefix}.CONSUMER.LIST.${stream}`;\n        return new ListerImpl(subj, filter, this);\n    }\n    pause(stream, name, until) {\n        const subj = `${this.prefix}.CONSUMER.PAUSE.${stream}.${name}`;\n        const opts = {\n            pause_until: until.toISOString()\n        };\n        return this._request(subj, opts);\n    }\n    resume(stream, name) {\n        return this.pause(stream, name, new Date(0));\n    }\n}\nfunction checkFn(fn, name, required = false) {\n    if (required === true && !fn) {\n        throw NatsError.errorForCode(ErrorCode.ApiError, new Error(`${name} is not a function`));\n    }\n    if (fn && typeof fn !== \"function\") {\n        throw NatsError.errorForCode(ErrorCode.ApiError, new Error(`${name} is not a function`));\n    }\n}\nclass TypedSubscription extends QueuedIteratorImpl {\n    sub;\n    adapter;\n    subIterDone;\n    constructor(nc, subject, opts){\n        super();\n        checkFn(opts.adapter, \"adapter\", true);\n        this.adapter = opts.adapter;\n        if (opts.callback) {\n            checkFn(opts.callback, \"callback\");\n        }\n        this.noIterator = typeof opts.callback === \"function\";\n        if (opts.ingestionFilterFn) {\n            checkFn(opts.ingestionFilterFn, \"ingestionFilterFn\");\n            this.ingestionFilterFn = opts.ingestionFilterFn;\n        }\n        if (opts.protocolFilterFn) {\n            checkFn(opts.protocolFilterFn, \"protocolFilterFn\");\n            this.protocolFilterFn = opts.protocolFilterFn;\n        }\n        if (opts.dispatchedFn) {\n            checkFn(opts.dispatchedFn, \"dispatchedFn\");\n            this.dispatchedFn = opts.dispatchedFn;\n        }\n        if (opts.cleanupFn) {\n            checkFn(opts.cleanupFn, \"cleanupFn\");\n        }\n        let callback = (err, msg)=>{\n            this.callback(err, msg);\n        };\n        if (opts.callback) {\n            const uh = opts.callback;\n            callback = (err, msg)=>{\n                const [jer, tm] = this.adapter(err, msg);\n                if (jer) {\n                    uh(jer, null);\n                    return;\n                }\n                const { ingest } = this.ingestionFilterFn ? this.ingestionFilterFn(tm, this) : {\n                    ingest: true\n                };\n                if (ingest) {\n                    const ok = this.protocolFilterFn ? this.protocolFilterFn(tm) : true;\n                    if (ok) {\n                        uh(jer, tm);\n                        if (this.dispatchedFn && tm) {\n                            this.dispatchedFn(tm);\n                        }\n                    }\n                }\n            };\n        }\n        const { max, queue, timeout } = opts;\n        const sopts = {\n            queue,\n            timeout,\n            callback\n        };\n        if (max && max > 0) {\n            sopts.max = max;\n        }\n        this.sub = nc.subscribe(subject, sopts);\n        if (opts.cleanupFn) {\n            this.sub.cleanupFn = opts.cleanupFn;\n        }\n        if (!this.noIterator) {\n            this.iterClosed.then(()=>{\n                this.unsubscribe();\n            });\n        }\n        this.subIterDone = deferred();\n        Promise.all([\n            this.sub.closed,\n            this.iterClosed\n        ]).then(()=>{\n            this.subIterDone.resolve();\n        }).catch(()=>{\n            this.subIterDone.resolve();\n        });\n        (async (s)=>{\n            await s.closed;\n            this.stop();\n        })(this.sub).then().catch();\n    }\n    unsubscribe(max) {\n        this.sub.unsubscribe(max);\n    }\n    drain() {\n        return this.sub.drain();\n    }\n    isDraining() {\n        return this.sub.isDraining();\n    }\n    isClosed() {\n        return this.sub.isClosed();\n    }\n    callback(e, msg) {\n        this.sub.cancelTimeout();\n        const [err, tm] = this.adapter(e, msg);\n        if (err) {\n            this.stop(err);\n        }\n        if (tm) {\n            this.push(tm);\n        }\n    }\n    getSubject() {\n        return this.sub.getSubject();\n    }\n    getReceived() {\n        return this.sub.getReceived();\n    }\n    getProcessed() {\n        return this.sub.getProcessed();\n    }\n    getPending() {\n        return this.sub.getPending();\n    }\n    getID() {\n        return this.sub.getID();\n    }\n    getMax() {\n        return this.sub.getMax();\n    }\n    get closed() {\n        return this.sub.closed;\n    }\n}\nlet transportConfig;\nfunction setTransportFactory(config) {\n    transportConfig = config;\n}\nfunction defaultPort() {\n    return transportConfig !== undefined && transportConfig.defaultPort !== undefined ? transportConfig.defaultPort : 4222;\n}\nfunction getUrlParseFn() {\n    return transportConfig !== undefined && transportConfig.urlParseFn ? transportConfig.urlParseFn : undefined;\n}\nfunction newTransport() {\n    if (!transportConfig || typeof transportConfig.factory !== \"function\") {\n        throw new Error(\"transport fn is not set\");\n    }\n    return transportConfig.factory();\n}\nfunction getResolveFn() {\n    return transportConfig !== undefined && transportConfig.dnsResolveFn ? transportConfig.dnsResolveFn : undefined;\n}\nconst CR_LF = \"\\r\\n\";\nCR_LF.length;\nconst CRLF = DataBuffer.fromAscii(CR_LF);\nconst CR = new Uint8Array(CRLF)[0];\nconst LF = new Uint8Array(CRLF)[1];\nfunction protoLen(ba) {\n    for(let i = 0; i < ba.length; i++){\n        const n = i + 1;\n        if (ba.byteLength > n && ba[i] === CR && ba[n] === LF) {\n            return n + 1;\n        }\n    }\n    return 0;\n}\nfunction extractProtocolMessage(a) {\n    const len = protoLen(a);\n    if (len > 0) {\n        const ba = new Uint8Array(a);\n        const out = ba.slice(0, len);\n        return TD.decode(out);\n    }\n    return \"\";\n}\nconst IPv4LEN = 4;\nconst ASCII0 = 48;\nconst ASCIIA = 65;\nconst ASCIIa = 97;\nfunction ipV4(a, b, c, d) {\n    const ip = new Uint8Array(16);\n    const prefix = [\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0xff,\n        0xff\n    ];\n    prefix.forEach((v, idx)=>{\n        ip[idx] = v;\n    });\n    ip[12] = a;\n    ip[13] = b;\n    ip[14] = c;\n    ip[15] = d;\n    return ip;\n}\nfunction isIP(h) {\n    return parseIP(h) !== undefined;\n}\nfunction parseIP(h) {\n    for(let i = 0; i < h.length; i++){\n        switch(h[i]){\n            case \".\":\n                return parseIPv4(h);\n            case \":\":\n                return parseIPv6(h);\n        }\n    }\n    return;\n}\nfunction parseIPv4(s) {\n    const ip = new Uint8Array(4);\n    for(let i = 0; i < 4; i++){\n        if (s.length === 0) {\n            return undefined;\n        }\n        if (i > 0) {\n            if (s[0] !== \".\") {\n                return undefined;\n            }\n            s = s.substring(1);\n        }\n        const { n, c, ok } = dtoi(s);\n        if (!ok || n > 0xFF) {\n            return undefined;\n        }\n        s = s.substring(c);\n        ip[i] = n;\n    }\n    return ipV4(ip[0], ip[1], ip[2], ip[3]);\n}\nfunction parseIPv6(s) {\n    const ip = new Uint8Array(16);\n    let ellipsis = -1;\n    if (s.length >= 2 && s[0] === \":\" && s[1] === \":\") {\n        ellipsis = 0;\n        s = s.substring(2);\n        if (s.length === 0) {\n            return ip;\n        }\n    }\n    let i = 0;\n    while(i < 16){\n        const { n, c, ok } = xtoi(s);\n        if (!ok || n > 0xFFFF) {\n            return undefined;\n        }\n        if (c < s.length && s[c] === \".\") {\n            if (ellipsis < 0 && i != 16 - 4) {\n                return undefined;\n            }\n            if (i + 4 > 16) {\n                return undefined;\n            }\n            const ip4 = parseIPv4(s);\n            if (ip4 === undefined) {\n                return undefined;\n            }\n            ip[i] = ip4[12];\n            ip[i + 1] = ip4[13];\n            ip[i + 2] = ip4[14];\n            ip[i + 3] = ip4[15];\n            s = \"\";\n            i += IPv4LEN;\n            break;\n        }\n        ip[i] = n >> 8;\n        ip[i + 1] = n;\n        i += 2;\n        s = s.substring(c);\n        if (s.length === 0) {\n            break;\n        }\n        if (s[0] !== \":\" || s.length == 1) {\n            return undefined;\n        }\n        s = s.substring(1);\n        if (s[0] === \":\") {\n            if (ellipsis >= 0) {\n                return undefined;\n            }\n            ellipsis = i;\n            s = s.substring(1);\n            if (s.length === 0) {\n                break;\n            }\n        }\n    }\n    if (s.length !== 0) {\n        return undefined;\n    }\n    if (i < 16) {\n        if (ellipsis < 0) {\n            return undefined;\n        }\n        const n = 16 - i;\n        for(let j = i - 1; j >= ellipsis; j--){\n            ip[j + n] = ip[j];\n        }\n        for(let j = ellipsis + n - 1; j >= ellipsis; j--){\n            ip[j] = 0;\n        }\n    } else if (ellipsis >= 0) {\n        return undefined;\n    }\n    return ip;\n}\nfunction dtoi(s) {\n    let i = 0;\n    let n = 0;\n    for(i = 0; i < s.length && 48 <= s.charCodeAt(i) && s.charCodeAt(i) <= 57; i++){\n        n = n * 10 + (s.charCodeAt(i) - ASCII0);\n        if (n >= 0xFFFFFF) {\n            return {\n                n: 0xFFFFFF,\n                c: i,\n                ok: false\n            };\n        }\n    }\n    if (i === 0) {\n        return {\n            n: 0,\n            c: 0,\n            ok: false\n        };\n    }\n    return {\n        n: n,\n        c: i,\n        ok: true\n    };\n}\nfunction xtoi(s) {\n    let n = 0;\n    let i = 0;\n    for(i = 0; i < s.length; i++){\n        if (48 <= s.charCodeAt(i) && s.charCodeAt(i) <= 57) {\n            n *= 16;\n            n += s.charCodeAt(i) - ASCII0;\n        } else if (97 <= s.charCodeAt(i) && s.charCodeAt(i) <= 102) {\n            n *= 16;\n            n += s.charCodeAt(i) - ASCIIa + 10;\n        } else if (65 <= s.charCodeAt(i) && s.charCodeAt(i) <= 70) {\n            n *= 16;\n            n += s.charCodeAt(i) - ASCIIA + 10;\n        } else {\n            break;\n        }\n        if (n >= 0xFFFFFF) {\n            return {\n                n: 0,\n                c: i,\n                ok: false\n            };\n        }\n    }\n    if (i === 0) {\n        return {\n            n: 0,\n            c: i,\n            ok: false\n        };\n    }\n    return {\n        n: n,\n        c: i,\n        ok: true\n    };\n}\nfunction isIPV4OrHostname(hp) {\n    if (hp.indexOf(\"[\") !== -1 || hp.indexOf(\"::\") !== -1) {\n        return false;\n    }\n    if (hp.indexOf(\".\") !== -1) {\n        return true;\n    }\n    if (hp.split(\":\").length <= 2) {\n        return true;\n    }\n    return false;\n}\nfunction isIPV6(hp) {\n    return !isIPV4OrHostname(hp);\n}\nfunction filterIpv6MappedToIpv4(hp) {\n    const prefix = \"::FFFF:\";\n    const idx = hp.toUpperCase().indexOf(prefix);\n    if (idx !== -1 && hp.indexOf(\".\") !== -1) {\n        let ip = hp.substring(idx + prefix.length);\n        ip = ip.replace(\"[\", \"\");\n        return ip.replace(\"]\", \"\");\n    }\n    return hp;\n}\nfunction hostPort(u) {\n    u = u.trim();\n    if (u.match(/^(.*:\\/\\/)(.*)/m)) {\n        u = u.replace(/^(.*:\\/\\/)(.*)/gm, \"$2\");\n    }\n    u = filterIpv6MappedToIpv4(u);\n    if (isIPV6(u) && u.indexOf(\"[\") === -1) {\n        u = `[${u}]`;\n    }\n    const op = isIPV6(u) ? u.match(/(]:)(\\d+)/) : u.match(/(:)(\\d+)/);\n    const port = op && op.length === 3 && op[1] && op[2] ? parseInt(op[2]) : 4222;\n    const protocol = port === 80 ? \"https\" : \"http\";\n    const url = new URL(`${protocol}://${u}`);\n    url.port = `${port}`;\n    let hostname = url.hostname;\n    if (hostname.charAt(0) === \"[\") {\n        hostname = hostname.substring(1, hostname.length - 1);\n    }\n    const listen = url.host;\n    return {\n        listen,\n        hostname,\n        port\n    };\n}\nclass ServerImpl {\n    src;\n    listen;\n    hostname;\n    port;\n    didConnect;\n    reconnects;\n    lastConnect;\n    gossiped;\n    tlsName;\n    resolves;\n    constructor(u, gossiped = false){\n        this.src = u;\n        this.tlsName = \"\";\n        const v = hostPort(u);\n        this.listen = v.listen;\n        this.hostname = v.hostname;\n        this.port = v.port;\n        this.didConnect = false;\n        this.reconnects = 0;\n        this.lastConnect = 0;\n        this.gossiped = gossiped;\n    }\n    toString() {\n        return this.listen;\n    }\n    async resolve(opts) {\n        if (!opts.fn || opts.resolve === false) {\n            return [\n                this\n            ];\n        }\n        const buf = [];\n        if (isIP(this.hostname)) {\n            return [\n                this\n            ];\n        } else {\n            const ips = await opts.fn(this.hostname);\n            if (opts.debug) {\n                console.log(`resolve ${this.hostname} = ${ips.join(\",\")}`);\n            }\n            for (const ip of ips){\n                const proto = this.port === 80 ? \"https\" : \"http\";\n                const url = new URL(`${proto}://${isIPV6(ip) ? \"[\" + ip + \"]\" : ip}`);\n                url.port = `${this.port}`;\n                const ss = new ServerImpl(url.host, false);\n                ss.tlsName = this.hostname;\n                buf.push(ss);\n            }\n        }\n        if (opts.randomize) {\n            shuffle(buf);\n        }\n        this.resolves = buf;\n        return buf;\n    }\n}\nclass Servers {\n    firstSelect;\n    servers;\n    currentServer;\n    tlsName;\n    randomize;\n    constructor(listens = [], opts = {}){\n        this.firstSelect = true;\n        this.servers = [];\n        this.tlsName = \"\";\n        this.randomize = opts.randomize || false;\n        const urlParseFn = getUrlParseFn();\n        if (listens) {\n            listens.forEach((hp)=>{\n                hp = urlParseFn ? urlParseFn(hp) : hp;\n                this.servers.push(new ServerImpl(hp));\n            });\n            if (this.randomize) {\n                this.servers = shuffle(this.servers);\n            }\n        }\n        if (this.servers.length === 0) {\n            this.addServer(`${DEFAULT_HOST}:${defaultPort()}`, false);\n        }\n        this.currentServer = this.servers[0];\n    }\n    clear() {\n        this.servers.length = 0;\n    }\n    updateTLSName() {\n        const cs = this.getCurrentServer();\n        if (!isIP(cs.hostname)) {\n            this.tlsName = cs.hostname;\n            this.servers.forEach((s)=>{\n                if (s.gossiped) {\n                    s.tlsName = this.tlsName;\n                }\n            });\n        }\n    }\n    getCurrentServer() {\n        return this.currentServer;\n    }\n    addServer(u, implicit = false) {\n        const urlParseFn = getUrlParseFn();\n        u = urlParseFn ? urlParseFn(u) : u;\n        const s = new ServerImpl(u, implicit);\n        if (isIP(s.hostname)) {\n            s.tlsName = this.tlsName;\n        }\n        this.servers.push(s);\n    }\n    selectServer() {\n        if (this.firstSelect) {\n            this.firstSelect = false;\n            return this.currentServer;\n        }\n        const t = this.servers.shift();\n        if (t) {\n            this.servers.push(t);\n            this.currentServer = t;\n        }\n        return t;\n    }\n    removeCurrentServer() {\n        this.removeServer(this.currentServer);\n    }\n    removeServer(server) {\n        if (server) {\n            const index = this.servers.indexOf(server);\n            this.servers.splice(index, 1);\n        }\n    }\n    length() {\n        return this.servers.length;\n    }\n    next() {\n        return this.servers.length ? this.servers[0] : undefined;\n    }\n    getServers() {\n        return this.servers;\n    }\n    update(info, encrypted) {\n        const added = [];\n        let deleted = [];\n        const urlParseFn = getUrlParseFn();\n        const discovered = new Map();\n        if (info.connect_urls && info.connect_urls.length > 0) {\n            info.connect_urls.forEach((hp)=>{\n                hp = urlParseFn ? urlParseFn(hp, encrypted) : hp;\n                const s = new ServerImpl(hp, true);\n                discovered.set(hp, s);\n            });\n        }\n        const toDelete = [];\n        this.servers.forEach((s, index)=>{\n            const u = s.listen;\n            if (s.gossiped && this.currentServer.listen !== u && discovered.get(u) === undefined) {\n                toDelete.push(index);\n            }\n            discovered.delete(u);\n        });\n        toDelete.reverse();\n        toDelete.forEach((index)=>{\n            const removed = this.servers.splice(index, 1);\n            deleted = deleted.concat(removed[0].listen);\n        });\n        discovered.forEach((v, k)=>{\n            this.servers.push(v);\n            added.push(k);\n        });\n        return {\n            added,\n            deleted\n        };\n    }\n}\nclass MuxSubscription {\n    baseInbox;\n    reqs;\n    constructor(){\n        this.reqs = new Map();\n    }\n    size() {\n        return this.reqs.size;\n    }\n    init(prefix) {\n        this.baseInbox = `${createInbox(prefix)}.`;\n        return this.baseInbox;\n    }\n    add(r) {\n        if (!isNaN(r.received)) {\n            r.received = 0;\n        }\n        this.reqs.set(r.token, r);\n    }\n    get(token) {\n        return this.reqs.get(token);\n    }\n    cancel(r) {\n        this.reqs.delete(r.token);\n    }\n    getToken(m) {\n        const s = m.subject || \"\";\n        if (s.indexOf(this.baseInbox) === 0) {\n            return s.substring(this.baseInbox.length);\n        }\n        return null;\n    }\n    all() {\n        return Array.from(this.reqs.values());\n    }\n    handleError(isMuxPermissionError, err) {\n        if (err && err.permissionContext) {\n            if (isMuxPermissionError) {\n                this.all().forEach((r)=>{\n                    r.resolver(err, {});\n                });\n                return true;\n            }\n            const ctx = err.permissionContext;\n            if (ctx.operation === \"publish\") {\n                const req = this.all().find((s)=>{\n                    return s.requestSubject === ctx.subject;\n                });\n                if (req) {\n                    req.resolver(err, {});\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    dispatcher() {\n        return (err, m)=>{\n            const token = this.getToken(m);\n            if (token) {\n                const r = this.get(token);\n                if (r) {\n                    if (err === null && m.headers) {\n                        err = isRequestError(m);\n                    }\n                    r.resolver(err, m);\n                }\n            }\n        };\n    }\n    close() {\n        const err = NatsError.errorForCode(ErrorCode.Timeout);\n        this.reqs.forEach((req)=>{\n            req.resolver(err, {});\n        });\n    }\n}\nclass Heartbeat {\n    ph;\n    interval;\n    maxOut;\n    timer;\n    pendings;\n    constructor(ph, interval, maxOut){\n        this.ph = ph;\n        this.interval = interval;\n        this.maxOut = maxOut;\n        this.pendings = [];\n    }\n    start() {\n        this.cancel();\n        this._schedule();\n    }\n    cancel(stale) {\n        if (this.timer) {\n            clearTimeout(this.timer);\n            this.timer = undefined;\n        }\n        this._reset();\n        if (stale) {\n            this.ph.disconnect();\n        }\n    }\n    _schedule() {\n        this.timer = setTimeout(()=>{\n            this.ph.dispatchStatus({\n                type: DebugEvents.PingTimer,\n                data: `${this.pendings.length + 1}`\n            });\n            if (this.pendings.length === this.maxOut) {\n                this.cancel(true);\n                return;\n            }\n            const ping = deferred();\n            this.ph.flush(ping).then(()=>{\n                this._reset();\n            }).catch(()=>{\n                this.cancel();\n            });\n            this.pendings.push(ping);\n            this._schedule();\n        }, this.interval);\n    }\n    _reset() {\n        this.pendings = this.pendings.filter((p)=>{\n            const d = p;\n            d.resolve();\n            return false;\n        });\n    }\n}\nclass AssertionError extends Error {\n    constructor(msg){\n        super(msg);\n        this.name = \"AssertionError\";\n    }\n}\nfunction assert(cond, msg = \"Assertion failed.\") {\n    if (!cond) {\n        throw new AssertionError(msg);\n    }\n}\nconst MIN_READ = 32 * 1024;\nconst MAX_SIZE = 2 ** 32 - 2;\nfunction copy(src, dst, off = 0) {\n    const r = dst.byteLength - off;\n    if (src.byteLength > r) {\n        src = src.subarray(0, r);\n    }\n    dst.set(src, off);\n    return src.byteLength;\n}\nclass DenoBuffer {\n    _buf;\n    _off;\n    constructor(ab){\n        this._off = 0;\n        if (ab == null) {\n            this._buf = new Uint8Array(0);\n            return;\n        }\n        this._buf = new Uint8Array(ab);\n    }\n    bytes(options = {\n        copy: true\n    }) {\n        if (options.copy === false) return this._buf.subarray(this._off);\n        return this._buf.slice(this._off);\n    }\n    empty() {\n        return this._buf.byteLength <= this._off;\n    }\n    get length() {\n        return this._buf.byteLength - this._off;\n    }\n    get capacity() {\n        return this._buf.buffer.byteLength;\n    }\n    truncate(n) {\n        if (n === 0) {\n            this.reset();\n            return;\n        }\n        if (n < 0 || n > this.length) {\n            throw Error(\"bytes.Buffer: truncation out of range\");\n        }\n        this._reslice(this._off + n);\n    }\n    reset() {\n        this._reslice(0);\n        this._off = 0;\n    }\n    _tryGrowByReslice(n) {\n        const l = this._buf.byteLength;\n        if (n <= this.capacity - l) {\n            this._reslice(l + n);\n            return l;\n        }\n        return -1;\n    }\n    _reslice(len) {\n        assert(len <= this._buf.buffer.byteLength);\n        this._buf = new Uint8Array(this._buf.buffer, 0, len);\n    }\n    readByte() {\n        const a = new Uint8Array(1);\n        if (this.read(a)) {\n            return a[0];\n        }\n        return null;\n    }\n    read(p) {\n        if (this.empty()) {\n            this.reset();\n            if (p.byteLength === 0) {\n                return 0;\n            }\n            return null;\n        }\n        const nread = copy(this._buf.subarray(this._off), p);\n        this._off += nread;\n        return nread;\n    }\n    writeByte(n) {\n        return this.write(Uint8Array.of(n));\n    }\n    writeString(s) {\n        return this.write(TE.encode(s));\n    }\n    write(p) {\n        const m = this._grow(p.byteLength);\n        return copy(p, this._buf, m);\n    }\n    _grow(n) {\n        const m = this.length;\n        if (m === 0 && this._off !== 0) {\n            this.reset();\n        }\n        const i = this._tryGrowByReslice(n);\n        if (i >= 0) {\n            return i;\n        }\n        const c = this.capacity;\n        if (n <= Math.floor(c / 2) - m) {\n            copy(this._buf.subarray(this._off), this._buf);\n        } else if (c + n > MAX_SIZE) {\n            throw new Error(\"The buffer cannot be grown beyond the maximum size.\");\n        } else {\n            const buf = new Uint8Array(Math.min(2 * c + n, MAX_SIZE));\n            copy(this._buf.subarray(this._off), buf);\n            this._buf = buf;\n        }\n        this._off = 0;\n        this._reslice(Math.min(m + n, MAX_SIZE));\n        return m;\n    }\n    grow(n) {\n        if (n < 0) {\n            throw Error(\"Buffer._grow: negative count\");\n        }\n        const m = this._grow(n);\n        this._reslice(m);\n    }\n    readFrom(r) {\n        let n = 0;\n        const tmp = new Uint8Array(MIN_READ);\n        while(true){\n            const shouldGrow = this.capacity - this.length < MIN_READ;\n            const buf = shouldGrow ? tmp : new Uint8Array(this._buf.buffer, this.length);\n            const nread = r.read(buf);\n            if (nread === null) {\n                return n;\n            }\n            if (shouldGrow) this.write(buf.subarray(0, nread));\n            else this._reslice(this.length + nread);\n            n += nread;\n        }\n    }\n}\nvar Kind;\n(function(Kind) {\n    Kind[Kind[\"OK\"] = 0] = \"OK\";\n    Kind[Kind[\"ERR\"] = 1] = \"ERR\";\n    Kind[Kind[\"MSG\"] = 2] = \"MSG\";\n    Kind[Kind[\"INFO\"] = 3] = \"INFO\";\n    Kind[Kind[\"PING\"] = 4] = \"PING\";\n    Kind[Kind[\"PONG\"] = 5] = \"PONG\";\n})(Kind || (Kind = {}));\nfunction newMsgArg() {\n    const ma = {};\n    ma.sid = -1;\n    ma.hdr = -1;\n    ma.size = -1;\n    return ma;\n}\nconst ASCII_0 = 48;\nclass Parser {\n    dispatcher;\n    state;\n    as;\n    drop;\n    hdr;\n    ma;\n    argBuf;\n    msgBuf;\n    constructor(dispatcher){\n        this.dispatcher = dispatcher;\n        this.state = State.OP_START;\n        this.as = 0;\n        this.drop = 0;\n        this.hdr = 0;\n    }\n    parse(buf) {\n        let i;\n        for(i = 0; i < buf.length; i++){\n            const b = buf[i];\n            switch(this.state){\n                case State.OP_START:\n                    switch(b){\n                        case cc.M:\n                        case cc.m:\n                            this.state = State.OP_M;\n                            this.hdr = -1;\n                            this.ma = newMsgArg();\n                            break;\n                        case cc.H:\n                        case cc.h:\n                            this.state = State.OP_H;\n                            this.hdr = 0;\n                            this.ma = newMsgArg();\n                            break;\n                        case cc.P:\n                        case cc.p:\n                            this.state = State.OP_P;\n                            break;\n                        case cc.PLUS:\n                            this.state = State.OP_PLUS;\n                            break;\n                        case cc.MINUS:\n                            this.state = State.OP_MINUS;\n                            break;\n                        case cc.I:\n                        case cc.i:\n                            this.state = State.OP_I;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_H:\n                    switch(b){\n                        case cc.M:\n                        case cc.m:\n                            this.state = State.OP_M;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_M:\n                    switch(b){\n                        case cc.S:\n                        case cc.s:\n                            this.state = State.OP_MS;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MS:\n                    switch(b){\n                        case cc.G:\n                        case cc.g:\n                            this.state = State.OP_MSG;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MSG:\n                    switch(b){\n                        case cc.SPACE:\n                        case cc.TAB:\n                            this.state = State.OP_MSG_SPC;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MSG_SPC:\n                    switch(b){\n                        case cc.SPACE:\n                        case cc.TAB:\n                            continue;\n                        default:\n                            this.state = State.MSG_ARG;\n                            this.as = i;\n                    }\n                    break;\n                case State.MSG_ARG:\n                    switch(b){\n                        case cc.CR:\n                            this.drop = 1;\n                            break;\n                        case cc.NL:\n                            {\n                                const arg = this.argBuf ? this.argBuf.bytes() : buf.subarray(this.as, i - this.drop);\n                                this.processMsgArgs(arg);\n                                this.drop = 0;\n                                this.as = i + 1;\n                                this.state = State.MSG_PAYLOAD;\n                                i = this.as + this.ma.size - 1;\n                                break;\n                            }\n                        default:\n                            if (this.argBuf) {\n                                this.argBuf.writeByte(b);\n                            }\n                    }\n                    break;\n                case State.MSG_PAYLOAD:\n                    if (this.msgBuf) {\n                        if (this.msgBuf.length >= this.ma.size) {\n                            const data = this.msgBuf.bytes({\n                                copy: false\n                            });\n                            this.dispatcher.push({\n                                kind: Kind.MSG,\n                                msg: this.ma,\n                                data: data\n                            });\n                            this.argBuf = undefined;\n                            this.msgBuf = undefined;\n                            this.state = State.MSG_END;\n                        } else {\n                            let toCopy = this.ma.size - this.msgBuf.length;\n                            const avail = buf.length - i;\n                            if (avail < toCopy) {\n                                toCopy = avail;\n                            }\n                            if (toCopy > 0) {\n                                this.msgBuf.write(buf.subarray(i, i + toCopy));\n                                i = i + toCopy - 1;\n                            } else {\n                                this.msgBuf.writeByte(b);\n                            }\n                        }\n                    } else if (i - this.as >= this.ma.size) {\n                        this.dispatcher.push({\n                            kind: Kind.MSG,\n                            msg: this.ma,\n                            data: buf.subarray(this.as, i)\n                        });\n                        this.argBuf = undefined;\n                        this.msgBuf = undefined;\n                        this.state = State.MSG_END;\n                    }\n                    break;\n                case State.MSG_END:\n                    switch(b){\n                        case cc.NL:\n                            this.drop = 0;\n                            this.as = i + 1;\n                            this.state = State.OP_START;\n                            break;\n                        default:\n                            continue;\n                    }\n                    break;\n                case State.OP_PLUS:\n                    switch(b){\n                        case cc.O:\n                        case cc.o:\n                            this.state = State.OP_PLUS_O;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PLUS_O:\n                    switch(b){\n                        case cc.K:\n                        case cc.k:\n                            this.state = State.OP_PLUS_OK;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PLUS_OK:\n                    switch(b){\n                        case cc.NL:\n                            this.dispatcher.push({\n                                kind: Kind.OK\n                            });\n                            this.drop = 0;\n                            this.state = State.OP_START;\n                            break;\n                    }\n                    break;\n                case State.OP_MINUS:\n                    switch(b){\n                        case cc.E:\n                        case cc.e:\n                            this.state = State.OP_MINUS_E;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MINUS_E:\n                    switch(b){\n                        case cc.R:\n                        case cc.r:\n                            this.state = State.OP_MINUS_ER;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MINUS_ER:\n                    switch(b){\n                        case cc.R:\n                        case cc.r:\n                            this.state = State.OP_MINUS_ERR;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MINUS_ERR:\n                    switch(b){\n                        case cc.SPACE:\n                        case cc.TAB:\n                            this.state = State.OP_MINUS_ERR_SPC;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MINUS_ERR_SPC:\n                    switch(b){\n                        case cc.SPACE:\n                        case cc.TAB:\n                            continue;\n                        default:\n                            this.state = State.MINUS_ERR_ARG;\n                            this.as = i;\n                    }\n                    break;\n                case State.MINUS_ERR_ARG:\n                    switch(b){\n                        case cc.CR:\n                            this.drop = 1;\n                            break;\n                        case cc.NL:\n                            {\n                                let arg;\n                                if (this.argBuf) {\n                                    arg = this.argBuf.bytes();\n                                    this.argBuf = undefined;\n                                } else {\n                                    arg = buf.subarray(this.as, i - this.drop);\n                                }\n                                this.dispatcher.push({\n                                    kind: Kind.ERR,\n                                    data: arg\n                                });\n                                this.drop = 0;\n                                this.as = i + 1;\n                                this.state = State.OP_START;\n                                break;\n                            }\n                        default:\n                            if (this.argBuf) {\n                                this.argBuf.write(Uint8Array.of(b));\n                            }\n                    }\n                    break;\n                case State.OP_P:\n                    switch(b){\n                        case cc.I:\n                        case cc.i:\n                            this.state = State.OP_PI;\n                            break;\n                        case cc.O:\n                        case cc.o:\n                            this.state = State.OP_PO;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PO:\n                    switch(b){\n                        case cc.N:\n                        case cc.n:\n                            this.state = State.OP_PON;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PON:\n                    switch(b){\n                        case cc.G:\n                        case cc.g:\n                            this.state = State.OP_PONG;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PONG:\n                    switch(b){\n                        case cc.NL:\n                            this.dispatcher.push({\n                                kind: Kind.PONG\n                            });\n                            this.drop = 0;\n                            this.state = State.OP_START;\n                            break;\n                    }\n                    break;\n                case State.OP_PI:\n                    switch(b){\n                        case cc.N:\n                        case cc.n:\n                            this.state = State.OP_PIN;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PIN:\n                    switch(b){\n                        case cc.G:\n                        case cc.g:\n                            this.state = State.OP_PING;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PING:\n                    switch(b){\n                        case cc.NL:\n                            this.dispatcher.push({\n                                kind: Kind.PING\n                            });\n                            this.drop = 0;\n                            this.state = State.OP_START;\n                            break;\n                    }\n                    break;\n                case State.OP_I:\n                    switch(b){\n                        case cc.N:\n                        case cc.n:\n                            this.state = State.OP_IN;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_IN:\n                    switch(b){\n                        case cc.F:\n                        case cc.f:\n                            this.state = State.OP_INF;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_INF:\n                    switch(b){\n                        case cc.O:\n                        case cc.o:\n                            this.state = State.OP_INFO;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_INFO:\n                    switch(b){\n                        case cc.SPACE:\n                        case cc.TAB:\n                            this.state = State.OP_INFO_SPC;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_INFO_SPC:\n                    switch(b){\n                        case cc.SPACE:\n                        case cc.TAB:\n                            continue;\n                        default:\n                            this.state = State.INFO_ARG;\n                            this.as = i;\n                    }\n                    break;\n                case State.INFO_ARG:\n                    switch(b){\n                        case cc.CR:\n                            this.drop = 1;\n                            break;\n                        case cc.NL:\n                            {\n                                let arg;\n                                if (this.argBuf) {\n                                    arg = this.argBuf.bytes();\n                                    this.argBuf = undefined;\n                                } else {\n                                    arg = buf.subarray(this.as, i - this.drop);\n                                }\n                                this.dispatcher.push({\n                                    kind: Kind.INFO,\n                                    data: arg\n                                });\n                                this.drop = 0;\n                                this.as = i + 1;\n                                this.state = State.OP_START;\n                                break;\n                            }\n                        default:\n                            if (this.argBuf) {\n                                this.argBuf.writeByte(b);\n                            }\n                    }\n                    break;\n                default:\n                    throw this.fail(buf.subarray(i));\n            }\n        }\n        if ((this.state === State.MSG_ARG || this.state === State.MINUS_ERR_ARG || this.state === State.INFO_ARG) && !this.argBuf) {\n            this.argBuf = new DenoBuffer(buf.subarray(this.as, i - this.drop));\n        }\n        if (this.state === State.MSG_PAYLOAD && !this.msgBuf) {\n            if (!this.argBuf) {\n                this.cloneMsgArg();\n            }\n            this.msgBuf = new DenoBuffer(buf.subarray(this.as));\n        }\n    }\n    cloneMsgArg() {\n        const s = this.ma.subject.length;\n        const r = this.ma.reply ? this.ma.reply.length : 0;\n        const buf = new Uint8Array(s + r);\n        buf.set(this.ma.subject);\n        if (this.ma.reply) {\n            buf.set(this.ma.reply, s);\n        }\n        this.argBuf = new DenoBuffer(buf);\n        this.ma.subject = buf.subarray(0, s);\n        if (this.ma.reply) {\n            this.ma.reply = buf.subarray(s);\n        }\n    }\n    processMsgArgs(arg) {\n        if (this.hdr >= 0) {\n            return this.processHeaderMsgArgs(arg);\n        }\n        const args = [];\n        let start = -1;\n        for(let i = 0; i < arg.length; i++){\n            const b = arg[i];\n            switch(b){\n                case cc.SPACE:\n                case cc.TAB:\n                case cc.CR:\n                case cc.NL:\n                    if (start >= 0) {\n                        args.push(arg.subarray(start, i));\n                        start = -1;\n                    }\n                    break;\n                default:\n                    if (start < 0) {\n                        start = i;\n                    }\n            }\n        }\n        if (start >= 0) {\n            args.push(arg.subarray(start));\n        }\n        switch(args.length){\n            case 3:\n                this.ma.subject = args[0];\n                this.ma.sid = this.protoParseInt(args[1]);\n                this.ma.reply = undefined;\n                this.ma.size = this.protoParseInt(args[2]);\n                break;\n            case 4:\n                this.ma.subject = args[0];\n                this.ma.sid = this.protoParseInt(args[1]);\n                this.ma.reply = args[2];\n                this.ma.size = this.protoParseInt(args[3]);\n                break;\n            default:\n                throw this.fail(arg, \"processMsgArgs Parse Error\");\n        }\n        if (this.ma.sid < 0) {\n            throw this.fail(arg, \"processMsgArgs Bad or Missing Sid Error\");\n        }\n        if (this.ma.size < 0) {\n            throw this.fail(arg, \"processMsgArgs Bad or Missing Size Error\");\n        }\n    }\n    fail(data, label = \"\") {\n        if (!label) {\n            label = `parse error [${this.state}]`;\n        } else {\n            label = `${label} [${this.state}]`;\n        }\n        return new Error(`${label}: ${TD.decode(data)}`);\n    }\n    processHeaderMsgArgs(arg) {\n        const args = [];\n        let start = -1;\n        for(let i = 0; i < arg.length; i++){\n            const b = arg[i];\n            switch(b){\n                case cc.SPACE:\n                case cc.TAB:\n                case cc.CR:\n                case cc.NL:\n                    if (start >= 0) {\n                        args.push(arg.subarray(start, i));\n                        start = -1;\n                    }\n                    break;\n                default:\n                    if (start < 0) {\n                        start = i;\n                    }\n            }\n        }\n        if (start >= 0) {\n            args.push(arg.subarray(start));\n        }\n        switch(args.length){\n            case 4:\n                this.ma.subject = args[0];\n                this.ma.sid = this.protoParseInt(args[1]);\n                this.ma.reply = undefined;\n                this.ma.hdr = this.protoParseInt(args[2]);\n                this.ma.size = this.protoParseInt(args[3]);\n                break;\n            case 5:\n                this.ma.subject = args[0];\n                this.ma.sid = this.protoParseInt(args[1]);\n                this.ma.reply = args[2];\n                this.ma.hdr = this.protoParseInt(args[3]);\n                this.ma.size = this.protoParseInt(args[4]);\n                break;\n            default:\n                throw this.fail(arg, \"processHeaderMsgArgs Parse Error\");\n        }\n        if (this.ma.sid < 0) {\n            throw this.fail(arg, \"processHeaderMsgArgs Bad or Missing Sid Error\");\n        }\n        if (this.ma.hdr < 0 || this.ma.hdr > this.ma.size) {\n            throw this.fail(arg, \"processHeaderMsgArgs Bad or Missing Header Size Error\");\n        }\n        if (this.ma.size < 0) {\n            throw this.fail(arg, \"processHeaderMsgArgs Bad or Missing Size Error\");\n        }\n    }\n    protoParseInt(a) {\n        if (a.length === 0) {\n            return -1;\n        }\n        let n = 0;\n        for(let i = 0; i < a.length; i++){\n            if (a[i] < 48 || a[i] > 57) {\n                return -1;\n            }\n            n = n * 10 + (a[i] - ASCII_0);\n        }\n        return n;\n    }\n}\nvar State;\n(function(State) {\n    State[State[\"OP_START\"] = 0] = \"OP_START\";\n    State[State[\"OP_PLUS\"] = 1] = \"OP_PLUS\";\n    State[State[\"OP_PLUS_O\"] = 2] = \"OP_PLUS_O\";\n    State[State[\"OP_PLUS_OK\"] = 3] = \"OP_PLUS_OK\";\n    State[State[\"OP_MINUS\"] = 4] = \"OP_MINUS\";\n    State[State[\"OP_MINUS_E\"] = 5] = \"OP_MINUS_E\";\n    State[State[\"OP_MINUS_ER\"] = 6] = \"OP_MINUS_ER\";\n    State[State[\"OP_MINUS_ERR\"] = 7] = \"OP_MINUS_ERR\";\n    State[State[\"OP_MINUS_ERR_SPC\"] = 8] = \"OP_MINUS_ERR_SPC\";\n    State[State[\"MINUS_ERR_ARG\"] = 9] = \"MINUS_ERR_ARG\";\n    State[State[\"OP_M\"] = 10] = \"OP_M\";\n    State[State[\"OP_MS\"] = 11] = \"OP_MS\";\n    State[State[\"OP_MSG\"] = 12] = \"OP_MSG\";\n    State[State[\"OP_MSG_SPC\"] = 13] = \"OP_MSG_SPC\";\n    State[State[\"MSG_ARG\"] = 14] = \"MSG_ARG\";\n    State[State[\"MSG_PAYLOAD\"] = 15] = \"MSG_PAYLOAD\";\n    State[State[\"MSG_END\"] = 16] = \"MSG_END\";\n    State[State[\"OP_H\"] = 17] = \"OP_H\";\n    State[State[\"OP_P\"] = 18] = \"OP_P\";\n    State[State[\"OP_PI\"] = 19] = \"OP_PI\";\n    State[State[\"OP_PIN\"] = 20] = \"OP_PIN\";\n    State[State[\"OP_PING\"] = 21] = \"OP_PING\";\n    State[State[\"OP_PO\"] = 22] = \"OP_PO\";\n    State[State[\"OP_PON\"] = 23] = \"OP_PON\";\n    State[State[\"OP_PONG\"] = 24] = \"OP_PONG\";\n    State[State[\"OP_I\"] = 25] = \"OP_I\";\n    State[State[\"OP_IN\"] = 26] = \"OP_IN\";\n    State[State[\"OP_INF\"] = 27] = \"OP_INF\";\n    State[State[\"OP_INFO\"] = 28] = \"OP_INFO\";\n    State[State[\"OP_INFO_SPC\"] = 29] = \"OP_INFO_SPC\";\n    State[State[\"INFO_ARG\"] = 30] = \"INFO_ARG\";\n})(State || (State = {}));\nvar cc;\n(function(cc) {\n    cc[cc[\"CR\"] = \"\\r\".charCodeAt(0)] = \"CR\";\n    cc[cc[\"E\"] = \"E\".charCodeAt(0)] = \"E\";\n    cc[cc[\"e\"] = \"e\".charCodeAt(0)] = \"e\";\n    cc[cc[\"F\"] = \"F\".charCodeAt(0)] = \"F\";\n    cc[cc[\"f\"] = \"f\".charCodeAt(0)] = \"f\";\n    cc[cc[\"G\"] = \"G\".charCodeAt(0)] = \"G\";\n    cc[cc[\"g\"] = \"g\".charCodeAt(0)] = \"g\";\n    cc[cc[\"H\"] = \"H\".charCodeAt(0)] = \"H\";\n    cc[cc[\"h\"] = \"h\".charCodeAt(0)] = \"h\";\n    cc[cc[\"I\"] = \"I\".charCodeAt(0)] = \"I\";\n    cc[cc[\"i\"] = \"i\".charCodeAt(0)] = \"i\";\n    cc[cc[\"K\"] = \"K\".charCodeAt(0)] = \"K\";\n    cc[cc[\"k\"] = \"k\".charCodeAt(0)] = \"k\";\n    cc[cc[\"M\"] = \"M\".charCodeAt(0)] = \"M\";\n    cc[cc[\"m\"] = \"m\".charCodeAt(0)] = \"m\";\n    cc[cc[\"MINUS\"] = \"-\".charCodeAt(0)] = \"MINUS\";\n    cc[cc[\"N\"] = \"N\".charCodeAt(0)] = \"N\";\n    cc[cc[\"n\"] = \"n\".charCodeAt(0)] = \"n\";\n    cc[cc[\"NL\"] = \"\\n\".charCodeAt(0)] = \"NL\";\n    cc[cc[\"O\"] = \"O\".charCodeAt(0)] = \"O\";\n    cc[cc[\"o\"] = \"o\".charCodeAt(0)] = \"o\";\n    cc[cc[\"P\"] = \"P\".charCodeAt(0)] = \"P\";\n    cc[cc[\"p\"] = \"p\".charCodeAt(0)] = \"p\";\n    cc[cc[\"PLUS\"] = \"+\".charCodeAt(0)] = \"PLUS\";\n    cc[cc[\"R\"] = \"R\".charCodeAt(0)] = \"R\";\n    cc[cc[\"r\"] = \"r\".charCodeAt(0)] = \"r\";\n    cc[cc[\"S\"] = \"S\".charCodeAt(0)] = \"S\";\n    cc[cc[\"s\"] = \"s\".charCodeAt(0)] = \"s\";\n    cc[cc[\"SPACE\"] = \" \".charCodeAt(0)] = \"SPACE\";\n    cc[cc[\"TAB\"] = \"\\t\".charCodeAt(0)] = \"TAB\";\n})(cc || (cc = {}));\n(function(nacl) {\n    'use strict';\n    var u64 = function(h, l) {\n        this.hi = h | 0 >>> 0;\n        this.lo = l | 0 >>> 0;\n    };\n    var gf = function(init) {\n        var i, r = new Float64Array(16);\n        if (init) for(i = 0; i < init.length; i++)r[i] = init[i];\n        return r;\n    };\n    var randombytes = function() {\n        throw new Error('no PRNG');\n    };\n    var _0 = new Uint8Array(16);\n    var _9 = new Uint8Array(32);\n    _9[0] = 9;\n    var gf0 = gf(), gf1 = gf([\n        1\n    ]), _121665 = gf([\n        0xdb41,\n        1\n    ]), D = gf([\n        0x78a3,\n        0x1359,\n        0x4dca,\n        0x75eb,\n        0xd8ab,\n        0x4141,\n        0x0a4d,\n        0x0070,\n        0xe898,\n        0x7779,\n        0x4079,\n        0x8cc7,\n        0xfe73,\n        0x2b6f,\n        0x6cee,\n        0x5203\n    ]), D2 = gf([\n        0xf159,\n        0x26b2,\n        0x9b94,\n        0xebd6,\n        0xb156,\n        0x8283,\n        0x149a,\n        0x00e0,\n        0xd130,\n        0xeef3,\n        0x80f2,\n        0x198e,\n        0xfce7,\n        0x56df,\n        0xd9dc,\n        0x2406\n    ]), X = gf([\n        0xd51a,\n        0x8f25,\n        0x2d60,\n        0xc956,\n        0xa7b2,\n        0x9525,\n        0xc760,\n        0x692c,\n        0xdc5c,\n        0xfdd6,\n        0xe231,\n        0xc0a4,\n        0x53fe,\n        0xcd6e,\n        0x36d3,\n        0x2169\n    ]), Y = gf([\n        0x6658,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666,\n        0x6666\n    ]), I = gf([\n        0xa0b0,\n        0x4a0e,\n        0x1b27,\n        0xc4ee,\n        0xe478,\n        0xad2f,\n        0x1806,\n        0x2f43,\n        0xd7a7,\n        0x3dfb,\n        0x0099,\n        0x2b4d,\n        0xdf0b,\n        0x4fc1,\n        0x2480,\n        0x2b83\n    ]);\n    function L32(x, c) {\n        return x << c | x >>> 32 - c;\n    }\n    function ld32(x, i) {\n        var u = x[i + 3] & 0xff;\n        u = u << 8 | x[i + 2] & 0xff;\n        u = u << 8 | x[i + 1] & 0xff;\n        return u << 8 | x[i + 0] & 0xff;\n    }\n    function dl64(x, i) {\n        var h = x[i] << 24 | x[i + 1] << 16 | x[i + 2] << 8 | x[i + 3];\n        var l = x[i + 4] << 24 | x[i + 5] << 16 | x[i + 6] << 8 | x[i + 7];\n        return new u64(h, l);\n    }\n    function st32(x, j, u) {\n        var i;\n        for(i = 0; i < 4; i++){\n            x[j + i] = u & 255;\n            u >>>= 8;\n        }\n    }\n    function ts64(x, i, u) {\n        x[i] = u.hi >> 24 & 0xff;\n        x[i + 1] = u.hi >> 16 & 0xff;\n        x[i + 2] = u.hi >> 8 & 0xff;\n        x[i + 3] = u.hi & 0xff;\n        x[i + 4] = u.lo >> 24 & 0xff;\n        x[i + 5] = u.lo >> 16 & 0xff;\n        x[i + 6] = u.lo >> 8 & 0xff;\n        x[i + 7] = u.lo & 0xff;\n    }\n    function vn(x, xi, y, yi, n) {\n        var i, d = 0;\n        for(i = 0; i < n; i++)d |= x[xi + i] ^ y[yi + i];\n        return (1 & d - 1 >>> 8) - 1;\n    }\n    function crypto_verify_16(x, xi, y, yi) {\n        return vn(x, xi, y, yi, 16);\n    }\n    function crypto_verify_32(x, xi, y, yi) {\n        return vn(x, xi, y, yi, 32);\n    }\n    function core(out, inp, k, c, h) {\n        var w = new Uint32Array(16), x = new Uint32Array(16), y = new Uint32Array(16), t = new Uint32Array(4);\n        var i, j, m;\n        for(i = 0; i < 4; i++){\n            x[5 * i] = ld32(c, 4 * i);\n            x[1 + i] = ld32(k, 4 * i);\n            x[6 + i] = ld32(inp, 4 * i);\n            x[11 + i] = ld32(k, 16 + 4 * i);\n        }\n        for(i = 0; i < 16; i++)y[i] = x[i];\n        for(i = 0; i < 20; i++){\n            for(j = 0; j < 4; j++){\n                for(m = 0; m < 4; m++)t[m] = x[(5 * j + 4 * m) % 16];\n                t[1] ^= L32(t[0] + t[3] | 0, 7);\n                t[2] ^= L32(t[1] + t[0] | 0, 9);\n                t[3] ^= L32(t[2] + t[1] | 0, 13);\n                t[0] ^= L32(t[3] + t[2] | 0, 18);\n                for(m = 0; m < 4; m++)w[4 * j + (j + m) % 4] = t[m];\n            }\n            for(m = 0; m < 16; m++)x[m] = w[m];\n        }\n        if (h) {\n            for(i = 0; i < 16; i++)x[i] = x[i] + y[i] | 0;\n            for(i = 0; i < 4; i++){\n                x[5 * i] = x[5 * i] - ld32(c, 4 * i) | 0;\n                x[6 + i] = x[6 + i] - ld32(inp, 4 * i) | 0;\n            }\n            for(i = 0; i < 4; i++){\n                st32(out, 4 * i, x[5 * i]);\n                st32(out, 16 + 4 * i, x[6 + i]);\n            }\n        } else {\n            for(i = 0; i < 16; i++)st32(out, 4 * i, x[i] + y[i] | 0);\n        }\n    }\n    function crypto_core_salsa20(out, inp, k, c) {\n        core(out, inp, k, c, false);\n        return 0;\n    }\n    function crypto_core_hsalsa20(out, inp, k, c) {\n        core(out, inp, k, c, true);\n        return 0;\n    }\n    var sigma = new Uint8Array([\n        101,\n        120,\n        112,\n        97,\n        110,\n        100,\n        32,\n        51,\n        50,\n        45,\n        98,\n        121,\n        116,\n        101,\n        32,\n        107\n    ]);\n    function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {\n        var z = new Uint8Array(16), x = new Uint8Array(64);\n        var u, i;\n        if (!b) return 0;\n        for(i = 0; i < 16; i++)z[i] = 0;\n        for(i = 0; i < 8; i++)z[i] = n[i];\n        while(b >= 64){\n            crypto_core_salsa20(x, z, k, sigma);\n            for(i = 0; i < 64; i++)c[cpos + i] = (m ? m[mpos + i] : 0) ^ x[i];\n            u = 1;\n            for(i = 8; i < 16; i++){\n                u = u + (z[i] & 0xff) | 0;\n                z[i] = u & 0xff;\n                u >>>= 8;\n            }\n            b -= 64;\n            cpos += 64;\n            if (m) mpos += 64;\n        }\n        if (b > 0) {\n            crypto_core_salsa20(x, z, k, sigma);\n            for(i = 0; i < b; i++)c[cpos + i] = (m ? m[mpos + i] : 0) ^ x[i];\n        }\n        return 0;\n    }\n    function crypto_stream_salsa20(c, cpos, d, n, k) {\n        return crypto_stream_salsa20_xor(c, cpos, null, 0, d, n, k);\n    }\n    function crypto_stream(c, cpos, d, n, k) {\n        var s = new Uint8Array(32);\n        crypto_core_hsalsa20(s, n, k, sigma);\n        return crypto_stream_salsa20(c, cpos, d, n.subarray(16), s);\n    }\n    function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {\n        var s = new Uint8Array(32);\n        crypto_core_hsalsa20(s, n, k, sigma);\n        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, n.subarray(16), s);\n    }\n    function add1305(h, c) {\n        var j, u = 0;\n        for(j = 0; j < 17; j++){\n            u = u + (h[j] + c[j] | 0) | 0;\n            h[j] = u & 255;\n            u >>>= 8;\n        }\n    }\n    var minusp = new Uint32Array([\n        5,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        252\n    ]);\n    function crypto_onetimeauth(out, outpos, m, mpos, n, k) {\n        var s, i, j, u;\n        var x = new Uint32Array(17), r = new Uint32Array(17), h = new Uint32Array(17), c = new Uint32Array(17), g = new Uint32Array(17);\n        for(j = 0; j < 17; j++)r[j] = h[j] = 0;\n        for(j = 0; j < 16; j++)r[j] = k[j];\n        r[3] &= 15;\n        r[4] &= 252;\n        r[7] &= 15;\n        r[8] &= 252;\n        r[11] &= 15;\n        r[12] &= 252;\n        r[15] &= 15;\n        while(n > 0){\n            for(j = 0; j < 17; j++)c[j] = 0;\n            for(j = 0; j < 16 && j < n; ++j)c[j] = m[mpos + j];\n            c[j] = 1;\n            mpos += j;\n            n -= j;\n            add1305(h, c);\n            for(i = 0; i < 17; i++){\n                x[i] = 0;\n                for(j = 0; j < 17; j++)x[i] = x[i] + h[j] * (j <= i ? r[i - j] : 320 * r[i + 17 - j] | 0) | 0 | 0;\n            }\n            for(i = 0; i < 17; i++)h[i] = x[i];\n            u = 0;\n            for(j = 0; j < 16; j++){\n                u = u + h[j] | 0;\n                h[j] = u & 255;\n                u >>>= 8;\n            }\n            u = u + h[16] | 0;\n            h[16] = u & 3;\n            u = 5 * (u >>> 2) | 0;\n            for(j = 0; j < 16; j++){\n                u = u + h[j] | 0;\n                h[j] = u & 255;\n                u >>>= 8;\n            }\n            u = u + h[16] | 0;\n            h[16] = u;\n        }\n        for(j = 0; j < 17; j++)g[j] = h[j];\n        add1305(h, minusp);\n        s = -(h[16] >>> 7) | 0;\n        for(j = 0; j < 17; j++)h[j] ^= s & (g[j] ^ h[j]);\n        for(j = 0; j < 16; j++)c[j] = k[j + 16];\n        c[16] = 0;\n        add1305(h, c);\n        for(j = 0; j < 16; j++)out[outpos + j] = h[j];\n        return 0;\n    }\n    function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {\n        var x = new Uint8Array(16);\n        crypto_onetimeauth(x, 0, m, mpos, n, k);\n        return crypto_verify_16(h, hpos, x, 0);\n    }\n    function crypto_secretbox(c, m, d, n, k) {\n        var i;\n        if (d < 32) return -1;\n        crypto_stream_xor(c, 0, m, 0, d, n, k);\n        crypto_onetimeauth(c, 16, c, 32, d - 32, c);\n        for(i = 0; i < 16; i++)c[i] = 0;\n        return 0;\n    }\n    function crypto_secretbox_open(m, c, d, n, k) {\n        var i;\n        var x = new Uint8Array(32);\n        if (d < 32) return -1;\n        crypto_stream(x, 0, 32, n, k);\n        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0) return -1;\n        crypto_stream_xor(m, 0, c, 0, d, n, k);\n        for(i = 0; i < 32; i++)m[i] = 0;\n        return 0;\n    }\n    function set25519(r, a) {\n        var i;\n        for(i = 0; i < 16; i++)r[i] = a[i] | 0;\n    }\n    function car25519(o) {\n        var c;\n        var i;\n        for(i = 0; i < 16; i++){\n            o[i] += 65536;\n            c = Math.floor(o[i] / 65536);\n            o[(i + 1) * (i < 15 ? 1 : 0)] += c - 1 + 37 * (c - 1) * (i === 15 ? 1 : 0);\n            o[i] -= c * 65536;\n        }\n    }\n    function sel25519(p, q, b) {\n        var t, c = ~(b - 1);\n        for(var i = 0; i < 16; i++){\n            t = c & (p[i] ^ q[i]);\n            p[i] ^= t;\n            q[i] ^= t;\n        }\n    }\n    function pack25519(o, n) {\n        var i, j, b;\n        var m = gf(), t = gf();\n        for(i = 0; i < 16; i++)t[i] = n[i];\n        car25519(t);\n        car25519(t);\n        car25519(t);\n        for(j = 0; j < 2; j++){\n            m[0] = t[0] - 0xffed;\n            for(i = 1; i < 15; i++){\n                m[i] = t[i] - 0xffff - (m[i - 1] >> 16 & 1);\n                m[i - 1] &= 0xffff;\n            }\n            m[15] = t[15] - 0x7fff - (m[14] >> 16 & 1);\n            b = m[15] >> 16 & 1;\n            m[14] &= 0xffff;\n            sel25519(t, m, 1 - b);\n        }\n        for(i = 0; i < 16; i++){\n            o[2 * i] = t[i] & 0xff;\n            o[2 * i + 1] = t[i] >> 8;\n        }\n    }\n    function neq25519(a, b) {\n        var c = new Uint8Array(32), d = new Uint8Array(32);\n        pack25519(c, a);\n        pack25519(d, b);\n        return crypto_verify_32(c, 0, d, 0);\n    }\n    function par25519(a) {\n        var d = new Uint8Array(32);\n        pack25519(d, a);\n        return d[0] & 1;\n    }\n    function unpack25519(o, n) {\n        var i;\n        for(i = 0; i < 16; i++)o[i] = n[2 * i] + (n[2 * i + 1] << 8);\n        o[15] &= 0x7fff;\n    }\n    function A(o, a, b) {\n        var i;\n        for(i = 0; i < 16; i++)o[i] = a[i] + b[i] | 0;\n    }\n    function Z(o, a, b) {\n        var i;\n        for(i = 0; i < 16; i++)o[i] = a[i] - b[i] | 0;\n    }\n    function M(o, a, b) {\n        var i, j, t = new Float64Array(31);\n        for(i = 0; i < 31; i++)t[i] = 0;\n        for(i = 0; i < 16; i++){\n            for(j = 0; j < 16; j++){\n                t[i + j] += a[i] * b[j];\n            }\n        }\n        for(i = 0; i < 15; i++){\n            t[i] += 38 * t[i + 16];\n        }\n        for(i = 0; i < 16; i++)o[i] = t[i];\n        car25519(o);\n        car25519(o);\n    }\n    function S(o, a) {\n        M(o, a, a);\n    }\n    function inv25519(o, i) {\n        var c = gf();\n        var a;\n        for(a = 0; a < 16; a++)c[a] = i[a];\n        for(a = 253; a >= 0; a--){\n            S(c, c);\n            if (a !== 2 && a !== 4) M(c, c, i);\n        }\n        for(a = 0; a < 16; a++)o[a] = c[a];\n    }\n    function pow2523(o, i) {\n        var c = gf();\n        var a;\n        for(a = 0; a < 16; a++)c[a] = i[a];\n        for(a = 250; a >= 0; a--){\n            S(c, c);\n            if (a !== 1) M(c, c, i);\n        }\n        for(a = 0; a < 16; a++)o[a] = c[a];\n    }\n    function crypto_scalarmult(q, n, p) {\n        var z = new Uint8Array(32);\n        var x = new Float64Array(80), r, i;\n        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();\n        for(i = 0; i < 31; i++)z[i] = n[i];\n        z[31] = n[31] & 127 | 64;\n        z[0] &= 248;\n        unpack25519(x, p);\n        for(i = 0; i < 16; i++){\n            b[i] = x[i];\n            d[i] = a[i] = c[i] = 0;\n        }\n        a[0] = d[0] = 1;\n        for(i = 254; i >= 0; --i){\n            r = z[i >>> 3] >>> (i & 7) & 1;\n            sel25519(a, b, r);\n            sel25519(c, d, r);\n            A(e, a, c);\n            Z(a, a, c);\n            A(c, b, d);\n            Z(b, b, d);\n            S(d, e);\n            S(f, a);\n            M(a, c, a);\n            M(c, b, e);\n            A(e, a, c);\n            Z(a, a, c);\n            S(b, a);\n            Z(c, d, f);\n            M(a, c, _121665);\n            A(a, a, d);\n            M(c, c, a);\n            M(a, d, f);\n            M(d, b, x);\n            S(b, e);\n            sel25519(a, b, r);\n            sel25519(c, d, r);\n        }\n        for(i = 0; i < 16; i++){\n            x[i + 16] = a[i];\n            x[i + 32] = c[i];\n            x[i + 48] = b[i];\n            x[i + 64] = d[i];\n        }\n        var x32 = x.subarray(32);\n        var x16 = x.subarray(16);\n        inv25519(x32, x32);\n        M(x16, x16, x32);\n        pack25519(q, x16);\n        return 0;\n    }\n    function crypto_scalarmult_base(q, n) {\n        return crypto_scalarmult(q, n, _9);\n    }\n    function crypto_box_keypair(y, x) {\n        randombytes(x, 32);\n        return crypto_scalarmult_base(y, x);\n    }\n    function crypto_box_beforenm(k, y, x) {\n        var s = new Uint8Array(32);\n        crypto_scalarmult(s, x, y);\n        return crypto_core_hsalsa20(k, _0, s, sigma);\n    }\n    var crypto_box_afternm = crypto_secretbox;\n    var crypto_box_open_afternm = crypto_secretbox_open;\n    function crypto_box(c, m, d, n, y, x) {\n        var k = new Uint8Array(32);\n        crypto_box_beforenm(k, y, x);\n        return crypto_box_afternm(c, m, d, n, k);\n    }\n    function crypto_box_open(m, c, d, n, y, x) {\n        var k = new Uint8Array(32);\n        crypto_box_beforenm(k, y, x);\n        return crypto_box_open_afternm(m, c, d, n, k);\n    }\n    function add64() {\n        var a = 0, b = 0, c = 0, d = 0, m16 = 65535, l, h, i;\n        for(i = 0; i < arguments.length; i++){\n            l = arguments[i].lo;\n            h = arguments[i].hi;\n            a += l & m16;\n            b += l >>> 16;\n            c += h & m16;\n            d += h >>> 16;\n        }\n        b += a >>> 16;\n        c += b >>> 16;\n        d += c >>> 16;\n        return new u64(c & m16 | d << 16, a & m16 | b << 16);\n    }\n    function shr64(x, c) {\n        return new u64(x.hi >>> c, x.lo >>> c | x.hi << 32 - c);\n    }\n    function xor64() {\n        var l = 0, h = 0, i;\n        for(i = 0; i < arguments.length; i++){\n            l ^= arguments[i].lo;\n            h ^= arguments[i].hi;\n        }\n        return new u64(h, l);\n    }\n    function R(x, c) {\n        var h, l, c1 = 32 - c;\n        if (c < 32) {\n            h = x.hi >>> c | x.lo << c1;\n            l = x.lo >>> c | x.hi << c1;\n        } else if (c < 64) {\n            h = x.lo >>> c | x.hi << c1;\n            l = x.hi >>> c | x.lo << c1;\n        }\n        return new u64(h, l);\n    }\n    function Ch(x, y, z) {\n        var h = x.hi & y.hi ^ ~x.hi & z.hi, l = x.lo & y.lo ^ ~x.lo & z.lo;\n        return new u64(h, l);\n    }\n    function Maj(x, y, z) {\n        var h = x.hi & y.hi ^ x.hi & z.hi ^ y.hi & z.hi, l = x.lo & y.lo ^ x.lo & z.lo ^ y.lo & z.lo;\n        return new u64(h, l);\n    }\n    function Sigma0(x) {\n        return xor64(R(x, 28), R(x, 34), R(x, 39));\n    }\n    function Sigma1(x) {\n        return xor64(R(x, 14), R(x, 18), R(x, 41));\n    }\n    function sigma0(x) {\n        return xor64(R(x, 1), R(x, 8), shr64(x, 7));\n    }\n    function sigma1(x) {\n        return xor64(R(x, 19), R(x, 61), shr64(x, 6));\n    }\n    var K = [\n        new u64(0x428a2f98, 0xd728ae22),\n        new u64(0x71374491, 0x23ef65cd),\n        new u64(0xb5c0fbcf, 0xec4d3b2f),\n        new u64(0xe9b5dba5, 0x8189dbbc),\n        new u64(0x3956c25b, 0xf348b538),\n        new u64(0x59f111f1, 0xb605d019),\n        new u64(0x923f82a4, 0xaf194f9b),\n        new u64(0xab1c5ed5, 0xda6d8118),\n        new u64(0xd807aa98, 0xa3030242),\n        new u64(0x12835b01, 0x45706fbe),\n        new u64(0x243185be, 0x4ee4b28c),\n        new u64(0x550c7dc3, 0xd5ffb4e2),\n        new u64(0x72be5d74, 0xf27b896f),\n        new u64(0x80deb1fe, 0x3b1696b1),\n        new u64(0x9bdc06a7, 0x25c71235),\n        new u64(0xc19bf174, 0xcf692694),\n        new u64(0xe49b69c1, 0x9ef14ad2),\n        new u64(0xefbe4786, 0x384f25e3),\n        new u64(0x0fc19dc6, 0x8b8cd5b5),\n        new u64(0x240ca1cc, 0x77ac9c65),\n        new u64(0x2de92c6f, 0x592b0275),\n        new u64(0x4a7484aa, 0x6ea6e483),\n        new u64(0x5cb0a9dc, 0xbd41fbd4),\n        new u64(0x76f988da, 0x831153b5),\n        new u64(0x983e5152, 0xee66dfab),\n        new u64(0xa831c66d, 0x2db43210),\n        new u64(0xb00327c8, 0x98fb213f),\n        new u64(0xbf597fc7, 0xbeef0ee4),\n        new u64(0xc6e00bf3, 0x3da88fc2),\n        new u64(0xd5a79147, 0x930aa725),\n        new u64(0x06ca6351, 0xe003826f),\n        new u64(0x14292967, 0x0a0e6e70),\n        new u64(0x27b70a85, 0x46d22ffc),\n        new u64(0x2e1b2138, 0x5c26c926),\n        new u64(0x4d2c6dfc, 0x5ac42aed),\n        new u64(0x53380d13, 0x9d95b3df),\n        new u64(0x650a7354, 0x8baf63de),\n        new u64(0x766a0abb, 0x3c77b2a8),\n        new u64(0x81c2c92e, 0x47edaee6),\n        new u64(0x92722c85, 0x1482353b),\n        new u64(0xa2bfe8a1, 0x4cf10364),\n        new u64(0xa81a664b, 0xbc423001),\n        new u64(0xc24b8b70, 0xd0f89791),\n        new u64(0xc76c51a3, 0x0654be30),\n        new u64(0xd192e819, 0xd6ef5218),\n        new u64(0xd6990624, 0x5565a910),\n        new u64(0xf40e3585, 0x5771202a),\n        new u64(0x106aa070, 0x32bbd1b8),\n        new u64(0x19a4c116, 0xb8d2d0c8),\n        new u64(0x1e376c08, 0x5141ab53),\n        new u64(0x2748774c, 0xdf8eeb99),\n        new u64(0x34b0bcb5, 0xe19b48a8),\n        new u64(0x391c0cb3, 0xc5c95a63),\n        new u64(0x4ed8aa4a, 0xe3418acb),\n        new u64(0x5b9cca4f, 0x7763e373),\n        new u64(0x682e6ff3, 0xd6b2b8a3),\n        new u64(0x748f82ee, 0x5defb2fc),\n        new u64(0x78a5636f, 0x43172f60),\n        new u64(0x84c87814, 0xa1f0ab72),\n        new u64(0x8cc70208, 0x1a6439ec),\n        new u64(0x90befffa, 0x23631e28),\n        new u64(0xa4506ceb, 0xde82bde9),\n        new u64(0xbef9a3f7, 0xb2c67915),\n        new u64(0xc67178f2, 0xe372532b),\n        new u64(0xca273ece, 0xea26619c),\n        new u64(0xd186b8c7, 0x21c0c207),\n        new u64(0xeada7dd6, 0xcde0eb1e),\n        new u64(0xf57d4f7f, 0xee6ed178),\n        new u64(0x06f067aa, 0x72176fba),\n        new u64(0x0a637dc5, 0xa2c898a6),\n        new u64(0x113f9804, 0xbef90dae),\n        new u64(0x1b710b35, 0x131c471b),\n        new u64(0x28db77f5, 0x23047d84),\n        new u64(0x32caab7b, 0x40c72493),\n        new u64(0x3c9ebe0a, 0x15c9bebc),\n        new u64(0x431d67c4, 0x9c100d4c),\n        new u64(0x4cc5d4be, 0xcb3e42b6),\n        new u64(0x597f299c, 0xfc657e2a),\n        new u64(0x5fcb6fab, 0x3ad6faec),\n        new u64(0x6c44198c, 0x4a475817)\n    ];\n    function crypto_hashblocks(x, m, n) {\n        var z = [], b = [], a = [], w = [], t, i, j;\n        for(i = 0; i < 8; i++)z[i] = a[i] = dl64(x, 8 * i);\n        var pos = 0;\n        while(n >= 128){\n            for(i = 0; i < 16; i++)w[i] = dl64(m, 8 * i + pos);\n            for(i = 0; i < 80; i++){\n                for(j = 0; j < 8; j++)b[j] = a[j];\n                t = add64(a[7], Sigma1(a[4]), Ch(a[4], a[5], a[6]), K[i], w[i % 16]);\n                b[7] = add64(t, Sigma0(a[0]), Maj(a[0], a[1], a[2]));\n                b[3] = add64(b[3], t);\n                for(j = 0; j < 8; j++)a[(j + 1) % 8] = b[j];\n                if (i % 16 === 15) {\n                    for(j = 0; j < 16; j++){\n                        w[j] = add64(w[j], w[(j + 9) % 16], sigma0(w[(j + 1) % 16]), sigma1(w[(j + 14) % 16]));\n                    }\n                }\n            }\n            for(i = 0; i < 8; i++){\n                a[i] = add64(a[i], z[i]);\n                z[i] = a[i];\n            }\n            pos += 128;\n            n -= 128;\n        }\n        for(i = 0; i < 8; i++)ts64(x, 8 * i, z[i]);\n        return n;\n    }\n    var iv = new Uint8Array([\n        0x6a,\n        0x09,\n        0xe6,\n        0x67,\n        0xf3,\n        0xbc,\n        0xc9,\n        0x08,\n        0xbb,\n        0x67,\n        0xae,\n        0x85,\n        0x84,\n        0xca,\n        0xa7,\n        0x3b,\n        0x3c,\n        0x6e,\n        0xf3,\n        0x72,\n        0xfe,\n        0x94,\n        0xf8,\n        0x2b,\n        0xa5,\n        0x4f,\n        0xf5,\n        0x3a,\n        0x5f,\n        0x1d,\n        0x36,\n        0xf1,\n        0x51,\n        0x0e,\n        0x52,\n        0x7f,\n        0xad,\n        0xe6,\n        0x82,\n        0xd1,\n        0x9b,\n        0x05,\n        0x68,\n        0x8c,\n        0x2b,\n        0x3e,\n        0x6c,\n        0x1f,\n        0x1f,\n        0x83,\n        0xd9,\n        0xab,\n        0xfb,\n        0x41,\n        0xbd,\n        0x6b,\n        0x5b,\n        0xe0,\n        0xcd,\n        0x19,\n        0x13,\n        0x7e,\n        0x21,\n        0x79\n    ]);\n    function crypto_hash(out, m, n) {\n        var h = new Uint8Array(64), x = new Uint8Array(256);\n        var i, b = n;\n        for(i = 0; i < 64; i++)h[i] = iv[i];\n        crypto_hashblocks(h, m, n);\n        n %= 128;\n        for(i = 0; i < 256; i++)x[i] = 0;\n        for(i = 0; i < n; i++)x[i] = m[b - n + i];\n        x[n] = 128;\n        n = 256 - 128 * (n < 112 ? 1 : 0);\n        x[n - 9] = 0;\n        ts64(x, n - 8, new u64(b / 0x20000000 | 0, b << 3));\n        crypto_hashblocks(h, x, n);\n        for(i = 0; i < 64; i++)out[i] = h[i];\n        return 0;\n    }\n    function add(p, q) {\n        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();\n        Z(a, p[1], p[0]);\n        Z(t, q[1], q[0]);\n        M(a, a, t);\n        A(b, p[0], p[1]);\n        A(t, q[0], q[1]);\n        M(b, b, t);\n        M(c, p[3], q[3]);\n        M(c, c, D2);\n        M(d, p[2], q[2]);\n        A(d, d, d);\n        Z(e, b, a);\n        Z(f, d, c);\n        A(g, d, c);\n        A(h, b, a);\n        M(p[0], e, f);\n        M(p[1], h, g);\n        M(p[2], g, f);\n        M(p[3], e, h);\n    }\n    function cswap(p, q, b) {\n        var i;\n        for(i = 0; i < 4; i++){\n            sel25519(p[i], q[i], b);\n        }\n    }\n    function pack(r, p) {\n        var tx = gf(), ty = gf(), zi = gf();\n        inv25519(zi, p[2]);\n        M(tx, p[0], zi);\n        M(ty, p[1], zi);\n        pack25519(r, ty);\n        r[31] ^= par25519(tx) << 7;\n    }\n    function scalarmult(p, q, s) {\n        var b, i;\n        set25519(p[0], gf0);\n        set25519(p[1], gf1);\n        set25519(p[2], gf1);\n        set25519(p[3], gf0);\n        for(i = 255; i >= 0; --i){\n            b = s[i / 8 | 0] >> (i & 7) & 1;\n            cswap(p, q, b);\n            add(q, p);\n            add(p, p);\n            cswap(p, q, b);\n        }\n    }\n    function scalarbase(p, s) {\n        var q = [\n            gf(),\n            gf(),\n            gf(),\n            gf()\n        ];\n        set25519(q[0], X);\n        set25519(q[1], Y);\n        set25519(q[2], gf1);\n        M(q[3], X, Y);\n        scalarmult(p, q, s);\n    }\n    function crypto_sign_keypair(pk, sk, seeded) {\n        var d = new Uint8Array(64);\n        var p = [\n            gf(),\n            gf(),\n            gf(),\n            gf()\n        ];\n        var i;\n        if (!seeded) randombytes(sk, 32);\n        crypto_hash(d, sk, 32);\n        d[0] &= 248;\n        d[31] &= 127;\n        d[31] |= 64;\n        scalarbase(p, d);\n        pack(pk, p);\n        for(i = 0; i < 32; i++)sk[i + 32] = pk[i];\n        return 0;\n    }\n    var L = new Float64Array([\n        0xed,\n        0xd3,\n        0xf5,\n        0x5c,\n        0x1a,\n        0x63,\n        0x12,\n        0x58,\n        0xd6,\n        0x9c,\n        0xf7,\n        0xa2,\n        0xde,\n        0xf9,\n        0xde,\n        0x14,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0x10\n    ]);\n    function modL(r, x) {\n        var carry, i, j, k;\n        for(i = 63; i >= 32; --i){\n            carry = 0;\n            for(j = i - 32, k = i - 12; j < k; ++j){\n                x[j] += carry - 16 * x[i] * L[j - (i - 32)];\n                carry = Math.floor((x[j] + 128) / 256);\n                x[j] -= carry * 256;\n            }\n            x[j] += carry;\n            x[i] = 0;\n        }\n        carry = 0;\n        for(j = 0; j < 32; j++){\n            x[j] += carry - (x[31] >> 4) * L[j];\n            carry = x[j] >> 8;\n            x[j] &= 255;\n        }\n        for(j = 0; j < 32; j++)x[j] -= carry * L[j];\n        for(i = 0; i < 32; i++){\n            x[i + 1] += x[i] >> 8;\n            r[i] = x[i] & 255;\n        }\n    }\n    function reduce(r) {\n        var x = new Float64Array(64), i;\n        for(i = 0; i < 64; i++)x[i] = r[i];\n        for(i = 0; i < 64; i++)r[i] = 0;\n        modL(r, x);\n    }\n    function crypto_sign(sm, m, n, sk) {\n        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);\n        var i, j, x = new Float64Array(64);\n        var p = [\n            gf(),\n            gf(),\n            gf(),\n            gf()\n        ];\n        crypto_hash(d, sk, 32);\n        d[0] &= 248;\n        d[31] &= 127;\n        d[31] |= 64;\n        var smlen = n + 64;\n        for(i = 0; i < n; i++)sm[64 + i] = m[i];\n        for(i = 0; i < 32; i++)sm[32 + i] = d[32 + i];\n        crypto_hash(r, sm.subarray(32), n + 32);\n        reduce(r);\n        scalarbase(p, r);\n        pack(sm, p);\n        for(i = 32; i < 64; i++)sm[i] = sk[i];\n        crypto_hash(h, sm, n + 64);\n        reduce(h);\n        for(i = 0; i < 64; i++)x[i] = 0;\n        for(i = 0; i < 32; i++)x[i] = r[i];\n        for(i = 0; i < 32; i++){\n            for(j = 0; j < 32; j++){\n                x[i + j] += h[i] * d[j];\n            }\n        }\n        modL(sm.subarray(32), x);\n        return smlen;\n    }\n    function unpackneg(r, p) {\n        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();\n        set25519(r[2], gf1);\n        unpack25519(r[1], p);\n        S(num, r[1]);\n        M(den, num, D);\n        Z(num, num, r[2]);\n        A(den, r[2], den);\n        S(den2, den);\n        S(den4, den2);\n        M(den6, den4, den2);\n        M(t, den6, num);\n        M(t, t, den);\n        pow2523(t, t);\n        M(t, t, num);\n        M(t, t, den);\n        M(t, t, den);\n        M(r[0], t, den);\n        S(chk, r[0]);\n        M(chk, chk, den);\n        if (neq25519(chk, num)) M(r[0], r[0], I);\n        S(chk, r[0]);\n        M(chk, chk, den);\n        if (neq25519(chk, num)) return -1;\n        if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);\n        M(r[3], r[0], r[1]);\n        return 0;\n    }\n    function crypto_sign_open(m, sm, n, pk) {\n        var i;\n        var t = new Uint8Array(32), h = new Uint8Array(64);\n        var p = [\n            gf(),\n            gf(),\n            gf(),\n            gf()\n        ], q = [\n            gf(),\n            gf(),\n            gf(),\n            gf()\n        ];\n        if (n < 64) return -1;\n        if (unpackneg(q, pk)) return -1;\n        for(i = 0; i < n; i++)m[i] = sm[i];\n        for(i = 0; i < 32; i++)m[i + 32] = pk[i];\n        crypto_hash(h, m, n);\n        reduce(h);\n        scalarmult(p, q, h);\n        scalarbase(q, sm.subarray(32));\n        add(p, q);\n        pack(t, p);\n        n -= 64;\n        if (crypto_verify_32(sm, 0, t, 0)) {\n            for(i = 0; i < n; i++)m[i] = 0;\n            return -1;\n        }\n        for(i = 0; i < n; i++)m[i] = sm[i + 64];\n        return n;\n    }\n    var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;\n    nacl.lowlevel = {\n        crypto_core_hsalsa20: crypto_core_hsalsa20,\n        crypto_stream_xor: crypto_stream_xor,\n        crypto_stream: crypto_stream,\n        crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,\n        crypto_stream_salsa20: crypto_stream_salsa20,\n        crypto_onetimeauth: crypto_onetimeauth,\n        crypto_onetimeauth_verify: crypto_onetimeauth_verify,\n        crypto_verify_16: crypto_verify_16,\n        crypto_verify_32: crypto_verify_32,\n        crypto_secretbox: crypto_secretbox,\n        crypto_secretbox_open: crypto_secretbox_open,\n        crypto_scalarmult: crypto_scalarmult,\n        crypto_scalarmult_base: crypto_scalarmult_base,\n        crypto_box_beforenm: crypto_box_beforenm,\n        crypto_box_afternm: crypto_box_afternm,\n        crypto_box: crypto_box,\n        crypto_box_open: crypto_box_open,\n        crypto_box_keypair: crypto_box_keypair,\n        crypto_hash: crypto_hash,\n        crypto_sign: crypto_sign,\n        crypto_sign_keypair: crypto_sign_keypair,\n        crypto_sign_open: crypto_sign_open,\n        crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,\n        crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,\n        crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,\n        crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,\n        crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,\n        crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,\n        crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,\n        crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,\n        crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,\n        crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,\n        crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,\n        crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,\n        crypto_sign_BYTES: crypto_sign_BYTES,\n        crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,\n        crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,\n        crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,\n        crypto_hash_BYTES: crypto_hash_BYTES,\n        gf: gf,\n        D: D,\n        L: L,\n        pack25519: pack25519,\n        unpack25519: unpack25519,\n        M: M,\n        A: A,\n        S: S,\n        Z: Z,\n        pow2523: pow2523,\n        add: add,\n        set25519: set25519,\n        modL: modL,\n        scalarmult: scalarmult,\n        scalarbase: scalarbase\n    };\n    function checkLengths(k, n) {\n        if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');\n        if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');\n    }\n    function checkBoxLengths(pk, sk) {\n        if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');\n        if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');\n    }\n    function checkArrayTypes() {\n        for(var i = 0; i < arguments.length; i++){\n            if (!(arguments[i] instanceof Uint8Array)) throw new TypeError('unexpected type, use Uint8Array');\n        }\n    }\n    function cleanup(arr) {\n        for(var i = 0; i < arr.length; i++)arr[i] = 0;\n    }\n    nacl.randomBytes = function(n) {\n        var b = new Uint8Array(n);\n        randombytes(b, n);\n        return b;\n    };\n    nacl.secretbox = function(msg, nonce, key) {\n        checkArrayTypes(msg, nonce, key);\n        checkLengths(key, nonce);\n        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);\n        var c = new Uint8Array(m.length);\n        for(var i = 0; i < msg.length; i++)m[i + crypto_secretbox_ZEROBYTES] = msg[i];\n        crypto_secretbox(c, m, m.length, nonce, key);\n        return c.subarray(crypto_secretbox_BOXZEROBYTES);\n    };\n    nacl.secretbox.open = function(box, nonce, key) {\n        checkArrayTypes(box, nonce, key);\n        checkLengths(key, nonce);\n        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);\n        var m = new Uint8Array(c.length);\n        for(var i = 0; i < box.length; i++)c[i + crypto_secretbox_BOXZEROBYTES] = box[i];\n        if (c.length < 32) return null;\n        if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;\n        return m.subarray(crypto_secretbox_ZEROBYTES);\n    };\n    nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;\n    nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;\n    nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;\n    nacl.scalarMult = function(n, p) {\n        checkArrayTypes(n, p);\n        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');\n        if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');\n        var q = new Uint8Array(crypto_scalarmult_BYTES);\n        crypto_scalarmult(q, n, p);\n        return q;\n    };\n    nacl.scalarMult.base = function(n) {\n        checkArrayTypes(n);\n        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');\n        var q = new Uint8Array(crypto_scalarmult_BYTES);\n        crypto_scalarmult_base(q, n);\n        return q;\n    };\n    nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;\n    nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;\n    nacl.box = function(msg, nonce, publicKey, secretKey) {\n        var k = nacl.box.before(publicKey, secretKey);\n        return nacl.secretbox(msg, nonce, k);\n    };\n    nacl.box.before = function(publicKey, secretKey) {\n        checkArrayTypes(publicKey, secretKey);\n        checkBoxLengths(publicKey, secretKey);\n        var k = new Uint8Array(crypto_box_BEFORENMBYTES);\n        crypto_box_beforenm(k, publicKey, secretKey);\n        return k;\n    };\n    nacl.box.after = nacl.secretbox;\n    nacl.box.open = function(msg, nonce, publicKey, secretKey) {\n        var k = nacl.box.before(publicKey, secretKey);\n        return nacl.secretbox.open(msg, nonce, k);\n    };\n    nacl.box.open.after = nacl.secretbox.open;\n    nacl.box.keyPair = function() {\n        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);\n        crypto_box_keypair(pk, sk);\n        return {\n            publicKey: pk,\n            secretKey: sk\n        };\n    };\n    nacl.box.keyPair.fromSecretKey = function(secretKey) {\n        checkArrayTypes(secretKey);\n        if (secretKey.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');\n        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n        crypto_scalarmult_base(pk, secretKey);\n        return {\n            publicKey: pk,\n            secretKey: new Uint8Array(secretKey)\n        };\n    };\n    nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;\n    nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;\n    nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;\n    nacl.box.nonceLength = crypto_box_NONCEBYTES;\n    nacl.box.overheadLength = nacl.secretbox.overheadLength;\n    nacl.sign = function(msg, secretKey) {\n        checkArrayTypes(msg, secretKey);\n        if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error('bad secret key size');\n        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);\n        crypto_sign(signedMsg, msg, msg.length, secretKey);\n        return signedMsg;\n    };\n    nacl.sign.open = function(signedMsg, publicKey) {\n        checkArrayTypes(signedMsg, publicKey);\n        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error('bad public key size');\n        var tmp = new Uint8Array(signedMsg.length);\n        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);\n        if (mlen < 0) return null;\n        var m = new Uint8Array(mlen);\n        for(var i = 0; i < m.length; i++)m[i] = tmp[i];\n        return m;\n    };\n    nacl.sign.detached = function(msg, secretKey) {\n        var signedMsg = nacl.sign(msg, secretKey);\n        var sig = new Uint8Array(crypto_sign_BYTES);\n        for(var i = 0; i < sig.length; i++)sig[i] = signedMsg[i];\n        return sig;\n    };\n    nacl.sign.detached.verify = function(msg, sig, publicKey) {\n        checkArrayTypes(msg, sig, publicKey);\n        if (sig.length !== crypto_sign_BYTES) throw new Error('bad signature size');\n        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error('bad public key size');\n        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);\n        var m = new Uint8Array(crypto_sign_BYTES + msg.length);\n        var i;\n        for(i = 0; i < crypto_sign_BYTES; i++)sm[i] = sig[i];\n        for(i = 0; i < msg.length; i++)sm[i + crypto_sign_BYTES] = msg[i];\n        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;\n    };\n    nacl.sign.keyPair = function() {\n        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n        crypto_sign_keypair(pk, sk);\n        return {\n            publicKey: pk,\n            secretKey: sk\n        };\n    };\n    nacl.sign.keyPair.fromSecretKey = function(secretKey) {\n        checkArrayTypes(secretKey);\n        if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error('bad secret key size');\n        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n        for(var i = 0; i < pk.length; i++)pk[i] = secretKey[32 + i];\n        return {\n            publicKey: pk,\n            secretKey: new Uint8Array(secretKey)\n        };\n    };\n    nacl.sign.keyPair.fromSeed = function(seed) {\n        checkArrayTypes(seed);\n        if (seed.length !== crypto_sign_SEEDBYTES) throw new Error('bad seed size');\n        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n        for(var i = 0; i < 32; i++)sk[i] = seed[i];\n        crypto_sign_keypair(pk, sk, true);\n        return {\n            publicKey: pk,\n            secretKey: sk\n        };\n    };\n    nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;\n    nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;\n    nacl.sign.seedLength = crypto_sign_SEEDBYTES;\n    nacl.sign.signatureLength = crypto_sign_BYTES;\n    nacl.hash = function(msg) {\n        checkArrayTypes(msg);\n        var h = new Uint8Array(crypto_hash_BYTES);\n        crypto_hash(h, msg, msg.length);\n        return h;\n    };\n    nacl.hash.hashLength = crypto_hash_BYTES;\n    nacl.verify = function(x, y) {\n        checkArrayTypes(x, y);\n        if (x.length === 0 || y.length === 0) return false;\n        if (x.length !== y.length) return false;\n        return vn(x, 0, y, 0, x.length) === 0 ? true : false;\n    };\n    nacl.setPRNG = function(fn) {\n        randombytes = fn;\n    };\n    (function() {\n        var crypto1 = typeof globalThis !== 'undefined' ? globalThis.crypto || globalThis.msCrypto : null;\n        if (crypto1 && crypto1.getRandomValues) {\n            var QUOTA = 65536;\n            nacl.setPRNG(function(x, n) {\n                var i, v = new Uint8Array(n);\n                for(i = 0; i < n; i += QUOTA){\n                    crypto1.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));\n                }\n                for(i = 0; i < n; i++)x[i] = v[i];\n                cleanup(v);\n            });\n        } else if (typeof require !== 'undefined') {\n            crypto1 = require('crypto');\n            if (crypto1 && crypto1.randomBytes) {\n                nacl.setPRNG(function(x, n) {\n                    var i, v = crypto1.randomBytes(n);\n                    for(i = 0; i < n; i++)x[i] = v[i];\n                    cleanup(v);\n                });\n            }\n        }\n    })();\n})(typeof module !== 'undefined' && module.exports ? module.exports : globalThis.nacl = globalThis.nacl || {});\nconst nacl = typeof module !== 'undefined' && module.exports ? module.exports : globalThis.nacl;\nconst denoHelper = {\n    fromSeed: nacl.sign.keyPair.fromSeed,\n    sign: nacl.sign.detached,\n    verify: nacl.sign.detached.verify,\n    randomBytes: nacl.randomBytes\n};\nlet helper;\nfunction setEd25519Helper(lib) {\n    helper = lib;\n}\nfunction getEd25519Helper() {\n    return helper;\n}\nconst crc16tab = new Uint16Array([\n    0x0000,\n    0x1021,\n    0x2042,\n    0x3063,\n    0x4084,\n    0x50a5,\n    0x60c6,\n    0x70e7,\n    0x8108,\n    0x9129,\n    0xa14a,\n    0xb16b,\n    0xc18c,\n    0xd1ad,\n    0xe1ce,\n    0xf1ef,\n    0x1231,\n    0x0210,\n    0x3273,\n    0x2252,\n    0x52b5,\n    0x4294,\n    0x72f7,\n    0x62d6,\n    0x9339,\n    0x8318,\n    0xb37b,\n    0xa35a,\n    0xd3bd,\n    0xc39c,\n    0xf3ff,\n    0xe3de,\n    0x2462,\n    0x3443,\n    0x0420,\n    0x1401,\n    0x64e6,\n    0x74c7,\n    0x44a4,\n    0x5485,\n    0xa56a,\n    0xb54b,\n    0x8528,\n    0x9509,\n    0xe5ee,\n    0xf5cf,\n    0xc5ac,\n    0xd58d,\n    0x3653,\n    0x2672,\n    0x1611,\n    0x0630,\n    0x76d7,\n    0x66f6,\n    0x5695,\n    0x46b4,\n    0xb75b,\n    0xa77a,\n    0x9719,\n    0x8738,\n    0xf7df,\n    0xe7fe,\n    0xd79d,\n    0xc7bc,\n    0x48c4,\n    0x58e5,\n    0x6886,\n    0x78a7,\n    0x0840,\n    0x1861,\n    0x2802,\n    0x3823,\n    0xc9cc,\n    0xd9ed,\n    0xe98e,\n    0xf9af,\n    0x8948,\n    0x9969,\n    0xa90a,\n    0xb92b,\n    0x5af5,\n    0x4ad4,\n    0x7ab7,\n    0x6a96,\n    0x1a71,\n    0x0a50,\n    0x3a33,\n    0x2a12,\n    0xdbfd,\n    0xcbdc,\n    0xfbbf,\n    0xeb9e,\n    0x9b79,\n    0x8b58,\n    0xbb3b,\n    0xab1a,\n    0x6ca6,\n    0x7c87,\n    0x4ce4,\n    0x5cc5,\n    0x2c22,\n    0x3c03,\n    0x0c60,\n    0x1c41,\n    0xedae,\n    0xfd8f,\n    0xcdec,\n    0xddcd,\n    0xad2a,\n    0xbd0b,\n    0x8d68,\n    0x9d49,\n    0x7e97,\n    0x6eb6,\n    0x5ed5,\n    0x4ef4,\n    0x3e13,\n    0x2e32,\n    0x1e51,\n    0x0e70,\n    0xff9f,\n    0xefbe,\n    0xdfdd,\n    0xcffc,\n    0xbf1b,\n    0xaf3a,\n    0x9f59,\n    0x8f78,\n    0x9188,\n    0x81a9,\n    0xb1ca,\n    0xa1eb,\n    0xd10c,\n    0xc12d,\n    0xf14e,\n    0xe16f,\n    0x1080,\n    0x00a1,\n    0x30c2,\n    0x20e3,\n    0x5004,\n    0x4025,\n    0x7046,\n    0x6067,\n    0x83b9,\n    0x9398,\n    0xa3fb,\n    0xb3da,\n    0xc33d,\n    0xd31c,\n    0xe37f,\n    0xf35e,\n    0x02b1,\n    0x1290,\n    0x22f3,\n    0x32d2,\n    0x4235,\n    0x5214,\n    0x6277,\n    0x7256,\n    0xb5ea,\n    0xa5cb,\n    0x95a8,\n    0x8589,\n    0xf56e,\n    0xe54f,\n    0xd52c,\n    0xc50d,\n    0x34e2,\n    0x24c3,\n    0x14a0,\n    0x0481,\n    0x7466,\n    0x6447,\n    0x5424,\n    0x4405,\n    0xa7db,\n    0xb7fa,\n    0x8799,\n    0x97b8,\n    0xe75f,\n    0xf77e,\n    0xc71d,\n    0xd73c,\n    0x26d3,\n    0x36f2,\n    0x0691,\n    0x16b0,\n    0x6657,\n    0x7676,\n    0x4615,\n    0x5634,\n    0xd94c,\n    0xc96d,\n    0xf90e,\n    0xe92f,\n    0x99c8,\n    0x89e9,\n    0xb98a,\n    0xa9ab,\n    0x5844,\n    0x4865,\n    0x7806,\n    0x6827,\n    0x18c0,\n    0x08e1,\n    0x3882,\n    0x28a3,\n    0xcb7d,\n    0xdb5c,\n    0xeb3f,\n    0xfb1e,\n    0x8bf9,\n    0x9bd8,\n    0xabbb,\n    0xbb9a,\n    0x4a75,\n    0x5a54,\n    0x6a37,\n    0x7a16,\n    0x0af1,\n    0x1ad0,\n    0x2ab3,\n    0x3a92,\n    0xfd2e,\n    0xed0f,\n    0xdd6c,\n    0xcd4d,\n    0xbdaa,\n    0xad8b,\n    0x9de8,\n    0x8dc9,\n    0x7c26,\n    0x6c07,\n    0x5c64,\n    0x4c45,\n    0x3ca2,\n    0x2c83,\n    0x1ce0,\n    0x0cc1,\n    0xef1f,\n    0xff3e,\n    0xcf5d,\n    0xdf7c,\n    0xaf9b,\n    0xbfba,\n    0x8fd9,\n    0x9ff8,\n    0x6e17,\n    0x7e36,\n    0x4e55,\n    0x5e74,\n    0x2e93,\n    0x3eb2,\n    0x0ed1,\n    0x1ef0\n]);\nclass crc16 {\n    static checksum(data) {\n        let crc = 0;\n        for(let i = 0; i < data.byteLength; i++){\n            let b = data[i];\n            crc = crc << 8 & 0xffff ^ crc16tab[(crc >> 8 ^ b) & 0x00FF];\n        }\n        return crc;\n    }\n    static validate(data, expected) {\n        let ba = crc16.checksum(data);\n        return ba == expected;\n    }\n}\nconst b32Alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\";\nclass base32 {\n    static encode(src) {\n        let bits = 0;\n        let value = 0;\n        let a = new Uint8Array(src);\n        let buf = new Uint8Array(src.byteLength * 2);\n        let j = 0;\n        for(let i = 0; i < a.byteLength; i++){\n            value = value << 8 | a[i];\n            bits += 8;\n            while(bits >= 5){\n                let index = value >>> bits - 5 & 31;\n                buf[j++] = b32Alphabet.charAt(index).charCodeAt(0);\n                bits -= 5;\n            }\n        }\n        if (bits > 0) {\n            let index = value << 5 - bits & 31;\n            buf[j++] = b32Alphabet.charAt(index).charCodeAt(0);\n        }\n        return buf.slice(0, j);\n    }\n    static decode(src) {\n        let bits = 0;\n        let __byte = 0;\n        let j = 0;\n        let a = new Uint8Array(src);\n        let out = new Uint8Array(a.byteLength * 5 / 8 | 0);\n        for(let i = 0; i < a.byteLength; i++){\n            let v = String.fromCharCode(a[i]);\n            let vv = b32Alphabet.indexOf(v);\n            if (vv === -1) {\n                throw new Error(\"Illegal Base32 character: \" + a[i]);\n            }\n            __byte = __byte << 5 | vv;\n            bits += 5;\n            if (bits >= 8) {\n                out[j++] = __byte >>> bits - 8 & 255;\n                bits -= 8;\n            }\n        }\n        return out.slice(0, j);\n    }\n}\nclass NKeysError extends Error {\n    name;\n    code;\n    chainedError;\n    constructor(code, chainedError){\n        super(code);\n        this.name = \"NKeysError\";\n        this.code = code;\n        this.chainedError = chainedError;\n    }\n}\nfunction createOperator() {\n    return createPair(Prefix.Operator);\n}\nfunction createAccount() {\n    return createPair(Prefix.Account);\n}\nfunction createUser() {\n    return createPair(Prefix.User);\n}\nvar NKeysErrorCode;\n(function(NKeysErrorCode) {\n    NKeysErrorCode[\"InvalidPrefixByte\"] = \"nkeys: invalid prefix byte\";\n    NKeysErrorCode[\"InvalidKey\"] = \"nkeys: invalid key\";\n    NKeysErrorCode[\"InvalidPublicKey\"] = \"nkeys: invalid public key\";\n    NKeysErrorCode[\"InvalidSeedLen\"] = \"nkeys: invalid seed length\";\n    NKeysErrorCode[\"InvalidSeed\"] = \"nkeys: invalid seed\";\n    NKeysErrorCode[\"InvalidEncoding\"] = \"nkeys: invalid encoded key\";\n    NKeysErrorCode[\"InvalidSignature\"] = \"nkeys: signature verification failed\";\n    NKeysErrorCode[\"CannotSign\"] = \"nkeys: cannot sign, no private key available\";\n    NKeysErrorCode[\"PublicKeyOnly\"] = \"nkeys: no seed or private key available\";\n    NKeysErrorCode[\"InvalidChecksum\"] = \"nkeys: invalid checksum\";\n    NKeysErrorCode[\"SerializationError\"] = \"nkeys: serialization error\";\n    NKeysErrorCode[\"ApiError\"] = \"nkeys: api error\";\n    NKeysErrorCode[\"ClearedPair\"] = \"nkeys: pair is cleared\";\n})(NKeysErrorCode || (NKeysErrorCode = {}));\nvar Prefix;\n(function(Prefix) {\n    Prefix[Prefix[\"Seed\"] = 144] = \"Seed\";\n    Prefix[Prefix[\"Private\"] = 120] = \"Private\";\n    Prefix[Prefix[\"Operator\"] = 112] = \"Operator\";\n    Prefix[Prefix[\"Server\"] = 104] = \"Server\";\n    Prefix[Prefix[\"Cluster\"] = 16] = \"Cluster\";\n    Prefix[Prefix[\"Account\"] = 0] = \"Account\";\n    Prefix[Prefix[\"User\"] = 160] = \"User\";\n})(Prefix || (Prefix = {}));\nclass Prefixes {\n    static isValidPublicPrefix(prefix) {\n        return prefix == Prefix.Server || prefix == Prefix.Operator || prefix == Prefix.Cluster || prefix == Prefix.Account || prefix == Prefix.User;\n    }\n    static startsWithValidPrefix(s) {\n        let c = s[0];\n        return c == \"S\" || c == \"P\" || c == \"O\" || c == \"N\" || c == \"C\" || c == \"A\" || c == \"U\";\n    }\n    static isValidPrefix(prefix) {\n        let v = this.parsePrefix(prefix);\n        return v != -1;\n    }\n    static parsePrefix(v) {\n        switch(v){\n            case Prefix.Seed:\n                return Prefix.Seed;\n            case Prefix.Private:\n                return Prefix.Private;\n            case Prefix.Operator:\n                return Prefix.Operator;\n            case Prefix.Server:\n                return Prefix.Server;\n            case Prefix.Cluster:\n                return Prefix.Cluster;\n            case Prefix.Account:\n                return Prefix.Account;\n            case Prefix.User:\n                return Prefix.User;\n            default:\n                return -1;\n        }\n    }\n}\nclass Codec {\n    static encode(prefix, src) {\n        if (!src || !(src instanceof Uint8Array)) {\n            throw new NKeysError(NKeysErrorCode.SerializationError);\n        }\n        if (!Prefixes.isValidPrefix(prefix)) {\n            throw new NKeysError(NKeysErrorCode.InvalidPrefixByte);\n        }\n        return Codec._encode(false, prefix, src);\n    }\n    static encodeSeed(role, src) {\n        if (!src) {\n            throw new NKeysError(NKeysErrorCode.ApiError);\n        }\n        if (!Prefixes.isValidPublicPrefix(role)) {\n            throw new NKeysError(NKeysErrorCode.InvalidPrefixByte);\n        }\n        if (src.byteLength !== 32) {\n            throw new NKeysError(NKeysErrorCode.InvalidSeedLen);\n        }\n        return Codec._encode(true, role, src);\n    }\n    static decode(expected, src) {\n        if (!Prefixes.isValidPrefix(expected)) {\n            throw new NKeysError(NKeysErrorCode.InvalidPrefixByte);\n        }\n        const raw = Codec._decode(src);\n        if (raw[0] !== expected) {\n            throw new NKeysError(NKeysErrorCode.InvalidPrefixByte);\n        }\n        return raw.slice(1);\n    }\n    static decodeSeed(src) {\n        const raw = Codec._decode(src);\n        const prefix = Codec._decodePrefix(raw);\n        if (prefix[0] != Prefix.Seed) {\n            throw new NKeysError(NKeysErrorCode.InvalidSeed);\n        }\n        if (!Prefixes.isValidPublicPrefix(prefix[1])) {\n            throw new NKeysError(NKeysErrorCode.InvalidPrefixByte);\n        }\n        return {\n            buf: raw.slice(2),\n            prefix: prefix[1]\n        };\n    }\n    static _encode(seed, role, payload) {\n        const payloadOffset = seed ? 2 : 1;\n        const payloadLen = payload.byteLength;\n        const cap = payloadOffset + payloadLen + 2;\n        const checkOffset = payloadOffset + payloadLen;\n        const raw = new Uint8Array(cap);\n        if (seed) {\n            const encodedPrefix = Codec._encodePrefix(Prefix.Seed, role);\n            raw.set(encodedPrefix);\n        } else {\n            raw[0] = role;\n        }\n        raw.set(payload, payloadOffset);\n        const checksum = crc16.checksum(raw.slice(0, checkOffset));\n        const dv = new DataView(raw.buffer);\n        dv.setUint16(checkOffset, checksum, true);\n        return base32.encode(raw);\n    }\n    static _decode(src) {\n        if (src.byteLength < 4) {\n            throw new NKeysError(NKeysErrorCode.InvalidEncoding);\n        }\n        let raw;\n        try {\n            raw = base32.decode(src);\n        } catch (ex) {\n            throw new NKeysError(NKeysErrorCode.InvalidEncoding, ex);\n        }\n        const checkOffset = raw.byteLength - 2;\n        const dv = new DataView(raw.buffer);\n        const checksum = dv.getUint16(checkOffset, true);\n        const payload = raw.slice(0, checkOffset);\n        if (!crc16.validate(payload, checksum)) {\n            throw new NKeysError(NKeysErrorCode.InvalidChecksum);\n        }\n        return payload;\n    }\n    static _encodePrefix(kind, role) {\n        const b1 = kind | role >> 5;\n        const b2 = (role & 31) << 3;\n        return new Uint8Array([\n            b1,\n            b2\n        ]);\n    }\n    static _decodePrefix(raw) {\n        const b1 = raw[0] & 248;\n        const b2 = (raw[0] & 7) << 5 | (raw[1] & 248) >> 3;\n        return new Uint8Array([\n            b1,\n            b2\n        ]);\n    }\n}\nclass KP {\n    seed;\n    constructor(seed){\n        this.seed = seed;\n    }\n    getRawSeed() {\n        if (!this.seed) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        let sd = Codec.decodeSeed(this.seed);\n        return sd.buf;\n    }\n    getSeed() {\n        if (!this.seed) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        return this.seed;\n    }\n    getPublicKey() {\n        if (!this.seed) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        const sd = Codec.decodeSeed(this.seed);\n        const kp = getEd25519Helper().fromSeed(this.getRawSeed());\n        const buf = Codec.encode(sd.prefix, kp.publicKey);\n        return new TextDecoder().decode(buf);\n    }\n    getPrivateKey() {\n        if (!this.seed) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        const kp = getEd25519Helper().fromSeed(this.getRawSeed());\n        return Codec.encode(Prefix.Private, kp.secretKey);\n    }\n    sign(input) {\n        if (!this.seed) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        const kp = getEd25519Helper().fromSeed(this.getRawSeed());\n        return getEd25519Helper().sign(input, kp.secretKey);\n    }\n    verify(input, sig) {\n        if (!this.seed) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        const kp = getEd25519Helper().fromSeed(this.getRawSeed());\n        return getEd25519Helper().verify(input, sig, kp.publicKey);\n    }\n    clear() {\n        if (!this.seed) {\n            return;\n        }\n        this.seed.fill(0);\n        this.seed = undefined;\n    }\n}\nfunction createPair(prefix) {\n    const rawSeed = getEd25519Helper().randomBytes(32);\n    let str = Codec.encodeSeed(prefix, new Uint8Array(rawSeed));\n    return new KP(str);\n}\nclass PublicKey {\n    publicKey;\n    constructor(publicKey){\n        this.publicKey = publicKey;\n    }\n    getPublicKey() {\n        if (!this.publicKey) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        return new TextDecoder().decode(this.publicKey);\n    }\n    getPrivateKey() {\n        if (!this.publicKey) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        throw new NKeysError(NKeysErrorCode.PublicKeyOnly);\n    }\n    getSeed() {\n        if (!this.publicKey) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        throw new NKeysError(NKeysErrorCode.PublicKeyOnly);\n    }\n    sign(_) {\n        if (!this.publicKey) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        throw new NKeysError(NKeysErrorCode.CannotSign);\n    }\n    verify(input, sig) {\n        if (!this.publicKey) {\n            throw new NKeysError(NKeysErrorCode.ClearedPair);\n        }\n        let buf = Codec._decode(this.publicKey);\n        return getEd25519Helper().verify(input, sig, buf.slice(1));\n    }\n    clear() {\n        if (!this.publicKey) {\n            return;\n        }\n        this.publicKey.fill(0);\n        this.publicKey = undefined;\n    }\n}\nfunction fromPublic(src) {\n    const ba = new TextEncoder().encode(src);\n    const raw = Codec._decode(ba);\n    const prefix = Prefixes.parsePrefix(raw[0]);\n    if (Prefixes.isValidPublicPrefix(prefix)) {\n        return new PublicKey(ba);\n    }\n    throw new NKeysError(NKeysErrorCode.InvalidPublicKey);\n}\nfunction fromSeed(src) {\n    Codec.decodeSeed(src);\n    return new KP(src);\n}\nfunction encode1(bytes) {\n    return btoa(String.fromCharCode(...bytes));\n}\nfunction decode1(b64str) {\n    const bin = atob(b64str);\n    const bytes = new Uint8Array(bin.length);\n    for(let i = 0; i < bin.length; i++){\n        bytes[i] = bin.charCodeAt(i);\n    }\n    return bytes;\n}\nsetEd25519Helper(denoHelper);\nconst mod = {\n    createAccount,\n    createOperator,\n    createPair,\n    createUser,\n    fromPublic,\n    fromSeed,\n    NKeysError,\n    NKeysErrorCode,\n    Prefix,\n    decode: decode1,\n    encode: encode1\n};\nfunction multiAuthenticator(authenticators) {\n    return (nonce)=>{\n        let auth = {};\n        authenticators.forEach((a)=>{\n            const args = a(nonce) || {};\n            auth = Object.assign(auth, args);\n        });\n        return auth;\n    };\n}\nfunction noAuthFn() {\n    return ()=>{\n        return;\n    };\n}\nfunction usernamePasswordAuthenticator(user, pass) {\n    return ()=>{\n        const u = typeof user === \"function\" ? user() : user;\n        const p = typeof pass === \"function\" ? pass() : pass;\n        return {\n            user: u,\n            pass: p\n        };\n    };\n}\nfunction tokenAuthenticator(token) {\n    return ()=>{\n        const auth_token = typeof token === \"function\" ? token() : token;\n        return {\n            auth_token\n        };\n    };\n}\nfunction nkeyAuthenticator(seed) {\n    return (nonce)=>{\n        const s = typeof seed === \"function\" ? seed() : seed;\n        const kp = s ? mod.fromSeed(s) : undefined;\n        const nkey = kp ? kp.getPublicKey() : \"\";\n        const challenge = TE.encode(nonce || \"\");\n        const sigBytes = kp !== undefined && nonce ? kp.sign(challenge) : undefined;\n        const sig = sigBytes ? mod.encode(sigBytes) : \"\";\n        return {\n            nkey,\n            sig\n        };\n    };\n}\nfunction jwtAuthenticator(ajwt, seed) {\n    return (nonce)=>{\n        const jwt = typeof ajwt === \"function\" ? ajwt() : ajwt;\n        const fn = nkeyAuthenticator(seed);\n        const { nkey, sig } = fn(nonce);\n        return {\n            jwt,\n            nkey,\n            sig\n        };\n    };\n}\nfunction credsAuthenticator(creds) {\n    const fn = typeof creds !== \"function\" ? ()=>creds : creds;\n    const parse = ()=>{\n        const CREDS = /\\s*(?:(?:[-]{3,}[^\\n]*[-]{3,}\\n)(.+)(?:\\n\\s*[-]{3,}[^\\n]*[-]{3,}\\n))/ig;\n        const s = TD.decode(fn());\n        let m = CREDS.exec(s);\n        if (!m) {\n            throw NatsError.errorForCode(ErrorCode.BadCreds);\n        }\n        const jwt = m[1].trim();\n        m = CREDS.exec(s);\n        if (!m) {\n            throw NatsError.errorForCode(ErrorCode.BadCreds);\n        }\n        if (!m) {\n            throw NatsError.errorForCode(ErrorCode.BadCreds);\n        }\n        const seed = TE.encode(m[1].trim());\n        return {\n            jwt,\n            seed\n        };\n    };\n    const jwtFn = ()=>{\n        const { jwt } = parse();\n        return jwt;\n    };\n    const nkeyFn = ()=>{\n        const { seed } = parse();\n        return seed;\n    };\n    return jwtAuthenticator(jwtFn, nkeyFn);\n}\nconst DEFAULT_PING_INTERVAL = 2 * 60 * 1000;\nconst DEFAULT_MAX_PING_OUT = 2;\nconst DEFAULT_RECONNECT_TIME_WAIT = 2 * 1000;\nfunction defaultOptions() {\n    return {\n        maxPingOut: 2,\n        maxReconnectAttempts: 10,\n        noRandomize: false,\n        pedantic: false,\n        pingInterval: DEFAULT_PING_INTERVAL,\n        reconnect: true,\n        reconnectJitter: 100,\n        reconnectJitterTLS: 1000,\n        reconnectTimeWait: DEFAULT_RECONNECT_TIME_WAIT,\n        tls: undefined,\n        verbose: false,\n        waitOnFirstConnect: false,\n        ignoreAuthErrorAbort: false\n    };\n}\nfunction buildAuthenticator(opts) {\n    const buf = [];\n    if (typeof opts.authenticator === \"function\") {\n        buf.push(opts.authenticator);\n    }\n    if (Array.isArray(opts.authenticator)) {\n        buf.push(...opts.authenticator);\n    }\n    if (opts.token) {\n        buf.push(tokenAuthenticator(opts.token));\n    }\n    if (opts.user) {\n        buf.push(usernamePasswordAuthenticator(opts.user, opts.pass));\n    }\n    return buf.length === 0 ? noAuthFn() : multiAuthenticator(buf);\n}\nfunction parseOptions(opts) {\n    const dhp = `${DEFAULT_HOST}:${defaultPort()}`;\n    opts = opts || {\n        servers: [\n            dhp\n        ]\n    };\n    opts.servers = opts.servers || [];\n    if (typeof opts.servers === \"string\") {\n        opts.servers = [\n            opts.servers\n        ];\n    }\n    if (opts.servers.length > 0 && opts.port) {\n        throw new NatsError(\"port and servers options are mutually exclusive\", ErrorCode.InvalidOption);\n    }\n    if (opts.servers.length === 0 && opts.port) {\n        opts.servers = [\n            `${DEFAULT_HOST}:${opts.port}`\n        ];\n    }\n    if (opts.servers && opts.servers.length === 0) {\n        opts.servers = [\n            dhp\n        ];\n    }\n    const options = extend(defaultOptions(), opts);\n    options.authenticator = buildAuthenticator(options);\n    [\n        \"reconnectDelayHandler\",\n        \"authenticator\"\n    ].forEach((n)=>{\n        if (options[n] && typeof options[n] !== \"function\") {\n            throw new NatsError(`${n} option should be a function`, ErrorCode.NotFunction);\n        }\n    });\n    if (!options.reconnectDelayHandler) {\n        options.reconnectDelayHandler = ()=>{\n            let extra = options.tls ? options.reconnectJitterTLS : options.reconnectJitter;\n            if (extra) {\n                extra++;\n                extra = Math.floor(Math.random() * extra);\n            }\n            return options.reconnectTimeWait + extra;\n        };\n    }\n    if (options.inboxPrefix) {\n        try {\n            createInbox(options.inboxPrefix);\n        } catch (err) {\n            throw new NatsError(err.message, ErrorCode.ApiError);\n        }\n    }\n    if (options.resolve === undefined) {\n        options.resolve = typeof getResolveFn() === \"function\";\n    }\n    if (options.resolve) {\n        if (typeof getResolveFn() !== \"function\") {\n            throw new NatsError(`'resolve' is not supported on this client`, ErrorCode.InvalidOption);\n        }\n    }\n    return options;\n}\nfunction checkOptions(info, options) {\n    const { proto, tls_required: tlsRequired, tls_available: tlsAvailable } = info;\n    if ((proto === undefined || proto < 1) && options.noEcho) {\n        throw new NatsError(\"noEcho\", ErrorCode.ServerOptionNotAvailable);\n    }\n    const tls = tlsRequired || tlsAvailable || false;\n    if (options.tls && !tls) {\n        throw new NatsError(\"tls\", ErrorCode.ServerOptionNotAvailable);\n    }\n}\nconst FLUSH_THRESHOLD = 1024 * 32;\nconst INFO = /^INFO\\s+([^\\r\\n]+)\\r\\n/i;\nconst PONG_CMD = encode(\"PONG\\r\\n\");\nconst PING_CMD = encode(\"PING\\r\\n\");\nclass Connect {\n    echo;\n    no_responders;\n    protocol;\n    verbose;\n    pedantic;\n    jwt;\n    nkey;\n    sig;\n    user;\n    pass;\n    auth_token;\n    tls_required;\n    name;\n    lang;\n    version;\n    headers;\n    constructor(transport, opts, nonce){\n        this.protocol = 1;\n        this.version = transport.version;\n        this.lang = transport.lang;\n        this.echo = opts.noEcho ? false : undefined;\n        this.verbose = opts.verbose;\n        this.pedantic = opts.pedantic;\n        this.tls_required = opts.tls ? true : undefined;\n        this.name = opts.name;\n        const creds = (opts && typeof opts.authenticator === \"function\" ? opts.authenticator(nonce) : {}) || {};\n        extend(this, creds);\n    }\n}\nclass SubscriptionImpl extends QueuedIteratorImpl {\n    sid;\n    queue;\n    draining;\n    max;\n    subject;\n    drained;\n    protocol;\n    timer;\n    info;\n    cleanupFn;\n    closed;\n    requestSubject;\n    constructor(protocol, subject, opts = {}){\n        super();\n        extend(this, opts);\n        this.protocol = protocol;\n        this.subject = subject;\n        this.draining = false;\n        this.noIterator = typeof opts.callback === \"function\";\n        this.closed = deferred();\n        const asyncTraces = !(protocol.options?.noAsyncTraces || false);\n        if (opts.timeout) {\n            this.timer = timeout(opts.timeout, asyncTraces);\n            this.timer.then(()=>{\n                this.timer = undefined;\n            }).catch((err)=>{\n                this.stop(err);\n                if (this.noIterator) {\n                    this.callback(err, {});\n                }\n            });\n        }\n        if (!this.noIterator) {\n            this.iterClosed.then(()=>{\n                this.closed.resolve();\n                this.unsubscribe();\n            });\n        }\n    }\n    setPrePostHandlers(opts) {\n        if (this.noIterator) {\n            const uc = this.callback;\n            const ingestion = opts.ingestionFilterFn ? opts.ingestionFilterFn : ()=>{\n                return {\n                    ingest: true,\n                    protocol: false\n                };\n            };\n            const filter = opts.protocolFilterFn ? opts.protocolFilterFn : ()=>{\n                return true;\n            };\n            const dispatched = opts.dispatchedFn ? opts.dispatchedFn : ()=>{};\n            this.callback = (err, msg)=>{\n                const { ingest } = ingestion(msg);\n                if (!ingest) {\n                    return;\n                }\n                if (filter(msg)) {\n                    uc(err, msg);\n                    dispatched(msg);\n                }\n            };\n        } else {\n            this.protocolFilterFn = opts.protocolFilterFn;\n            this.dispatchedFn = opts.dispatchedFn;\n        }\n    }\n    callback(err, msg) {\n        this.cancelTimeout();\n        err ? this.stop(err) : this.push(msg);\n    }\n    close() {\n        if (!this.isClosed()) {\n            this.cancelTimeout();\n            const fn = ()=>{\n                this.stop();\n                if (this.cleanupFn) {\n                    try {\n                        this.cleanupFn(this, this.info);\n                    } catch (_err) {}\n                }\n                this.closed.resolve();\n            };\n            if (this.noIterator) {\n                fn();\n            } else {\n                this.push(fn);\n            }\n        }\n    }\n    unsubscribe(max) {\n        this.protocol.unsubscribe(this, max);\n    }\n    cancelTimeout() {\n        if (this.timer) {\n            this.timer.cancel();\n            this.timer = undefined;\n        }\n    }\n    drain() {\n        if (this.protocol.isClosed()) {\n            return Promise.reject(NatsError.errorForCode(ErrorCode.ConnectionClosed));\n        }\n        if (this.isClosed()) {\n            return Promise.reject(NatsError.errorForCode(ErrorCode.SubClosed));\n        }\n        if (!this.drained) {\n            this.draining = true;\n            this.protocol.unsub(this);\n            this.drained = this.protocol.flush(deferred()).then(()=>{\n                this.protocol.subscriptions.cancel(this);\n            }).catch(()=>{\n                this.protocol.subscriptions.cancel(this);\n            });\n        }\n        return this.drained;\n    }\n    isDraining() {\n        return this.draining;\n    }\n    isClosed() {\n        return this.done;\n    }\n    getSubject() {\n        return this.subject;\n    }\n    getMax() {\n        return this.max;\n    }\n    getID() {\n        return this.sid;\n    }\n}\nclass Subscriptions {\n    mux;\n    subs;\n    sidCounter;\n    constructor(){\n        this.sidCounter = 0;\n        this.mux = null;\n        this.subs = new Map();\n    }\n    size() {\n        return this.subs.size;\n    }\n    add(s) {\n        this.sidCounter++;\n        s.sid = this.sidCounter;\n        this.subs.set(s.sid, s);\n        return s;\n    }\n    setMux(s) {\n        this.mux = s;\n        return s;\n    }\n    getMux() {\n        return this.mux;\n    }\n    get(sid) {\n        return this.subs.get(sid);\n    }\n    resub(s) {\n        this.sidCounter++;\n        this.subs.delete(s.sid);\n        s.sid = this.sidCounter;\n        this.subs.set(s.sid, s);\n        return s;\n    }\n    all() {\n        return Array.from(this.subs.values());\n    }\n    cancel(s) {\n        if (s) {\n            s.close();\n            this.subs.delete(s.sid);\n        }\n    }\n    handleError(err) {\n        if (err && err.permissionContext) {\n            const ctx = err.permissionContext;\n            const subs = this.all();\n            let sub;\n            if (ctx.operation === \"subscription\") {\n                sub = subs.find((s)=>{\n                    return s.subject === ctx.subject && s.queue === ctx.queue;\n                });\n            }\n            if (ctx.operation === \"publish\") {\n                sub = subs.find((s)=>{\n                    return s.requestSubject === ctx.subject;\n                });\n            }\n            if (sub) {\n                sub.callback(err, {});\n                sub.close();\n                this.subs.delete(sub.sid);\n                return sub !== this.mux;\n            }\n        }\n        return false;\n    }\n    close() {\n        this.subs.forEach((sub)=>{\n            sub.close();\n        });\n    }\n}\nclass ProtocolHandler {\n    connected;\n    connectedOnce;\n    infoReceived;\n    info;\n    muxSubscriptions;\n    options;\n    outbound;\n    pongs;\n    subscriptions;\n    transport;\n    noMorePublishing;\n    connectError;\n    publisher;\n    _closed;\n    closed;\n    listeners;\n    heartbeats;\n    parser;\n    outMsgs;\n    inMsgs;\n    outBytes;\n    inBytes;\n    pendingLimit;\n    lastError;\n    abortReconnect;\n    whyClosed;\n    servers;\n    server;\n    features;\n    connectPromise;\n    constructor(options, publisher){\n        this._closed = false;\n        this.connected = false;\n        this.connectedOnce = false;\n        this.infoReceived = false;\n        this.noMorePublishing = false;\n        this.abortReconnect = false;\n        this.listeners = [];\n        this.pendingLimit = FLUSH_THRESHOLD;\n        this.outMsgs = 0;\n        this.inMsgs = 0;\n        this.outBytes = 0;\n        this.inBytes = 0;\n        this.options = options;\n        this.publisher = publisher;\n        this.subscriptions = new Subscriptions();\n        this.muxSubscriptions = new MuxSubscription();\n        this.outbound = new DataBuffer();\n        this.pongs = [];\n        this.whyClosed = \"\";\n        this.pendingLimit = options.pendingLimit || this.pendingLimit;\n        this.features = new Features({\n            major: 0,\n            minor: 0,\n            micro: 0\n        });\n        this.connectPromise = null;\n        const servers = typeof options.servers === \"string\" ? [\n            options.servers\n        ] : options.servers;\n        this.servers = new Servers(servers, {\n            randomize: !options.noRandomize\n        });\n        this.closed = deferred();\n        this.parser = new Parser(this);\n        this.heartbeats = new Heartbeat(this, this.options.pingInterval || DEFAULT_PING_INTERVAL, this.options.maxPingOut || DEFAULT_MAX_PING_OUT);\n    }\n    resetOutbound() {\n        this.outbound.reset();\n        const pongs = this.pongs;\n        this.pongs = [];\n        const err = NatsError.errorForCode(ErrorCode.Disconnect);\n        err.stack = \"\";\n        pongs.forEach((p)=>{\n            p.reject(err);\n        });\n        this.parser = new Parser(this);\n        this.infoReceived = false;\n    }\n    dispatchStatus(status) {\n        this.listeners.forEach((q)=>{\n            q.push(status);\n        });\n    }\n    status() {\n        const iter = new QueuedIteratorImpl();\n        this.listeners.push(iter);\n        return iter;\n    }\n    prepare() {\n        if (this.transport) {\n            this.transport.discard();\n        }\n        this.info = undefined;\n        this.resetOutbound();\n        const pong = deferred();\n        pong.catch(()=>{});\n        this.pongs.unshift(pong);\n        this.connectError = (err)=>{\n            pong.reject(err);\n        };\n        this.transport = newTransport();\n        this.transport.closed().then(async (_err)=>{\n            this.connected = false;\n            if (!this.isClosed()) {\n                await this.disconnected(this.transport.closeError || this.lastError);\n                return;\n            }\n        });\n        return pong;\n    }\n    disconnect() {\n        this.dispatchStatus({\n            type: DebugEvents.StaleConnection,\n            data: \"\"\n        });\n        this.transport.disconnect();\n    }\n    reconnect() {\n        if (this.connected) {\n            this.dispatchStatus({\n                type: DebugEvents.ClientInitiatedReconnect,\n                data: \"\"\n            });\n            this.transport.disconnect();\n        }\n        return Promise.resolve();\n    }\n    async disconnected(err) {\n        this.dispatchStatus({\n            type: Events.Disconnect,\n            data: this.servers.getCurrentServer().toString()\n        });\n        if (this.options.reconnect) {\n            await this.dialLoop().then(()=>{\n                this.dispatchStatus({\n                    type: Events.Reconnect,\n                    data: this.servers.getCurrentServer().toString()\n                });\n                if (this.lastError?.code === ErrorCode.AuthenticationExpired) {\n                    this.lastError = undefined;\n                }\n            }).catch((err)=>{\n                this._close(err);\n            });\n        } else {\n            await this._close(err);\n        }\n    }\n    async dial(srv) {\n        const pong = this.prepare();\n        let timer;\n        try {\n            timer = timeout(this.options.timeout || 20000);\n            const cp = this.transport.connect(srv, this.options);\n            await Promise.race([\n                cp,\n                timer\n            ]);\n            (async ()=>{\n                try {\n                    for await (const b of this.transport){\n                        this.parser.parse(b);\n                    }\n                } catch (err) {\n                    console.log(\"reader closed\", err);\n                }\n            })().then();\n        } catch (err) {\n            pong.reject(err);\n        }\n        try {\n            await Promise.race([\n                timer,\n                pong\n            ]);\n            if (timer) {\n                timer.cancel();\n            }\n            this.connected = true;\n            this.connectError = undefined;\n            this.sendSubscriptions();\n            this.connectedOnce = true;\n            this.server.didConnect = true;\n            this.server.reconnects = 0;\n            this.flushPending();\n            this.heartbeats.start();\n        } catch (err) {\n            if (timer) {\n                timer.cancel();\n            }\n            await this.transport.close(err);\n            throw err;\n        }\n    }\n    async _doDial(srv) {\n        const { resolve } = this.options;\n        const alts = await srv.resolve({\n            fn: getResolveFn(),\n            debug: this.options.debug,\n            randomize: !this.options.noRandomize,\n            resolve\n        });\n        let lastErr = null;\n        for (const a of alts){\n            try {\n                lastErr = null;\n                this.dispatchStatus({\n                    type: DebugEvents.Reconnecting,\n                    data: a.toString()\n                });\n                await this.dial(a);\n                return;\n            } catch (err) {\n                lastErr = err;\n            }\n        }\n        throw lastErr;\n    }\n    dialLoop() {\n        if (this.connectPromise === null) {\n            this.connectPromise = this.dodialLoop();\n            this.connectPromise.then(()=>{}).catch(()=>{}).finally(()=>{\n                this.connectPromise = null;\n            });\n        }\n        return this.connectPromise;\n    }\n    async dodialLoop() {\n        let lastError;\n        while(true){\n            if (this._closed) {\n                this.servers.clear();\n            }\n            const wait = this.options.reconnectDelayHandler ? this.options.reconnectDelayHandler() : DEFAULT_RECONNECT_TIME_WAIT;\n            let maxWait = wait;\n            const srv = this.selectServer();\n            if (!srv || this.abortReconnect) {\n                if (lastError) {\n                    throw lastError;\n                } else if (this.lastError) {\n                    throw this.lastError;\n                } else {\n                    throw NatsError.errorForCode(ErrorCode.ConnectionRefused);\n                }\n            }\n            const now = Date.now();\n            if (srv.lastConnect === 0 || srv.lastConnect + wait <= now) {\n                srv.lastConnect = Date.now();\n                try {\n                    await this._doDial(srv);\n                    break;\n                } catch (err) {\n                    lastError = err;\n                    if (!this.connectedOnce) {\n                        if (this.options.waitOnFirstConnect) {\n                            continue;\n                        }\n                        this.servers.removeCurrentServer();\n                    }\n                    srv.reconnects++;\n                    const mra = this.options.maxReconnectAttempts || 0;\n                    if (mra !== -1 && srv.reconnects >= mra) {\n                        this.servers.removeCurrentServer();\n                    }\n                }\n            } else {\n                maxWait = Math.min(maxWait, srv.lastConnect + wait - now);\n                await delay(maxWait);\n            }\n        }\n    }\n    static async connect(options, publisher) {\n        const h = new ProtocolHandler(options, publisher);\n        await h.dialLoop();\n        return h;\n    }\n    static toError(s) {\n        const t = s ? s.toLowerCase() : \"\";\n        if (t.indexOf(\"permissions violation\") !== -1) {\n            const err = new NatsError(s, ErrorCode.PermissionsViolation);\n            const m = s.match(/(Publish|Subscription) to \"(\\S+)\"/);\n            if (m) {\n                err.permissionContext = {\n                    operation: m[1].toLowerCase(),\n                    subject: m[2],\n                    queue: undefined\n                };\n                const qm = s.match(/using queue \"(\\S+)\"/);\n                if (qm) {\n                    err.permissionContext.queue = qm[1];\n                }\n            }\n            return err;\n        } else if (t.indexOf(\"authorization violation\") !== -1) {\n            return new NatsError(s, ErrorCode.AuthorizationViolation);\n        } else if (t.indexOf(\"user authentication expired\") !== -1) {\n            return new NatsError(s, ErrorCode.AuthenticationExpired);\n        } else if (t.indexOf(\"account authentication expired\") != -1) {\n            return new NatsError(s, ErrorCode.AccountExpired);\n        } else if (t.indexOf(\"authentication timeout\") !== -1) {\n            return new NatsError(s, ErrorCode.AuthenticationTimeout);\n        } else {\n            return new NatsError(s, ErrorCode.ProtocolError);\n        }\n    }\n    processMsg(msg, data) {\n        this.inMsgs++;\n        this.inBytes += data.length;\n        if (!this.subscriptions.sidCounter) {\n            return;\n        }\n        const sub = this.subscriptions.get(msg.sid);\n        if (!sub) {\n            return;\n        }\n        sub.received += 1;\n        if (sub.callback) {\n            sub.callback(null, new MsgImpl(msg, data, this));\n        }\n        if (sub.max !== undefined && sub.received >= sub.max) {\n            sub.unsubscribe();\n        }\n    }\n    processError(m) {\n        const s = decode(m);\n        const err = ProtocolHandler.toError(s);\n        const status = {\n            type: Events.Error,\n            data: err.code\n        };\n        if (err.isPermissionError()) {\n            let isMuxPermissionError = false;\n            if (err.permissionContext) {\n                status.permissionContext = err.permissionContext;\n                const mux = this.subscriptions.getMux();\n                isMuxPermissionError = mux?.subject === err.permissionContext.subject;\n            }\n            this.subscriptions.handleError(err);\n            this.muxSubscriptions.handleError(isMuxPermissionError, err);\n            if (isMuxPermissionError) {\n                this.subscriptions.setMux(null);\n            }\n        }\n        this.dispatchStatus(status);\n        this.handleError(err);\n    }\n    handleError(err) {\n        if (err.isAuthError()) {\n            this.handleAuthError(err);\n        } else if (err.isProtocolError()) {\n            this.lastError = err;\n        } else if (err.isAuthTimeout()) {\n            this.lastError = err;\n        }\n        if (!err.isPermissionError()) {\n            this.lastError = err;\n        }\n    }\n    handleAuthError(err) {\n        if (this.lastError && err.code === this.lastError.code && this.options.ignoreAuthErrorAbort === false) {\n            this.abortReconnect = true;\n        }\n        if (this.connectError) {\n            this.connectError(err);\n        } else {\n            this.disconnect();\n        }\n    }\n    processPing() {\n        this.transport.send(PONG_CMD);\n    }\n    processPong() {\n        const cb = this.pongs.shift();\n        if (cb) {\n            cb.resolve();\n        }\n    }\n    processInfo(m) {\n        const info = JSON.parse(decode(m));\n        this.info = info;\n        const updates = this.options && this.options.ignoreClusterUpdates ? undefined : this.servers.update(info, this.transport.isEncrypted());\n        if (!this.infoReceived) {\n            this.features.update(parseSemVer(info.version));\n            this.infoReceived = true;\n            if (this.transport.isEncrypted()) {\n                this.servers.updateTLSName();\n            }\n            const { version, lang } = this.transport;\n            try {\n                const c = new Connect({\n                    version,\n                    lang\n                }, this.options, info.nonce);\n                if (info.headers) {\n                    c.headers = true;\n                    c.no_responders = true;\n                }\n                const cs = JSON.stringify(c);\n                this.transport.send(encode(`CONNECT ${cs}${CR_LF}`));\n                this.transport.send(PING_CMD);\n            } catch (err) {\n                this._close(err);\n            }\n        }\n        if (updates) {\n            this.dispatchStatus({\n                type: Events.Update,\n                data: updates\n            });\n        }\n        const ldm = info.ldm !== undefined ? info.ldm : false;\n        if (ldm) {\n            this.dispatchStatus({\n                type: Events.LDM,\n                data: this.servers.getCurrentServer().toString()\n            });\n        }\n    }\n    push(e) {\n        switch(e.kind){\n            case Kind.MSG:\n                {\n                    const { msg, data } = e;\n                    this.processMsg(msg, data);\n                    break;\n                }\n            case Kind.OK:\n                break;\n            case Kind.ERR:\n                this.processError(e.data);\n                break;\n            case Kind.PING:\n                this.processPing();\n                break;\n            case Kind.PONG:\n                this.processPong();\n                break;\n            case Kind.INFO:\n                this.processInfo(e.data);\n                break;\n        }\n    }\n    sendCommand(cmd, ...payloads) {\n        const len = this.outbound.length();\n        let buf;\n        if (typeof cmd === \"string\") {\n            buf = encode(cmd);\n        } else {\n            buf = cmd;\n        }\n        this.outbound.fill(buf, ...payloads);\n        if (len === 0) {\n            queueMicrotask(()=>{\n                this.flushPending();\n            });\n        } else if (this.outbound.size() >= this.pendingLimit) {\n            this.flushPending();\n        }\n    }\n    publish(subject, payload = Empty, options) {\n        let data;\n        if (payload instanceof Uint8Array) {\n            data = payload;\n        } else if (typeof payload === \"string\") {\n            data = TE.encode(payload);\n        } else {\n            throw NatsError.errorForCode(ErrorCode.BadPayload);\n        }\n        let len = data.length;\n        options = options || {};\n        options.reply = options.reply || \"\";\n        let headers = Empty;\n        let hlen = 0;\n        if (options.headers) {\n            if (this.info && !this.info.headers) {\n                throw new NatsError(\"headers\", ErrorCode.ServerOptionNotAvailable);\n            }\n            const hdrs = options.headers;\n            headers = hdrs.encode();\n            hlen = headers.length;\n            len = data.length + hlen;\n        }\n        if (this.info && len > this.info.max_payload) {\n            throw NatsError.errorForCode(ErrorCode.MaxPayloadExceeded);\n        }\n        this.outBytes += len;\n        this.outMsgs++;\n        let proto;\n        if (options.headers) {\n            if (options.reply) {\n                proto = `HPUB ${subject} ${options.reply} ${hlen} ${len}\\r\\n`;\n            } else {\n                proto = `HPUB ${subject} ${hlen} ${len}\\r\\n`;\n            }\n            this.sendCommand(proto, headers, data, CRLF);\n        } else {\n            if (options.reply) {\n                proto = `PUB ${subject} ${options.reply} ${len}\\r\\n`;\n            } else {\n                proto = `PUB ${subject} ${len}\\r\\n`;\n            }\n            this.sendCommand(proto, data, CRLF);\n        }\n    }\n    request(r) {\n        this.initMux();\n        this.muxSubscriptions.add(r);\n        return r;\n    }\n    subscribe(s) {\n        this.subscriptions.add(s);\n        this._subunsub(s);\n        return s;\n    }\n    _sub(s) {\n        if (s.queue) {\n            this.sendCommand(`SUB ${s.subject} ${s.queue} ${s.sid}\\r\\n`);\n        } else {\n            this.sendCommand(`SUB ${s.subject} ${s.sid}\\r\\n`);\n        }\n    }\n    _subunsub(s) {\n        this._sub(s);\n        if (s.max) {\n            this.unsubscribe(s, s.max);\n        }\n        return s;\n    }\n    unsubscribe(s, max) {\n        this.unsub(s, max);\n        if (s.max === undefined || s.received >= s.max) {\n            this.subscriptions.cancel(s);\n        }\n    }\n    unsub(s, max) {\n        if (!s || this.isClosed()) {\n            return;\n        }\n        if (max) {\n            this.sendCommand(`UNSUB ${s.sid} ${max}\\r\\n`);\n        } else {\n            this.sendCommand(`UNSUB ${s.sid}\\r\\n`);\n        }\n        s.max = max;\n    }\n    resub(s, subject) {\n        if (!s || this.isClosed()) {\n            return;\n        }\n        this.unsub(s);\n        s.subject = subject;\n        this.subscriptions.resub(s);\n        this._sub(s);\n    }\n    flush(p) {\n        if (!p) {\n            p = deferred();\n        }\n        this.pongs.push(p);\n        this.outbound.fill(PING_CMD);\n        this.flushPending();\n        return p;\n    }\n    sendSubscriptions() {\n        const cmds = [];\n        this.subscriptions.all().forEach((s)=>{\n            const sub = s;\n            if (sub.queue) {\n                cmds.push(`SUB ${sub.subject} ${sub.queue} ${sub.sid}${CR_LF}`);\n            } else {\n                cmds.push(`SUB ${sub.subject} ${sub.sid}${CR_LF}`);\n            }\n        });\n        if (cmds.length) {\n            this.transport.send(encode(cmds.join(\"\")));\n        }\n    }\n    async _close(err) {\n        if (this._closed) {\n            return;\n        }\n        this.whyClosed = new Error(\"close trace\").stack || \"\";\n        this.heartbeats.cancel();\n        if (this.connectError) {\n            this.connectError(err);\n            this.connectError = undefined;\n        }\n        this.muxSubscriptions.close();\n        this.subscriptions.close();\n        this.listeners.forEach((l)=>{\n            l.stop();\n        });\n        this._closed = true;\n        await this.transport.close(err);\n        await this.closed.resolve(err);\n    }\n    close() {\n        return this._close();\n    }\n    isClosed() {\n        return this._closed;\n    }\n    drain() {\n        const subs = this.subscriptions.all();\n        const promises = [];\n        subs.forEach((sub)=>{\n            promises.push(sub.drain());\n        });\n        return Promise.all(promises).then(async ()=>{\n            this.noMorePublishing = true;\n            await this.flush();\n            return this.close();\n        }).catch(()=>{});\n    }\n    flushPending() {\n        if (!this.infoReceived || !this.connected) {\n            return;\n        }\n        if (this.outbound.size()) {\n            const d = this.outbound.drain();\n            this.transport.send(d);\n        }\n    }\n    initMux() {\n        const mux = this.subscriptions.getMux();\n        if (!mux) {\n            const inbox = this.muxSubscriptions.init(this.options.inboxPrefix);\n            const sub = new SubscriptionImpl(this, `${inbox}*`);\n            sub.callback = this.muxSubscriptions.dispatcher();\n            this.subscriptions.setMux(sub);\n            this.subscribe(sub);\n        }\n    }\n    selectServer() {\n        const server = this.servers.selectServer();\n        if (server === undefined) {\n            return undefined;\n        }\n        this.server = server;\n        return this.server;\n    }\n    getServer() {\n        return this.server;\n    }\n}\nconst ServiceApiPrefix = \"$SRV\";\nclass ServiceMsgImpl {\n    msg;\n    constructor(msg){\n        this.msg = msg;\n    }\n    get data() {\n        return this.msg.data;\n    }\n    get sid() {\n        return this.msg.sid;\n    }\n    get subject() {\n        return this.msg.subject;\n    }\n    get reply() {\n        return this.msg.reply || \"\";\n    }\n    get headers() {\n        return this.msg.headers;\n    }\n    respond(data, opts) {\n        return this.msg.respond(data, opts);\n    }\n    respondError(code, description, data, opts) {\n        opts = opts || {};\n        opts.headers = opts.headers || headers();\n        opts.headers?.set(ServiceErrorCodeHeader, `${code}`);\n        opts.headers?.set(ServiceErrorHeader, description);\n        return this.msg.respond(data, opts);\n    }\n    json(reviver) {\n        return this.msg.json(reviver);\n    }\n    string() {\n        return this.msg.string();\n    }\n}\nclass ServiceGroupImpl {\n    subject;\n    queue;\n    srv;\n    constructor(parent, name = \"\", queue = \"\"){\n        if (name !== \"\") {\n            validInternalToken(\"service group\", name);\n        }\n        let root = \"\";\n        if (parent instanceof ServiceImpl) {\n            this.srv = parent;\n            root = \"\";\n        } else if (parent instanceof ServiceGroupImpl) {\n            const sg = parent;\n            this.srv = sg.srv;\n            if (queue === \"\" && sg.queue !== \"\") {\n                queue = sg.queue;\n            }\n            root = sg.subject;\n        } else {\n            throw new Error(\"unknown ServiceGroup type\");\n        }\n        this.subject = this.calcSubject(root, name);\n        this.queue = queue;\n    }\n    calcSubject(root, name = \"\") {\n        if (name === \"\") {\n            return root;\n        }\n        return root !== \"\" ? `${root}.${name}` : name;\n    }\n    addEndpoint(name = \"\", opts) {\n        opts = opts || {\n            subject: name\n        };\n        const args = typeof opts === \"function\" ? {\n            handler: opts,\n            subject: name\n        } : opts;\n        validateName(\"endpoint\", name);\n        let { subject, handler, metadata, queue } = args;\n        subject = subject || name;\n        queue = queue || this.queue;\n        validSubjectName(\"endpoint subject\", subject);\n        subject = this.calcSubject(this.subject, subject);\n        const ne = {\n            name,\n            subject,\n            queue,\n            handler,\n            metadata\n        };\n        return this.srv._addEndpoint(ne);\n    }\n    addGroup(name = \"\", queue = \"\") {\n        return new ServiceGroupImpl(this, name, queue);\n    }\n}\nfunction validSubjectName(context, subj) {\n    if (subj === \"\") {\n        throw new Error(`${context} cannot be empty`);\n    }\n    if (subj.indexOf(\" \") !== -1) {\n        throw new Error(`${context} cannot contain spaces: '${subj}'`);\n    }\n    const tokens = subj.split(\".\");\n    tokens.forEach((v, idx)=>{\n        if (v === \">\" && idx !== tokens.length - 1) {\n            throw new Error(`${context} cannot have internal '>': '${subj}'`);\n        }\n    });\n}\nfunction validInternalToken(context, subj) {\n    if (subj.indexOf(\" \") !== -1) {\n        throw new Error(`${context} cannot contain spaces: '${subj}'`);\n    }\n    const tokens = subj.split(\".\");\n    tokens.forEach((v)=>{\n        if (v === \">\") {\n            throw new Error(`${context} name cannot contain internal '>': '${subj}'`);\n        }\n    });\n}\nclass ServiceImpl {\n    nc;\n    _id;\n    config;\n    handlers;\n    internal;\n    _stopped;\n    _done;\n    started;\n    static controlSubject(verb, name = \"\", id = \"\", prefix) {\n        const pre = prefix ?? ServiceApiPrefix;\n        if (name === \"\" && id === \"\") {\n            return `${pre}.${verb}`;\n        }\n        validateName(\"control subject name\", name);\n        if (id !== \"\") {\n            validateName(\"control subject id\", id);\n            return `${pre}.${verb}.${name}.${id}`;\n        }\n        return `${pre}.${verb}.${name}`;\n    }\n    constructor(nc, config = {\n        name: \"\",\n        version: \"\"\n    }){\n        this.nc = nc;\n        this.config = Object.assign({}, config);\n        if (!this.config.queue) {\n            this.config.queue = \"q\";\n        }\n        validateName(\"name\", this.config.name);\n        validateName(\"queue\", this.config.queue);\n        parseSemVer(this.config.version);\n        this._id = nuid.next();\n        this.internal = [];\n        this._done = deferred();\n        this._stopped = false;\n        this.handlers = [];\n        this.started = new Date().toISOString();\n        this.reset();\n        this.nc.closed().then(()=>{\n            this.close().catch();\n        }).catch((err)=>{\n            this.close(err).catch();\n        });\n    }\n    get subjects() {\n        return this.handlers.filter((s)=>{\n            return s.internal === false;\n        }).map((s)=>{\n            return s.subject;\n        });\n    }\n    get id() {\n        return this._id;\n    }\n    get name() {\n        return this.config.name;\n    }\n    get description() {\n        return this.config.description ?? \"\";\n    }\n    get version() {\n        return this.config.version;\n    }\n    get metadata() {\n        return this.config.metadata;\n    }\n    errorToHeader(err) {\n        const h = headers();\n        if (err instanceof ServiceError) {\n            const se = err;\n            h.set(ServiceErrorHeader, se.message);\n            h.set(ServiceErrorCodeHeader, `${se.code}`);\n        } else {\n            h.set(ServiceErrorHeader, err.message);\n            h.set(ServiceErrorCodeHeader, \"500\");\n        }\n        return h;\n    }\n    setupHandler(h, internal = false) {\n        const queue = internal ? \"\" : h.queue ? h.queue : this.config.queue;\n        const { name, subject, handler } = h;\n        const sv = h;\n        sv.internal = internal;\n        if (internal) {\n            this.internal.push(sv);\n        }\n        sv.stats = new NamedEndpointStatsImpl(name, subject, queue);\n        sv.queue = queue;\n        const callback = handler ? (err, msg)=>{\n            if (err) {\n                this.close(err);\n                return;\n            }\n            const start = Date.now();\n            try {\n                handler(err, new ServiceMsgImpl(msg));\n            } catch (err) {\n                sv.stats.countError(err);\n                msg?.respond(Empty, {\n                    headers: this.errorToHeader(err)\n                });\n            } finally{\n                sv.stats.countLatency(start);\n            }\n        } : undefined;\n        sv.sub = this.nc.subscribe(subject, {\n            callback,\n            queue\n        });\n        sv.sub.closed.then(()=>{\n            if (!this._stopped) {\n                this.close(new Error(`required subscription ${h.subject} stopped`)).catch();\n            }\n        }).catch((err)=>{\n            if (!this._stopped) {\n                const ne = new Error(`required subscription ${h.subject} errored: ${err.message}`);\n                ne.stack = err.stack;\n                this.close(ne).catch();\n            }\n        });\n        return sv;\n    }\n    info() {\n        return {\n            type: ServiceResponseType.INFO,\n            name: this.name,\n            id: this.id,\n            version: this.version,\n            description: this.description,\n            metadata: this.metadata,\n            endpoints: this.endpoints()\n        };\n    }\n    endpoints() {\n        return this.handlers.map((v)=>{\n            const { subject, metadata, name, queue } = v;\n            return {\n                subject,\n                metadata,\n                name,\n                queue_group: queue\n            };\n        });\n    }\n    async stats() {\n        const endpoints = [];\n        for (const h of this.handlers){\n            if (typeof this.config.statsHandler === \"function\") {\n                try {\n                    h.stats.data = await this.config.statsHandler(h);\n                } catch (err) {\n                    h.stats.countError(err);\n                }\n            }\n            endpoints.push(h.stats.stats(h.qi));\n        }\n        return {\n            type: ServiceResponseType.STATS,\n            name: this.name,\n            id: this.id,\n            version: this.version,\n            started: this.started,\n            metadata: this.metadata,\n            endpoints\n        };\n    }\n    addInternalHandler(verb, handler) {\n        const v = `${verb}`.toUpperCase();\n        this._doAddInternalHandler(`${v}-all`, verb, handler);\n        this._doAddInternalHandler(`${v}-kind`, verb, handler, this.name);\n        this._doAddInternalHandler(`${v}`, verb, handler, this.name, this.id);\n    }\n    _doAddInternalHandler(name, verb, handler, kind = \"\", id = \"\") {\n        const endpoint = {};\n        endpoint.name = name;\n        endpoint.subject = ServiceImpl.controlSubject(verb, kind, id);\n        endpoint.handler = handler;\n        this.setupHandler(endpoint, true);\n    }\n    start() {\n        const jc = JSONCodec();\n        const statsHandler = (err, msg)=>{\n            if (err) {\n                this.close(err);\n                return Promise.reject(err);\n            }\n            return this.stats().then((s)=>{\n                msg?.respond(jc.encode(s));\n                return Promise.resolve();\n            });\n        };\n        const infoHandler = (err, msg)=>{\n            if (err) {\n                this.close(err);\n                return Promise.reject(err);\n            }\n            msg?.respond(jc.encode(this.info()));\n            return Promise.resolve();\n        };\n        const ping = jc.encode(this.ping());\n        const pingHandler = (err, msg)=>{\n            if (err) {\n                this.close(err).then().catch();\n                return Promise.reject(err);\n            }\n            msg.respond(ping);\n            return Promise.resolve();\n        };\n        this.addInternalHandler(ServiceVerb.PING, pingHandler);\n        this.addInternalHandler(ServiceVerb.STATS, statsHandler);\n        this.addInternalHandler(ServiceVerb.INFO, infoHandler);\n        this.handlers.forEach((h)=>{\n            const { subject } = h;\n            if (typeof subject !== \"string\") {\n                return;\n            }\n            if (h.handler === null) {\n                return;\n            }\n            this.setupHandler(h);\n        });\n        return Promise.resolve(this);\n    }\n    close(err) {\n        if (this._stopped) {\n            return this._done;\n        }\n        this._stopped = true;\n        let buf = [];\n        if (!this.nc.isClosed()) {\n            buf = this.handlers.concat(this.internal).map((h)=>{\n                return h.sub.drain();\n            });\n        }\n        Promise.allSettled(buf).then(()=>{\n            this._done.resolve(err ? err : null);\n        });\n        return this._done;\n    }\n    get stopped() {\n        return this._done;\n    }\n    get isStopped() {\n        return this._stopped;\n    }\n    stop(err) {\n        return this.close(err);\n    }\n    ping() {\n        return {\n            type: ServiceResponseType.PING,\n            name: this.name,\n            id: this.id,\n            version: this.version,\n            metadata: this.metadata\n        };\n    }\n    reset() {\n        this.started = new Date().toISOString();\n        if (this.handlers) {\n            for (const h of this.handlers){\n                h.stats.reset(h.qi);\n            }\n        }\n    }\n    addGroup(name, queue) {\n        return new ServiceGroupImpl(this, name, queue);\n    }\n    addEndpoint(name, handler) {\n        const sg = new ServiceGroupImpl(this);\n        return sg.addEndpoint(name, handler);\n    }\n    _addEndpoint(e) {\n        const qi = new QueuedIteratorImpl();\n        qi.noIterator = typeof e.handler === \"function\";\n        if (!qi.noIterator) {\n            e.handler = (err, msg)=>{\n                err ? this.stop(err).catch() : qi.push(new ServiceMsgImpl(msg));\n            };\n            qi.iterClosed.then(()=>{\n                this.close().catch();\n            });\n        }\n        const ss = this.setupHandler(e, false);\n        ss.qi = qi;\n        this.handlers.push(ss);\n        return qi;\n    }\n}\nclass NamedEndpointStatsImpl {\n    name;\n    subject;\n    average_processing_time;\n    num_requests;\n    processing_time;\n    num_errors;\n    last_error;\n    data;\n    metadata;\n    queue;\n    constructor(name, subject, queue = \"\"){\n        this.name = name;\n        this.subject = subject;\n        this.average_processing_time = 0;\n        this.num_errors = 0;\n        this.num_requests = 0;\n        this.processing_time = 0;\n        this.queue = queue;\n    }\n    reset(qi) {\n        this.num_requests = 0;\n        this.processing_time = 0;\n        this.average_processing_time = 0;\n        this.num_errors = 0;\n        this.last_error = undefined;\n        this.data = undefined;\n        const qii = qi;\n        if (qii) {\n            qii.time = 0;\n            qii.processed = 0;\n        }\n    }\n    countLatency(start) {\n        this.num_requests++;\n        this.processing_time += nanos(Date.now() - start);\n        this.average_processing_time = Math.round(this.processing_time / this.num_requests);\n    }\n    countError(err) {\n        this.num_errors++;\n        this.last_error = err.message;\n    }\n    _stats() {\n        const { name, subject, average_processing_time, num_errors, num_requests, processing_time, last_error, data, queue } = this;\n        return {\n            name,\n            subject,\n            average_processing_time,\n            num_errors,\n            num_requests,\n            processing_time,\n            last_error,\n            data,\n            queue_group: queue\n        };\n    }\n    stats(qi) {\n        const qii = qi;\n        if (qii?.noIterator === false) {\n            this.processing_time = nanos(qii.time);\n            this.num_requests = qii.processed;\n            this.average_processing_time = this.processing_time > 0 && this.num_requests > 0 ? this.processing_time / this.num_requests : 0;\n        }\n        return this._stats();\n    }\n}\nclass ServiceClientImpl {\n    nc;\n    prefix;\n    opts;\n    constructor(nc, opts = {\n        strategy: RequestStrategy.JitterTimer,\n        maxWait: 2000\n    }, prefix){\n        this.nc = nc;\n        this.prefix = prefix;\n        this.opts = opts;\n    }\n    ping(name = \"\", id = \"\") {\n        return this.q(ServiceVerb.PING, name, id);\n    }\n    stats(name = \"\", id = \"\") {\n        return this.q(ServiceVerb.STATS, name, id);\n    }\n    info(name = \"\", id = \"\") {\n        return this.q(ServiceVerb.INFO, name, id);\n    }\n    async q(v, name = \"\", id = \"\") {\n        const iter = new QueuedIteratorImpl();\n        const jc = JSONCodec();\n        const subj = ServiceImpl.controlSubject(v, name, id, this.prefix);\n        const responses = await this.nc.requestMany(subj, Empty, this.opts);\n        (async ()=>{\n            for await (const m of responses){\n                try {\n                    const s = jc.decode(m.data);\n                    iter.push(s);\n                } catch (err) {\n                    iter.push(()=>{\n                        iter.stop(err);\n                    });\n                }\n            }\n            iter.push(()=>{\n                iter.stop();\n            });\n        })().catch((err)=>{\n            iter.stop(err);\n        });\n        return iter;\n    }\n}\nclass Metric {\n    name;\n    duration;\n    date;\n    payload;\n    msgs;\n    lang;\n    version;\n    bytes;\n    asyncRequests;\n    min;\n    max;\n    constructor(name, duration){\n        this.name = name;\n        this.duration = duration;\n        this.date = Date.now();\n        this.payload = 0;\n        this.msgs = 0;\n        this.bytes = 0;\n    }\n    toString() {\n        const sec = this.duration / 1000;\n        const mps = Math.round(this.msgs / sec);\n        const label = this.asyncRequests ? \"asyncRequests\" : \"\";\n        let minmax = \"\";\n        if (this.max) {\n            minmax = `${this.min}/${this.max}`;\n        }\n        return `${this.name}${label ? \" [asyncRequests]\" : \"\"} ${humanizeNumber(mps)} msgs/sec - [${sec.toFixed(2)} secs] ~ ${throughput(this.bytes, sec)} ${minmax}`;\n    }\n    toCsv() {\n        return `\"${this.name}\",${new Date(this.date).toISOString()},${this.lang},${this.version},${this.msgs},${this.payload},${this.bytes},${this.duration},${this.asyncRequests ? this.asyncRequests : false}\\n`;\n    }\n    static header() {\n        return `Test,Date,Lang,Version,Count,MsgPayload,Bytes,Millis,Async\\n`;\n    }\n}\nclass Bench {\n    nc;\n    callbacks;\n    msgs;\n    size;\n    subject;\n    asyncRequests;\n    pub;\n    sub;\n    req;\n    rep;\n    perf;\n    payload;\n    constructor(nc, opts = {\n        msgs: 100000,\n        size: 128,\n        subject: \"\",\n        asyncRequests: false,\n        pub: false,\n        sub: false,\n        req: false,\n        rep: false\n    }){\n        this.nc = nc;\n        this.callbacks = opts.callbacks || false;\n        this.msgs = opts.msgs || 0;\n        this.size = opts.size || 0;\n        this.subject = opts.subject || nuid.next();\n        this.asyncRequests = opts.asyncRequests || false;\n        this.pub = opts.pub || false;\n        this.sub = opts.sub || false;\n        this.req = opts.req || false;\n        this.rep = opts.rep || false;\n        this.perf = new Perf();\n        this.payload = this.size ? new Uint8Array(this.size) : Empty;\n        if (!this.pub && !this.sub && !this.req && !this.rep) {\n            throw new Error(\"no bench option selected\");\n        }\n    }\n    async run() {\n        this.nc.closed().then((err)=>{\n            if (err) {\n                throw new NatsError(`bench closed with an error: ${err.message}`, ErrorCode.Unknown, err);\n            }\n        });\n        if (this.callbacks) {\n            await this.runCallbacks();\n        } else {\n            await this.runAsync();\n        }\n        return this.processMetrics();\n    }\n    processMetrics() {\n        const nc = this.nc;\n        const { lang, version } = nc.protocol.transport;\n        if (this.pub && this.sub) {\n            this.perf.measure(\"pubsub\", \"pubStart\", \"subStop\");\n        }\n        if (this.req && this.rep) {\n            this.perf.measure(\"reqrep\", \"reqStart\", \"reqStop\");\n        }\n        const measures = this.perf.getEntries();\n        const pubsub = measures.find((m)=>m.name === \"pubsub\");\n        const reqrep = measures.find((m)=>m.name === \"reqrep\");\n        const req = measures.find((m)=>m.name === \"req\");\n        const rep = measures.find((m)=>m.name === \"rep\");\n        const pub = measures.find((m)=>m.name === \"pub\");\n        const sub = measures.find((m)=>m.name === \"sub\");\n        const stats = this.nc.stats();\n        const metrics = [];\n        if (pubsub) {\n            const { name, duration } = pubsub;\n            const m = new Metric(name, duration);\n            m.msgs = this.msgs * 2;\n            m.bytes = stats.inBytes + stats.outBytes;\n            m.lang = lang;\n            m.version = version;\n            m.payload = this.payload.length;\n            metrics.push(m);\n        }\n        if (reqrep) {\n            const { name, duration } = reqrep;\n            const m = new Metric(name, duration);\n            m.msgs = this.msgs * 2;\n            m.bytes = stats.inBytes + stats.outBytes;\n            m.lang = lang;\n            m.version = version;\n            m.payload = this.payload.length;\n            metrics.push(m);\n        }\n        if (pub) {\n            const { name, duration } = pub;\n            const m = new Metric(name, duration);\n            m.msgs = this.msgs;\n            m.bytes = stats.outBytes;\n            m.lang = lang;\n            m.version = version;\n            m.payload = this.payload.length;\n            metrics.push(m);\n        }\n        if (sub) {\n            const { name, duration } = sub;\n            const m = new Metric(name, duration);\n            m.msgs = this.msgs;\n            m.bytes = stats.inBytes;\n            m.lang = lang;\n            m.version = version;\n            m.payload = this.payload.length;\n            metrics.push(m);\n        }\n        if (rep) {\n            const { name, duration } = rep;\n            const m = new Metric(name, duration);\n            m.msgs = this.msgs;\n            m.bytes = stats.inBytes + stats.outBytes;\n            m.lang = lang;\n            m.version = version;\n            m.payload = this.payload.length;\n            metrics.push(m);\n        }\n        if (req) {\n            const { name, duration } = req;\n            const m = new Metric(name, duration);\n            m.msgs = this.msgs;\n            m.bytes = stats.inBytes + stats.outBytes;\n            m.lang = lang;\n            m.version = version;\n            m.payload = this.payload.length;\n            metrics.push(m);\n        }\n        return metrics;\n    }\n    async runCallbacks() {\n        const jobs = [];\n        if (this.sub) {\n            const d = deferred();\n            jobs.push(d);\n            let i = 0;\n            this.nc.subscribe(this.subject, {\n                max: this.msgs,\n                callback: ()=>{\n                    i++;\n                    if (i === 1) {\n                        this.perf.mark(\"subStart\");\n                    }\n                    if (i === this.msgs) {\n                        this.perf.mark(\"subStop\");\n                        this.perf.measure(\"sub\", \"subStart\", \"subStop\");\n                        d.resolve();\n                    }\n                }\n            });\n        }\n        if (this.rep) {\n            const d = deferred();\n            jobs.push(d);\n            let i = 0;\n            this.nc.subscribe(this.subject, {\n                max: this.msgs,\n                callback: (_, m)=>{\n                    m.respond(this.payload);\n                    i++;\n                    if (i === 1) {\n                        this.perf.mark(\"repStart\");\n                    }\n                    if (i === this.msgs) {\n                        this.perf.mark(\"repStop\");\n                        this.perf.measure(\"rep\", \"repStart\", \"repStop\");\n                        d.resolve();\n                    }\n                }\n            });\n        }\n        if (this.pub) {\n            const job = (async ()=>{\n                this.perf.mark(\"pubStart\");\n                for(let i = 0; i < this.msgs; i++){\n                    this.nc.publish(this.subject, this.payload);\n                }\n                await this.nc.flush();\n                this.perf.mark(\"pubStop\");\n                this.perf.measure(\"pub\", \"pubStart\", \"pubStop\");\n            })();\n            jobs.push(job);\n        }\n        if (this.req) {\n            const job = (async ()=>{\n                if (this.asyncRequests) {\n                    this.perf.mark(\"reqStart\");\n                    const a = [];\n                    for(let i = 0; i < this.msgs; i++){\n                        a.push(this.nc.request(this.subject, this.payload, {\n                            timeout: 20000\n                        }));\n                    }\n                    await Promise.all(a);\n                    this.perf.mark(\"reqStop\");\n                    this.perf.measure(\"req\", \"reqStart\", \"reqStop\");\n                } else {\n                    this.perf.mark(\"reqStart\");\n                    for(let i = 0; i < this.msgs; i++){\n                        await this.nc.request(this.subject);\n                    }\n                    this.perf.mark(\"reqStop\");\n                    this.perf.measure(\"req\", \"reqStart\", \"reqStop\");\n                }\n            })();\n            jobs.push(job);\n        }\n        await Promise.all(jobs);\n    }\n    async runAsync() {\n        const jobs = [];\n        if (this.rep) {\n            let first = false;\n            const sub = this.nc.subscribe(this.subject, {\n                max: this.msgs\n            });\n            const job = (async ()=>{\n                for await (const m of sub){\n                    if (!first) {\n                        this.perf.mark(\"repStart\");\n                        first = true;\n                    }\n                    m.respond(this.payload);\n                }\n                await this.nc.flush();\n                this.perf.mark(\"repStop\");\n                this.perf.measure(\"rep\", \"repStart\", \"repStop\");\n            })();\n            jobs.push(job);\n        }\n        if (this.sub) {\n            let first = false;\n            const sub = this.nc.subscribe(this.subject, {\n                max: this.msgs\n            });\n            const job = (async ()=>{\n                for await (const _m of sub){\n                    if (!first) {\n                        this.perf.mark(\"subStart\");\n                        first = true;\n                    }\n                }\n                this.perf.mark(\"subStop\");\n                this.perf.measure(\"sub\", \"subStart\", \"subStop\");\n            })();\n            jobs.push(job);\n        }\n        if (this.pub) {\n            const job = (async ()=>{\n                this.perf.mark(\"pubStart\");\n                for(let i = 0; i < this.msgs; i++){\n                    this.nc.publish(this.subject, this.payload);\n                }\n                await this.nc.flush();\n                this.perf.mark(\"pubStop\");\n                this.perf.measure(\"pub\", \"pubStart\", \"pubStop\");\n            })();\n            jobs.push(job);\n        }\n        if (this.req) {\n            const job = (async ()=>{\n                if (this.asyncRequests) {\n                    this.perf.mark(\"reqStart\");\n                    const a = [];\n                    for(let i = 0; i < this.msgs; i++){\n                        a.push(this.nc.request(this.subject, this.payload, {\n                            timeout: 20000\n                        }));\n                    }\n                    await Promise.all(a);\n                    this.perf.mark(\"reqStop\");\n                    this.perf.measure(\"req\", \"reqStart\", \"reqStop\");\n                } else {\n                    this.perf.mark(\"reqStart\");\n                    for(let i = 0; i < this.msgs; i++){\n                        await this.nc.request(this.subject);\n                    }\n                    this.perf.mark(\"reqStop\");\n                    this.perf.measure(\"req\", \"reqStart\", \"reqStop\");\n                }\n            })();\n            jobs.push(job);\n        }\n        await Promise.all(jobs);\n    }\n}\nfunction throughput(bytes, seconds) {\n    return `${humanizeBytes(bytes / seconds)}/sec`;\n}\nfunction humanizeBytes(bytes, si = false) {\n    const base = si ? 1000 : 1024;\n    const pre = si ? [\n        \"k\",\n        \"M\",\n        \"G\",\n        \"T\",\n        \"P\",\n        \"E\"\n    ] : [\n        \"K\",\n        \"M\",\n        \"G\",\n        \"T\",\n        \"P\",\n        \"E\"\n    ];\n    const post = si ? \"iB\" : \"B\";\n    if (bytes < base) {\n        return `${bytes.toFixed(2)} ${post}`;\n    }\n    const exp = parseInt(Math.log(bytes) / Math.log(base) + \"\");\n    const index = parseInt(exp - 1 + \"\");\n    return `${(bytes / Math.pow(base, exp)).toFixed(2)} ${pre[index]}${post}`;\n}\nfunction humanizeNumber(n) {\n    return n.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n}\n\nfunction NoopKvCodecs() {\n    return {\n        key: {\n            encode (k) {\n                return k;\n            },\n            decode (k) {\n                return k;\n            }\n        },\n        value: {\n            encode (v) {\n                return v;\n            },\n            decode (v) {\n                return v;\n            }\n        }\n    };\n}\nfunction defaultBucketOpts() {\n    return {\n        replicas: 1,\n        history: 1,\n        timeout: 2000,\n        max_bytes: -1,\n        maxValueSize: -1,\n        codec: NoopKvCodecs(),\n        storage: StorageType.File\n    };\n}\nconst kvOperationHdr = \"KV-Operation\";\nconst kvSubjectPrefix = \"$KV\";\nconst validKeyRe = /^[-/=.\\w]+$/;\nconst validSearchKey = /^[-/=.>*\\w]+$/;\nconst validBucketRe = /^[-\\w]+$/;\nfunction validateKey(k) {\n    if (k.startsWith(\".\") || k.endsWith(\".\") || !validKeyRe.test(k)) {\n        throw new Error(`invalid key: ${k}`);\n    }\n}\nfunction validateSearchKey(k) {\n    if (k.startsWith(\".\") || k.endsWith(\".\") || !validSearchKey.test(k)) {\n        throw new Error(`invalid key: ${k}`);\n    }\n}\nfunction hasWildcards(k) {\n    if (k.startsWith(\".\") || k.endsWith(\".\")) {\n        throw new Error(`invalid key: ${k}`);\n    }\n    const chunks = k.split(\".\");\n    let hasWildcards = false;\n    for(let i = 0; i < chunks.length; i++){\n        switch(chunks[i]){\n            case \"*\":\n                hasWildcards = true;\n                break;\n            case \">\":\n                if (i !== chunks.length - 1) {\n                    throw new Error(`invalid key: ${k}`);\n                }\n                hasWildcards = true;\n                break;\n            default:\n        }\n    }\n    return hasWildcards;\n}\nfunction validateBucket(name) {\n    if (!validBucketRe.test(name)) {\n        throw new Error(`invalid bucket name: ${name}`);\n    }\n}\nvar PubHeaders;\n(function(PubHeaders) {\n    PubHeaders[\"MsgIdHdr\"] = \"Nats-Msg-Id\";\n    PubHeaders[\"ExpectedStreamHdr\"] = \"Nats-Expected-Stream\";\n    PubHeaders[\"ExpectedLastSeqHdr\"] = \"Nats-Expected-Last-Sequence\";\n    PubHeaders[\"ExpectedLastMsgIdHdr\"] = \"Nats-Expected-Last-Msg-Id\";\n    PubHeaders[\"ExpectedLastSubjectSequenceHdr\"] = \"Nats-Expected-Last-Subject-Sequence\";\n})(PubHeaders || (PubHeaders = {}));\nclass Bucket {\n    js;\n    jsm;\n    stream;\n    bucket;\n    direct;\n    codec;\n    prefix;\n    editPrefix;\n    useJsPrefix;\n    _prefixLen;\n    constructor(bucket, js, jsm){\n        validateBucket(bucket);\n        this.js = js;\n        this.jsm = jsm;\n        this.bucket = bucket;\n        this.prefix = kvSubjectPrefix;\n        this.editPrefix = \"\";\n        this.useJsPrefix = false;\n        this._prefixLen = 0;\n    }\n    static async create(js, name, opts = {}) {\n        validateBucket(name);\n        const jsm = await js.jetstreamManager();\n        const bucket = new Bucket(name, js, jsm);\n        await bucket.init(opts);\n        return bucket;\n    }\n    static async bind(js, name, opts = {}) {\n        const jsm = await js.jetstreamManager();\n        const info = {\n            config: {\n                allow_direct: opts.allow_direct\n            }\n        };\n        validateBucket(name);\n        const bucket = new Bucket(name, js, jsm);\n        info.config.name = opts.streamName ?? bucket.bucketName();\n        Object.assign(bucket, info);\n        bucket.stream = info.config.name;\n        bucket.codec = opts.codec || NoopKvCodecs();\n        bucket.direct = info.config.allow_direct ?? false;\n        bucket.initializePrefixes(info);\n        return bucket;\n    }\n    async init(opts = {}) {\n        const bo = Object.assign(defaultBucketOpts(), opts);\n        this.codec = bo.codec;\n        const sc = {};\n        this.stream = sc.name = opts.streamName ?? this.bucketName();\n        sc.retention = RetentionPolicy.Limits;\n        sc.max_msgs_per_subject = bo.history;\n        if (bo.maxBucketSize) {\n            bo.max_bytes = bo.maxBucketSize;\n        }\n        if (bo.max_bytes) {\n            sc.max_bytes = bo.max_bytes;\n        }\n        sc.max_msg_size = bo.maxValueSize;\n        sc.storage = bo.storage;\n        const location = opts.placementCluster ?? \"\";\n        if (location) {\n            opts.placement = {};\n            opts.placement.cluster = location;\n            opts.placement.tags = [];\n        }\n        if (opts.placement) {\n            sc.placement = opts.placement;\n        }\n        if (opts.republish) {\n            sc.republish = opts.republish;\n        }\n        if (opts.description) {\n            sc.description = opts.description;\n        }\n        if (opts.mirror) {\n            const mirror = Object.assign({}, opts.mirror);\n            if (!mirror.name.startsWith(kvPrefix)) {\n                mirror.name = `${kvPrefix}${mirror.name}`;\n            }\n            sc.mirror = mirror;\n            sc.mirror_direct = true;\n        } else if (opts.sources) {\n            const sources = opts.sources.map((s)=>{\n                const c = Object.assign({}, s);\n                const srcBucketName = c.name.startsWith(kvPrefix) ? c.name.substring(kvPrefix.length) : c.name;\n                if (!c.name.startsWith(kvPrefix)) {\n                    c.name = `${kvPrefix}${c.name}`;\n                }\n                if (!s.external && srcBucketName !== this.bucket) {\n                    c.subject_transforms = [\n                        {\n                            src: `$KV.${srcBucketName}.>`,\n                            dest: `$KV.${this.bucket}.>`\n                        }\n                    ];\n                }\n                return c;\n            });\n            sc.sources = sources;\n            sc.subjects = [\n                this.subjectForBucket()\n            ];\n        } else {\n            sc.subjects = [\n                this.subjectForBucket()\n            ];\n        }\n        if (opts.metadata) {\n            sc.metadata = opts.metadata;\n        }\n        if (typeof opts.compression === \"boolean\") {\n            sc.compression = opts.compression ? StoreCompression.S2 : StoreCompression.None;\n        }\n        const nci = this.js.nc;\n        const have = nci.getServerVersion();\n        const discardNew = have ? compare(have, parseSemVer(\"2.7.2\")) >= 0 : false;\n        sc.discard = discardNew ? DiscardPolicy.New : DiscardPolicy.Old;\n        const { ok: direct, min } = nci.features.get(Feature.JS_ALLOW_DIRECT);\n        if (!direct && opts.allow_direct === true) {\n            const v = have ? `${have.major}.${have.minor}.${have.micro}` : \"unknown\";\n            return Promise.reject(new Error(`allow_direct is not available on server version ${v} - requires ${min}`));\n        }\n        opts.allow_direct = typeof opts.allow_direct === \"boolean\" ? opts.allow_direct : direct;\n        sc.allow_direct = opts.allow_direct;\n        this.direct = sc.allow_direct;\n        sc.num_replicas = bo.replicas;\n        if (bo.ttl) {\n            sc.max_age = nanos(bo.ttl);\n        }\n        sc.allow_rollup_hdrs = true;\n        let info;\n        try {\n            info = await this.jsm.streams.info(sc.name);\n            if (!info.config.allow_direct && this.direct === true) {\n                this.direct = false;\n            }\n        } catch (err) {\n            if (err.message === \"stream not found\") {\n                info = await this.jsm.streams.add(sc);\n            } else {\n                throw err;\n            }\n        }\n        this.initializePrefixes(info);\n    }\n    initializePrefixes(info) {\n        this._prefixLen = 0;\n        this.prefix = `$KV.${this.bucket}`;\n        this.useJsPrefix = this.js.apiPrefix !== \"$JS.API\";\n        const { mirror } = info.config;\n        if (mirror) {\n            let n = mirror.name;\n            if (n.startsWith(kvPrefix)) {\n                n = n.substring(kvPrefix.length);\n            }\n            if (mirror.external && mirror.external.api !== \"\") {\n                const mb = mirror.name.substring(kvPrefix.length);\n                this.useJsPrefix = false;\n                this.prefix = `$KV.${mb}`;\n                this.editPrefix = `${mirror.external.api}.$KV.${n}`;\n            } else {\n                this.editPrefix = this.prefix;\n            }\n        }\n    }\n    bucketName() {\n        return this.stream ?? `${kvPrefix}${this.bucket}`;\n    }\n    subjectForBucket() {\n        return `${this.prefix}.${this.bucket}.>`;\n    }\n    subjectForKey(k, edit = false) {\n        const builder = [];\n        if (edit) {\n            if (this.useJsPrefix) {\n                builder.push(this.js.apiPrefix);\n            }\n            if (this.editPrefix !== \"\") {\n                builder.push(this.editPrefix);\n            } else {\n                builder.push(this.prefix);\n            }\n        } else {\n            if (this.prefix) {\n                builder.push(this.prefix);\n            }\n        }\n        builder.push(k);\n        return builder.join(\".\");\n    }\n    fullKeyName(k) {\n        if (this.prefix !== \"\") {\n            return `${this.prefix}.${k}`;\n        }\n        return `${kvSubjectPrefix}.${this.bucket}.${k}`;\n    }\n    get prefixLen() {\n        if (this._prefixLen === 0) {\n            this._prefixLen = this.prefix.length + 1;\n        }\n        return this._prefixLen;\n    }\n    encodeKey(key) {\n        const chunks = [];\n        for (const t of key.split(\".\")){\n            switch(t){\n                case \">\":\n                case \"*\":\n                    chunks.push(t);\n                    break;\n                default:\n                    chunks.push(this.codec.key.encode(t));\n                    break;\n            }\n        }\n        return chunks.join(\".\");\n    }\n    decodeKey(ekey) {\n        const chunks = [];\n        for (const t of ekey.split(\".\")){\n            switch(t){\n                case \">\":\n                case \"*\":\n                    chunks.push(t);\n                    break;\n                default:\n                    chunks.push(this.codec.key.decode(t));\n                    break;\n            }\n        }\n        return chunks.join(\".\");\n    }\n    validateKey = validateKey;\n    validateSearchKey = validateSearchKey;\n    hasWildcards = hasWildcards;\n    close() {\n        return Promise.resolve();\n    }\n    dataLen(data, h) {\n        const slen = h ? h.get(JsHeaders.MessageSizeHdr) || \"\" : \"\";\n        if (slen !== \"\") {\n            return parseInt(slen, 10);\n        }\n        return data.length;\n    }\n    smToEntry(sm) {\n        return new KvStoredEntryImpl(this.bucket, this.prefixLen, sm);\n    }\n    jmToEntry(jm) {\n        const key = this.decodeKey(jm.subject.substring(this.prefixLen));\n        return new KvJsMsgEntryImpl(this.bucket, key, jm);\n    }\n    async create(k, data) {\n        let firstErr;\n        try {\n            const n = await this.put(k, data, {\n                previousSeq: 0\n            });\n            return Promise.resolve(n);\n        } catch (err) {\n            firstErr = err;\n            if (err?.api_error?.err_code !== 10071) {\n                return Promise.reject(err);\n            }\n        }\n        let rev = 0;\n        try {\n            const e = await this.get(k);\n            if (e?.operation === \"DEL\" || e?.operation === \"PURGE\") {\n                rev = e !== null ? e.revision : 0;\n                return this.update(k, data, rev);\n            } else {\n                return Promise.reject(firstErr);\n            }\n        } catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    update(k, data, version) {\n        if (version <= 0) {\n            throw new Error(\"version must be greater than 0\");\n        }\n        return this.put(k, data, {\n            previousSeq: version\n        });\n    }\n    async put(k, data, opts = {}) {\n        const ek = this.encodeKey(k);\n        this.validateKey(ek);\n        const o = {};\n        if (opts.previousSeq !== undefined) {\n            const h = headers();\n            o.headers = h;\n            h.set(PubHeaders.ExpectedLastSubjectSequenceHdr, `${opts.previousSeq}`);\n        }\n        try {\n            const pa = await this.js.publish(this.subjectForKey(ek, true), data, o);\n            return pa.seq;\n        } catch (err) {\n            const ne = err;\n            if (ne.isJetStreamError()) {\n                ne.message = ne.api_error?.description;\n                ne.code = `${ne.api_error?.code}`;\n                return Promise.reject(ne);\n            }\n            return Promise.reject(err);\n        }\n    }\n    async get(k, opts) {\n        const ek = this.encodeKey(k);\n        this.validateKey(ek);\n        let arg = {\n            last_by_subj: this.subjectForKey(ek)\n        };\n        if (opts && opts.revision > 0) {\n            arg = {\n                seq: opts.revision\n            };\n        }\n        let sm;\n        try {\n            if (this.direct) {\n                const direct = this.jsm.direct;\n                sm = await direct.getMessage(this.bucketName(), arg);\n            } else {\n                sm = await this.jsm.streams.getMessage(this.bucketName(), arg);\n            }\n            const ke = this.smToEntry(sm);\n            if (ke.key !== ek) {\n                return null;\n            }\n            return ke;\n        } catch (err) {\n            if (err.code === ErrorCode.JetStream404NoMessages) {\n                return null;\n            }\n            throw err;\n        }\n    }\n    purge(k, opts) {\n        return this._deleteOrPurge(k, \"PURGE\", opts);\n    }\n    delete(k, opts) {\n        return this._deleteOrPurge(k, \"DEL\", opts);\n    }\n    async purgeDeletes(olderMillis = 30 * 60 * 1000) {\n        const done = deferred();\n        const buf = [];\n        const i = await this.watch({\n            key: \">\",\n            initializedFn: ()=>{\n                done.resolve();\n            }\n        });\n        (async ()=>{\n            for await (const e of i){\n                if (e.operation === \"DEL\" || e.operation === \"PURGE\") {\n                    buf.push(e);\n                }\n            }\n        })().then();\n        await done;\n        i.stop();\n        const min = Date.now() - olderMillis;\n        const proms = buf.map((e)=>{\n            const subj = this.subjectForKey(e.key);\n            if (e.created.getTime() >= min) {\n                return this.jsm.streams.purge(this.stream, {\n                    filter: subj,\n                    keep: 1\n                });\n            } else {\n                return this.jsm.streams.purge(this.stream, {\n                    filter: subj,\n                    keep: 0\n                });\n            }\n        });\n        const purged = await Promise.all(proms);\n        purged.unshift({\n            success: true,\n            purged: 0\n        });\n        return purged.reduce((pv, cv)=>{\n            pv.purged += cv.purged;\n            return pv;\n        });\n    }\n    async _deleteOrPurge(k, op, opts) {\n        if (!this.hasWildcards(k)) {\n            return this._doDeleteOrPurge(k, op, opts);\n        }\n        const iter = await this.keys(k);\n        const buf = [];\n        for await (const k of iter){\n            buf.push(this._doDeleteOrPurge(k, op));\n            if (buf.length === 100) {\n                await Promise.all(buf);\n                buf.length = 0;\n            }\n        }\n        if (buf.length > 0) {\n            await Promise.all(buf);\n        }\n    }\n    async _doDeleteOrPurge(k, op, opts) {\n        const ek = this.encodeKey(k);\n        this.validateKey(ek);\n        const h = headers();\n        h.set(kvOperationHdr, op);\n        if (op === \"PURGE\") {\n            h.set(JsHeaders.RollupHdr, JsHeaders.RollupValueSubject);\n        }\n        if (opts?.previousSeq) {\n            h.set(PubHeaders.ExpectedLastSubjectSequenceHdr, `${opts.previousSeq}`);\n        }\n        await this.js.publish(this.subjectForKey(ek, true), Empty, {\n            headers: h\n        });\n    }\n    _buildCC(k, content, opts = {}) {\n        const a = !Array.isArray(k) ? [\n            k\n        ] : k;\n        let filter_subjects = a.map((k)=>{\n            const ek = this.encodeKey(k);\n            this.validateSearchKey(k);\n            return this.fullKeyName(ek);\n        });\n        let deliver_policy = DeliverPolicy.LastPerSubject;\n        if (content === KvWatchInclude.AllHistory) {\n            deliver_policy = DeliverPolicy.All;\n        }\n        if (content === KvWatchInclude.UpdatesOnly) {\n            deliver_policy = DeliverPolicy.New;\n        }\n        let filter_subject = undefined;\n        if (filter_subjects.length === 1) {\n            filter_subject = filter_subjects[0];\n            filter_subjects = undefined;\n        }\n        return Object.assign({\n            deliver_policy,\n            \"ack_policy\": AckPolicy.None,\n            filter_subjects,\n            filter_subject,\n            \"flow_control\": true,\n            \"idle_heartbeat\": nanos(5 * 1000)\n        }, opts);\n    }\n    remove(k) {\n        return this.purge(k);\n    }\n    async history(opts = {}) {\n        const k = opts.key ?? \">\";\n        const qi = new QueuedIteratorImpl();\n        const co = {};\n        co.headers_only = opts.headers_only || false;\n        let fn;\n        fn = ()=>{\n            qi.stop();\n        };\n        let count = 0;\n        const cc = this._buildCC(k, KvWatchInclude.AllHistory, co);\n        const subj = cc.filter_subject;\n        const copts = consumerOpts(cc);\n        copts.bindStream(this.stream);\n        copts.orderedConsumer();\n        copts.callback((err, jm)=>{\n            if (err) {\n                qi.stop(err);\n                return;\n            }\n            if (jm) {\n                const e = this.jmToEntry(jm);\n                qi.push(e);\n                qi.received++;\n                if (fn && count > 0 && qi.received >= count || jm.info.pending === 0) {\n                    qi.push(fn);\n                    fn = undefined;\n                }\n            }\n        });\n        const sub = await this.js.subscribe(subj, copts);\n        if (fn) {\n            const { info: { last } } = sub;\n            const expect = last.num_pending + last.delivered.consumer_seq;\n            if (expect === 0 || qi.received >= expect) {\n                try {\n                    fn();\n                } catch (err) {\n                    qi.stop(err);\n                } finally{\n                    fn = undefined;\n                }\n            } else {\n                count = expect;\n            }\n        }\n        qi._data = sub;\n        qi.iterClosed.then(()=>{\n            sub.unsubscribe();\n        });\n        sub.closed.then(()=>{\n            qi.stop();\n        }).catch((err)=>{\n            qi.stop(err);\n        });\n        return qi;\n    }\n    canSetWatcherName() {\n        const jsi = this.js;\n        const nci = jsi.nc;\n        const { ok } = nci.features.get(Feature.JS_NEW_CONSUMER_CREATE_API);\n        return ok;\n    }\n    async watch(opts = {}) {\n        const k = opts.key ?? \">\";\n        const qi = new QueuedIteratorImpl();\n        const co = {};\n        co.headers_only = opts.headers_only || false;\n        let content = KvWatchInclude.LastValue;\n        if (opts.include === KvWatchInclude.AllHistory) {\n            content = KvWatchInclude.AllHistory;\n        } else if (opts.include === KvWatchInclude.UpdatesOnly) {\n            content = KvWatchInclude.UpdatesOnly;\n        }\n        const ignoreDeletes = opts.ignoreDeletes === true;\n        let fn = opts.initializedFn;\n        let count = 0;\n        const cc = this._buildCC(k, content, co);\n        const subj = cc.filter_subject;\n        const copts = consumerOpts(cc);\n        if (this.canSetWatcherName()) {\n            copts.consumerName(nuid.next());\n        }\n        copts.bindStream(this.stream);\n        if (opts.resumeFromRevision && opts.resumeFromRevision > 0) {\n            copts.startSequence(opts.resumeFromRevision);\n        }\n        copts.orderedConsumer();\n        copts.callback((err, jm)=>{\n            if (err) {\n                qi.stop(err);\n                return;\n            }\n            if (jm) {\n                const e = this.jmToEntry(jm);\n                if (ignoreDeletes && e.operation === \"DEL\") {\n                    return;\n                }\n                qi.push(e);\n                qi.received++;\n                if (fn && (count > 0 && qi.received >= count || jm.info.pending === 0)) {\n                    qi.push(fn);\n                    fn = undefined;\n                }\n            }\n        });\n        const sub = await this.js.subscribe(subj, copts);\n        if (fn) {\n            const { info: { last } } = sub;\n            const expect = last.num_pending + last.delivered.consumer_seq;\n            if (expect === 0 || qi.received >= expect) {\n                try {\n                    fn();\n                } catch (err) {\n                    qi.stop(err);\n                } finally{\n                    fn = undefined;\n                }\n            } else {\n                count = expect;\n            }\n        }\n        qi._data = sub;\n        qi.iterClosed.then(()=>{\n            sub.unsubscribe();\n        });\n        sub.closed.then(()=>{\n            qi.stop();\n        }).catch((err)=>{\n            qi.stop(err);\n        });\n        return qi;\n    }\n    async keys(k = \">\") {\n        const keys = new QueuedIteratorImpl();\n        const cc = this._buildCC(k, KvWatchInclude.LastValue, {\n            headers_only: true\n        });\n        const subj = Array.isArray(k) ? \">\" : cc.filter_subject;\n        const copts = consumerOpts(cc);\n        copts.bindStream(this.stream);\n        copts.orderedConsumer();\n        const sub = await this.js.subscribe(subj, copts);\n        (async ()=>{\n            for await (const jm of sub){\n                const op = jm.headers?.get(kvOperationHdr);\n                if (op !== \"DEL\" && op !== \"PURGE\") {\n                    const key = this.decodeKey(jm.subject.substring(this.prefixLen));\n                    keys.push(key);\n                }\n                if (jm.info.pending === 0) {\n                    sub.unsubscribe();\n                }\n            }\n        })().then(()=>{\n            keys.stop();\n        }).catch((err)=>{\n            keys.stop(err);\n        });\n        const si = sub;\n        if (si.info.last.num_pending === 0) {\n            sub.unsubscribe();\n        }\n        return keys;\n    }\n    purgeBucket(opts) {\n        return this.jsm.streams.purge(this.bucketName(), opts);\n    }\n    destroy() {\n        return this.jsm.streams.delete(this.bucketName());\n    }\n    async status() {\n        const nc = this.js.nc;\n        const cluster = nc.info?.cluster ?? \"\";\n        const bn = this.bucketName();\n        const si = await this.jsm.streams.info(bn);\n        return new KvStatusImpl(si, cluster);\n    }\n}\nclass KvStatusImpl {\n    si;\n    cluster;\n    constructor(si, cluster = \"\"){\n        this.si = si;\n        this.cluster = cluster;\n    }\n    get bucket() {\n        return this.si.config.name.startsWith(kvPrefix) ? this.si.config.name.substring(kvPrefix.length) : this.si.config.name;\n    }\n    get values() {\n        return this.si.state.messages;\n    }\n    get history() {\n        return this.si.config.max_msgs_per_subject;\n    }\n    get ttl() {\n        return millis(this.si.config.max_age);\n    }\n    get bucket_location() {\n        return this.cluster;\n    }\n    get backingStore() {\n        return this.si.config.storage;\n    }\n    get storage() {\n        return this.si.config.storage;\n    }\n    get replicas() {\n        return this.si.config.num_replicas;\n    }\n    get description() {\n        return this.si.config.description ?? \"\";\n    }\n    get maxBucketSize() {\n        return this.si.config.max_bytes;\n    }\n    get maxValueSize() {\n        return this.si.config.max_msg_size;\n    }\n    get max_bytes() {\n        return this.si.config.max_bytes;\n    }\n    get placement() {\n        return this.si.config.placement || {\n            cluster: \"\",\n            tags: []\n        };\n    }\n    get placementCluster() {\n        return this.si.config.placement?.cluster ?? \"\";\n    }\n    get republish() {\n        return this.si.config.republish ?? {\n            src: \"\",\n            dest: \"\"\n        };\n    }\n    get streamInfo() {\n        return this.si;\n    }\n    get size() {\n        return this.si.state.bytes;\n    }\n    get metadata() {\n        return this.si.config.metadata ?? {};\n    }\n    get compression() {\n        if (this.si.config.compression) {\n            return this.si.config.compression !== StoreCompression.None;\n        }\n        return false;\n    }\n}\nconst osPrefix = \"OBJ_\";\nconst digestType = \"SHA-256=\";\nfunction objectStoreStreamName(bucket) {\n    validateBucket(bucket);\n    return `${osPrefix}${bucket}`;\n}\nfunction objectStoreBucketName(stream) {\n    if (stream.startsWith(osPrefix)) {\n        return stream.substring(4);\n    }\n    return stream;\n}\nclass ObjectStoreStatusImpl {\n    si;\n    backingStore;\n    constructor(si){\n        this.si = si;\n        this.backingStore = \"JetStream\";\n    }\n    get bucket() {\n        return objectStoreBucketName(this.si.config.name);\n    }\n    get description() {\n        return this.si.config.description ?? \"\";\n    }\n    get ttl() {\n        return this.si.config.max_age;\n    }\n    get storage() {\n        return this.si.config.storage;\n    }\n    get replicas() {\n        return this.si.config.num_replicas;\n    }\n    get sealed() {\n        return this.si.config.sealed;\n    }\n    get size() {\n        return this.si.state.bytes;\n    }\n    get streamInfo() {\n        return this.si;\n    }\n    get metadata() {\n        return this.si.config.metadata;\n    }\n    get compression() {\n        if (this.si.config.compression) {\n            return this.si.config.compression !== StoreCompression.None;\n        }\n        return false;\n    }\n}\nfunction convertStreamSourceDomain(s) {\n    if (s === undefined) {\n        return undefined;\n    }\n    const { domain } = s;\n    if (domain === undefined) {\n        return s;\n    }\n    const copy = Object.assign({}, s);\n    delete copy.domain;\n    if (domain === \"\") {\n        return copy;\n    }\n    if (copy.external) {\n        throw new Error(\"domain and external are both set\");\n    }\n    copy.external = {\n        api: `$JS.${domain}.API`\n    };\n    return copy;\n}\nvar PullConsumerType;\n(function(PullConsumerType) {\n    PullConsumerType[PullConsumerType[\"Unset\"] = -1] = \"Unset\";\n    PullConsumerType[PullConsumerType[\"Consume\"] = 0] = \"Consume\";\n    PullConsumerType[PullConsumerType[\"Fetch\"] = 1] = \"Fetch\";\n})(PullConsumerType || (PullConsumerType = {}));\nvar ConsumerEvents;\n(function(ConsumerEvents) {\n    ConsumerEvents[\"HeartbeatsMissed\"] = \"heartbeats_missed\";\n    ConsumerEvents[\"ConsumerNotFound\"] = \"consumer_not_found\";\n    ConsumerEvents[\"StreamNotFound\"] = \"stream_not_found\";\n    ConsumerEvents[\"ConsumerDeleted\"] = \"consumer_deleted\";\n    ConsumerEvents[\"OrderedConsumerRecreated\"] = \"ordered_consumer_recreated\";\n    ConsumerEvents[\"NoResponders\"] = \"no_responders\";\n})(ConsumerEvents || (ConsumerEvents = {}));\nvar ConsumerDebugEvents;\n(function(ConsumerDebugEvents) {\n    ConsumerDebugEvents[\"DebugEvent\"] = \"debug\";\n    ConsumerDebugEvents[\"Discard\"] = \"discard\";\n    ConsumerDebugEvents[\"Reset\"] = \"reset\";\n    ConsumerDebugEvents[\"Next\"] = \"next\";\n})(ConsumerDebugEvents || (ConsumerDebugEvents = {}));\nconst ACK = Uint8Array.of(43, 65, 67, 75);\nconst NAK = Uint8Array.of(45, 78, 65, 75);\nconst WPI = Uint8Array.of(43, 87, 80, 73);\nconst NXT = Uint8Array.of(43, 78, 88, 84);\nconst TERM = Uint8Array.of(43, 84, 69, 82, 77);\nconst SPACE = Uint8Array.of(32);\nfunction toJsMsg(m, ackTimeout = 5000) {\n    return new JsMsgImpl(m, ackTimeout);\n}\nclass PullConsumerMessagesImpl extends QueuedIteratorImpl {\n    consumer;\n    opts;\n    sub;\n    monitor;\n    pending;\n    inbox;\n    refilling;\n    pong;\n    callback;\n    timeout;\n    cleanupHandler;\n    listeners;\n    statusIterator;\n    forOrderedConsumer;\n    resetHandler;\n    abortOnMissingResource;\n    bind;\n    inBackOff;\n    constructor(c, opts, refilling = false){\n        super();\n        this.consumer = c;\n        const copts = opts;\n        this.opts = this.parseOptions(opts, refilling);\n        this.callback = copts.callback || null;\n        this.noIterator = typeof this.callback === \"function\";\n        this.monitor = null;\n        this.pong = null;\n        this.pending = {\n            msgs: 0,\n            bytes: 0,\n            requests: 0\n        };\n        this.refilling = refilling;\n        this.timeout = null;\n        this.inbox = createInbox(c.api.nc.options.inboxPrefix);\n        this.listeners = [];\n        this.forOrderedConsumer = false;\n        this.abortOnMissingResource = copts.abort_on_missing_resource === true;\n        this.bind = copts.bind === true;\n        this.inBackOff = false;\n        this.start();\n    }\n    start() {\n        const { max_messages, max_bytes, idle_heartbeat, threshold_bytes, threshold_messages } = this.opts;\n        this.closed().then((err)=>{\n            if (this.cleanupHandler) {\n                try {\n                    this.cleanupHandler(err);\n                } catch (_err) {}\n            }\n        });\n        const { sub } = this;\n        if (sub) {\n            sub.unsubscribe();\n        }\n        this.sub = this.consumer.api.nc.subscribe(this.inbox, {\n            callback: (err, msg)=>{\n                if (err) {\n                    this.stop(err);\n                    return;\n                }\n                this.monitor?.work();\n                const isProtocol = msg.subject === this.inbox;\n                if (isProtocol) {\n                    if (isHeartbeatMsg(msg)) {\n                        return;\n                    }\n                    const code = msg.headers?.code;\n                    const description = msg.headers?.description?.toLowerCase() || \"unknown\";\n                    const { msgsLeft, bytesLeft } = this.parseDiscard(msg.headers);\n                    if (msgsLeft > 0 || bytesLeft > 0) {\n                        this.pending.msgs -= msgsLeft;\n                        this.pending.bytes -= bytesLeft;\n                        this.pending.requests--;\n                        this.notify(ConsumerDebugEvents.Discard, {\n                            msgsLeft,\n                            bytesLeft\n                        });\n                    } else {\n                        if (code === 400) {\n                            this.stop(new NatsError(description, `${code}`));\n                            return;\n                        } else if (code === 409 && description === \"consumer deleted\") {\n                            this.notify(ConsumerEvents.ConsumerDeleted, `${code} ${description}`);\n                            if (!this.refilling || this.abortOnMissingResource) {\n                                const error = new NatsError(description, `${code}`);\n                                this.stop(error);\n                                return;\n                            }\n                        } else if (code === 503) {\n                            this.notify(ConsumerEvents.NoResponders, `${code} No Responders`);\n                            if (!this.refilling || this.abortOnMissingResource) {\n                                const error = new NatsError(\"no responders\", `${code}`);\n                                this.stop(error);\n                                return;\n                            }\n                        } else {\n                            this.notify(ConsumerDebugEvents.DebugEvent, `${code} ${description}`);\n                        }\n                    }\n                } else {\n                    this._push(toJsMsg(msg, this.consumer.api.timeout));\n                    this.received++;\n                    if (this.pending.msgs) {\n                        this.pending.msgs--;\n                    }\n                    if (this.pending.bytes) {\n                        this.pending.bytes -= msg.size();\n                    }\n                }\n                if (this.pending.msgs === 0 && this.pending.bytes === 0) {\n                    this.pending.requests = 0;\n                }\n                if (this.refilling) {\n                    if (max_messages && this.pending.msgs <= threshold_messages || max_bytes && this.pending.bytes <= threshold_bytes) {\n                        const batch = this.pullOptions();\n                        this.pull(batch);\n                    }\n                } else if (this.pending.requests === 0) {\n                    this._push(()=>{\n                        this.stop();\n                    });\n                }\n            }\n        });\n        this.sub.closed.then(()=>{\n            if (this.sub.draining) {\n                this._push(()=>{\n                    this.stop();\n                });\n            }\n        });\n        if (idle_heartbeat) {\n            this.monitor = new IdleHeartbeatMonitor(idle_heartbeat, (data)=>{\n                this.notify(ConsumerEvents.HeartbeatsMissed, data);\n                this.resetPending().then(()=>{}).catch(()=>{});\n                return false;\n            }, {\n                maxOut: 2\n            });\n        }\n        (async ()=>{\n            const status = this.consumer.api.nc.status();\n            this.statusIterator = status;\n            for await (const s of status){\n                switch(s.type){\n                    case Events.Disconnect:\n                        this.monitor?.cancel();\n                        break;\n                    case Events.Reconnect:\n                        this.resetPending().then((ok)=>{\n                            if (ok) {\n                                this.monitor?.restart();\n                            }\n                        }).catch(()=>{});\n                        break;\n                    default:\n                }\n            }\n        })();\n        this.pull(this.pullOptions());\n    }\n    _push(r) {\n        if (!this.callback) {\n            super.push(r);\n        } else {\n            const fn = typeof r === \"function\" ? r : null;\n            try {\n                if (!fn) {\n                    this.callback(r);\n                } else {\n                    fn();\n                }\n            } catch (err) {\n                this.stop(err);\n            }\n        }\n    }\n    notify(type, data) {\n        if (this.listeners.length > 0) {\n            (()=>{\n                this.listeners.forEach((l)=>{\n                    if (!l.done) {\n                        l.push({\n                            type,\n                            data\n                        });\n                    }\n                });\n            })();\n        }\n    }\n    resetPending() {\n        return this.bind ? this.resetPendingNoInfo() : this.resetPendingWithInfo();\n    }\n    resetPendingNoInfo() {\n        this.pending.msgs = 0;\n        this.pending.bytes = 0;\n        this.pending.requests = 0;\n        this.pull(this.pullOptions());\n        return Promise.resolve(true);\n    }\n    async resetPendingWithInfo() {\n        if (this.inBackOff) {\n            return false;\n        }\n        let notFound = 0;\n        let streamNotFound = 0;\n        const bo = backoff([\n            this.opts.expires\n        ]);\n        let attempt = 0;\n        while(true){\n            if (this.done) {\n                return false;\n            }\n            if (this.consumer.api.nc.isClosed()) {\n                console.error(\"aborting resetPending - connection is closed\");\n                return false;\n            }\n            try {\n                await this.consumer.info();\n                this.inBackOff = false;\n                notFound = 0;\n                this.pending.msgs = 0;\n                this.pending.bytes = 0;\n                this.pending.requests = 0;\n                this.pull(this.pullOptions());\n                return true;\n            } catch (err) {\n                if (err.message === \"stream not found\") {\n                    streamNotFound++;\n                    this.notify(ConsumerEvents.StreamNotFound, streamNotFound);\n                    if (!this.refilling || this.abortOnMissingResource) {\n                        this.stop(err);\n                        return false;\n                    }\n                } else if (err.message === \"consumer not found\") {\n                    notFound++;\n                    this.notify(ConsumerEvents.ConsumerNotFound, notFound);\n                    if (this.resetHandler) {\n                        try {\n                            this.resetHandler();\n                        } catch (_) {}\n                    }\n                    if (!this.refilling || this.abortOnMissingResource) {\n                        this.stop(err);\n                        return false;\n                    }\n                    if (this.forOrderedConsumer) {\n                        return false;\n                    }\n                } else {\n                    notFound = 0;\n                    streamNotFound = 0;\n                }\n                this.inBackOff = true;\n                const to = bo.backoff(attempt);\n                const de = delay(to);\n                await Promise.race([\n                    de,\n                    this.consumer.api.nc.closed()\n                ]);\n                de.cancel();\n                attempt++;\n            }\n        }\n    }\n    pull(opts) {\n        this.pending.bytes += opts.max_bytes ?? 0;\n        this.pending.msgs += opts.batch ?? 0;\n        this.pending.requests++;\n        const nc = this.consumer.api.nc;\n        this._push(()=>{\n            nc.publish(`${this.consumer.api.prefix}.CONSUMER.MSG.NEXT.${this.consumer.stream}.${this.consumer.name}`, this.consumer.api.jc.encode(opts), {\n                reply: this.inbox\n            });\n            this.notify(ConsumerDebugEvents.Next, opts);\n        });\n    }\n    pullOptions() {\n        const batch = this.opts.max_messages - this.pending.msgs;\n        const max_bytes = this.opts.max_bytes - this.pending.bytes;\n        const idle_heartbeat = nanos(this.opts.idle_heartbeat);\n        const expires = nanos(this.opts.expires);\n        return {\n            batch,\n            max_bytes,\n            idle_heartbeat,\n            expires\n        };\n    }\n    parseDiscard(headers) {\n        const discard = {\n            msgsLeft: 0,\n            bytesLeft: 0\n        };\n        const msgsLeft = headers?.get(JsHeaders.PendingMessagesHdr);\n        if (msgsLeft) {\n            discard.msgsLeft = parseInt(msgsLeft);\n        }\n        const bytesLeft = headers?.get(JsHeaders.PendingBytesHdr);\n        if (bytesLeft) {\n            discard.bytesLeft = parseInt(bytesLeft);\n        }\n        return discard;\n    }\n    trackTimeout(t) {\n        this.timeout = t;\n    }\n    close() {\n        this.stop();\n        return this.iterClosed;\n    }\n    closed() {\n        return this.iterClosed;\n    }\n    clearTimers() {\n        this.monitor?.cancel();\n        this.monitor = null;\n        this.timeout?.cancel();\n        this.timeout = null;\n    }\n    setCleanupHandler(fn) {\n        this.cleanupHandler = fn;\n    }\n    stop(err) {\n        if (this.done) {\n            return;\n        }\n        this.sub?.unsubscribe();\n        this.clearTimers();\n        this.statusIterator?.stop();\n        this._push(()=>{\n            super.stop(err);\n            this.listeners.forEach((n)=>{\n                n.stop();\n            });\n        });\n    }\n    parseOptions(opts, refilling = false) {\n        const args = opts || {};\n        args.max_messages = args.max_messages || 0;\n        args.max_bytes = args.max_bytes || 0;\n        if (args.max_messages !== 0 && args.max_bytes !== 0) {\n            throw new Error(`only specify one of max_messages or max_bytes`);\n        }\n        if (args.max_messages === 0) {\n            args.max_messages = 100;\n        }\n        args.expires = args.expires || 30_000;\n        if (args.expires < 1000) {\n            throw new Error(\"expires should be at least 1000ms\");\n        }\n        args.idle_heartbeat = args.idle_heartbeat || args.expires / 2;\n        args.idle_heartbeat = args.idle_heartbeat > 30_000 ? 30_000 : args.idle_heartbeat;\n        if (refilling) {\n            const minMsgs = Math.round(args.max_messages * .75) || 1;\n            args.threshold_messages = args.threshold_messages || minMsgs;\n            const minBytes = Math.round(args.max_bytes * .75) || 1;\n            args.threshold_bytes = args.threshold_bytes || minBytes;\n        }\n        return args;\n    }\n    status() {\n        const iter = new QueuedIteratorImpl();\n        this.listeners.push(iter);\n        return Promise.resolve(iter);\n    }\n}\nclass OrderedConsumerMessages extends QueuedIteratorImpl {\n    src;\n    listeners;\n    constructor(){\n        super();\n        this.listeners = [];\n    }\n    setSource(src) {\n        if (this.src) {\n            this.src.resetHandler = undefined;\n            this.src.setCleanupHandler();\n            this.src.stop();\n        }\n        this.src = src;\n        this.src.setCleanupHandler((err)=>{\n            this.stop(err || undefined);\n        });\n        (async ()=>{\n            const status = await this.src.status();\n            for await (const s of status){\n                this.notify(s.type, s.data);\n            }\n        })().catch(()=>{});\n    }\n    notify(type, data) {\n        if (this.listeners.length > 0) {\n            (()=>{\n                this.listeners.forEach((l)=>{\n                    if (!l.done) {\n                        l.push({\n                            type,\n                            data\n                        });\n                    }\n                });\n            })();\n        }\n    }\n    stop(err) {\n        if (this.done) {\n            return;\n        }\n        this.src?.stop(err);\n        super.stop(err);\n        this.listeners.forEach((n)=>{\n            n.stop();\n        });\n    }\n    close() {\n        this.stop();\n        return this.iterClosed;\n    }\n    closed() {\n        return this.iterClosed;\n    }\n    status() {\n        const iter = new QueuedIteratorImpl();\n        this.listeners.push(iter);\n        return Promise.resolve(iter);\n    }\n}\nclass PullConsumerImpl {\n    api;\n    _info;\n    stream;\n    name;\n    constructor(api, info){\n        this.api = api;\n        this._info = info;\n        this.stream = info.stream_name;\n        this.name = info.name;\n    }\n    consume(opts = {\n        max_messages: 100,\n        expires: 30_000\n    }) {\n        return Promise.resolve(new PullConsumerMessagesImpl(this, opts, true));\n    }\n    fetch(opts = {\n        max_messages: 100,\n        expires: 30_000\n    }) {\n        const m = new PullConsumerMessagesImpl(this, opts, false);\n        const to = Math.round(m.opts.expires * 1.05);\n        const timer = timeout(to);\n        m.closed().catch(()=>{}).finally(()=>{\n            timer.cancel();\n        });\n        timer.catch(()=>{\n            m.close().catch();\n        });\n        m.trackTimeout(timer);\n        return Promise.resolve(m);\n    }\n    next(opts = {\n        expires: 30_000\n    }) {\n        const d = deferred();\n        const fopts = opts;\n        fopts.max_messages = 1;\n        const iter = new PullConsumerMessagesImpl(this, fopts, false);\n        const to = Math.round(iter.opts.expires * 1.05);\n        if (to >= 60_000) {\n            (async ()=>{\n                for await (const s of (await iter.status())){\n                    if (s.type === ConsumerEvents.HeartbeatsMissed && s.data >= 2) {\n                        d.reject(new Error(\"consumer missed heartbeats\"));\n                        break;\n                    }\n                }\n            })().catch();\n        }\n        (async ()=>{\n            for await (const m of iter){\n                d.resolve(m);\n                break;\n            }\n        })().catch(()=>{});\n        const timer = timeout(to);\n        iter.closed().then((err)=>{\n            err ? d.reject(err) : d.resolve(null);\n        }).catch((err)=>{\n            d.reject(err);\n        }).finally(()=>{\n            timer.cancel();\n        });\n        timer.catch((_err)=>{\n            d.resolve(null);\n            iter.close().catch();\n        });\n        iter.trackTimeout(timer);\n        return d;\n    }\n    delete() {\n        const { stream_name, name } = this._info;\n        return this.api.delete(stream_name, name);\n    }\n    info(cached = false) {\n        if (cached) {\n            return Promise.resolve(this._info);\n        }\n        const { stream_name, name } = this._info;\n        return this.api.info(stream_name, name).then((ci)=>{\n            this._info = ci;\n            return this._info;\n        });\n    }\n}\nclass OrderedPullConsumerImpl {\n    api;\n    consumerOpts;\n    consumer;\n    opts;\n    cursor;\n    stream;\n    namePrefix;\n    serial;\n    currentConsumer;\n    userCallback;\n    iter;\n    type;\n    startSeq;\n    maxInitialReset;\n    constructor(api, stream, opts = {}){\n        this.api = api;\n        this.stream = stream;\n        this.cursor = {\n            stream_seq: 1,\n            deliver_seq: 0\n        };\n        this.namePrefix = nuid.next();\n        if (typeof opts.name_prefix === \"string\") {\n            minValidation(\"name_prefix\", opts.name_prefix);\n            this.namePrefix = opts.name_prefix + this.namePrefix;\n        }\n        this.serial = 0;\n        this.currentConsumer = null;\n        this.userCallback = null;\n        this.iter = null;\n        this.type = PullConsumerType.Unset;\n        this.consumerOpts = opts;\n        this.maxInitialReset = 30;\n        this.startSeq = this.consumerOpts.opt_start_seq || 0;\n        this.cursor.stream_seq = this.startSeq > 0 ? this.startSeq - 1 : 0;\n    }\n    getConsumerOpts(seq) {\n        this.serial++;\n        const name = `${this.namePrefix}_${this.serial}`;\n        seq = seq === 0 ? 1 : seq;\n        const config = {\n            name,\n            deliver_policy: DeliverPolicy.StartSequence,\n            opt_start_seq: seq,\n            ack_policy: AckPolicy.None,\n            inactive_threshold: nanos(5 * 60 * 1000),\n            num_replicas: 1\n        };\n        if (this.consumerOpts.headers_only === true) {\n            config.headers_only = true;\n        }\n        if (Array.isArray(this.consumerOpts.filterSubjects)) {\n            config.filter_subjects = this.consumerOpts.filterSubjects;\n        }\n        if (typeof this.consumerOpts.filterSubjects === \"string\") {\n            config.filter_subject = this.consumerOpts.filterSubjects;\n        }\n        if (this.consumerOpts.replay_policy) {\n            config.replay_policy = this.consumerOpts.replay_policy;\n        }\n        if (seq === this.startSeq + 1) {\n            config.deliver_policy = this.consumerOpts.deliver_policy || DeliverPolicy.StartSequence;\n            if (this.consumerOpts.deliver_policy === DeliverPolicy.LastPerSubject || this.consumerOpts.deliver_policy === DeliverPolicy.New || this.consumerOpts.deliver_policy === DeliverPolicy.Last) {\n                delete config.opt_start_seq;\n                config.deliver_policy = this.consumerOpts.deliver_policy;\n            }\n            if (config.deliver_policy === DeliverPolicy.LastPerSubject) {\n                if (typeof config.filter_subjects === \"undefined\" && typeof config.filter_subject === \"undefined\") {\n                    config.filter_subject = \">\";\n                }\n            }\n            if (this.consumerOpts.opt_start_time) {\n                delete config.opt_start_seq;\n                config.deliver_policy = DeliverPolicy.StartTime;\n                config.opt_start_time = this.consumerOpts.opt_start_time;\n            }\n            if (this.consumerOpts.inactive_threshold) {\n                config.inactive_threshold = nanos(this.consumerOpts.inactive_threshold);\n            }\n        }\n        return config;\n    }\n    async resetConsumer(seq = 0) {\n        nuid.next();\n        const isNew = this.serial === 0;\n        this.consumer?.delete().catch(()=>{});\n        seq = seq === 0 ? 1 : seq;\n        this.cursor.deliver_seq = 0;\n        const config = this.getConsumerOpts(seq);\n        config.max_deliver = 1;\n        config.mem_storage = true;\n        const bo = backoff([\n            this.opts?.expires || 30_000\n        ]);\n        let ci;\n        for(let i = 0;; i++){\n            try {\n                ci = await this.api.add(this.stream, config);\n                this.iter?.notify(ConsumerEvents.OrderedConsumerRecreated, ci.name);\n                break;\n            } catch (err) {\n                if (err.message === \"stream not found\") {\n                    this.iter?.notify(ConsumerEvents.StreamNotFound, i);\n                    if (this.type === PullConsumerType.Fetch || this.opts.abort_on_missing_resource === true) {\n                        this.iter?.stop(err);\n                        return Promise.reject(err);\n                    }\n                }\n                if (isNew && i >= this.maxInitialReset) {\n                    throw err;\n                } else {\n                    await delay(bo.backoff(i + 1));\n                }\n            }\n        }\n        return ci;\n    }\n    internalHandler(serial) {\n        return (m)=>{\n            if (this.serial !== serial) {\n                return;\n            }\n            const dseq = m.info.deliverySequence;\n            if (dseq !== this.cursor.deliver_seq + 1) {\n                this.notifyOrderedResetAndReset();\n                return;\n            }\n            this.cursor.deliver_seq = dseq;\n            this.cursor.stream_seq = m.info.streamSequence;\n            if (this.userCallback) {\n                this.userCallback(m);\n            } else {\n                this.iter?.push(m);\n            }\n        };\n    }\n    async reset(opts = {\n        max_messages: 100,\n        expires: 30_000\n    }, info) {\n        info = info || {};\n        const fromFetch = info.fromFetch || false;\n        const orderedReset = info.orderedReset || false;\n        if (this.type === PullConsumerType.Fetch && orderedReset) {\n            this.iter?.src.stop();\n            await this.iter?.closed();\n            this.currentConsumer = null;\n            return;\n        }\n        if (this.currentConsumer === null || orderedReset) {\n            this.currentConsumer = await this.resetConsumer(this.cursor.stream_seq + 1);\n        }\n        if (this.iter === null || fromFetch) {\n            this.iter = new OrderedConsumerMessages();\n        }\n        this.consumer = new PullConsumerImpl(this.api, this.currentConsumer);\n        const copts = opts;\n        copts.callback = this.internalHandler(this.serial);\n        let msgs = null;\n        if (this.type === PullConsumerType.Fetch && fromFetch) {\n            msgs = await this.consumer.fetch(opts);\n        } else if (this.type === PullConsumerType.Consume) {\n            msgs = await this.consumer.consume(opts);\n        }\n        const msgsImpl = msgs;\n        msgsImpl.forOrderedConsumer = true;\n        msgsImpl.resetHandler = ()=>{\n            this.notifyOrderedResetAndReset();\n        };\n        this.iter.setSource(msgsImpl);\n    }\n    notifyOrderedResetAndReset() {\n        this.iter?.notify(ConsumerDebugEvents.Reset, \"\");\n        this.reset(this.opts, {\n            orderedReset: true\n        });\n    }\n    async consume(opts = {\n        max_messages: 100,\n        expires: 30_000\n    }) {\n        const copts = opts;\n        if (copts.bind) {\n            return Promise.reject(new Error(\"bind is not supported\"));\n        }\n        if (this.type === PullConsumerType.Fetch) {\n            return Promise.reject(new Error(\"ordered consumer initialized as fetch\"));\n        }\n        if (this.type === PullConsumerType.Consume) {\n            return Promise.reject(new Error(\"ordered consumer doesn't support concurrent consume\"));\n        }\n        const { callback } = opts;\n        if (callback) {\n            this.userCallback = callback;\n        }\n        this.type = PullConsumerType.Consume;\n        this.opts = opts;\n        await this.reset(opts);\n        return this.iter;\n    }\n    async fetch(opts = {\n        max_messages: 100,\n        expires: 30_000\n    }) {\n        const copts = opts;\n        if (copts.bind) {\n            return Promise.reject(new Error(\"bind is not supported\"));\n        }\n        if (this.type === PullConsumerType.Consume) {\n            return Promise.reject(new Error(\"ordered consumer already initialized as consume\"));\n        }\n        if (this.iter?.done === false) {\n            return Promise.reject(new Error(\"ordered consumer doesn't support concurrent fetch\"));\n        }\n        const { callback } = opts;\n        if (callback) {\n            this.userCallback = callback;\n        }\n        this.type = PullConsumerType.Fetch;\n        this.opts = opts;\n        await this.reset(opts, {\n            fromFetch: true\n        });\n        return this.iter;\n    }\n    async next(opts = {\n        expires: 30_000\n    }) {\n        const copts = opts;\n        if (copts.bind) {\n            return Promise.reject(new Error(\"bind is not supported\"));\n        }\n        copts.max_messages = 1;\n        const d = deferred();\n        copts.callback = (m)=>{\n            this.userCallback = null;\n            d.resolve(m);\n        };\n        const iter = await this.fetch(copts);\n        iter.iterClosed.then((err)=>{\n            if (err) {\n                d.reject(err);\n            }\n            d.resolve(null);\n        }).catch((err)=>{\n            d.reject(err);\n        });\n        return d;\n    }\n    delete() {\n        if (!this.currentConsumer) {\n            return Promise.resolve(false);\n        }\n        return this.api.delete(this.stream, this.currentConsumer.name).then((tf)=>{\n            return Promise.resolve(tf);\n        }).catch((err)=>{\n            return Promise.reject(err);\n        }).finally(()=>{\n            this.currentConsumer = null;\n        });\n    }\n    async info(cached) {\n        if (this.currentConsumer == null) {\n            this.currentConsumer = await this.resetConsumer(this.startSeq);\n            return Promise.resolve(this.currentConsumer);\n        }\n        if (cached && this.currentConsumer) {\n            return Promise.resolve(this.currentConsumer);\n        }\n        return this.api.info(this.stream, this.currentConsumer.name);\n    }\n}\nclass ConsumersImpl {\n    api;\n    notified;\n    constructor(api){\n        this.api = api;\n        this.notified = false;\n    }\n    checkVersion() {\n        const fv = this.api.nc.features.get(Feature.JS_SIMPLIFICATION);\n        if (!fv.ok) {\n            return Promise.reject(new Error(`consumers framework is only supported on servers ${fv.min} or better`));\n        }\n        return Promise.resolve();\n    }\n    getPullConsumerFor(ci) {\n        if (ci.config.deliver_subject !== undefined) {\n            throw new Error(\"push consumer not supported\");\n        }\n        return new PullConsumerImpl(this.api, ci);\n    }\n    async get(stream, name = {}) {\n        if (typeof name === \"object\") {\n            return this.ordered(stream, name);\n        }\n        await this.checkVersion();\n        return this.api.info(stream, name).then((ci)=>{\n            if (ci.config.deliver_subject !== undefined) {\n                return Promise.reject(new Error(\"push consumer not supported\"));\n            }\n            return new PullConsumerImpl(this.api, ci);\n        }).catch((err)=>{\n            return Promise.reject(err);\n        });\n    }\n    async ordered(stream, opts) {\n        await this.checkVersion();\n        const impl = this.api;\n        const sapi = new StreamAPIImpl(impl.nc, impl.opts);\n        return sapi.info(stream).then((_si)=>{\n            return Promise.resolve(new OrderedPullConsumerImpl(this.api, stream, opts));\n        }).catch((err)=>{\n            return Promise.reject(err);\n        });\n    }\n}\nclass StreamImpl {\n    api;\n    _info;\n    constructor(api, info){\n        this.api = api;\n        this._info = info;\n    }\n    get name() {\n        return this._info.config.name;\n    }\n    alternates() {\n        return this.info().then((si)=>{\n            return si.alternates ? si.alternates : [];\n        });\n    }\n    async best() {\n        await this.info();\n        if (this._info.alternates) {\n            const asi = await this.api.info(this._info.alternates[0].name);\n            return new StreamImpl(this.api, asi);\n        } else {\n            return this;\n        }\n    }\n    info(cached = false, opts) {\n        if (cached) {\n            return Promise.resolve(this._info);\n        }\n        return this.api.info(this.name, opts).then((si)=>{\n            this._info = si;\n            return this._info;\n        });\n    }\n    getConsumerFromInfo(ci) {\n        return new ConsumersImpl(new ConsumerAPIImpl(this.api.nc, this.api.opts)).getPullConsumerFor(ci);\n    }\n    getConsumer(name) {\n        return new ConsumersImpl(new ConsumerAPIImpl(this.api.nc, this.api.opts)).get(this.name, name);\n    }\n    getMessage(query) {\n        return this.api.getMessage(this.name, query);\n    }\n    deleteMessage(seq, erase) {\n        return this.api.deleteMessage(this.name, seq, erase);\n    }\n}\nclass StreamAPIImpl extends BaseApiClient {\n    constructor(nc, opts){\n        super(nc, opts);\n    }\n    checkStreamConfigVersions(cfg) {\n        const nci = this.nc;\n        if (cfg.metadata) {\n            const { min, ok } = nci.features.get(Feature.JS_STREAM_CONSUMER_METADATA);\n            if (!ok) {\n                throw new Error(`stream 'metadata' requires server ${min}`);\n            }\n        }\n        if (cfg.first_seq) {\n            const { min, ok } = nci.features.get(Feature.JS_STREAM_FIRST_SEQ);\n            if (!ok) {\n                throw new Error(`stream 'first_seq' requires server ${min}`);\n            }\n        }\n        if (cfg.subject_transform) {\n            const { min, ok } = nci.features.get(Feature.JS_STREAM_SUBJECT_TRANSFORM);\n            if (!ok) {\n                throw new Error(`stream 'subject_transform' requires server ${min}`);\n            }\n        }\n        if (cfg.compression) {\n            const { min, ok } = nci.features.get(Feature.JS_STREAM_COMPRESSION);\n            if (!ok) {\n                throw new Error(`stream 'compression' requires server ${min}`);\n            }\n        }\n        if (cfg.consumer_limits) {\n            const { min, ok } = nci.features.get(Feature.JS_DEFAULT_CONSUMER_LIMITS);\n            if (!ok) {\n                throw new Error(`stream 'consumer_limits' requires server ${min}`);\n            }\n        }\n        function validateStreamSource(context, src) {\n            const count = src?.subject_transforms?.length || 0;\n            if (count > 0) {\n                const { min, ok } = nci.features.get(Feature.JS_STREAM_SOURCE_SUBJECT_TRANSFORM);\n                if (!ok) {\n                    throw new Error(`${context} 'subject_transforms' requires server ${min}`);\n                }\n            }\n        }\n        if (cfg.sources) {\n            cfg.sources.forEach((src)=>{\n                validateStreamSource(\"stream sources\", src);\n            });\n        }\n        if (cfg.mirror) {\n            validateStreamSource(\"stream mirror\", cfg.mirror);\n        }\n    }\n    async add(cfg = {}) {\n        this.checkStreamConfigVersions(cfg);\n        validateStreamName(cfg.name);\n        cfg.mirror = convertStreamSourceDomain(cfg.mirror);\n        cfg.sources = cfg.sources?.map(convertStreamSourceDomain);\n        const r = await this._request(`${this.prefix}.STREAM.CREATE.${cfg.name}`, cfg);\n        const si = r;\n        this._fixInfo(si);\n        return si;\n    }\n    async delete(stream) {\n        validateStreamName(stream);\n        const r = await this._request(`${this.prefix}.STREAM.DELETE.${stream}`);\n        const cr = r;\n        return cr.success;\n    }\n    async update(name, cfg = {}) {\n        if (typeof name === \"object\") {\n            const sc = name;\n            name = sc.name;\n            cfg = sc;\n            console.trace(`\\u001B[33m >> streams.update(config: StreamConfig) api changed to streams.update(name: string, config: StreamUpdateConfig) - this shim will be removed - update your code.  \\u001B[0m`);\n        }\n        this.checkStreamConfigVersions(cfg);\n        validateStreamName(name);\n        const old = await this.info(name);\n        const update = Object.assign(old.config, cfg);\n        update.mirror = convertStreamSourceDomain(update.mirror);\n        update.sources = update.sources?.map(convertStreamSourceDomain);\n        const r = await this._request(`${this.prefix}.STREAM.UPDATE.${name}`, update);\n        const si = r;\n        this._fixInfo(si);\n        return si;\n    }\n    async info(name, data) {\n        validateStreamName(name);\n        const subj = `${this.prefix}.STREAM.INFO.${name}`;\n        const r = await this._request(subj, data);\n        let si = r;\n        let { total, limit } = si;\n        let have = si.state.subjects ? Object.getOwnPropertyNames(si.state.subjects).length : 1;\n        if (total && total > have) {\n            const infos = [\n                si\n            ];\n            const paged = data || {};\n            let i = 0;\n            while(total > have){\n                i++;\n                paged.offset = limit * i;\n                const r = await this._request(subj, paged);\n                total = r.total;\n                infos.push(r);\n                const count = Object.getOwnPropertyNames(r.state.subjects).length;\n                have += count;\n                if (count < limit) {\n                    break;\n                }\n            }\n            let subjects = {};\n            for(let i = 0; i < infos.length; i++){\n                si = infos[i];\n                if (si.state.subjects) {\n                    subjects = Object.assign(subjects, si.state.subjects);\n                }\n            }\n            si.offset = 0;\n            si.total = 0;\n            si.limit = 0;\n            si.state.subjects = subjects;\n        }\n        this._fixInfo(si);\n        return si;\n    }\n    list(subject = \"\") {\n        const payload = subject?.length ? {\n            subject\n        } : {};\n        const listerFilter = (v)=>{\n            const slr = v;\n            slr.streams.forEach((si)=>{\n                this._fixInfo(si);\n            });\n            return slr.streams;\n        };\n        const subj = `${this.prefix}.STREAM.LIST`;\n        return new ListerImpl(subj, listerFilter, this, payload);\n    }\n    _fixInfo(si) {\n        si.config.sealed = si.config.sealed || false;\n        si.config.deny_delete = si.config.deny_delete || false;\n        si.config.deny_purge = si.config.deny_purge || false;\n        si.config.allow_rollup_hdrs = si.config.allow_rollup_hdrs || false;\n    }\n    async purge(name, opts) {\n        if (opts) {\n            const { keep, seq } = opts;\n            if (typeof keep === \"number\" && typeof seq === \"number\") {\n                throw new Error(\"can specify one of keep or seq\");\n            }\n        }\n        validateStreamName(name);\n        const v = await this._request(`${this.prefix}.STREAM.PURGE.${name}`, opts);\n        return v;\n    }\n    async deleteMessage(stream, seq, erase = true) {\n        validateStreamName(stream);\n        const dr = {\n            seq\n        };\n        if (!erase) {\n            dr.no_erase = true;\n        }\n        const r = await this._request(`${this.prefix}.STREAM.MSG.DELETE.${stream}`, dr);\n        const cr = r;\n        return cr.success;\n    }\n    async getMessage(stream, query) {\n        validateStreamName(stream);\n        const r = await this._request(`${this.prefix}.STREAM.MSG.GET.${stream}`, query);\n        const sm = r;\n        return new StoredMsgImpl(sm);\n    }\n    find(subject) {\n        return this.findStream(subject);\n    }\n    listKvs() {\n        const filter = (v)=>{\n            const slr = v;\n            const kvStreams = slr.streams.filter((v)=>{\n                return v.config.name.startsWith(kvPrefix);\n            });\n            kvStreams.forEach((si)=>{\n                this._fixInfo(si);\n            });\n            let cluster = \"\";\n            if (kvStreams.length) {\n                cluster = this.nc.info?.cluster ?? \"\";\n            }\n            const status = kvStreams.map((si)=>{\n                return new KvStatusImpl(si, cluster);\n            });\n            return status;\n        };\n        const subj = `${this.prefix}.STREAM.LIST`;\n        return new ListerImpl(subj, filter, this);\n    }\n    listObjectStores() {\n        const filter = (v)=>{\n            const slr = v;\n            const objStreams = slr.streams.filter((v)=>{\n                return v.config.name.startsWith(osPrefix);\n            });\n            objStreams.forEach((si)=>{\n                this._fixInfo(si);\n            });\n            const status = objStreams.map((si)=>{\n                return new ObjectStoreStatusImpl(si);\n            });\n            return status;\n        };\n        const subj = `${this.prefix}.STREAM.LIST`;\n        return new ListerImpl(subj, filter, this);\n    }\n    names(subject = \"\") {\n        const payload = subject?.length ? {\n            subject\n        } : {};\n        const listerFilter = (v)=>{\n            const sr = v;\n            return sr.streams;\n        };\n        const subj = `${this.prefix}.STREAM.NAMES`;\n        return new ListerImpl(subj, listerFilter, this, payload);\n    }\n    async get(name) {\n        const si = await this.info(name);\n        return Promise.resolve(new StreamImpl(this, si));\n    }\n}\nclass DirectStreamAPIImpl extends BaseApiClient {\n    constructor(nc, opts){\n        super(nc, opts);\n    }\n    async getMessage(stream, query) {\n        validateStreamName(stream);\n        let qq = query;\n        const { last_by_subj } = qq;\n        if (last_by_subj) {\n            qq = null;\n        }\n        const payload = qq ? this.jc.encode(qq) : Empty;\n        const pre = this.opts.apiPrefix || \"$JS.API\";\n        const subj = last_by_subj ? `${pre}.DIRECT.GET.${stream}.${last_by_subj}` : `${pre}.DIRECT.GET.${stream}`;\n        const r = await this.nc.request(subj, payload, {\n            timeout: this.timeout\n        });\n        const err = checkJsError(r);\n        if (err) {\n            return Promise.reject(err);\n        }\n        const dm = new DirectMsgImpl(r);\n        return Promise.resolve(dm);\n    }\n    async getBatch(stream, opts) {\n        validateStreamName(stream);\n        const pre = this.opts.apiPrefix || \"$JS.API\";\n        const subj = `${pre}.DIRECT.GET.${stream}`;\n        if (!Array.isArray(opts.multi_last) || opts.multi_last.length === 0) {\n            return Promise.reject(\"multi_last is required\");\n        }\n        const payload = JSON.stringify(opts, (key, value)=>{\n            if (key === \"up_to_time\" && value instanceof Date) {\n                return value.toISOString();\n            }\n            return value;\n        });\n        const iter = new QueuedIteratorImpl();\n        const raw = await this.nc.requestMany(subj, payload, {\n            strategy: RequestStrategy.SentinelMsg\n        });\n        (async ()=>{\n            let gotFirst = false;\n            let badServer = false;\n            let badRequest;\n            for await (const m of raw){\n                if (!gotFirst) {\n                    gotFirst = true;\n                    const code = m.headers?.code || 0;\n                    if (code !== 0 && code < 200 || code > 299) {\n                        badRequest = m.headers?.description.toLowerCase();\n                        break;\n                    }\n                    const v = m.headers?.get(\"Nats-Num-Pending\");\n                    if (v === \"\") {\n                        badServer = true;\n                        break;\n                    }\n                }\n                if (m.data.length === 0) {\n                    break;\n                }\n                iter.push(new DirectMsgImpl(m));\n            }\n            iter.push(()=>{\n                if (badServer) {\n                    throw new Error(\"batch direct get not supported by the server\");\n                }\n                if (badRequest) {\n                    throw new Error(`bad request: ${badRequest}`);\n                }\n                iter.stop();\n            });\n        })();\n        return Promise.resolve(iter);\n    }\n}\nclass DirectMsgImpl {\n    data;\n    header;\n    static jc;\n    constructor(m){\n        if (!m.headers) {\n            throw new Error(\"headers expected\");\n        }\n        this.data = m.data;\n        this.header = m.headers;\n    }\n    get subject() {\n        return this.header.last(DirectMsgHeaders.Subject);\n    }\n    get seq() {\n        const v = this.header.last(DirectMsgHeaders.Sequence);\n        return typeof v === \"string\" ? parseInt(v) : 0;\n    }\n    get time() {\n        return new Date(Date.parse(this.timestamp));\n    }\n    get timestamp() {\n        return this.header.last(DirectMsgHeaders.TimeStamp);\n    }\n    get stream() {\n        return this.header.last(DirectMsgHeaders.Stream);\n    }\n    json(reviver) {\n        return JSONCodec(reviver).decode(this.data);\n    }\n    string() {\n        return TD.decode(this.data);\n    }\n}\nclass JetStreamManagerImpl extends BaseApiClient {\n    streams;\n    consumers;\n    direct;\n    constructor(nc, opts){\n        super(nc, opts);\n        this.streams = new StreamAPIImpl(nc, opts);\n        this.consumers = new ConsumerAPIImpl(nc, opts);\n        this.direct = new DirectStreamAPIImpl(nc, opts);\n    }\n    async getAccountInfo() {\n        const r = await this._request(`${this.prefix}.INFO`);\n        return r;\n    }\n    jetstream() {\n        return this.nc.jetstream(this.getOptions());\n    }\n    advisories() {\n        const iter = new QueuedIteratorImpl();\n        this.nc.subscribe(`$JS.EVENT.ADVISORY.>`, {\n            callback: (err, msg)=>{\n                if (err) {\n                    throw err;\n                }\n                try {\n                    const d = this.parseJsResponse(msg);\n                    const chunks = d.type.split(\".\");\n                    const kind = chunks[chunks.length - 1];\n                    iter.push({\n                        kind: kind,\n                        data: d\n                    });\n                } catch (err) {\n                    iter.stop(err);\n                }\n            }\n        });\n        return iter;\n    }\n}\nclass StoredMsgImpl {\n    _header;\n    smr;\n    static jc;\n    constructor(smr){\n        this.smr = smr;\n    }\n    get subject() {\n        return this.smr.message.subject;\n    }\n    get seq() {\n        return this.smr.message.seq;\n    }\n    get timestamp() {\n        return this.smr.message.time;\n    }\n    get time() {\n        return new Date(Date.parse(this.timestamp));\n    }\n    get data() {\n        return this.smr.message.data ? this._parse(this.smr.message.data) : Empty;\n    }\n    get header() {\n        if (!this._header) {\n            if (this.smr.message.hdrs) {\n                const hd = this._parse(this.smr.message.hdrs);\n                this._header = MsgHdrsImpl.decode(hd);\n            } else {\n                this._header = headers();\n            }\n        }\n        return this._header;\n    }\n    _parse(s) {\n        const bs = atob(s);\n        const len = bs.length;\n        const bytes = new Uint8Array(len);\n        for(let i = 0; i < len; i++){\n            bytes[i] = bs.charCodeAt(i);\n        }\n        return bytes;\n    }\n    json(reviver) {\n        return JSONCodec(reviver).decode(this.data);\n    }\n    string() {\n        return TD.decode(this.data);\n    }\n}\nclass StreamsImpl {\n    api;\n    constructor(api){\n        this.api = api;\n    }\n    get(stream) {\n        return this.api.info(stream).then((si)=>{\n            return new StreamImpl(this.api, si);\n        });\n    }\n}\nclass ObjectInfoImpl {\n    info;\n    hdrs;\n    constructor(oi){\n        this.info = oi;\n    }\n    get name() {\n        return this.info.name;\n    }\n    get description() {\n        return this.info.description ?? \"\";\n    }\n    get headers() {\n        if (!this.hdrs) {\n            this.hdrs = MsgHdrsImpl.fromRecord(this.info.headers || {});\n        }\n        return this.hdrs;\n    }\n    get options() {\n        return this.info.options;\n    }\n    get bucket() {\n        return this.info.bucket;\n    }\n    get chunks() {\n        return this.info.chunks;\n    }\n    get deleted() {\n        return this.info.deleted ?? false;\n    }\n    get digest() {\n        return this.info.digest;\n    }\n    get mtime() {\n        return this.info.mtime;\n    }\n    get nuid() {\n        return this.info.nuid;\n    }\n    get size() {\n        return this.info.size;\n    }\n    get revision() {\n        return this.info.revision;\n    }\n    get metadata() {\n        return this.info.metadata || {};\n    }\n    isLink() {\n        return this.info.options?.link !== undefined && this.info.options?.link !== null;\n    }\n}\nfunction toServerObjectStoreMeta(meta) {\n    const v = {\n        name: meta.name,\n        description: meta.description ?? \"\",\n        options: meta.options,\n        metadata: meta.metadata\n    };\n    if (meta.headers) {\n        const mhi = meta.headers;\n        v.headers = mhi.toRecord();\n    }\n    return v;\n}\nfunction emptyReadableStream() {\n    return new ReadableStream({\n        pull (c) {\n            c.enqueue(new Uint8Array(0));\n            c.close();\n        }\n    });\n}\nclass ObjectStoreImpl {\n    jsm;\n    js;\n    stream;\n    name;\n    constructor(name, jsm, js){\n        this.name = name;\n        this.jsm = jsm;\n        this.js = js;\n    }\n    _checkNotEmpty(name) {\n        if (!name || name.length === 0) {\n            return {\n                name,\n                error: new Error(\"name cannot be empty\")\n            };\n        }\n        return {\n            name\n        };\n    }\n    async info(name) {\n        const info = await this.rawInfo(name);\n        return info ? new ObjectInfoImpl(info) : null;\n    }\n    async list() {\n        const buf = [];\n        const iter = await this.watch({\n            ignoreDeletes: true,\n            includeHistory: true\n        });\n        for await (const info of iter){\n            if (info === null) {\n                break;\n            }\n            buf.push(info);\n        }\n        return Promise.resolve(buf);\n    }\n    async rawInfo(name) {\n        const { name: obj, error } = this._checkNotEmpty(name);\n        if (error) {\n            return Promise.reject(error);\n        }\n        const meta = this._metaSubject(obj);\n        try {\n            const m = await this.jsm.streams.getMessage(this.stream, {\n                last_by_subj: meta\n            });\n            const jc = JSONCodec();\n            const soi = jc.decode(m.data);\n            soi.revision = m.seq;\n            return soi;\n        } catch (err) {\n            if (err.code === \"404\") {\n                return null;\n            }\n            return Promise.reject(err);\n        }\n    }\n    async _si(opts) {\n        try {\n            return await this.jsm.streams.info(this.stream, opts);\n        } catch (err) {\n            const nerr = err;\n            if (nerr.code === \"404\") {\n                return null;\n            }\n            return Promise.reject(err);\n        }\n    }\n    async seal() {\n        let info = await this._si();\n        if (info === null) {\n            return Promise.reject(new Error(\"object store not found\"));\n        }\n        info.config.sealed = true;\n        info = await this.jsm.streams.update(this.stream, info.config);\n        return Promise.resolve(new ObjectStoreStatusImpl(info));\n    }\n    async status(opts) {\n        const info = await this._si(opts);\n        if (info === null) {\n            return Promise.reject(new Error(\"object store not found\"));\n        }\n        return Promise.resolve(new ObjectStoreStatusImpl(info));\n    }\n    destroy() {\n        return this.jsm.streams.delete(this.stream);\n    }\n    async _put(meta, rs, opts) {\n        const jsopts = this.js.getOptions();\n        opts = opts || {\n            timeout: jsopts.timeout\n        };\n        opts.timeout = opts.timeout || jsopts.timeout;\n        opts.previousRevision = opts.previousRevision ?? undefined;\n        const { timeout, previousRevision } = opts;\n        const si = this.js.nc.info;\n        const maxPayload = si?.max_payload || 1024;\n        meta = meta || {};\n        meta.options = meta.options || {};\n        let maxChunk = meta.options?.max_chunk_size || 128 * 1024;\n        maxChunk = maxChunk > maxPayload ? maxPayload : maxChunk;\n        meta.options.max_chunk_size = maxChunk;\n        const old = await this.info(meta.name);\n        const { name: n, error } = this._checkNotEmpty(meta.name);\n        if (error) {\n            return Promise.reject(error);\n        }\n        const id = nuid.next();\n        const chunkSubj = this._chunkSubject(id);\n        const metaSubj = this._metaSubject(n);\n        const info = Object.assign({\n            bucket: this.name,\n            nuid: id,\n            size: 0,\n            chunks: 0\n        }, toServerObjectStoreMeta(meta));\n        const d = deferred();\n        const proms = [];\n        const db = new DataBuffer();\n        try {\n            const reader = rs ? rs.getReader() : null;\n            const sha = J.create();\n            while(true){\n                const { done, value } = reader ? await reader.read() : {\n                    done: true,\n                    value: undefined\n                };\n                if (done) {\n                    if (db.size() > 0) {\n                        const payload = db.drain();\n                        sha.update(payload);\n                        info.chunks++;\n                        info.size += payload.length;\n                        proms.push(this.js.publish(chunkSubj, payload, {\n                            timeout\n                        }));\n                    }\n                    await Promise.all(proms);\n                    proms.length = 0;\n                    info.mtime = new Date().toISOString();\n                    const digest = Base64UrlPaddedCodec.encode(sha.digest());\n                    info.digest = `${digestType}${digest}`;\n                    info.deleted = false;\n                    const h = headers();\n                    if (typeof previousRevision === \"number\") {\n                        h.set(PubHeaders.ExpectedLastSubjectSequenceHdr, `${previousRevision}`);\n                    }\n                    h.set(JsHeaders.RollupHdr, JsHeaders.RollupValueSubject);\n                    const pa = await this.js.publish(metaSubj, JSONCodec().encode(info), {\n                        headers: h,\n                        timeout\n                    });\n                    info.revision = pa.seq;\n                    if (old) {\n                        try {\n                            await this.jsm.streams.purge(this.stream, {\n                                filter: `$O.${this.name}.C.${old.nuid}`\n                            });\n                        } catch (_err) {}\n                    }\n                    d.resolve(new ObjectInfoImpl(info));\n                    break;\n                }\n                if (value) {\n                    db.fill(value);\n                    while(db.size() > maxChunk){\n                        info.chunks++;\n                        info.size += maxChunk;\n                        const payload = db.drain(meta.options.max_chunk_size);\n                        sha.update(payload);\n                        proms.push(this.js.publish(chunkSubj, payload, {\n                            timeout\n                        }));\n                    }\n                }\n            }\n        } catch (err) {\n            await this.jsm.streams.purge(this.stream, {\n                filter: chunkSubj\n            });\n            d.reject(err);\n        }\n        return d;\n    }\n    putBlob(meta, data, opts) {\n        function readableStreamFrom(data) {\n            return new ReadableStream({\n                pull (controller) {\n                    controller.enqueue(data);\n                    controller.close();\n                }\n            });\n        }\n        if (data === null) {\n            data = new Uint8Array(0);\n        }\n        return this.put(meta, readableStreamFrom(data), opts);\n    }\n    put(meta, rs, opts) {\n        if (meta?.options?.link) {\n            return Promise.reject(new Error(\"link cannot be set when putting the object in bucket\"));\n        }\n        return this._put(meta, rs, opts);\n    }\n    async getBlob(name) {\n        async function fromReadableStream(rs) {\n            const buf = new DataBuffer();\n            const reader = rs.getReader();\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) {\n                    return buf.drain();\n                }\n                if (value && value.length) {\n                    buf.fill(value);\n                }\n            }\n        }\n        const r = await this.get(name);\n        if (r === null) {\n            return Promise.resolve(null);\n        }\n        const vs = await Promise.all([\n            r.error,\n            fromReadableStream(r.data)\n        ]);\n        if (vs[0]) {\n            return Promise.reject(vs[0]);\n        } else {\n            return Promise.resolve(vs[1]);\n        }\n    }\n    async get(name) {\n        const info = await this.rawInfo(name);\n        if (info === null) {\n            return Promise.resolve(null);\n        }\n        if (info.deleted) {\n            return Promise.resolve(null);\n        }\n        if (info.options && info.options.link) {\n            const ln = info.options.link.name || \"\";\n            if (ln === \"\") {\n                throw new Error(\"link is a bucket\");\n            }\n            const os = info.options.link.bucket !== this.name ? await ObjectStoreImpl.create(this.js, info.options.link.bucket) : this;\n            return os.get(ln);\n        }\n        if (!info.digest.startsWith(digestType)) {\n            return Promise.reject(new Error(`unknown digest type: ${info.digest}`));\n        }\n        const digest = parseSha256(info.digest.substring(8));\n        if (digest === null) {\n            return Promise.reject(new Error(`unable to parse digest: ${info.digest}`));\n        }\n        const d = deferred();\n        const r = {\n            info: new ObjectInfoImpl(info),\n            error: d\n        };\n        if (info.size === 0) {\n            r.data = emptyReadableStream();\n            d.resolve(null);\n            return Promise.resolve(r);\n        }\n        let controller;\n        const oc = consumerOpts();\n        oc.orderedConsumer();\n        const sha = J.create();\n        const subj = `$O.${this.name}.C.${info.nuid}`;\n        const sub = await this.js.subscribe(subj, oc);\n        (async ()=>{\n            for await (const jm of sub){\n                if (jm.data.length > 0) {\n                    sha.update(jm.data);\n                    controller.enqueue(jm.data);\n                }\n                if (jm.info.pending === 0) {\n                    if (!checkSha256(digest, sha.digest())) {\n                        controller.error(new Error(`received a corrupt object, digests do not match received: ${info.digest} calculated ${digest}`));\n                    } else {\n                        controller.close();\n                    }\n                    sub.unsubscribe();\n                }\n            }\n        })().then(()=>{\n            d.resolve();\n        }).catch((err)=>{\n            controller.error(err);\n            d.reject(err);\n        });\n        r.data = new ReadableStream({\n            start (c) {\n                controller = c;\n            },\n            cancel () {\n                sub.unsubscribe();\n            }\n        });\n        return r;\n    }\n    linkStore(name, bucket) {\n        if (!(bucket instanceof ObjectStoreImpl)) {\n            return Promise.reject(\"bucket required\");\n        }\n        const osi = bucket;\n        const { name: n, error } = this._checkNotEmpty(name);\n        if (error) {\n            return Promise.reject(error);\n        }\n        const meta = {\n            name: n,\n            options: {\n                link: {\n                    bucket: osi.name\n                }\n            }\n        };\n        return this._put(meta, null);\n    }\n    async link(name, info) {\n        const { name: n, error } = this._checkNotEmpty(name);\n        if (error) {\n            return Promise.reject(error);\n        }\n        if (info.deleted) {\n            return Promise.reject(new Error(\"src object is deleted\"));\n        }\n        if (info.isLink()) {\n            return Promise.reject(new Error(\"src object is a link\"));\n        }\n        const dest = await this.rawInfo(name);\n        if (dest !== null && !dest.deleted) {\n            return Promise.reject(new Error(\"an object already exists with that name\"));\n        }\n        const link = {\n            bucket: info.bucket,\n            name: info.name\n        };\n        const mm = {\n            name: n,\n            bucket: info.bucket,\n            options: {\n                link: link\n            }\n        };\n        await this.js.publish(this._metaSubject(name), JSON.stringify(mm));\n        const i = await this.info(name);\n        return Promise.resolve(i);\n    }\n    async delete(name) {\n        const info = await this.rawInfo(name);\n        if (info === null) {\n            return Promise.resolve({\n                purged: 0,\n                success: false\n            });\n        }\n        info.deleted = true;\n        info.size = 0;\n        info.chunks = 0;\n        info.digest = \"\";\n        const jc = JSONCodec();\n        const h = headers();\n        h.set(JsHeaders.RollupHdr, JsHeaders.RollupValueSubject);\n        await this.js.publish(this._metaSubject(info.name), jc.encode(info), {\n            headers: h\n        });\n        return this.jsm.streams.purge(this.stream, {\n            filter: this._chunkSubject(info.nuid)\n        });\n    }\n    async update(name, meta = {}) {\n        const info = await this.rawInfo(name);\n        if (info === null) {\n            return Promise.reject(new Error(\"object not found\"));\n        }\n        if (info.deleted) {\n            return Promise.reject(new Error(\"cannot update meta for a deleted object\"));\n        }\n        meta.name = meta.name ?? info.name;\n        const { name: n, error } = this._checkNotEmpty(meta.name);\n        if (error) {\n            return Promise.reject(error);\n        }\n        if (name !== meta.name) {\n            const i = await this.info(meta.name);\n            if (i && !i.deleted) {\n                return Promise.reject(new Error(\"an object already exists with that name\"));\n            }\n        }\n        meta.name = n;\n        const ii = Object.assign({}, info, toServerObjectStoreMeta(meta));\n        const ack = await this.js.publish(this._metaSubject(ii.name), JSON.stringify(ii));\n        if (name !== meta.name) {\n            await this.jsm.streams.purge(this.stream, {\n                filter: this._metaSubject(name)\n            });\n        }\n        return Promise.resolve(ack);\n    }\n    async watch(opts = {}) {\n        opts.includeHistory = opts.includeHistory ?? false;\n        opts.ignoreDeletes = opts.ignoreDeletes ?? false;\n        let initialized = false;\n        const qi = new QueuedIteratorImpl();\n        const subj = this._metaSubjectAll();\n        try {\n            await this.jsm.streams.getMessage(this.stream, {\n                last_by_subj: subj\n            });\n        } catch (err) {\n            if (err.code === \"404\") {\n                qi.push(null);\n                initialized = true;\n            } else {\n                qi.stop(err);\n            }\n        }\n        const jc = JSONCodec();\n        const copts = consumerOpts();\n        copts.orderedConsumer();\n        if (opts.includeHistory) {\n            copts.deliverLastPerSubject();\n        } else {\n            initialized = true;\n            copts.deliverNew();\n        }\n        copts.callback((err, jm)=>{\n            if (err) {\n                qi.stop(err);\n                return;\n            }\n            if (jm !== null) {\n                const oi = jc.decode(jm.data);\n                if (oi.deleted && opts.ignoreDeletes === true) {} else {\n                    qi.push(oi);\n                }\n                if (jm.info?.pending === 0 && !initialized) {\n                    initialized = true;\n                    qi.push(null);\n                }\n            }\n        });\n        const sub = await this.js.subscribe(subj, copts);\n        qi._data = sub;\n        qi.iterClosed.then(()=>{\n            sub.unsubscribe();\n        });\n        sub.closed.then(()=>{\n            qi.stop();\n        }).catch((err)=>{\n            qi.stop(err);\n        });\n        return qi;\n    }\n    _chunkSubject(id) {\n        return `$O.${this.name}.C.${id}`;\n    }\n    _metaSubject(n) {\n        return `$O.${this.name}.M.${Base64UrlPaddedCodec.encode(n)}`;\n    }\n    _metaSubjectAll() {\n        return `$O.${this.name}.M.>`;\n    }\n    async init(opts = {}) {\n        try {\n            this.stream = objectStoreStreamName(this.name);\n        } catch (err) {\n            return Promise.reject(err);\n        }\n        const max_age = opts?.ttl || 0;\n        delete opts.ttl;\n        const sc = Object.assign({\n            max_age\n        }, opts);\n        sc.name = this.stream;\n        sc.num_replicas = opts.replicas ?? 1;\n        sc.allow_direct = true;\n        sc.allow_rollup_hdrs = true;\n        sc.discard = DiscardPolicy.New;\n        sc.subjects = [\n            `$O.${this.name}.C.>`,\n            `$O.${this.name}.M.>`\n        ];\n        if (opts.placement) {\n            sc.placement = opts.placement;\n        }\n        if (opts.metadata) {\n            sc.metadata = opts.metadata;\n        }\n        if (typeof opts.compression === \"boolean\") {\n            sc.compression = opts.compression ? StoreCompression.S2 : StoreCompression.None;\n        }\n        try {\n            await this.jsm.streams.info(sc.name);\n        } catch (err) {\n            if (err.message === \"stream not found\") {\n                await this.jsm.streams.add(sc);\n            }\n        }\n    }\n    static async create(js, name, opts = {}) {\n        const jsm = await js.jetstreamManager();\n        const os = new ObjectStoreImpl(name, jsm, js);\n        await os.init(opts);\n        return Promise.resolve(os);\n    }\n}\nclass ViewsImpl {\n    js;\n    constructor(js){\n        this.js = js;\n    }\n    kv(name, opts = {}) {\n        const jsi = this.js;\n        const { ok, min } = jsi.nc.features.get(Feature.JS_KV);\n        if (!ok) {\n            return Promise.reject(new Error(`kv is only supported on servers ${min} or better`));\n        }\n        if (opts.bindOnly) {\n            return Bucket.bind(this.js, name, opts);\n        }\n        return Bucket.create(this.js, name, opts);\n    }\n    os(name, opts = {}) {\n        if (typeof crypto?.subtle?.digest !== \"function\") {\n            return Promise.reject(new Error(\"objectstore: unable to calculate hashes - crypto.subtle.digest with sha256 support is required\"));\n        }\n        const jsi = this.js;\n        const { ok, min } = jsi.nc.features.get(Feature.JS_OBJECTSTORE);\n        if (!ok) {\n            return Promise.reject(new Error(`objectstore is only supported on servers ${min} or better`));\n        }\n        return ObjectStoreImpl.create(this.js, name, opts);\n    }\n}\nclass JetStreamClientImpl extends BaseApiClient {\n    consumers;\n    streams;\n    consumerAPI;\n    streamAPI;\n    constructor(nc, opts){\n        super(nc, opts);\n        this.consumerAPI = new ConsumerAPIImpl(nc, opts);\n        this.streamAPI = new StreamAPIImpl(nc, opts);\n        this.consumers = new ConsumersImpl(this.consumerAPI);\n        this.streams = new StreamsImpl(this.streamAPI);\n    }\n    jetstreamManager(checkAPI) {\n        if (checkAPI === undefined) {\n            checkAPI = this.opts.checkAPI;\n        }\n        const opts = Object.assign({}, this.opts, {\n            checkAPI\n        });\n        return this.nc.jetstreamManager(opts);\n    }\n    get apiPrefix() {\n        return this.prefix;\n    }\n    get views() {\n        return new ViewsImpl(this);\n    }\n    async publish(subj, data = Empty, opts) {\n        opts = opts || {};\n        opts.expect = opts.expect || {};\n        const mh = opts?.headers || headers();\n        if (opts) {\n            if (opts.msgID) {\n                mh.set(PubHeaders.MsgIdHdr, opts.msgID);\n            }\n            if (opts.expect.lastMsgID) {\n                mh.set(PubHeaders.ExpectedLastMsgIdHdr, opts.expect.lastMsgID);\n            }\n            if (opts.expect.streamName) {\n                mh.set(PubHeaders.ExpectedStreamHdr, opts.expect.streamName);\n            }\n            if (typeof opts.expect.lastSequence === \"number\") {\n                mh.set(PubHeaders.ExpectedLastSeqHdr, `${opts.expect.lastSequence}`);\n            }\n            if (typeof opts.expect.lastSubjectSequence === \"number\") {\n                mh.set(PubHeaders.ExpectedLastSubjectSequenceHdr, `${opts.expect.lastSubjectSequence}`);\n            }\n        }\n        const to = opts.timeout || this.timeout;\n        const ro = {};\n        if (to) {\n            ro.timeout = to;\n        }\n        if (opts) {\n            ro.headers = mh;\n        }\n        let { retries, retry_delay } = opts;\n        retries = retries || 1;\n        retry_delay = retry_delay || 250;\n        let r;\n        for(let i = 0; i < retries; i++){\n            try {\n                r = await this.nc.request(subj, data, ro);\n                break;\n            } catch (err) {\n                const ne = err;\n                if (ne.code === \"503\" && i + 1 < retries) {\n                    await delay(retry_delay);\n                } else {\n                    throw err;\n                }\n            }\n        }\n        const pa = this.parseJsResponse(r);\n        if (pa.stream === \"\") {\n            throw NatsError.errorForCode(ErrorCode.JetStreamInvalidAck);\n        }\n        pa.duplicate = pa.duplicate ? pa.duplicate : false;\n        return pa;\n    }\n    async pull(stream, durable, expires = 0) {\n        validateStreamName(stream);\n        validateDurableName(durable);\n        let timeout = this.timeout;\n        if (expires > timeout) {\n            timeout = expires;\n        }\n        expires = expires < 0 ? 0 : nanos(expires);\n        const pullOpts = {\n            batch: 1,\n            no_wait: expires === 0,\n            expires\n        };\n        const msg = await this.nc.request(`${this.prefix}.CONSUMER.MSG.NEXT.${stream}.${durable}`, this.jc.encode(pullOpts), {\n            noMux: true,\n            timeout\n        });\n        const err = checkJsError(msg);\n        if (err) {\n            throw err;\n        }\n        return toJsMsg(msg, this.timeout);\n    }\n    fetch(stream, durable, opts = {}) {\n        validateStreamName(stream);\n        validateDurableName(durable);\n        let timer = null;\n        const trackBytes = (opts.max_bytes ?? 0) > 0;\n        let receivedBytes = 0;\n        const max_bytes = trackBytes ? opts.max_bytes : 0;\n        let monitor = null;\n        const args = {};\n        args.batch = opts.batch || 1;\n        if (max_bytes) {\n            const fv = this.nc.features.get(Feature.JS_PULL_MAX_BYTES);\n            if (!fv.ok) {\n                throw new Error(`max_bytes is only supported on servers ${fv.min} or better`);\n            }\n            args.max_bytes = max_bytes;\n        }\n        args.no_wait = opts.no_wait || false;\n        if (args.no_wait && args.expires) {\n            args.expires = 0;\n        }\n        const expires = opts.expires || 0;\n        if (expires) {\n            args.expires = nanos(expires);\n        }\n        if (expires === 0 && args.no_wait === false) {\n            throw new Error(\"expires or no_wait is required\");\n        }\n        const hb = opts.idle_heartbeat || 0;\n        if (hb) {\n            args.idle_heartbeat = nanos(hb);\n            if (opts.delay_heartbeat === true) {\n                args.idle_heartbeat = nanos(hb * 4);\n            }\n        }\n        const qi = new QueuedIteratorImpl();\n        const wants = args.batch;\n        let received = 0;\n        qi.protocolFilterFn = (jm, _ingest = false)=>{\n            const jsmi = jm;\n            if (isHeartbeatMsg(jsmi.msg)) {\n                monitor?.work();\n                return false;\n            }\n            return true;\n        };\n        qi.dispatchedFn = (m)=>{\n            if (m) {\n                if (trackBytes) {\n                    receivedBytes += m.data.length;\n                }\n                received++;\n                if (timer && m.info.pending === 0) {\n                    return;\n                }\n                if (qi.getPending() === 1 && m.info.pending === 0 || wants === received || max_bytes > 0 && receivedBytes >= max_bytes) {\n                    qi.stop();\n                }\n            }\n        };\n        const inbox = createInbox(this.nc.options.inboxPrefix);\n        const sub = this.nc.subscribe(inbox, {\n            max: opts.batch,\n            callback: (err, msg)=>{\n                if (err === null) {\n                    err = checkJsError(msg);\n                }\n                if (err !== null) {\n                    if (timer) {\n                        timer.cancel();\n                        timer = null;\n                    }\n                    if (isNatsError(err)) {\n                        qi.stop(hideNonTerminalJsErrors(err) === null ? undefined : err);\n                    } else {\n                        qi.stop(err);\n                    }\n                } else {\n                    monitor?.work();\n                    qi.received++;\n                    qi.push(toJsMsg(msg, this.timeout));\n                }\n            }\n        });\n        if (expires) {\n            timer = timeout(expires);\n            timer.catch(()=>{\n                if (!sub.isClosed()) {\n                    sub.drain().catch(()=>{});\n                    timer = null;\n                }\n                if (monitor) {\n                    monitor.cancel();\n                }\n            });\n        }\n        (async ()=>{\n            try {\n                if (hb) {\n                    monitor = new IdleHeartbeatMonitor(hb, (v)=>{\n                        qi.push(()=>{\n                            qi.err = new NatsError(`${Js409Errors.IdleHeartbeatMissed}: ${v}`, ErrorCode.JetStreamIdleHeartBeat);\n                        });\n                        return true;\n                    });\n                }\n            } catch (_err) {}\n            await sub.closed;\n            if (timer !== null) {\n                timer.cancel();\n                timer = null;\n            }\n            if (monitor) {\n                monitor.cancel();\n            }\n            qi.stop();\n        })().catch();\n        this.nc.publish(`${this.prefix}.CONSUMER.MSG.NEXT.${stream}.${durable}`, this.jc.encode(args), {\n            reply: inbox\n        });\n        return qi;\n    }\n    async pullSubscribe(subject, opts = consumerOpts()) {\n        const cso = await this._processOptions(subject, opts);\n        if (cso.ordered) {\n            throw new Error(\"pull subscribers cannot be be ordered\");\n        }\n        if (cso.config.deliver_subject) {\n            throw new Error(\"consumer info specifies deliver_subject - pull consumers cannot have deliver_subject set\");\n        }\n        const ackPolicy = cso.config.ack_policy;\n        if (ackPolicy === AckPolicy.None || ackPolicy === AckPolicy.All) {\n            throw new Error(\"ack policy for pull consumers must be explicit\");\n        }\n        const so = this._buildTypedSubscriptionOpts(cso);\n        const sub = new JetStreamPullSubscriptionImpl(this, cso.deliver, so);\n        sub.info = cso;\n        try {\n            await this._maybeCreateConsumer(cso);\n        } catch (err) {\n            sub.unsubscribe();\n            throw err;\n        }\n        return sub;\n    }\n    async subscribe(subject, opts = consumerOpts()) {\n        const cso = await this._processOptions(subject, opts);\n        if (!cso.isBind && !cso.config.deliver_subject) {\n            throw new Error(\"push consumer requires deliver_subject\");\n        }\n        const so = this._buildTypedSubscriptionOpts(cso);\n        const sub = new JetStreamSubscriptionImpl(this, cso.deliver, so);\n        sub.info = cso;\n        try {\n            await this._maybeCreateConsumer(cso);\n        } catch (err) {\n            sub.unsubscribe();\n            throw err;\n        }\n        sub._maybeSetupHbMonitoring();\n        return sub;\n    }\n    async _processOptions(subject, opts = consumerOpts()) {\n        const jsi = isConsumerOptsBuilder(opts) ? opts.getOpts() : opts;\n        jsi.isBind = isConsumerOptsBuilder(opts) ? opts.isBind : false;\n        jsi.flow_control = {\n            heartbeat_count: 0,\n            fc_count: 0,\n            consumer_restarts: 0\n        };\n        if (jsi.ordered) {\n            jsi.ordered_consumer_sequence = {\n                stream_seq: 0,\n                delivery_seq: 0\n            };\n            if (jsi.config.ack_policy !== AckPolicy.NotSet && jsi.config.ack_policy !== AckPolicy.None) {\n                throw new NatsError(\"ordered consumer: ack_policy can only be set to 'none'\", ErrorCode.ApiError);\n            }\n            if (jsi.config.durable_name && jsi.config.durable_name.length > 0) {\n                throw new NatsError(\"ordered consumer: durable_name cannot be set\", ErrorCode.ApiError);\n            }\n            if (jsi.config.deliver_subject && jsi.config.deliver_subject.length > 0) {\n                throw new NatsError(\"ordered consumer: deliver_subject cannot be set\", ErrorCode.ApiError);\n            }\n            if (jsi.config.max_deliver !== undefined && jsi.config.max_deliver > 1) {\n                throw new NatsError(\"ordered consumer: max_deliver cannot be set\", ErrorCode.ApiError);\n            }\n            if (jsi.config.deliver_group && jsi.config.deliver_group.length > 0) {\n                throw new NatsError(\"ordered consumer: deliver_group cannot be set\", ErrorCode.ApiError);\n            }\n            jsi.config.deliver_subject = createInbox(this.nc.options.inboxPrefix);\n            jsi.config.ack_policy = AckPolicy.None;\n            jsi.config.max_deliver = 1;\n            jsi.config.flow_control = true;\n            jsi.config.idle_heartbeat = jsi.config.idle_heartbeat || nanos(5000);\n            jsi.config.ack_wait = nanos(22 * 60 * 60 * 1000);\n            jsi.config.mem_storage = true;\n            jsi.config.num_replicas = 1;\n        }\n        if (jsi.config.ack_policy === AckPolicy.NotSet) {\n            jsi.config.ack_policy = AckPolicy.All;\n        }\n        jsi.api = this;\n        jsi.config = jsi.config || {};\n        jsi.stream = jsi.stream ? jsi.stream : await this.findStream(subject);\n        jsi.attached = false;\n        if (jsi.config.durable_name) {\n            try {\n                const info = await this.consumerAPI.info(jsi.stream, jsi.config.durable_name);\n                if (info) {\n                    if (info.config.filter_subject && info.config.filter_subject !== subject) {\n                        throw new Error(\"subject does not match consumer\");\n                    }\n                    const qn = jsi.config.deliver_group ?? \"\";\n                    if (qn === \"\" && info.push_bound === true) {\n                        throw new Error(`duplicate subscription`);\n                    }\n                    const rqn = info.config.deliver_group ?? \"\";\n                    if (qn !== rqn) {\n                        if (rqn === \"\") {\n                            throw new Error(`durable requires no queue group`);\n                        } else {\n                            throw new Error(`durable requires queue group '${rqn}'`);\n                        }\n                    }\n                    jsi.last = info;\n                    jsi.config = info.config;\n                    jsi.attached = true;\n                    if (!jsi.config.durable_name) {\n                        jsi.name = info.name;\n                    }\n                }\n            } catch (err) {\n                if (err.code !== \"404\") {\n                    throw err;\n                }\n            }\n        }\n        if (!jsi.attached && jsi.config.filter_subject === undefined && jsi.config.filter_subjects === undefined) {\n            jsi.config.filter_subject = subject;\n        }\n        jsi.deliver = jsi.config.deliver_subject || createInbox(this.nc.options.inboxPrefix);\n        return jsi;\n    }\n    _buildTypedSubscriptionOpts(jsi) {\n        const so = {};\n        so.adapter = msgAdapter(jsi.callbackFn === undefined, this.timeout);\n        so.ingestionFilterFn = JetStreamClientImpl.ingestionFn(jsi.ordered);\n        so.protocolFilterFn = (jm, ingest = false)=>{\n            const jsmi = jm;\n            if (isFlowControlMsg(jsmi.msg)) {\n                if (!ingest) {\n                    jsmi.msg.respond();\n                }\n                return false;\n            }\n            return true;\n        };\n        if (!jsi.mack && jsi.config.ack_policy !== AckPolicy.None) {\n            so.dispatchedFn = autoAckJsMsg;\n        }\n        if (jsi.callbackFn) {\n            so.callback = jsi.callbackFn;\n        }\n        so.max = jsi.max || 0;\n        so.queue = jsi.queue;\n        return so;\n    }\n    async _maybeCreateConsumer(jsi) {\n        if (jsi.attached) {\n            return;\n        }\n        if (jsi.isBind) {\n            throw new Error(`unable to bind - durable consumer ${jsi.config.durable_name} doesn't exist in ${jsi.stream}`);\n        }\n        jsi.config = Object.assign({\n            deliver_policy: DeliverPolicy.All,\n            ack_policy: AckPolicy.Explicit,\n            ack_wait: nanos(30 * 1000),\n            replay_policy: ReplayPolicy.Instant\n        }, jsi.config);\n        const ci = await this.consumerAPI.add(jsi.stream, jsi.config);\n        if (Array.isArray(jsi.config.filter_subjects && !Array.isArray(ci.config.filter_subjects))) {\n            throw new Error(`jetstream server doesn't support consumers with multiple filter subjects`);\n        }\n        jsi.name = ci.name;\n        jsi.config = ci.config;\n        jsi.last = ci;\n    }\n    static ingestionFn(ordered) {\n        return (jm, ctx)=>{\n            const jsub = ctx;\n            if (!jm) return {\n                ingest: false,\n                protocol: false\n            };\n            const jmi = jm;\n            if (!checkJsError(jmi.msg)) {\n                jsub.monitor?.work();\n            }\n            if (isHeartbeatMsg(jmi.msg)) {\n                const ingest = ordered ? jsub._checkHbOrderConsumer(jmi.msg) : true;\n                if (!ordered) {\n                    jsub.info.flow_control.heartbeat_count++;\n                }\n                return {\n                    ingest,\n                    protocol: true\n                };\n            } else if (isFlowControlMsg(jmi.msg)) {\n                jsub.info.flow_control.fc_count++;\n                return {\n                    ingest: true,\n                    protocol: true\n                };\n            }\n            const ingest = ordered ? jsub._checkOrderedConsumer(jm) : true;\n            return {\n                ingest,\n                protocol: false\n            };\n        };\n    }\n}\nclass NatsConnectionImpl {\n    options;\n    protocol;\n    draining;\n    listeners;\n    _services;\n    constructor(opts){\n        this.draining = false;\n        this.options = parseOptions(opts);\n        this.listeners = [];\n    }\n    static connect(opts = {}) {\n        return new Promise((resolve, reject)=>{\n            const nc = new NatsConnectionImpl(opts);\n            ProtocolHandler.connect(nc.options, nc).then((ph)=>{\n                nc.protocol = ph;\n                (async function() {\n                    for await (const s of ph.status()){\n                        nc.listeners.forEach((l)=>{\n                            l.push(s);\n                        });\n                    }\n                })();\n                resolve(nc);\n            }).catch((err)=>{\n                reject(err);\n            });\n        });\n    }\n    closed() {\n        return this.protocol.closed;\n    }\n    async close() {\n        await this.protocol.close();\n    }\n    _check(subject, sub, pub) {\n        if (this.isClosed()) {\n            throw NatsError.errorForCode(ErrorCode.ConnectionClosed);\n        }\n        if (sub && this.isDraining()) {\n            throw NatsError.errorForCode(ErrorCode.ConnectionDraining);\n        }\n        if (pub && this.protocol.noMorePublishing) {\n            throw NatsError.errorForCode(ErrorCode.ConnectionDraining);\n        }\n        subject = subject || \"\";\n        if (subject.length === 0) {\n            throw NatsError.errorForCode(ErrorCode.BadSubject);\n        }\n    }\n    publish(subject, data, options) {\n        this._check(subject, false, true);\n        this.protocol.publish(subject, data, options);\n    }\n    publishMessage(msg) {\n        return this.publish(msg.subject, msg.data, {\n            reply: msg.reply,\n            headers: msg.headers\n        });\n    }\n    respondMessage(msg) {\n        if (msg.reply) {\n            this.publish(msg.reply, msg.data, {\n                reply: msg.reply,\n                headers: msg.headers\n            });\n            return true;\n        }\n        return false;\n    }\n    subscribe(subject, opts = {}) {\n        this._check(subject, true, false);\n        const sub = new SubscriptionImpl(this.protocol, subject, opts);\n        this.protocol.subscribe(sub);\n        return sub;\n    }\n    _resub(s, subject, max) {\n        this._check(subject, true, false);\n        const si = s;\n        si.max = max;\n        if (max) {\n            si.max = max + si.received;\n        }\n        this.protocol.resub(si, subject);\n    }\n    requestMany(subject, data = Empty, opts = {\n        maxWait: 1000,\n        maxMessages: -1\n    }) {\n        const asyncTraces = !(this.protocol.options.noAsyncTraces || false);\n        try {\n            this._check(subject, true, true);\n        } catch (err) {\n            return Promise.reject(err);\n        }\n        opts.strategy = opts.strategy || RequestStrategy.Timer;\n        opts.maxWait = opts.maxWait || 1000;\n        if (opts.maxWait < 1) {\n            return Promise.reject(new NatsError(\"timeout\", ErrorCode.InvalidOption));\n        }\n        const qi = new QueuedIteratorImpl();\n        function stop(err) {\n            qi.push(()=>{\n                qi.stop(err);\n            });\n        }\n        function callback(err, msg) {\n            if (err || msg === null) {\n                stop(err === null ? undefined : err);\n            } else {\n                qi.push(msg);\n            }\n        }\n        if (opts.noMux) {\n            const stack = asyncTraces ? new Error().stack : null;\n            let max = typeof opts.maxMessages === \"number\" && opts.maxMessages > 0 ? opts.maxMessages : -1;\n            const sub = this.subscribe(createInbox(this.options.inboxPrefix), {\n                callback: (err, msg)=>{\n                    if (msg?.data?.length === 0 && msg?.headers?.status === ErrorCode.NoResponders) {\n                        err = NatsError.errorForCode(ErrorCode.NoResponders);\n                    }\n                    if (err) {\n                        if (stack) {\n                            err.stack += `\\n\\n${stack}`;\n                        }\n                        cancel(err);\n                        return;\n                    }\n                    callback(null, msg);\n                    if (opts.strategy === RequestStrategy.Count) {\n                        max--;\n                        if (max === 0) {\n                            cancel();\n                        }\n                    }\n                    if (opts.strategy === RequestStrategy.JitterTimer) {\n                        clearTimers();\n                        timer = setTimeout(()=>{\n                            cancel();\n                        }, 300);\n                    }\n                    if (opts.strategy === RequestStrategy.SentinelMsg) {\n                        if (msg && msg.data.length === 0) {\n                            cancel();\n                        }\n                    }\n                }\n            });\n            sub.requestSubject = subject;\n            sub.closed.then(()=>{\n                stop();\n            }).catch((err)=>{\n                qi.stop(err);\n            });\n            const cancel = (err)=>{\n                if (err) {\n                    qi.push(()=>{\n                        throw err;\n                    });\n                }\n                clearTimers();\n                sub.drain().then(()=>{\n                    stop();\n                }).catch((_err)=>{\n                    stop();\n                });\n            };\n            qi.iterClosed.then(()=>{\n                clearTimers();\n                sub?.unsubscribe();\n            }).catch((_err)=>{\n                clearTimers();\n                sub?.unsubscribe();\n            });\n            try {\n                this.publish(subject, data, {\n                    reply: sub.getSubject()\n                });\n            } catch (err) {\n                cancel(err);\n            }\n            let timer = setTimeout(()=>{\n                cancel();\n            }, opts.maxWait);\n            const clearTimers = ()=>{\n                if (timer) {\n                    clearTimeout(timer);\n                }\n            };\n        } else {\n            const rmo = opts;\n            rmo.callback = callback;\n            qi.iterClosed.then(()=>{\n                r.cancel();\n            }).catch((err)=>{\n                r.cancel(err);\n            });\n            const r = new RequestMany(this.protocol.muxSubscriptions, subject, rmo);\n            this.protocol.request(r);\n            try {\n                this.publish(subject, data, {\n                    reply: `${this.protocol.muxSubscriptions.baseInbox}${r.token}`,\n                    headers: opts.headers\n                });\n            } catch (err) {\n                r.cancel(err);\n            }\n        }\n        return Promise.resolve(qi);\n    }\n    request(subject, data, opts = {\n        timeout: 1000,\n        noMux: false\n    }) {\n        try {\n            this._check(subject, true, true);\n        } catch (err) {\n            return Promise.reject(err);\n        }\n        const asyncTraces = !(this.protocol.options.noAsyncTraces || false);\n        opts.timeout = opts.timeout || 1000;\n        if (opts.timeout < 1) {\n            return Promise.reject(new NatsError(\"timeout\", ErrorCode.InvalidOption));\n        }\n        if (!opts.noMux && opts.reply) {\n            return Promise.reject(new NatsError(\"reply can only be used with noMux\", ErrorCode.InvalidOption));\n        }\n        if (opts.noMux) {\n            const inbox = opts.reply ? opts.reply : createInbox(this.options.inboxPrefix);\n            const d = deferred();\n            const errCtx = asyncTraces ? new Error() : null;\n            const sub = this.subscribe(inbox, {\n                max: 1,\n                timeout: opts.timeout,\n                callback: (err, msg)=>{\n                    if (err) {\n                        if (errCtx && err.code !== ErrorCode.Timeout) {\n                            err.stack += `\\n\\n${errCtx.stack}`;\n                        }\n                        sub.unsubscribe();\n                        d.reject(err);\n                    } else {\n                        err = isRequestError(msg);\n                        if (err) {\n                            if (errCtx) {\n                                err.stack += `\\n\\n${errCtx.stack}`;\n                            }\n                            d.reject(err);\n                        } else {\n                            d.resolve(msg);\n                        }\n                    }\n                }\n            });\n            sub.requestSubject = subject;\n            this.protocol.publish(subject, data, {\n                reply: inbox,\n                headers: opts.headers\n            });\n            return d;\n        } else {\n            const r = new RequestOne(this.protocol.muxSubscriptions, subject, opts, asyncTraces);\n            this.protocol.request(r);\n            try {\n                this.publish(subject, data, {\n                    reply: `${this.protocol.muxSubscriptions.baseInbox}${r.token}`,\n                    headers: opts.headers\n                });\n            } catch (err) {\n                r.cancel(err);\n            }\n            const p = Promise.race([\n                r.timer,\n                r.deferred\n            ]);\n            p.catch(()=>{\n                r.cancel();\n            });\n            return p;\n        }\n    }\n    flush() {\n        if (this.isClosed()) {\n            return Promise.reject(NatsError.errorForCode(ErrorCode.ConnectionClosed));\n        }\n        return this.protocol.flush();\n    }\n    drain() {\n        if (this.isClosed()) {\n            return Promise.reject(NatsError.errorForCode(ErrorCode.ConnectionClosed));\n        }\n        if (this.isDraining()) {\n            return Promise.reject(NatsError.errorForCode(ErrorCode.ConnectionDraining));\n        }\n        this.draining = true;\n        return this.protocol.drain();\n    }\n    isClosed() {\n        return this.protocol.isClosed();\n    }\n    isDraining() {\n        return this.draining;\n    }\n    getServer() {\n        const srv = this.protocol.getServer();\n        return srv ? srv.listen : \"\";\n    }\n    status() {\n        const iter = new QueuedIteratorImpl();\n        iter.iterClosed.then(()=>{\n            const idx = this.listeners.indexOf(iter);\n            this.listeners.splice(idx, 1);\n        });\n        this.listeners.push(iter);\n        return iter;\n    }\n    get info() {\n        return this.protocol.isClosed() ? undefined : this.protocol.info;\n    }\n    async context() {\n        const r = await this.request(`$SYS.REQ.USER.INFO`);\n        return r.json((key, value)=>{\n            if (key === \"time\") {\n                return new Date(Date.parse(value));\n            }\n            return value;\n        });\n    }\n    stats() {\n        return {\n            inBytes: this.protocol.inBytes,\n            outBytes: this.protocol.outBytes,\n            inMsgs: this.protocol.inMsgs,\n            outMsgs: this.protocol.outMsgs\n        };\n    }\n    async jetstreamManager(opts = {}) {\n        const adm = new JetStreamManagerImpl(this, opts);\n        if (opts.checkAPI !== false) {\n            try {\n                await adm.getAccountInfo();\n            } catch (err) {\n                const ne = err;\n                if (ne.code === ErrorCode.NoResponders) {\n                    ne.code = ErrorCode.JetStreamNotEnabled;\n                }\n                throw ne;\n            }\n        }\n        return adm;\n    }\n    jetstream(opts = {}) {\n        return new JetStreamClientImpl(this, opts);\n    }\n    getServerVersion() {\n        const info = this.info;\n        return info ? parseSemVer(info.version) : undefined;\n    }\n    async rtt() {\n        if (!this.protocol._closed && !this.protocol.connected) {\n            throw NatsError.errorForCode(ErrorCode.Disconnect);\n        }\n        const start = Date.now();\n        await this.flush();\n        return Date.now() - start;\n    }\n    get features() {\n        return this.protocol.features;\n    }\n    get services() {\n        if (!this._services) {\n            this._services = new ServicesFactory(this);\n        }\n        return this._services;\n    }\n    reconnect() {\n        if (this.isClosed()) {\n            return Promise.reject(NatsError.errorForCode(ErrorCode.ConnectionClosed));\n        }\n        if (this.isDraining()) {\n            return Promise.reject(NatsError.errorForCode(ErrorCode.ConnectionDraining));\n        }\n        return this.protocol.reconnect();\n    }\n}\nclass ServicesFactory {\n    nc;\n    constructor(nc){\n        this.nc = nc;\n    }\n    add(config) {\n        try {\n            const s = new ServiceImpl(this.nc, config);\n            return s.start();\n        } catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    client(opts, prefix) {\n        return new ServiceClientImpl(this.nc, opts, prefix);\n    }\n}\nclass KvStoredEntryImpl {\n    bucket;\n    sm;\n    prefixLen;\n    constructor(bucket, prefixLen, sm){\n        this.bucket = bucket;\n        this.prefixLen = prefixLen;\n        this.sm = sm;\n    }\n    get key() {\n        return this.sm.subject.substring(this.prefixLen);\n    }\n    get value() {\n        return this.sm.data;\n    }\n    get delta() {\n        return 0;\n    }\n    get created() {\n        return this.sm.time;\n    }\n    get revision() {\n        return this.sm.seq;\n    }\n    get operation() {\n        return this.sm.header.get(kvOperationHdr) || \"PUT\";\n    }\n    get length() {\n        const slen = this.sm.header.get(JsHeaders.MessageSizeHdr) || \"\";\n        if (slen !== \"\") {\n            return parseInt(slen, 10);\n        }\n        return this.sm.data.length;\n    }\n    json() {\n        return this.sm.json();\n    }\n    string() {\n        return this.sm.string();\n    }\n}\nclass KvJsMsgEntryImpl {\n    bucket;\n    key;\n    sm;\n    constructor(bucket, key, sm){\n        this.bucket = bucket;\n        this.key = key;\n        this.sm = sm;\n    }\n    get value() {\n        return this.sm.data;\n    }\n    get created() {\n        return new Date(millis(this.sm.info.timestampNanos));\n    }\n    get revision() {\n        return this.sm.seq;\n    }\n    get operation() {\n        return this.sm.headers?.get(kvOperationHdr) || \"PUT\";\n    }\n    get delta() {\n        return this.sm.info.pending;\n    }\n    get length() {\n        const slen = this.sm.headers?.get(JsHeaders.MessageSizeHdr) || \"\";\n        if (slen !== \"\") {\n            return parseInt(slen, 10);\n        }\n        return this.sm.data.length;\n    }\n    json() {\n        return this.sm.json();\n    }\n    string() {\n        return this.sm.string();\n    }\n}\nclass JetStreamSubscriptionImpl extends TypedSubscription {\n    js;\n    monitor;\n    constructor(js, subject, opts){\n        super(js.nc, subject, opts);\n        this.js = js;\n        this.monitor = null;\n        this.sub.closed.then(()=>{\n            if (this.monitor) {\n                this.monitor.cancel();\n            }\n        });\n    }\n    set info(info) {\n        this.sub.info = info;\n    }\n    get info() {\n        return this.sub.info;\n    }\n    _resetOrderedConsumer(sseq) {\n        if (this.info === null || this.sub.isClosed()) {\n            return;\n        }\n        const newDeliver = createInbox(this.js.nc.options.inboxPrefix);\n        const nci = this.js.nc;\n        nci._resub(this.sub, newDeliver);\n        const info = this.info;\n        info.config.name = nuid.next();\n        info.ordered_consumer_sequence.delivery_seq = 0;\n        info.flow_control.heartbeat_count = 0;\n        info.flow_control.fc_count = 0;\n        info.flow_control.consumer_restarts++;\n        info.deliver = newDeliver;\n        info.config.deliver_subject = newDeliver;\n        info.config.deliver_policy = DeliverPolicy.StartSequence;\n        info.config.opt_start_seq = sseq;\n        const req = {};\n        req.stream_name = this.info.stream;\n        req.config = info.config;\n        const subj = `${info.api.prefix}.CONSUMER.CREATE.${info.stream}`;\n        this.js._request(subj, req, {\n            retries: -1\n        }).then((v)=>{\n            const ci = v;\n            const jinfo = this.sub.info;\n            jinfo.last = ci;\n            this.info.config = ci.config;\n            this.info.name = ci.name;\n        }).catch((err)=>{\n            const nerr = new NatsError(`unable to recreate ordered consumer ${info.stream} at seq ${sseq}`, ErrorCode.RequestError, err);\n            this.sub.callback(nerr, {});\n        });\n    }\n    _maybeSetupHbMonitoring() {\n        const ns = this.info?.config?.idle_heartbeat || 0;\n        if (ns) {\n            this._setupHbMonitoring(millis(ns));\n        }\n    }\n    _setupHbMonitoring(millis, cancelAfter = 0) {\n        const opts = {\n            cancelAfter: 0,\n            maxOut: 2\n        };\n        if (cancelAfter) {\n            opts.cancelAfter = cancelAfter;\n        }\n        const sub = this.sub;\n        const handler = (v)=>{\n            const msg = newJsErrorMsg(409, `${Js409Errors.IdleHeartbeatMissed}: ${v}`, this.sub.subject);\n            const ordered = this.info?.ordered;\n            if (!ordered) {\n                this.sub.callback(null, msg);\n            } else {\n                if (!this.js.nc.protocol.connected) {\n                    return false;\n                }\n                const seq = this.info?.ordered_consumer_sequence?.stream_seq || 0;\n                this._resetOrderedConsumer(seq + 1);\n                this.monitor?.restart();\n                return false;\n            }\n            return !sub.noIterator;\n        };\n        this.monitor = new IdleHeartbeatMonitor(millis, handler, opts);\n    }\n    _checkHbOrderConsumer(msg) {\n        const rm = msg.headers.get(JsHeaders.ConsumerStalledHdr);\n        if (rm !== \"\") {\n            const nci = this.js.nc;\n            nci.publish(rm);\n        }\n        const lastDelivered = parseInt(msg.headers.get(JsHeaders.LastConsumerSeqHdr), 10);\n        const ordered = this.info.ordered_consumer_sequence;\n        this.info.flow_control.heartbeat_count++;\n        if (lastDelivered !== ordered.delivery_seq) {\n            this._resetOrderedConsumer(ordered.stream_seq + 1);\n        }\n        return false;\n    }\n    _checkOrderedConsumer(jm) {\n        const ordered = this.info.ordered_consumer_sequence;\n        const sseq = jm.info.streamSequence;\n        const dseq = jm.info.deliverySequence;\n        if (dseq != ordered.delivery_seq + 1) {\n            this._resetOrderedConsumer(ordered.stream_seq + 1);\n            return false;\n        }\n        ordered.delivery_seq = dseq;\n        ordered.stream_seq = sseq;\n        return true;\n    }\n    async destroy() {\n        if (!this.isClosed()) {\n            await this.drain();\n        }\n        const jinfo = this.sub.info;\n        const name = jinfo.config.durable_name || jinfo.name;\n        const subj = `${jinfo.api.prefix}.CONSUMER.DELETE.${jinfo.stream}.${name}`;\n        await jinfo.api._request(subj);\n    }\n    async consumerInfo() {\n        const jinfo = this.sub.info;\n        const name = jinfo.config.durable_name || jinfo.name;\n        const subj = `${jinfo.api.prefix}.CONSUMER.INFO.${jinfo.stream}.${name}`;\n        const ci = await jinfo.api._request(subj);\n        jinfo.last = ci;\n        return ci;\n    }\n}\nclass JetStreamPullSubscriptionImpl extends JetStreamSubscriptionImpl {\n    constructor(js, subject, opts){\n        super(js, subject, opts);\n    }\n    pull(opts = {\n        batch: 1\n    }) {\n        const { stream, config, name } = this.sub.info;\n        const consumer = config.durable_name ?? name;\n        const args = {};\n        args.batch = opts.batch || 1;\n        args.no_wait = opts.no_wait || false;\n        if ((opts.max_bytes ?? 0) > 0) {\n            const fv = this.js.nc.features.get(Feature.JS_PULL_MAX_BYTES);\n            if (!fv.ok) {\n                throw new Error(`max_bytes is only supported on servers ${fv.min} or better`);\n            }\n            args.max_bytes = opts.max_bytes;\n        }\n        let expires = 0;\n        if (opts.expires && opts.expires > 0) {\n            expires = opts.expires;\n            args.expires = nanos(expires);\n        }\n        let hb = 0;\n        if (opts.idle_heartbeat && opts.idle_heartbeat > 0) {\n            hb = opts.idle_heartbeat;\n            args.idle_heartbeat = nanos(hb);\n        }\n        if (hb && expires === 0) {\n            throw new Error(\"idle_heartbeat requires expires\");\n        }\n        if (hb > expires) {\n            throw new Error(\"expires must be greater than idle_heartbeat\");\n        }\n        if (this.info) {\n            if (this.monitor) {\n                this.monitor.cancel();\n            }\n            if (expires && hb) {\n                if (!this.monitor) {\n                    this._setupHbMonitoring(hb, expires);\n                } else {\n                    this.monitor._change(hb, expires);\n                }\n            }\n            const api = this.info.api;\n            const subj = `${api.prefix}.CONSUMER.MSG.NEXT.${stream}.${consumer}`;\n            const reply = this.sub.subject;\n            api.nc.publish(subj, api.jc.encode(args), {\n                reply: reply\n            });\n        }\n    }\n}\nfunction msgAdapter(iterator, ackTimeout) {\n    if (iterator) {\n        return iterMsgAdapter(ackTimeout);\n    } else {\n        return cbMsgAdapter(ackTimeout);\n    }\n}\nfunction cbMsgAdapter(ackTimeout) {\n    return (err, msg)=>{\n        if (err) {\n            return [\n                err,\n                null\n            ];\n        }\n        err = checkJsError(msg);\n        if (err) {\n            return [\n                err,\n                null\n            ];\n        }\n        return [\n            null,\n            toJsMsg(msg, ackTimeout)\n        ];\n    };\n}\nfunction iterMsgAdapter(ackTimeout) {\n    return (err, msg)=>{\n        if (err) {\n            return [\n                err,\n                null\n            ];\n        }\n        const ne = checkJsError(msg);\n        if (ne !== null) {\n            return [\n                hideNonTerminalJsErrors(ne),\n                null\n            ];\n        }\n        return [\n            null,\n            toJsMsg(msg, ackTimeout)\n        ];\n    };\n}\nfunction hideNonTerminalJsErrors(ne) {\n    if (ne !== null) {\n        switch(ne.code){\n            case ErrorCode.JetStream404NoMessages:\n            case ErrorCode.JetStream408RequestTimeout:\n                return null;\n            case ErrorCode.JetStream409:\n                if (isTerminal409(ne)) {\n                    return ne;\n                }\n                return null;\n            default:\n                return ne;\n        }\n    }\n    return null;\n}\nfunction autoAckJsMsg(data) {\n    if (data) {\n        data.ack();\n    }\n}\nfunction parseInfo(s) {\n    const tokens = s.split(\".\");\n    if (tokens.length === 9) {\n        tokens.splice(2, 0, \"_\", \"\");\n    }\n    if (tokens.length < 11 || tokens[0] !== \"$JS\" || tokens[1] !== \"ACK\") {\n        throw new Error(`not js message`);\n    }\n    const di = {};\n    di.domain = tokens[2] === \"_\" ? \"\" : tokens[2];\n    di.account_hash = tokens[3];\n    di.stream = tokens[4];\n    di.consumer = tokens[5];\n    di.deliveryCount = parseInt(tokens[6], 10);\n    di.redeliveryCount = di.deliveryCount;\n    di.redelivered = di.deliveryCount > 1;\n    di.streamSequence = parseInt(tokens[7], 10);\n    di.deliverySequence = parseInt(tokens[8], 10);\n    di.timestampNanos = parseInt(tokens[9], 10);\n    di.pending = parseInt(tokens[10], 10);\n    return di;\n}\nclass JsMsgImpl {\n    msg;\n    di;\n    didAck;\n    timeout;\n    constructor(msg, timeout){\n        this.msg = msg;\n        this.didAck = false;\n        this.timeout = timeout;\n    }\n    get subject() {\n        return this.msg.subject;\n    }\n    get sid() {\n        return this.msg.sid;\n    }\n    get data() {\n        return this.msg.data;\n    }\n    get headers() {\n        return this.msg.headers;\n    }\n    get info() {\n        if (!this.di) {\n            this.di = parseInfo(this.reply);\n        }\n        return this.di;\n    }\n    get redelivered() {\n        return this.info.deliveryCount > 1;\n    }\n    get reply() {\n        return this.msg.reply || \"\";\n    }\n    get seq() {\n        return this.info.streamSequence;\n    }\n    doAck(payload) {\n        if (!this.didAck) {\n            this.didAck = !this.isWIP(payload);\n            this.msg.respond(payload);\n        }\n    }\n    isWIP(p) {\n        return p.length === 4 && p[0] === WPI[0] && p[1] === WPI[1] && p[2] === WPI[2] && p[3] === WPI[3];\n    }\n    async ackAck(opts) {\n        opts = opts || {};\n        opts.timeout = opts.timeout || this.timeout;\n        const d = deferred();\n        if (!this.didAck) {\n            this.didAck = true;\n            if (this.msg.reply) {\n                const mi = this.msg;\n                const proto = mi.publisher;\n                const trace = !(proto.options?.noAsyncTraces || false);\n                const r = new RequestOne(proto.muxSubscriptions, this.msg.reply, {\n                    timeout: opts.timeout\n                }, trace);\n                proto.request(r);\n                try {\n                    proto.publish(this.msg.reply, ACK, {\n                        reply: `${proto.muxSubscriptions.baseInbox}${r.token}`\n                    });\n                } catch (err) {\n                    r.cancel(err);\n                }\n                try {\n                    await Promise.race([\n                        r.timer,\n                        r.deferred\n                    ]);\n                    d.resolve(true);\n                } catch (err) {\n                    r.cancel(err);\n                    d.reject(err);\n                }\n            } else {\n                d.resolve(false);\n            }\n        } else {\n            d.resolve(false);\n        }\n        return d;\n    }\n    ack() {\n        this.doAck(ACK);\n    }\n    nak(millis) {\n        let payload = NAK;\n        if (millis) {\n            payload = StringCodec().encode(`-NAK ${JSON.stringify({\n                delay: nanos(millis)\n            })}`);\n        }\n        this.doAck(payload);\n    }\n    working() {\n        this.doAck(WPI);\n    }\n    next(subj, opts = {\n        batch: 1\n    }) {\n        const args = {};\n        args.batch = opts.batch || 1;\n        args.no_wait = opts.no_wait || false;\n        if (opts.expires && opts.expires > 0) {\n            args.expires = nanos(opts.expires);\n        }\n        const data = JSONCodec().encode(args);\n        const payload = DataBuffer.concat(NXT, SPACE, data);\n        const reqOpts = subj ? {\n            reply: subj\n        } : undefined;\n        this.msg.respond(payload, reqOpts);\n    }\n    term(reason = \"\") {\n        let term = TERM;\n        if (reason?.length > 0) {\n            term = StringCodec().encode(`+TERM ${reason}`);\n        }\n        this.doAck(term);\n    }\n    json() {\n        return this.msg.json();\n    }\n    string() {\n        return this.msg.string();\n    }\n}\n\n\n\nconst VERSION = \"1.30.3\";\nconst LANG = \"nats.ws\";\nclass WsTransport {\n    version;\n    lang;\n    closeError;\n    connected;\n    done;\n    socket;\n    options;\n    socketClosed;\n    encrypted;\n    peeked;\n    yields;\n    signal;\n    closedNotification;\n    constructor(){\n        this.version = VERSION;\n        this.lang = LANG;\n        this.connected = false;\n        this.done = false;\n        this.socketClosed = false;\n        this.encrypted = false;\n        this.peeked = false;\n        this.yields = [];\n        this.signal = deferred();\n        this.closedNotification = deferred();\n    }\n    async connect(server, options) {\n        const connected = false;\n        const connLock = deferred();\n        if (options.tls) {\n            connLock.reject(new NatsError(\"tls\", ErrorCode.InvalidOption));\n            return connLock;\n        }\n        this.options = options;\n        const u = server.src;\n        if (options.wsFactory) {\n            const { socket, encrypted } = await options.wsFactory(server.src, options);\n            this.socket = socket;\n            this.encrypted = encrypted;\n        } else {\n            this.encrypted = u.indexOf(\"wss://\") === 0;\n            this.socket = new WebSocket(u);\n        }\n        this.socket.binaryType = \"arraybuffer\";\n        this.socket.onopen = ()=>{\n            if (this.isDiscarded()) {\n                return;\n            }\n        };\n        this.socket.onmessage = (me)=>{\n            if (this.isDiscarded()) {\n                return;\n            }\n            this.yields.push(new Uint8Array(me.data));\n            if (this.peeked) {\n                this.signal.resolve();\n                return;\n            }\n            const t = DataBuffer.concat(...this.yields);\n            const pm = extractProtocolMessage(t);\n            if (pm !== \"\") {\n                const m = INFO.exec(pm);\n                if (!m) {\n                    if (options.debug) {\n                        console.error(\"!!!\", render(t));\n                    }\n                    connLock.reject(new Error(\"unexpected response from server\"));\n                    return;\n                }\n                try {\n                    const info = JSON.parse(m[1]);\n                    checkOptions(info, this.options);\n                    this.peeked = true;\n                    this.connected = true;\n                    this.signal.resolve();\n                    connLock.resolve();\n                } catch (err) {\n                    connLock.reject(err);\n                    return;\n                }\n            }\n        };\n        this.socket.onclose = (evt)=>{\n            if (this.isDiscarded()) {\n                return;\n            }\n            this.socketClosed = true;\n            let reason;\n            if (this.done) return;\n            if (!evt.wasClean) {\n                reason = new Error(evt.reason);\n            }\n            this._closed(reason);\n        };\n        this.socket.onerror = (e)=>{\n            if (this.isDiscarded()) {\n                return;\n            }\n            const evt = e;\n            const err = new NatsError(evt.message, ErrorCode.Unknown, new Error(evt.error));\n            if (!connected) {\n                connLock.reject(err);\n            } else {\n                this._closed(err);\n            }\n        };\n        return connLock;\n    }\n    disconnect() {\n        this._closed(undefined, true);\n    }\n    async _closed(err, internal = true) {\n        if (this.isDiscarded()) {\n            return;\n        }\n        if (!this.connected) return;\n        if (this.done) return;\n        this.closeError = err;\n        if (!err) {\n            while(!this.socketClosed && this.socket.bufferedAmount > 0){\n                await delay(100);\n            }\n        }\n        this.done = true;\n        try {\n            this.socket.close(err ? 1002 : 1000, err ? err.message : undefined);\n        } catch (err) {}\n        if (internal) {\n            this.closedNotification.resolve(err);\n        }\n    }\n    get isClosed() {\n        return this.done;\n    }\n    [Symbol.asyncIterator]() {\n        return this.iterate();\n    }\n    async *iterate() {\n        while(true){\n            if (this.isDiscarded()) {\n                return;\n            }\n            if (this.yields.length === 0) {\n                await this.signal;\n            }\n            const yields = this.yields;\n            this.yields = [];\n            for(let i = 0; i < yields.length; i++){\n                if (this.options.debug) {\n                    console.info(`> ${render(yields[i])}`);\n                }\n                yield yields[i];\n            }\n            if (this.done) {\n                break;\n            } else if (this.yields.length === 0) {\n                yields.length = 0;\n                this.yields = yields;\n                this.signal = deferred();\n            }\n        }\n    }\n    isEncrypted() {\n        return this.connected && this.encrypted;\n    }\n    send(frame) {\n        if (this.isDiscarded()) {\n            return;\n        }\n        try {\n            this.socket.send(frame.buffer);\n            if (this.options.debug) {\n                console.info(`< ${render(frame)}`);\n            }\n            return;\n        } catch (err) {\n            if (this.options.debug) {\n                console.error(`!!! ${render(frame)}: ${err}`);\n            }\n        }\n    }\n    close(err) {\n        return this._closed(err, false);\n    }\n    closed() {\n        return this.closedNotification;\n    }\n    isDiscarded() {\n        if (this.done) {\n            this.discard();\n            return true;\n        }\n        return false;\n    }\n    discard() {\n        this.done = true;\n        try {\n            this.socket?.close();\n        } catch (_err) {}\n    }\n}\nfunction wsUrlParseFn(u, encrypted) {\n    const ut = /^(.*:\\/\\/)(.*)/;\n    if (!ut.test(u)) {\n        if (typeof encrypted === \"boolean\") {\n            u = `${encrypted === true ? \"https\" : \"http\"}://${u}`;\n        } else {\n            u = `https://${u}`;\n        }\n    }\n    let url = new URL(u);\n    const srcProto = url.protocol.toLowerCase();\n    if (srcProto === \"ws:\") {\n        encrypted = false;\n    }\n    if (srcProto === \"wss:\") {\n        encrypted = true;\n    }\n    if (srcProto !== \"https:\" && srcProto !== \"http\") {\n        u = u.replace(/^(.*:\\/\\/)(.*)/gm, \"$2\");\n        url = new URL(`http://${u}`);\n    }\n    let protocol;\n    let port;\n    const host = url.hostname;\n    const path = url.pathname;\n    const search = url.search || \"\";\n    switch(srcProto){\n        case \"http:\":\n        case \"ws:\":\n        case \"nats:\":\n            port = url.port || \"80\";\n            protocol = \"ws:\";\n            break;\n        case \"https:\":\n        case \"wss:\":\n        case \"tls:\":\n            port = url.port || \"443\";\n            protocol = \"wss:\";\n            break;\n        default:\n            port = url.port || encrypted === true ? \"443\" : \"80\";\n            protocol = encrypted === true ? \"wss:\" : \"ws:\";\n            break;\n    }\n    return `${protocol}//${host}:${port}${path}${search}`;\n}\nfunction connect(opts = {}) {\n    setTransportFactory({\n        defaultPort: 443,\n        urlParseFn: wsUrlParseFn,\n        factory: ()=>{\n            return new WsTransport();\n        }\n    });\n    return NatsConnectionImpl.connect(opts);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmF0cy53cy9lc20vbmF0cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQkFBc0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0RBQWtEO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLE9BQU87QUFDNUU7QUFDQSxLQUFLO0FBQ0wsY0FBYyxPQUFPLEdBQUcsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsVUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0Esb0NBQW9DLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixlQUFlO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWSxFQUFFLGtCQUFrQjtBQUNyRDtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekMsdUJBQXVCLEVBQUUsTUFBTSxFQUFFLElBQUksS0FBSztBQUMxQztBQUNBO0FBQ0Esa0JBQWtCLEVBQUU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZLEVBQUUsa0JBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxTQUFTLFNBQVMsU0FBUyx1QkFBdUIsRUFBRTtBQUN2RjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxTQUFTLFNBQVMsU0FBUyxPQUFPLEVBQUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLEVBQUU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0Q0FBNEM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxFQUFFO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseUJBQXlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEVBQUU7QUFDaEMsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHNCQUFzQjtBQUN2RTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUMsUUFBUTtBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FB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QUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZUFBZTtBQUMxQztBQUNBO0FBQ0Esc0NBQXNDLGVBQWU7QUFDckQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0VBQWdFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix5QkFBeUI7QUFDbEQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFdBQVc7QUFDL0MsVUFBVTtBQUNWLHVCQUF1QixPQUFPLEdBQUcsV0FBVztBQUM1QztBQUNBLDRCQUE0QixNQUFNLElBQUksZ0JBQWdCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdCQUFnQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CLHVCQUF1QixRQUFRO0FBQy9CLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixjQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUMsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU87QUFDdEM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDLDRHQUE0RztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELEdBQUcsRUFBRSxNQUFNO0FBQ2pFO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUyxFQUFFLGVBQWUsRUFBRSxNQUFNLEVBQUUsSUFBSTtBQUN4RSxjQUFjO0FBQ2QsZ0NBQWdDLFNBQVMsRUFBRSxNQUFNLEVBQUUsSUFBSTtBQUN2RDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsK0JBQStCLFNBQVMsRUFBRSxlQUFlLEVBQUUsSUFBSTtBQUMvRCxjQUFjO0FBQ2QsK0JBQStCLFNBQVMsRUFBRSxJQUFJO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFdBQVcsRUFBRSxTQUFTLEVBQUUsTUFBTTtBQUNsRSxVQUFVO0FBQ1Ysb0NBQW9DLFdBQVcsRUFBRSxNQUFNO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTyxFQUFFLElBQUk7QUFDbkQsVUFBVTtBQUNWLHNDQUFzQyxNQUFNO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsYUFBYSxFQUFFLFdBQVcsRUFBRSxRQUFRLEVBQUUsTUFBTTtBQUM3RSxjQUFjO0FBQ2QsaUNBQWlDLGFBQWEsRUFBRSxRQUFRLEVBQUUsTUFBTTtBQUNoRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxjQUFjO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsTUFBTTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QixzQ0FBc0MsRUFBRTtBQUN4QyxzQ0FBc0MsRUFBRTtBQUN4QyxzQ0FBc0MsRUFBRTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkdBQTZHO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVMsR0FBRyxTQUFTO0FBQzdDO0FBQ0Esa0JBQWtCLFVBQVUsRUFBRSxpQ0FBaUMsRUFBRSxxQkFBcUIsY0FBYyxnQkFBZ0IsVUFBVSw2QkFBNkIsRUFBRSxPQUFPO0FBQ3BLO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVSxJQUFJLGtDQUFrQyxHQUFHLFVBQVUsR0FBRyxhQUFhLEdBQUcsVUFBVSxHQUFHLGFBQWEsR0FBRyxXQUFXLEdBQUcsY0FBYyxHQUFHLGdEQUFnRDtBQUMvTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsWUFBWTtBQUMvRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGVBQWU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxlQUFlO0FBQ2xEO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxtQ0FBbUMsZUFBZTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGVBQWU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxlQUFlO0FBQ2xEO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxtQ0FBbUMsZUFBZTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0JBQStCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCLEVBQUUsS0FBSztBQUMzQztBQUNBO0FBQ0E7QUFDQSxjQUFjLDBDQUEwQyxFQUFFLFdBQVcsRUFBRSxLQUFLO0FBQzVFO0FBQ0E7QUFDQSwwQ0FBMEMsRUFBRTtBQUM1QztBQUN3Z0M7QUFDeGdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsRUFBRTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxFQUFFO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLEVBQUU7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsRUFBRTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxLQUFLO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsaUNBQWlDLFNBQVMsRUFBRSxZQUFZO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsZ0NBQWdDLFNBQVMsRUFBRSxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQseUNBQXlDLFlBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQSxnQ0FBZ0MsV0FBVyxHQUFHLFdBQVcsR0FBRyxXQUFXO0FBQ3ZFLCtGQUErRixHQUFHLGFBQWEsSUFBSTtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixZQUFZO0FBQ3pDO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxHQUFHO0FBQ3hDLHFDQUFxQyxvQkFBb0IsT0FBTyxFQUFFO0FBQ2xFLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVMsRUFBRSxZQUFZO0FBQ3hEO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWSxHQUFHLFlBQVk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVksR0FBRyxFQUFFO0FBQ3ZDO0FBQ0Esa0JBQWtCLGdCQUFnQixHQUFHLFlBQVksR0FBRyxFQUFFO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsaUJBQWlCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsaUJBQWlCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLFFBQVEsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBSztBQUNyQjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLFFBQVEsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTLEVBQUUsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrREFBa0Q7QUFDbkQ7QUFD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QjtBQUNuSDtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnQkFBZ0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnQkFBZ0I7QUFDekI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQixHQUFHLFlBQVk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDZFQUE2RSxJQUFJO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSx5QkFBeUIsbUJBQW1CLFdBQVc7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVC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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0IsbUJBQW1CLFlBQVk7QUFDdkU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDhFQUE4RSxhQUFhLFNBQVMsS0FBSztBQUN6RyxzQ0FBc0M7QUFDdEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0NBQWdDLElBQUksRUFBRTtBQUNwRjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUIsbUJBQW1CLGFBQWEsR0FBRyxLQUFLO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCLGlCQUFpQixhQUFhLEdBQUcsS0FBSztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsUUFBUTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFdBQVcscUJBQXFCLE9BQU8sR0FBRyxTQUFTO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFzQyxLQUFLLEVBQUU7QUFDaEUsVUFBVTtBQUNWLDJCQUEyQixFQUFFO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxFQUFFO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUyxJQUFJLEtBQUssR0FBRyxLQUFLLEVBQUUsS0FBSyxFQUFFLE9BQU87QUFDeEQ7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDOEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9uYXRzLndzL2VzbS9uYXRzLmpzPzg1MTYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZGVuby1mbXQtaWdub3JlLWZpbGVcbi8vIGRlbm8tbGludC1pZ25vcmUtZmlsZVxuLy8gVGhpcyBjb2RlIHdhcyBidW5kbGVkIHVzaW5nIGBkZW5vIGJ1bmRsZWAgYW5kIGl0J3Mgbm90IHJlY29tbWVuZGVkIHRvIGVkaXQgaXQgbWFudWFsbHlcblxuY29uc3QgRW1wdHkgPSBuZXcgVWludDhBcnJheSgwKTtcbmNvbnN0IFRFID0gbmV3IFRleHRFbmNvZGVyKCk7XG5jb25zdCBURCA9IG5ldyBUZXh0RGVjb2RlcigpO1xuZnVuY3Rpb24gY29uY2F0KC4uLmJ1ZnMpIHtcbiAgICBsZXQgbWF4ID0gMDtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgYnVmcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIG1heCArPSBidWZzW2ldLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkobWF4KTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBidWZzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgb3V0LnNldChidWZzW2ldLCBpbmRleCk7XG4gICAgICAgIGluZGV4ICs9IGJ1ZnNbaV0ubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gZW5jb2RlKC4uLmEpIHtcbiAgICBjb25zdCBidWZzID0gW107XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspe1xuICAgICAgICBidWZzLnB1c2goVEUuZW5jb2RlKGFbaV0pKTtcbiAgICB9XG4gICAgaWYgKGJ1ZnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBFbXB0eTtcbiAgICB9XG4gICAgaWYgKGJ1ZnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBidWZzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gY29uY2F0KC4uLmJ1ZnMpO1xufVxuZnVuY3Rpb24gZGVjb2RlKGEpIHtcbiAgICBpZiAoIWEgfHwgYS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHJldHVybiBURC5kZWNvZGUoYSk7XG59XG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IGRpZ2l0cyA9IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCI7XG5jb25zdCBiYXNlID0gMzY7XG5jb25zdCBtYXhTZXEgPSAzNjU2MTU4NDQwMDYyOTc2O1xuY29uc3QgbWluSW5jID0gMzM7XG5jb25zdCBtYXhJbmMgPSAzMzM7XG5jb25zdCB0b3RhbExlbiA9IDEyICsgMTA7XG5mdW5jdGlvbiBfZ2V0UmFuZG9tVmFsdWVzKGEpIHtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGFbaV0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbGxSYW5kb20oYSkge1xuICAgIGlmIChnbG9iYWxUaGlzPy5jcnlwdG8/LmdldFJhbmRvbVZhbHVlcykge1xuICAgICAgICBnbG9iYWxUaGlzLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2dldFJhbmRvbVZhbHVlcyhhKTtcbiAgICB9XG59XG5jbGFzcyBOdWlkIHtcbiAgICBidWY7XG4gICAgc2VxO1xuICAgIGluYztcbiAgICBpbml0ZWQ7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5idWYgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbik7XG4gICAgICAgIHRoaXMuaW5pdGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIHRoaXMuaW5pdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZXRQcmUoKTtcbiAgICAgICAgdGhpcy5pbml0U2VxQW5kSW5jKCk7XG4gICAgICAgIHRoaXMuZmlsbFNlcSgpO1xuICAgIH1cbiAgICBpbml0U2VxQW5kSW5jKCkge1xuICAgICAgICB0aGlzLnNlcSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG1heFNlcSk7XG4gICAgICAgIHRoaXMuaW5jID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heEluYyAtIG1pbkluYykgKyBtaW5JbmMpO1xuICAgIH1cbiAgICBzZXRQcmUoKSB7XG4gICAgICAgIGNvbnN0IGNidWYgPSBuZXcgVWludDhBcnJheSgxMik7XG4gICAgICAgIGZpbGxSYW5kb20oY2J1Zik7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCAxMjsgaSsrKXtcbiAgICAgICAgICAgIGNvbnN0IGRpID0gY2J1ZltpXSAlIDM2O1xuICAgICAgICAgICAgdGhpcy5idWZbaV0gPSBkaWdpdHMuY2hhckNvZGVBdChkaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmlsbFNlcSgpIHtcbiAgICAgICAgbGV0IG4gPSB0aGlzLnNlcTtcbiAgICAgICAgZm9yKGxldCBpID0gdG90YWxMZW4gLSAxOyBpID49IDEyOyBpLS0pe1xuICAgICAgICAgICAgdGhpcy5idWZbaV0gPSBkaWdpdHMuY2hhckNvZGVBdChuICUgYmFzZSk7XG4gICAgICAgICAgICBuID0gTWF0aC5mbG9vcihuIC8gYmFzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmluaXRlZCkge1xuICAgICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXEgKz0gdGhpcy5pbmM7XG4gICAgICAgIGlmICh0aGlzLnNlcSA+IDM2NTYxNTg0NDAwNjI5NzYpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UHJlKCk7XG4gICAgICAgICAgICB0aGlzLmluaXRTZXFBbmRJbmMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbGxTZXEoKTtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCB0aGlzLmJ1Zik7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG59XG5jb25zdCBudWlkID0gbmV3IE51aWQoKTtcbnZhciBFdmVudHM7XG4oZnVuY3Rpb24oRXZlbnRzKSB7XG4gICAgRXZlbnRzW1wiRGlzY29ubmVjdFwiXSA9IFwiZGlzY29ubmVjdFwiO1xuICAgIEV2ZW50c1tcIlJlY29ubmVjdFwiXSA9IFwicmVjb25uZWN0XCI7XG4gICAgRXZlbnRzW1wiVXBkYXRlXCJdID0gXCJ1cGRhdGVcIjtcbiAgICBFdmVudHNbXCJMRE1cIl0gPSBcImxkbVwiO1xuICAgIEV2ZW50c1tcIkVycm9yXCJdID0gXCJlcnJvclwiO1xufSkoRXZlbnRzIHx8IChFdmVudHMgPSB7fSkpO1xudmFyIERlYnVnRXZlbnRzO1xuKGZ1bmN0aW9uKERlYnVnRXZlbnRzKSB7XG4gICAgRGVidWdFdmVudHNbXCJSZWNvbm5lY3RpbmdcIl0gPSBcInJlY29ubmVjdGluZ1wiO1xuICAgIERlYnVnRXZlbnRzW1wiUGluZ1RpbWVyXCJdID0gXCJwaW5nVGltZXJcIjtcbiAgICBEZWJ1Z0V2ZW50c1tcIlN0YWxlQ29ubmVjdGlvblwiXSA9IFwic3RhbGVDb25uZWN0aW9uXCI7XG4gICAgRGVidWdFdmVudHNbXCJDbGllbnRJbml0aWF0ZWRSZWNvbm5lY3RcIl0gPSBcImNsaWVudCBpbml0aWF0ZWQgcmVjb25uZWN0XCI7XG59KShEZWJ1Z0V2ZW50cyB8fCAoRGVidWdFdmVudHMgPSB7fSkpO1xudmFyIEVycm9yQ29kZTtcbihmdW5jdGlvbihFcnJvckNvZGUpIHtcbiAgICBFcnJvckNvZGVbXCJBcGlFcnJvclwiXSA9IFwiQkFEIEFQSVwiO1xuICAgIEVycm9yQ29kZVtcIkJhZEF1dGhlbnRpY2F0aW9uXCJdID0gXCJCQURfQVVUSEVOVElDQVRJT05cIjtcbiAgICBFcnJvckNvZGVbXCJCYWRDcmVkc1wiXSA9IFwiQkFEX0NSRURTXCI7XG4gICAgRXJyb3JDb2RlW1wiQmFkSGVhZGVyXCJdID0gXCJCQURfSEVBREVSXCI7XG4gICAgRXJyb3JDb2RlW1wiQmFkSnNvblwiXSA9IFwiQkFEX0pTT05cIjtcbiAgICBFcnJvckNvZGVbXCJCYWRQYXlsb2FkXCJdID0gXCJCQURfUEFZTE9BRFwiO1xuICAgIEVycm9yQ29kZVtcIkJhZFN1YmplY3RcIl0gPSBcIkJBRF9TVUJKRUNUXCI7XG4gICAgRXJyb3JDb2RlW1wiQ2FuY2VsbGVkXCJdID0gXCJDQU5DRUxMRURcIjtcbiAgICBFcnJvckNvZGVbXCJDb25uZWN0aW9uQ2xvc2VkXCJdID0gXCJDT05ORUNUSU9OX0NMT1NFRFwiO1xuICAgIEVycm9yQ29kZVtcIkNvbm5lY3Rpb25EcmFpbmluZ1wiXSA9IFwiQ09OTkVDVElPTl9EUkFJTklOR1wiO1xuICAgIEVycm9yQ29kZVtcIkNvbm5lY3Rpb25SZWZ1c2VkXCJdID0gXCJDT05ORUNUSU9OX1JFRlVTRURcIjtcbiAgICBFcnJvckNvZGVbXCJDb25uZWN0aW9uVGltZW91dFwiXSA9IFwiQ09OTkVDVElPTl9USU1FT1VUXCI7XG4gICAgRXJyb3JDb2RlW1wiRGlzY29ubmVjdFwiXSA9IFwiRElTQ09OTkVDVFwiO1xuICAgIEVycm9yQ29kZVtcIkludmFsaWRPcHRpb25cIl0gPSBcIklOVkFMSURfT1BUSU9OXCI7XG4gICAgRXJyb3JDb2RlW1wiSW52YWxpZFBheWxvYWRcIl0gPSBcIklOVkFMSURfUEFZTE9BRFwiO1xuICAgIEVycm9yQ29kZVtcIk1heFBheWxvYWRFeGNlZWRlZFwiXSA9IFwiTUFYX1BBWUxPQURfRVhDRUVERURcIjtcbiAgICBFcnJvckNvZGVbXCJOb1Jlc3BvbmRlcnNcIl0gPSBcIjUwM1wiO1xuICAgIEVycm9yQ29kZVtcIk5vdEZ1bmN0aW9uXCJdID0gXCJOT1RfRlVOQ1wiO1xuICAgIEVycm9yQ29kZVtcIlJlcXVlc3RFcnJvclwiXSA9IFwiUkVRVUVTVF9FUlJPUlwiO1xuICAgIEVycm9yQ29kZVtcIlNlcnZlck9wdGlvbk5vdEF2YWlsYWJsZVwiXSA9IFwiU0VSVkVSX09QVF9OQVwiO1xuICAgIEVycm9yQ29kZVtcIlN1YkNsb3NlZFwiXSA9IFwiU1VCX0NMT1NFRFwiO1xuICAgIEVycm9yQ29kZVtcIlN1YkRyYWluaW5nXCJdID0gXCJTVUJfRFJBSU5JTkdcIjtcbiAgICBFcnJvckNvZGVbXCJUaW1lb3V0XCJdID0gXCJUSU1FT1VUXCI7XG4gICAgRXJyb3JDb2RlW1wiVGxzXCJdID0gXCJUTFNcIjtcbiAgICBFcnJvckNvZGVbXCJVbmtub3duXCJdID0gXCJVTktOT1dOX0VSUk9SXCI7XG4gICAgRXJyb3JDb2RlW1wiV3NzUmVxdWlyZWRcIl0gPSBcIldTU19SRVFVSVJFRFwiO1xuICAgIEVycm9yQ29kZVtcIkpldFN0cmVhbUludmFsaWRBY2tcIl0gPSBcIkpFU1RSRUFNX0lOVkFMSURfQUNLXCI7XG4gICAgRXJyb3JDb2RlW1wiSmV0U3RyZWFtNDA0Tm9NZXNzYWdlc1wiXSA9IFwiNDA0XCI7XG4gICAgRXJyb3JDb2RlW1wiSmV0U3RyZWFtNDA4UmVxdWVzdFRpbWVvdXRcIl0gPSBcIjQwOFwiO1xuICAgIEVycm9yQ29kZVtcIkpldFN0cmVhbTQwOU1heEFja1BlbmRpbmdFeGNlZWRlZFwiXSA9IFwiNDA5XCI7XG4gICAgRXJyb3JDb2RlW1wiSmV0U3RyZWFtNDA5XCJdID0gXCI0MDlcIjtcbiAgICBFcnJvckNvZGVbXCJKZXRTdHJlYW1Ob3RFbmFibGVkXCJdID0gXCI1MDNcIjtcbiAgICBFcnJvckNvZGVbXCJKZXRTdHJlYW1JZGxlSGVhcnRCZWF0XCJdID0gXCJJRExFX0hFQVJUQkVBVFwiO1xuICAgIEVycm9yQ29kZVtcIkF1dGhvcml6YXRpb25WaW9sYXRpb25cIl0gPSBcIkFVVEhPUklaQVRJT05fVklPTEFUSU9OXCI7XG4gICAgRXJyb3JDb2RlW1wiQXV0aGVudGljYXRpb25FeHBpcmVkXCJdID0gXCJBVVRIRU5USUNBVElPTl9FWFBJUkVEXCI7XG4gICAgRXJyb3JDb2RlW1wiUHJvdG9jb2xFcnJvclwiXSA9IFwiTkFUU19QUk9UT0NPTF9FUlJcIjtcbiAgICBFcnJvckNvZGVbXCJQZXJtaXNzaW9uc1Zpb2xhdGlvblwiXSA9IFwiUEVSTUlTU0lPTlNfVklPTEFUSU9OXCI7XG4gICAgRXJyb3JDb2RlW1wiQXV0aGVudGljYXRpb25UaW1lb3V0XCJdID0gXCJBVVRIRU5USUNBVElPTl9USU1FT1VUXCI7XG4gICAgRXJyb3JDb2RlW1wiQWNjb3VudEV4cGlyZWRcIl0gPSBcIkFDQ09VTlRfRVhQSVJFRFwiO1xufSkoRXJyb3JDb2RlIHx8IChFcnJvckNvZGUgPSB7fSkpO1xuZnVuY3Rpb24gaXNOYXRzRXJyb3IoZXJyKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlcnIuY29kZSA9PT0gXCJzdHJpbmdcIjtcbn1cbmNsYXNzIE1lc3NhZ2VzIHtcbiAgICBtZXNzYWdlcztcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLm1lc3NhZ2VzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzLnNldChFcnJvckNvZGUuSW52YWxpZFBheWxvYWQsIFwiSW52YWxpZCBwYXlsb2FkIHR5cGUgLSBwYXlsb2FkcyBjYW4gYmUgJ2JpbmFyeScsICdzdHJpbmcnLCBvciAnanNvbidcIik7XG4gICAgICAgIHRoaXMubWVzc2FnZXMuc2V0KEVycm9yQ29kZS5CYWRKc29uLCBcIkJhZCBKU09OXCIpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzLnNldChFcnJvckNvZGUuV3NzUmVxdWlyZWQsIFwiVExTIGlzIHJlcXVpcmVkLCB0aGVyZWZvcmUgYSBzZWN1cmUgd2Vic29ja2V0IGNvbm5lY3Rpb24gaXMgYWxzbyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgc3RhdGljIGdldE1lc3NhZ2Uocykge1xuICAgICAgICByZXR1cm4gbWVzc2FnZXMuZ2V0TWVzc2FnZShzKTtcbiAgICB9XG4gICAgZ2V0TWVzc2FnZShzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzLmdldChzKSB8fCBzO1xuICAgIH1cbn1cbmNvbnN0IG1lc3NhZ2VzID0gbmV3IE1lc3NhZ2VzKCk7XG5jbGFzcyBOYXRzRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgbmFtZTtcbiAgICBtZXNzYWdlO1xuICAgIGNvZGU7XG4gICAgcGVybWlzc2lvbkNvbnRleHQ7XG4gICAgY2hhaW5lZEVycm9yO1xuICAgIGFwaV9lcnJvcjtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjb2RlLCBjaGFpbmVkRXJyb3Ipe1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJOYXRzRXJyb3JcIjtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5jaGFpbmVkRXJyb3IgPSBjaGFpbmVkRXJyb3I7XG4gICAgfVxuICAgIHN0YXRpYyBlcnJvckZvckNvZGUoY29kZSwgY2hhaW5lZEVycm9yKSB7XG4gICAgICAgIGNvbnN0IG0gPSBNZXNzYWdlcy5nZXRNZXNzYWdlKGNvZGUpO1xuICAgICAgICByZXR1cm4gbmV3IE5hdHNFcnJvcihtLCBjb2RlLCBjaGFpbmVkRXJyb3IpO1xuICAgIH1cbiAgICBpc0F1dGhFcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZSA9PT0gRXJyb3JDb2RlLkF1dGhlbnRpY2F0aW9uRXhwaXJlZCB8fCB0aGlzLmNvZGUgPT09IEVycm9yQ29kZS5BdXRob3JpemF0aW9uVmlvbGF0aW9uIHx8IHRoaXMuY29kZSA9PT0gRXJyb3JDb2RlLkFjY291bnRFeHBpcmVkO1xuICAgIH1cbiAgICBpc0F1dGhUaW1lb3V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2RlID09PSBFcnJvckNvZGUuQXV0aGVudGljYXRpb25UaW1lb3V0O1xuICAgIH1cbiAgICBpc1Blcm1pc3Npb25FcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZSA9PT0gRXJyb3JDb2RlLlBlcm1pc3Npb25zVmlvbGF0aW9uO1xuICAgIH1cbiAgICBpc1Byb3RvY29sRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGUgPT09IEVycm9yQ29kZS5Qcm90b2NvbEVycm9yO1xuICAgIH1cbiAgICBpc0pldFN0cmVhbUVycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcGlfZXJyb3IgIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAganNFcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpX2Vycm9yID8gdGhpcy5hcGlfZXJyb3IgOiBudWxsO1xuICAgIH1cbn1cbnZhciBNYXRjaDtcbihmdW5jdGlvbihNYXRjaCkge1xuICAgIE1hdGNoW01hdGNoW1wiRXhhY3RcIl0gPSAwXSA9IFwiRXhhY3RcIjtcbiAgICBNYXRjaFtNYXRjaFtcIkNhbm9uaWNhbE1JTUVcIl0gPSAxXSA9IFwiQ2Fub25pY2FsTUlNRVwiO1xuICAgIE1hdGNoW01hdGNoW1wiSWdub3JlQ2FzZVwiXSA9IDJdID0gXCJJZ25vcmVDYXNlXCI7XG59KShNYXRjaCB8fCAoTWF0Y2ggPSB7fSkpO1xudmFyIFJlcXVlc3RTdHJhdGVneTtcbihmdW5jdGlvbihSZXF1ZXN0U3RyYXRlZ3kpIHtcbiAgICBSZXF1ZXN0U3RyYXRlZ3lbXCJUaW1lclwiXSA9IFwidGltZXJcIjtcbiAgICBSZXF1ZXN0U3RyYXRlZ3lbXCJDb3VudFwiXSA9IFwiY291bnRcIjtcbiAgICBSZXF1ZXN0U3RyYXRlZ3lbXCJKaXR0ZXJUaW1lclwiXSA9IFwiaml0dGVyVGltZXJcIjtcbiAgICBSZXF1ZXN0U3RyYXRlZ3lbXCJTZW50aW5lbE1zZ1wiXSA9IFwic2VudGluZWxNc2dcIjtcbn0pKFJlcXVlc3RTdHJhdGVneSB8fCAoUmVxdWVzdFN0cmF0ZWd5ID0ge30pKTtcbmZ1bmN0aW9uIHN5bmNJdGVyYXRvcihzcmMpIHtcbiAgICBjb25zdCBpdGVyID0gc3JjW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFzeW5jIG5leHQgKCkge1xuICAgICAgICAgICAgY29uc3QgbSA9IGF3YWl0IGl0ZXIubmV4dCgpO1xuICAgICAgICAgICAgaWYgKG0uZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG0udmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbnZhciBTZXJ2aWNlUmVzcG9uc2VUeXBlO1xuKGZ1bmN0aW9uKFNlcnZpY2VSZXNwb25zZVR5cGUpIHtcbiAgICBTZXJ2aWNlUmVzcG9uc2VUeXBlW1wiU1RBVFNcIl0gPSBcImlvLm5hdHMubWljcm8udjEuc3RhdHNfcmVzcG9uc2VcIjtcbiAgICBTZXJ2aWNlUmVzcG9uc2VUeXBlW1wiSU5GT1wiXSA9IFwiaW8ubmF0cy5taWNyby52MS5pbmZvX3Jlc3BvbnNlXCI7XG4gICAgU2VydmljZVJlc3BvbnNlVHlwZVtcIlBJTkdcIl0gPSBcImlvLm5hdHMubWljcm8udjEucGluZ19yZXNwb25zZVwiO1xufSkoU2VydmljZVJlc3BvbnNlVHlwZSB8fCAoU2VydmljZVJlc3BvbnNlVHlwZSA9IHt9KSk7XG5jb25zdCBTZXJ2aWNlRXJyb3JIZWFkZXIgPSBcIk5hdHMtU2VydmljZS1FcnJvclwiO1xuY29uc3QgU2VydmljZUVycm9yQ29kZUhlYWRlciA9IFwiTmF0cy1TZXJ2aWNlLUVycm9yLUNvZGVcIjtcbmNsYXNzIFNlcnZpY2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb2RlO1xuICAgIGNvbnN0cnVjdG9yKGNvZGUsIG1lc3NhZ2Upe1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG4gICAgc3RhdGljIGlzU2VydmljZUVycm9yKG1zZykge1xuICAgICAgICByZXR1cm4gU2VydmljZUVycm9yLnRvU2VydmljZUVycm9yKG1zZykgIT09IG51bGw7XG4gICAgfVxuICAgIHN0YXRpYyB0b1NlcnZpY2VFcnJvcihtc2cpIHtcbiAgICAgICAgY29uc3Qgc2NvZGUgPSBtc2c/LmhlYWRlcnM/LmdldChTZXJ2aWNlRXJyb3JDb2RlSGVhZGVyKSB8fCBcIlwiO1xuICAgICAgICBpZiAoc2NvZGUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBwYXJzZUludChzY29kZSkgfHwgNDAwO1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBtc2c/LmhlYWRlcnM/LmdldChTZXJ2aWNlRXJyb3JIZWFkZXIpIHx8IFwiXCI7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNlcnZpY2VFcnJvcihjb2RlLCBkZXNjcmlwdGlvbi5sZW5ndGggPyBkZXNjcmlwdGlvbiA6IHNjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVJbmJveChwcmVmaXggPSBcIlwiKSB7XG4gICAgcHJlZml4ID0gcHJlZml4IHx8IFwiX0lOQk9YXCI7XG4gICAgaWYgKHR5cGVvZiBwcmVmaXggIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJlZml4IG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgfVxuICAgIHByZWZpeC5zcGxpdChcIi5cIikuZm9yRWFjaCgodik9PntcbiAgICAgICAgaWYgKHYgPT09IFwiKlwiIHx8IHYgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGluYm94IHByZWZpeGVzIGNhbm5vdCBoYXZlIHdpbGRjYXJkcyAnJHtwcmVmaXh9J2ApO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGAke3ByZWZpeH0uJHtudWlkLm5leHQoKX1gO1xufVxuY29uc3QgREVGQVVMVF9IT1NUID0gXCIxMjcuMC4wLjFcIjtcbnZhciBTZXJ2aWNlVmVyYjtcbihmdW5jdGlvbihTZXJ2aWNlVmVyYikge1xuICAgIFNlcnZpY2VWZXJiW1wiUElOR1wiXSA9IFwiUElOR1wiO1xuICAgIFNlcnZpY2VWZXJiW1wiU1RBVFNcIl0gPSBcIlNUQVRTXCI7XG4gICAgU2VydmljZVZlcmJbXCJJTkZPXCJdID0gXCJJTkZPXCI7XG59KShTZXJ2aWNlVmVyYiB8fCAoU2VydmljZVZlcmIgPSB7fSkpO1xuZnVuY3Rpb24gZXh0ZW5kKGEsIC4uLmIpIHtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGNvbnN0IG8gPSBiW2ldO1xuICAgICAgICBPYmplY3Qua2V5cyhvKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgIGFba10gPSBvW2tdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG59XG5mdW5jdGlvbiByZW5kZXIoZnJhbWUpIHtcbiAgICBjb25zdCBjciA9IFwi4pCNXCI7XG4gICAgY29uc3QgbGYgPSBcIuKQilwiO1xuICAgIHJldHVybiBURC5kZWNvZGUoZnJhbWUpLnJlcGxhY2UoL1xcbi9nLCBsZikucmVwbGFjZSgvXFxyL2csIGNyKTtcbn1cbmZ1bmN0aW9uIHRpbWVvdXQobXMsIGFzeW5jVHJhY2VzID0gdHJ1ZSkge1xuICAgIGNvbnN0IGVyciA9IGFzeW5jVHJhY2VzID8gTmF0c0Vycm9yLmVycm9yRm9yQ29kZShFcnJvckNvZGUuVGltZW91dCkgOiBudWxsO1xuICAgIGxldCBtZXRob2RzO1xuICAgIGxldCB0aW1lcjtcbiAgICBjb25zdCBwID0gbmV3IFByb21pc2UoKF9yZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIGNvbnN0IGNhbmNlbCA9ICgpPT57XG4gICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBtZXRob2RzID0ge1xuICAgICAgICAgICAgY2FuY2VsXG4gICAgICAgIH07XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgaWYgKGVyciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlamVjdChOYXRzRXJyb3IuZXJyb3JGb3JDb2RlKEVycm9yQ29kZS5UaW1lb3V0KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBtcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocCwgbWV0aG9kcyk7XG59XG5mdW5jdGlvbiBkZWxheShtcyA9IDApIHtcbiAgICBsZXQgbWV0aG9kcztcbiAgICBjb25zdCBwID0gbmV3IFByb21pc2UoKHJlc29sdmUpPT57XG4gICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9LCBtcyk7XG4gICAgICAgIGNvbnN0IGNhbmNlbCA9ICgpPT57XG4gICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBtZXRob2RzID0ge1xuICAgICAgICAgICAgY2FuY2VsXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocCwgbWV0aG9kcyk7XG59XG5mdW5jdGlvbiBkZWFkbGluZShwLCBtaWxsaXMgPSAxMDAwKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBkZWFkbGluZSBleGNlZWRlZGApO1xuICAgIGNvbnN0IGQgPSBkZWZlcnJlZCgpO1xuICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKT0+ZC5yZWplY3QoZXJyKSwgbWlsbGlzKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgcCxcbiAgICAgICAgZFxuICAgIF0pLmZpbmFsbHkoKCk9PmNsZWFyVGltZW91dCh0aW1lcikpO1xufVxuZnVuY3Rpb24gZGVmZXJyZWQoKSB7XG4gICAgbGV0IG1ldGhvZHMgPSB7fTtcbiAgICBjb25zdCBwID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgbWV0aG9kcyA9IHtcbiAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICByZWplY3RcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihwLCBtZXRob2RzKTtcbn1cbmZ1bmN0aW9uIHNodWZmbGUoYSkge1xuICAgIGZvcihsZXQgaSA9IGEubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSl7XG4gICAgICAgIGNvbnN0IGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaSArIDEpKTtcbiAgICAgICAgW2FbaV0sIGFbal1dID0gW1xuICAgICAgICAgICAgYVtqXSxcbiAgICAgICAgICAgIGFbaV1cbiAgICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG59XG5jbGFzcyBQZXJmIHtcbiAgICB0aW1lcnM7XG4gICAgbWVhc3VyZXM7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy50aW1lcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubWVhc3VyZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIG1hcmsoa2V5KSB7XG4gICAgICAgIHRoaXMudGltZXJzLnNldChrZXksIHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICB9XG4gICAgbWVhc3VyZShrZXksIHN0YXJ0S2V5LCBlbmRLZXkpIHtcbiAgICAgICAgY29uc3QgcyA9IHRoaXMudGltZXJzLmdldChzdGFydEtleSk7XG4gICAgICAgIGlmIChzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtzdGFydEtleX0gaXMgbm90IGRlZmluZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlID0gdGhpcy50aW1lcnMuZ2V0KGVuZEtleSk7XG4gICAgICAgIGlmIChlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtlbmRLZXl9IGlzIG5vdCBkZWZpbmVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZWFzdXJlcy5zZXQoa2V5LCBlIC0gcyk7XG4gICAgfVxuICAgIGdldEVudHJpZXMoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgICAgICB0aGlzLm1lYXN1cmVzLmZvckVhY2goKHYsIGspPT57XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogayxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogdlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGppdHRlcihuKSB7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmZsb29yKG4gLyAyICsgTWF0aC5yYW5kb20oKSAqIG4pO1xufVxuZnVuY3Rpb24gYmFja29mZihwb2xpY3kgPSBbXG4gICAgMCxcbiAgICAyNTAsXG4gICAgMjUwLFxuICAgIDUwMCxcbiAgICA1MDAsXG4gICAgMzAwMCxcbiAgICA1MDAwXG5dKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBvbGljeSkpIHtcbiAgICAgICAgcG9saWN5ID0gW1xuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDI1MCxcbiAgICAgICAgICAgIDI1MCxcbiAgICAgICAgICAgIDUwMCxcbiAgICAgICAgICAgIDUwMCxcbiAgICAgICAgICAgIDMwMDAsXG4gICAgICAgICAgICA1MDAwXG4gICAgICAgIF07XG4gICAgfVxuICAgIGNvbnN0IG1heCA9IHBvbGljeS5sZW5ndGggLSAxO1xuICAgIHJldHVybiB7XG4gICAgICAgIGJhY2tvZmYgKGF0dGVtcHQpIHtcbiAgICAgICAgICAgIHJldHVybiBqaXR0ZXIoYXR0ZW1wdCA+IG1heCA/IHBvbGljeVttYXhdIDogcG9saWN5W2F0dGVtcHRdKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBuYW5vcyhtaWxsaXMpIHtcbiAgICByZXR1cm4gbWlsbGlzICogMTAwMDAwMDtcbn1cbmZ1bmN0aW9uIG1pbGxpcyhucykge1xuICAgIHJldHVybiBNYXRoLmZsb29yKG5zIC8gMTAwMDAwMCk7XG59XG5mdW5jdGlvbiBjYW5vbmljYWxNSU1FSGVhZGVyS2V5KGspIHtcbiAgICBjb25zdCBkYXNoID0gNDU7XG4gICAgY29uc3QgdG9Mb3dlciA9IDk3IC0gNjU7XG4gICAgbGV0IHVwcGVyID0gdHJ1ZTtcbiAgICBjb25zdCBidWYgPSBuZXcgQXJyYXkoay5sZW5ndGgpO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgbGV0IGMgPSBrLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjID09PSA1OCB8fCBjIDwgMzMgfHwgYyA+IDEyNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5hdHNFcnJvcihgJyR7a1tpXX0nIGlzIG5vdCBhIHZhbGlkIGNoYXJhY3RlciBmb3IgYSBoZWFkZXIga2V5YCwgRXJyb3JDb2RlLkJhZEhlYWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwcGVyICYmIDk3IDw9IGMgJiYgYyA8PSAxMjIpIHtcbiAgICAgICAgICAgIGMgLT0gdG9Mb3dlcjtcbiAgICAgICAgfSBlbHNlIGlmICghdXBwZXIgJiYgNjUgPD0gYyAmJiBjIDw9IDkwKSB7XG4gICAgICAgICAgICBjICs9IHRvTG93ZXI7XG4gICAgICAgIH1cbiAgICAgICAgYnVmW2ldID0gYztcbiAgICAgICAgdXBwZXIgPSBjID09IGRhc2g7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLmJ1Zik7XG59XG5mdW5jdGlvbiBoZWFkZXJzKGNvZGUgPSAwLCBkZXNjcmlwdGlvbiA9IFwiXCIpIHtcbiAgICBpZiAoY29kZSA9PT0gMCAmJiBkZXNjcmlwdGlvbiAhPT0gXCJcIiB8fCBjb2RlID4gMCAmJiBkZXNjcmlwdGlvbiA9PT0gXCJcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZXR0aW5nIHN0YXR1cyByZXF1aXJlcyBib3RoIGNvZGUgYW5kIGRlc2NyaXB0aW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE1zZ0hkcnNJbXBsKGNvZGUsIGRlc2NyaXB0aW9uKTtcbn1cbmNvbnN0IEhFQURFUiA9IFwiTkFUUy8xLjBcIjtcbmNsYXNzIE1zZ0hkcnNJbXBsIHtcbiAgICBfY29kZTtcbiAgICBoZWFkZXJzO1xuICAgIF9kZXNjcmlwdGlvbjtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlID0gMCwgZGVzY3JpcHRpb24gPSBcIlwiKXtcbiAgICAgICAgdGhpcy5fY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMuX2Rlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWRlcnMuZW50cmllcygpO1xuICAgIH1cbiAgICBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJzLnNpemU7XG4gICAgfVxuICAgIGVxdWFscyhtaCkge1xuICAgICAgICBpZiAobWggJiYgdGhpcy5oZWFkZXJzLnNpemUgPT09IG1oLmhlYWRlcnMuc2l6ZSAmJiB0aGlzLl9jb2RlID09PSBtaC5fY29kZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgdGhpcy5oZWFkZXJzKXtcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gbWgudmFsdWVzKGspO1xuICAgICAgICAgICAgICAgIGlmICh2Lmxlbmd0aCAhPT0gYS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB2diA9IFtcbiAgICAgICAgICAgICAgICAgICAgLi4udlxuICAgICAgICAgICAgICAgIF0uc29ydCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFhID0gW1xuICAgICAgICAgICAgICAgICAgICAuLi5hXG4gICAgICAgICAgICAgICAgXS5zb3J0KCk7XG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHZ2Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZ2W2ldICE9PSBhYVtpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzdGF0aWMgZGVjb2RlKGEpIHtcbiAgICAgICAgY29uc3QgbWggPSBuZXcgTXNnSGRyc0ltcGwoKTtcbiAgICAgICAgY29uc3QgcyA9IFRELmRlY29kZShhKTtcbiAgICAgICAgY29uc3QgbGluZXMgPSBzLnNwbGl0KFwiXFxyXFxuXCIpO1xuICAgICAgICBjb25zdCBoID0gbGluZXNbMF07XG4gICAgICAgIGlmIChoICE9PSBIRUFERVIpIHtcbiAgICAgICAgICAgIGxldCBzdHIgPSBoLnJlcGxhY2UoSEVBREVSLCBcIlwiKS50cmltKCk7XG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBtaC5fY29kZSA9IHBhcnNlSW50KHN0ciwgMTApO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihtaC5fY29kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWguX2NvZGUgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzY29kZSA9IG1oLl9jb2RlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2Uoc2NvZGUsIFwiXCIpO1xuICAgICAgICAgICAgICAgIG1oLl9kZXNjcmlwdGlvbiA9IHN0ci50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgICAgICBsaW5lcy5zbGljZSgxKS5tYXAoKHMpPT57XG4gICAgICAgICAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWR4ID0gcy5pbmRleE9mKFwiOlwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrID0gcy5zbGljZSgwLCBpZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHMuc2xpY2UoaWR4ICsgMSkudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWguYXBwZW5kKGssIHYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1oO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVycy5zaXplID09PSAwICYmIHRoaXMuX2NvZGUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzID0gSEVBREVSO1xuICAgICAgICBpZiAodGhpcy5fY29kZSA+IDAgJiYgdGhpcy5fZGVzY3JpcHRpb24gIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHMgKz0gYCAke3RoaXMuX2NvZGV9ICR7dGhpcy5fZGVzY3JpcHRpb259YDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiB0aGlzLmhlYWRlcnMpe1xuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHYubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgIHMgPSBgJHtzfVxcclxcbiR7a306ICR7dltpXX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtzfVxcclxcblxcclxcbmA7XG4gICAgfVxuICAgIGVuY29kZSgpIHtcbiAgICAgICAgcmV0dXJuIFRFLmVuY29kZSh0aGlzLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBzdGF0aWMgdmFsaWRIZWFkZXJWYWx1ZShrKSB7XG4gICAgICAgIGNvbnN0IGludiA9IC9bXFxyXFxuXS87XG4gICAgICAgIGlmIChpbnYudGVzdChrKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5hdHNFcnJvcihcImludmFsaWQgaGVhZGVyIHZhbHVlIC0gXFxcXHIgYW5kIFxcXFxuIGFyZSBub3QgYWxsb3dlZC5cIiwgRXJyb3JDb2RlLkJhZEhlYWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGsudHJpbSgpO1xuICAgIH1cbiAgICBrZXlzKCkge1xuICAgICAgICBjb25zdCBrZXlzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgc2sgb2YgdGhpcy5oZWFkZXJzLmtleXMoKSl7XG4gICAgICAgICAgICBrZXlzLnB1c2goc2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cbiAgICBmaW5kS2V5cyhrLCBtYXRjaCA9IE1hdGNoLkV4YWN0KSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSB0aGlzLmtleXMoKTtcbiAgICAgICAgc3dpdGNoKG1hdGNoKXtcbiAgICAgICAgICAgIGNhc2UgTWF0Y2guRXhhY3Q6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXMuZmlsdGVyKCh2KT0+e1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdiA9PT0gaztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgTWF0Y2guQ2Fub25pY2FsTUlNRTpcbiAgICAgICAgICAgICAgICBrID0gY2Fub25pY2FsTUlNRUhlYWRlcktleShrKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5maWx0ZXIoKHYpPT57XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2ID09PSBrO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxjaSA9IGsudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleXMuZmlsdGVyKCh2KT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxjaSA9PT0gdi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0KGssIG1hdGNoID0gTWF0Y2guRXhhY3QpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IHRoaXMuZmluZEtleXMoaywgbWF0Y2gpO1xuICAgICAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLmhlYWRlcnMuZ2V0KGtleXNbMF0pO1xuICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2KSA/IHZbMF0gOiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBsYXN0KGssIG1hdGNoID0gTWF0Y2guRXhhY3QpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IHRoaXMuZmluZEtleXMoaywgbWF0Y2gpO1xuICAgICAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLmhlYWRlcnMuZ2V0KGtleXNbMF0pO1xuICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2KSA/IHZbdi5sZW5ndGggLSAxXSA6IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGhhcyhrLCBtYXRjaCA9IE1hdGNoLkV4YWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRLZXlzKGssIG1hdGNoKS5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBzZXQoaywgdiwgbWF0Y2ggPSBNYXRjaC5FeGFjdCkge1xuICAgICAgICB0aGlzLmRlbGV0ZShrLCBtYXRjaCk7XG4gICAgICAgIHRoaXMuYXBwZW5kKGssIHYsIG1hdGNoKTtcbiAgICB9XG4gICAgYXBwZW5kKGssIHYsIG1hdGNoID0gTWF0Y2guRXhhY3QpIHtcbiAgICAgICAgY29uc3QgY2sgPSBjYW5vbmljYWxNSU1FSGVhZGVyS2V5KGspO1xuICAgICAgICBpZiAobWF0Y2ggPT09IE1hdGNoLkNhbm9uaWNhbE1JTUUpIHtcbiAgICAgICAgICAgIGsgPSBjaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlzID0gdGhpcy5maW5kS2V5cyhrLCBtYXRjaCk7XG4gICAgICAgIGsgPSBrZXlzLmxlbmd0aCA+IDAgPyBrZXlzWzBdIDogaztcbiAgICAgICAgY29uc3QgdmFsdWUgPSBNc2dIZHJzSW1wbC52YWxpZEhlYWRlclZhbHVlKHYpO1xuICAgICAgICBsZXQgYSA9IHRoaXMuaGVhZGVycy5nZXQoayk7XG4gICAgICAgIGlmICghYSkge1xuICAgICAgICAgICAgYSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzLnNldChrLCBhKTtcbiAgICAgICAgfVxuICAgICAgICBhLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICB2YWx1ZXMoaywgbWF0Y2ggPSBNYXRjaC5FeGFjdCkge1xuICAgICAgICBjb25zdCBidWYgPSBbXTtcbiAgICAgICAgY29uc3Qga2V5cyA9IHRoaXMuZmluZEtleXMoaywgbWF0Y2gpO1xuICAgICAgICBrZXlzLmZvckVhY2goKHYpPT57XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLmhlYWRlcnMuZ2V0KHYpO1xuICAgICAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgICAgICAgIGJ1Zi5wdXNoKC4uLnZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICBkZWxldGUoaywgbWF0Y2ggPSBNYXRjaC5FeGFjdCkge1xuICAgICAgICBjb25zdCBrZXlzID0gdGhpcy5maW5kS2V5cyhrLCBtYXRjaCk7XG4gICAgICAgIGtleXMuZm9yRWFjaCgodik9PntcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycy5kZWxldGUodik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgaGFzRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2RlID49IDMwMDtcbiAgICB9XG4gICAgZ2V0IHN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuX2NvZGV9ICR7dGhpcy5fZGVzY3JpcHRpb259YC50cmltKCk7XG4gICAgfVxuICAgIHRvUmVjb3JkKCkge1xuICAgICAgICBjb25zdCBkYXRhID0ge307XG4gICAgICAgIHRoaXMua2V5cygpLmZvckVhY2goKHYpPT57XG4gICAgICAgICAgICBkYXRhW3ZdID0gdGhpcy52YWx1ZXModik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgZ2V0IGNvZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2RlO1xuICAgIH1cbiAgICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZXNjcmlwdGlvbjtcbiAgICB9XG4gICAgc3RhdGljIGZyb21SZWNvcmQocikge1xuICAgICAgICBjb25zdCBoID0gbmV3IE1zZ0hkcnNJbXBsKCk7XG4gICAgICAgIGZvcihjb25zdCBrIGluIHIpe1xuICAgICAgICAgICAgaC5oZWFkZXJzLnNldChrLCByW2tdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaDtcbiAgICB9XG59XG5mdW5jdGlvbiBTdHJpbmdDb2RlYygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUgKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBURS5lbmNvZGUoZCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZSAoYSkge1xuICAgICAgICAgICAgcmV0dXJuIFRELmRlY29kZShhKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBKU09OQ29kZWMocmV2aXZlcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZSAoZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gVEUuZW5jb2RlKEpTT04uc3RyaW5naWZ5KGQpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRocm93IE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLkJhZEpzb24sIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZSAoYSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShURC5kZWNvZGUoYSksIHJldml2ZXIpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgTmF0c0Vycm9yLmVycm9yRm9yQ29kZShFcnJvckNvZGUuQmFkSnNvbiwgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBpc1JlcXVlc3RFcnJvcihtc2cpIHtcbiAgICBpZiAobXNnICYmIG1zZy5kYXRhLmxlbmd0aCA9PT0gMCAmJiBtc2cuaGVhZGVycz8uY29kZSA9PT0gNTAzKSB7XG4gICAgICAgIHJldHVybiBOYXRzRXJyb3IuZXJyb3JGb3JDb2RlKEVycm9yQ29kZS5Ob1Jlc3BvbmRlcnMpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmNsYXNzIE1zZ0ltcGwge1xuICAgIF9oZWFkZXJzO1xuICAgIF9tc2c7XG4gICAgX3JkYXRhO1xuICAgIF9yZXBseTtcbiAgICBfc3ViamVjdDtcbiAgICBwdWJsaXNoZXI7XG4gICAgc3RhdGljIGpjO1xuICAgIGNvbnN0cnVjdG9yKG1zZywgZGF0YSwgcHVibGlzaGVyKXtcbiAgICAgICAgdGhpcy5fbXNnID0gbXNnO1xuICAgICAgICB0aGlzLl9yZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMucHVibGlzaGVyID0gcHVibGlzaGVyO1xuICAgIH1cbiAgICBnZXQgc3ViamVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N1YmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdWJqZWN0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N1YmplY3QgPSBURC5kZWNvZGUodGhpcy5fbXNnLnN1YmplY3QpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc3ViamVjdDtcbiAgICB9XG4gICAgZ2V0IHJlcGx5KCkge1xuICAgICAgICBpZiAodGhpcy5fcmVwbHkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXBseTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXBseSA9IFRELmRlY29kZSh0aGlzLl9tc2cucmVwbHkpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVwbHk7XG4gICAgfVxuICAgIGdldCBzaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tc2cuc2lkO1xuICAgIH1cbiAgICBnZXQgaGVhZGVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuX21zZy5oZHIgPiAtMSAmJiAhdGhpcy5faGVhZGVycykge1xuICAgICAgICAgICAgY29uc3QgYnVmID0gdGhpcy5fcmRhdGEuc3ViYXJyYXkoMCwgdGhpcy5fbXNnLmhkcik7XG4gICAgICAgICAgICB0aGlzLl9oZWFkZXJzID0gTXNnSGRyc0ltcGwuZGVjb2RlKGJ1Zik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlcnM7XG4gICAgfVxuICAgIGdldCBkYXRhKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3JkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX21zZy5oZHIgPiAtMSA/IHRoaXMuX3JkYXRhLnN1YmFycmF5KHRoaXMuX21zZy5oZHIpIDogdGhpcy5fcmRhdGE7XG4gICAgfVxuICAgIHJlc3BvbmQoZGF0YSA9IEVtcHR5LCBvcHRzKSB7XG4gICAgICAgIGlmICh0aGlzLnJlcGx5KSB7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2hlci5wdWJsaXNoKHRoaXMucmVwbHksIGRhdGEsIG9wdHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzaXplKCkge1xuICAgICAgICBjb25zdCBzdWJqID0gdGhpcy5fbXNnLnN1YmplY3QubGVuZ3RoO1xuICAgICAgICBjb25zdCByZXBseSA9IHRoaXMuX21zZy5yZXBseT8ubGVuZ3RoIHx8IDA7XG4gICAgICAgIGNvbnN0IHBheWxvYWRBbmRIZWFkZXJzID0gdGhpcy5fbXNnLnNpemUgPT09IC0xID8gMCA6IHRoaXMuX21zZy5zaXplO1xuICAgICAgICByZXR1cm4gc3ViaiArIHJlcGx5ICsgcGF5bG9hZEFuZEhlYWRlcnM7XG4gICAgfVxuICAgIGpzb24ocmV2aXZlcikge1xuICAgICAgICByZXR1cm4gSlNPTkNvZGVjKHJldml2ZXIpLmRlY29kZSh0aGlzLmRhdGEpO1xuICAgIH1cbiAgICBzdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBURC5kZWNvZGUodGhpcy5kYXRhKTtcbiAgICB9XG4gICAgcmVxdWVzdEluZm8oKSB7XG4gICAgICAgIGNvbnN0IHYgPSB0aGlzLmhlYWRlcnM/LmdldChcIk5hdHMtUmVxdWVzdC1JbmZvXCIpO1xuICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodiwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICgoa2V5ID09PSBcInN0YXJ0XCIgfHwga2V5ID09PSBcInN0b3BcIikgJiYgdmFsdWUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUucGFyc2UodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVEdXJhYmxlTmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG1pblZhbGlkYXRpb24oXCJkdXJhYmxlXCIsIG5hbWUpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVTdHJlYW1OYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbWluVmFsaWRhdGlvbihcInN0cmVhbVwiLCBuYW1lKTtcbn1cbmZ1bmN0aW9uIG1pblZhbGlkYXRpb24oY29udGV4dCwgbmFtZSA9IFwiXCIpIHtcbiAgICBpZiAobmFtZSA9PT0gXCJcIikge1xuICAgICAgICB0aHJvdyBFcnJvcihgJHtjb250ZXh0fSBuYW1lIHJlcXVpcmVkYCk7XG4gICAgfVxuICAgIGNvbnN0IGJhZCA9IFtcbiAgICAgICAgXCIuXCIsXG4gICAgICAgIFwiKlwiLFxuICAgICAgICBcIj5cIixcbiAgICAgICAgXCIvXCIsXG4gICAgICAgIFwiXFxcXFwiLFxuICAgICAgICBcIiBcIixcbiAgICAgICAgXCJcXHRcIixcbiAgICAgICAgXCJcXG5cIixcbiAgICAgICAgXCJcXHJcIlxuICAgIF07XG4gICAgYmFkLmZvckVhY2goKHYpPT57XG4gICAgICAgIGlmIChuYW1lLmluZGV4T2YodikgIT09IC0xKSB7XG4gICAgICAgICAgICBzd2l0Y2godil7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICAgICAgICAgICAgICB2ID0gXCJcXFxcblwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFxyXCI6XG4gICAgICAgICAgICAgICAgICAgIHYgPSBcIlxcXFxyXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJcXHRcIjpcbiAgICAgICAgICAgICAgICAgICAgdiA9IFwiXFxcXHRcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IEVycm9yKGBpbnZhbGlkICR7Y29udGV4dH0gbmFtZSAtICR7Y29udGV4dH0gbmFtZSBjYW5ub3QgY29udGFpbiAnJHt2fSdgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBcIlwiO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVOYW1lKGNvbnRleHQsIG5hbWUgPSBcIlwiKSB7XG4gICAgaWYgKG5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYCR7Y29udGV4dH0gbmFtZSByZXF1aXJlZGApO1xuICAgIH1cbiAgICBjb25zdCBtID0gdmFsaWROYW1lKG5hbWUpO1xuICAgIGlmIChtLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgJHtjb250ZXh0fSBuYW1lIC0gJHtjb250ZXh0fSBuYW1lICR7bX1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZE5hbWUobmFtZSA9IFwiXCIpIHtcbiAgICBpZiAobmFtZSA9PT0gXCJcIikge1xuICAgICAgICB0aHJvdyBFcnJvcihgbmFtZSByZXF1aXJlZGApO1xuICAgIH1cbiAgICBjb25zdCBSRSA9IC9eWy1cXHddKyQvZztcbiAgICBjb25zdCBtID0gbmFtZS5tYXRjaChSRSk7XG4gICAgaWYgKG0gPT09IG51bGwpIHtcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIG5hbWUuc3BsaXQoXCJcIikpe1xuICAgICAgICAgICAgY29uc3QgbW0gPSBjLm1hdGNoKFJFKTtcbiAgICAgICAgICAgIGlmIChtbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgY2Fubm90IGNvbnRhaW4gJyR7Y30nYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbn1cbmZ1bmN0aW9uIGlzRmxvd0NvbnRyb2xNc2cobXNnKSB7XG4gICAgaWYgKG1zZy5kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBoID0gbXNnLmhlYWRlcnM7XG4gICAgaWYgKCFoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGguY29kZSA+PSAxMDAgJiYgaC5jb2RlIDwgMjAwO1xufVxuZnVuY3Rpb24gaXNIZWFydGJlYXRNc2cobXNnKSB7XG4gICAgcmV0dXJuIGlzRmxvd0NvbnRyb2xNc2cobXNnKSAmJiBtc2cuaGVhZGVycz8uZGVzY3JpcHRpb24gPT09IFwiSWRsZSBIZWFydGJlYXRcIjtcbn1cbmZ1bmN0aW9uIG5ld0pzRXJyb3JNc2coY29kZSwgZGVzY3JpcHRpb24sIHN1YmplY3QpIHtcbiAgICBjb25zdCBoID0gaGVhZGVycyhjb2RlLCBkZXNjcmlwdGlvbik7XG4gICAgY29uc3QgYXJnID0ge1xuICAgICAgICBoZHI6IDEsXG4gICAgICAgIHNpZDogMCxcbiAgICAgICAgc2l6ZTogMFxuICAgIH07XG4gICAgY29uc3QgbXNnID0gbmV3IE1zZ0ltcGwoYXJnLCBFbXB0eSwge30pO1xuICAgIG1zZy5faGVhZGVycyA9IGg7XG4gICAgbXNnLl9zdWJqZWN0ID0gc3ViamVjdDtcbiAgICByZXR1cm4gbXNnO1xufVxuZnVuY3Rpb24gY2hlY2tKc0Vycm9yKG1zZykge1xuICAgIGlmIChtc2cuZGF0YS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGggPSBtc2cuaGVhZGVycztcbiAgICBpZiAoIWgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjaGVja0pzRXJyb3JDb2RlKGguY29kZSwgaC5kZXNjcmlwdGlvbik7XG59XG52YXIgSnM0MDlFcnJvcnM7XG4oZnVuY3Rpb24oSnM0MDlFcnJvcnMpIHtcbiAgICBKczQwOUVycm9yc1tcIk1heEJhdGNoRXhjZWVkZWRcIl0gPSBcImV4Y2VlZGVkIG1heHJlcXVlc3RiYXRjaCBvZlwiO1xuICAgIEpzNDA5RXJyb3JzW1wiTWF4RXhwaXJlc0V4Y2VlZGVkXCJdID0gXCJleGNlZWRlZCBtYXhyZXF1ZXN0ZXhwaXJlcyBvZlwiO1xuICAgIEpzNDA5RXJyb3JzW1wiTWF4Qnl0ZXNFeGNlZWRlZFwiXSA9IFwiZXhjZWVkZWQgbWF4cmVxdWVzdG1heGJ5dGVzIG9mXCI7XG4gICAgSnM0MDlFcnJvcnNbXCJNYXhNZXNzYWdlU2l6ZUV4Y2VlZGVkXCJdID0gXCJtZXNzYWdlIHNpemUgZXhjZWVkcyBtYXhieXRlc1wiO1xuICAgIEpzNDA5RXJyb3JzW1wiUHVzaENvbnN1bWVyXCJdID0gXCJjb25zdW1lciBpcyBwdXNoIGJhc2VkXCI7XG4gICAgSnM0MDlFcnJvcnNbXCJNYXhXYWl0aW5nRXhjZWVkZWRcIl0gPSBcImV4Y2VlZGVkIG1heHdhaXRpbmdcIjtcbiAgICBKczQwOUVycm9yc1tcIklkbGVIZWFydGJlYXRNaXNzZWRcIl0gPSBcImlkbGUgaGVhcnRiZWF0cyBtaXNzZWRcIjtcbiAgICBKczQwOUVycm9yc1tcIkNvbnN1bWVyRGVsZXRlZFwiXSA9IFwiY29uc3VtZXIgZGVsZXRlZFwiO1xufSkoSnM0MDlFcnJvcnMgfHwgKEpzNDA5RXJyb3JzID0ge30pKTtcbmxldCBNQVhfV0FJVElOR19GQUlMID0gZmFsc2U7XG5mdW5jdGlvbiBpc1Rlcm1pbmFsNDA5KGVycikge1xuICAgIGlmIChlcnIuY29kZSAhPT0gRXJyb3JDb2RlLkpldFN0cmVhbTQwOSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGZhdGFsID0gW1xuICAgICAgICBKczQwOUVycm9ycy5NYXhCYXRjaEV4Y2VlZGVkLFxuICAgICAgICBKczQwOUVycm9ycy5NYXhFeHBpcmVzRXhjZWVkZWQsXG4gICAgICAgIEpzNDA5RXJyb3JzLk1heEJ5dGVzRXhjZWVkZWQsXG4gICAgICAgIEpzNDA5RXJyb3JzLk1heE1lc3NhZ2VTaXplRXhjZWVkZWQsXG4gICAgICAgIEpzNDA5RXJyb3JzLlB1c2hDb25zdW1lcixcbiAgICAgICAgSnM0MDlFcnJvcnMuSWRsZUhlYXJ0YmVhdE1pc3NlZCxcbiAgICAgICAgSnM0MDlFcnJvcnMuQ29uc3VtZXJEZWxldGVkXG4gICAgXTtcbiAgICBpZiAoTUFYX1dBSVRJTkdfRkFJTCkge1xuICAgICAgICBmYXRhbC5wdXNoKEpzNDA5RXJyb3JzLk1heFdhaXRpbmdFeGNlZWRlZCk7XG4gICAgfVxuICAgIHJldHVybiBmYXRhbC5maW5kKChzKT0+e1xuICAgICAgICByZXR1cm4gZXJyLm1lc3NhZ2UuaW5kZXhPZihzKSAhPT0gLTE7XG4gICAgfSkgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGNoZWNrSnNFcnJvckNvZGUoY29kZSwgZGVzY3JpcHRpb24gPSBcIlwiKSB7XG4gICAgaWYgKGNvZGUgPCAzMDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb24udG9Mb3dlckNhc2UoKTtcbiAgICBzd2l0Y2goY29kZSl7XG4gICAgICAgIGNhc2UgNDA0OlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOYXRzRXJyb3IoZGVzY3JpcHRpb24sIEVycm9yQ29kZS5KZXRTdHJlYW00MDROb01lc3NhZ2VzKTtcbiAgICAgICAgY2FzZSA0MDg6XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5hdHNFcnJvcihkZXNjcmlwdGlvbiwgRXJyb3JDb2RlLkpldFN0cmVhbTQwOFJlcXVlc3RUaW1lb3V0KTtcbiAgICAgICAgY2FzZSA0MDk6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWMgPSBkZXNjcmlwdGlvbi5zdGFydHNXaXRoKEpzNDA5RXJyb3JzLklkbGVIZWFydGJlYXRNaXNzZWQpID8gRXJyb3JDb2RlLkpldFN0cmVhbUlkbGVIZWFydEJlYXQgOiBFcnJvckNvZGUuSmV0U3RyZWFtNDA5O1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTmF0c0Vycm9yKGRlc2NyaXB0aW9uLCBlYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgNTAzOlxuICAgICAgICAgICAgcmV0dXJuIE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLkpldFN0cmVhbU5vdEVuYWJsZWQsIG5ldyBFcnJvcihkZXNjcmlwdGlvbikpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKGRlc2NyaXB0aW9uID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gPSBFcnJvckNvZGUuVW5rbm93bjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgTmF0c0Vycm9yKGRlc2NyaXB0aW9uLCBgJHtjb2RlfWApO1xuICAgIH1cbn1cbmNsYXNzIFF1ZXVlZEl0ZXJhdG9ySW1wbCB7XG4gICAgaW5mbGlnaHQ7XG4gICAgcHJvY2Vzc2VkO1xuICAgIHJlY2VpdmVkO1xuICAgIG5vSXRlcmF0b3I7XG4gICAgaXRlckNsb3NlZDtcbiAgICBkb25lO1xuICAgIHNpZ25hbDtcbiAgICB5aWVsZHM7XG4gICAgZmlsdGVyZWQ7XG4gICAgcGVuZGluZ0ZpbHRlcmVkO1xuICAgIGluZ2VzdGlvbkZpbHRlckZuO1xuICAgIHByb3RvY29sRmlsdGVyRm47XG4gICAgZGlzcGF0Y2hlZEZuO1xuICAgIGN0eDtcbiAgICBfZGF0YTtcbiAgICBlcnI7XG4gICAgdGltZTtcbiAgICB5aWVsZGluZztcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLmluZmxpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5maWx0ZXJlZCA9IDA7XG4gICAgICAgIHRoaXMucGVuZGluZ0ZpbHRlcmVkID0gMDtcbiAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSAwO1xuICAgICAgICB0aGlzLnJlY2VpdmVkID0gMDtcbiAgICAgICAgdGhpcy5ub0l0ZXJhdG9yID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNpZ25hbCA9IGRlZmVycmVkKCk7XG4gICAgICAgIHRoaXMueWllbGRzID0gW107XG4gICAgICAgIHRoaXMuaXRlckNsb3NlZCA9IGRlZmVycmVkKCk7XG4gICAgICAgIHRoaXMudGltZSA9IDA7XG4gICAgICAgIHRoaXMueWllbGRpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0ZSgpO1xuICAgIH1cbiAgICBwdXNoKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLnlpZWxkcy5wdXNoKHYpO1xuICAgICAgICAgICAgdGhpcy5zaWduYWwucmVzb2x2ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaW5nZXN0LCBwcm90b2NvbCB9ID0gdGhpcy5pbmdlc3Rpb25GaWx0ZXJGbiA/IHRoaXMuaW5nZXN0aW9uRmlsdGVyRm4odiwgdGhpcy5jdHggfHwgdGhpcykgOiB7XG4gICAgICAgICAgICBpbmdlc3Q6IHRydWUsXG4gICAgICAgICAgICBwcm90b2NvbDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGluZ2VzdCkge1xuICAgICAgICAgICAgaWYgKHByb3RvY29sKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJlZCsrO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0ZpbHRlcmVkKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnlpZWxkcy5wdXNoKHYpO1xuICAgICAgICAgICAgdGhpcy5zaWduYWwucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICppdGVyYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5ub0l0ZXJhdG9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTmF0c0Vycm9yKFwidW5zdXBwb3J0ZWQgaXRlcmF0b3JcIiwgRXJyb3JDb2RlLkFwaUVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy55aWVsZGluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5hdHNFcnJvcihcImFscmVhZHkgeWllbGRpbmdcIiwgRXJyb3JDb2RlLkFwaUVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnlpZWxkaW5nID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdoaWxlKHRydWUpe1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnlpZWxkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zaWduYWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVycikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeWllbGRzID0gdGhpcy55aWVsZHM7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmZsaWdodCA9IHlpZWxkcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy55aWVsZHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgeWllbGRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB5aWVsZHNbaV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm4gPSB5aWVsZHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5lcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9rID0gdGhpcy5wcm90b2NvbEZpbHRlckZuID8gdGhpcy5wcm90b2NvbEZpbHRlckZuKHlpZWxkc1tpXSkgOiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc2VkKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXNwYXRjaGVkRm4gJiYgeWllbGRzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGVkRm4oeWllbGRzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0ZpbHRlcmVkLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmZsaWdodC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy55aWVsZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnlpZWxkcyA9IHlpZWxkcztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaWduYWwgPSBkZWZlcnJlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RvcChlcnIpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXJyID0gZXJyO1xuICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLnNpZ25hbC5yZXNvbHZlKCk7XG4gICAgICAgIHRoaXMuaXRlckNsb3NlZC5yZXNvbHZlKGVycik7XG4gICAgfVxuICAgIGdldFByb2Nlc3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9JdGVyYXRvciA/IHRoaXMucmVjZWl2ZWQgOiB0aGlzLnByb2Nlc3NlZDtcbiAgICB9XG4gICAgZ2V0UGVuZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRzLmxlbmd0aCArIHRoaXMuaW5mbGlnaHQgLSB0aGlzLnBlbmRpbmdGaWx0ZXJlZDtcbiAgICB9XG4gICAgZ2V0UmVjZWl2ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY2VpdmVkIC0gdGhpcy5maWx0ZXJlZDtcbiAgICB9XG59XG5jbGFzcyBJZGxlSGVhcnRiZWF0TW9uaXRvciB7XG4gICAgaW50ZXJ2YWw7XG4gICAgbWF4T3V0O1xuICAgIGNhbmNlbEFmdGVyO1xuICAgIHRpbWVyO1xuICAgIGF1dG9DYW5jZWxUaW1lcjtcbiAgICBsYXN0O1xuICAgIG1pc3NlZDtcbiAgICBjb3VudDtcbiAgICBjYWxsYmFjaztcbiAgICBjb25zdHJ1Y3RvcihpbnRlcnZhbCwgY2IsIG9wdHMgPSB7XG4gICAgICAgIG1heE91dDogMlxuICAgIH0pe1xuICAgICAgICB0aGlzLmludGVydmFsID0gaW50ZXJ2YWw7XG4gICAgICAgIHRoaXMubWF4T3V0ID0gb3B0cz8ubWF4T3V0IHx8IDI7XG4gICAgICAgIHRoaXMuY2FuY2VsQWZ0ZXIgPSBvcHRzPy5jYW5jZWxBZnRlciB8fCAwO1xuICAgICAgICB0aGlzLmxhc3QgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLm1pc3NlZCA9IDA7XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlKCk7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0NhbmNlbFRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5hdXRvQ2FuY2VsVGltZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGltZXIgPSAwO1xuICAgICAgICB0aGlzLmF1dG9DYW5jZWxUaW1lciA9IDA7XG4gICAgICAgIHRoaXMubWlzc2VkID0gMDtcbiAgICB9XG4gICAgd29yaygpIHtcbiAgICAgICAgdGhpcy5sYXN0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5taXNzZWQgPSAwO1xuICAgIH1cbiAgICBfY2hhbmdlKGludGVydmFsLCBjYW5jZWxBZnRlciA9IDAsIG1heE91dCA9IDIpIHtcbiAgICAgICAgdGhpcy5pbnRlcnZhbCA9IGludGVydmFsO1xuICAgICAgICB0aGlzLm1heE91dCA9IG1heE91dDtcbiAgICAgICAgdGhpcy5jYW5jZWxBZnRlciA9IGNhbmNlbEFmdGVyO1xuICAgICAgICB0aGlzLnJlc3RhcnQoKTtcbiAgICB9XG4gICAgcmVzdGFydCgpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGUoKTtcbiAgICB9XG4gICAgX3NjaGVkdWxlKCkge1xuICAgICAgICBpZiAodGhpcy5jYW5jZWxBZnRlciA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b0NhbmNlbFRpbWVyID0gc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgICAgICB9LCB0aGlzLmNhbmNlbEFmdGVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwoKCk9PntcbiAgICAgICAgICAgIHRoaXMuY291bnQrKztcbiAgICAgICAgICAgIGlmIChEYXRlLm5vdygpIC0gdGhpcy5sYXN0ID4gdGhpcy5pbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWlzc2VkKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5taXNzZWQgPj0gdGhpcy5tYXhPdXQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jYWxsYmFjayh0aGlzLm1pc3NlZCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMuaW50ZXJ2YWwpO1xuICAgIH1cbn1cbnZhciBSZXRlbnRpb25Qb2xpY3k7XG4oZnVuY3Rpb24oUmV0ZW50aW9uUG9saWN5KSB7XG4gICAgUmV0ZW50aW9uUG9saWN5W1wiTGltaXRzXCJdID0gXCJsaW1pdHNcIjtcbiAgICBSZXRlbnRpb25Qb2xpY3lbXCJJbnRlcmVzdFwiXSA9IFwiaW50ZXJlc3RcIjtcbiAgICBSZXRlbnRpb25Qb2xpY3lbXCJXb3JrcXVldWVcIl0gPSBcIndvcmtxdWV1ZVwiO1xufSkoUmV0ZW50aW9uUG9saWN5IHx8IChSZXRlbnRpb25Qb2xpY3kgPSB7fSkpO1xudmFyIERpc2NhcmRQb2xpY3k7XG4oZnVuY3Rpb24oRGlzY2FyZFBvbGljeSkge1xuICAgIERpc2NhcmRQb2xpY3lbXCJPbGRcIl0gPSBcIm9sZFwiO1xuICAgIERpc2NhcmRQb2xpY3lbXCJOZXdcIl0gPSBcIm5ld1wiO1xufSkoRGlzY2FyZFBvbGljeSB8fCAoRGlzY2FyZFBvbGljeSA9IHt9KSk7XG52YXIgU3RvcmFnZVR5cGU7XG4oZnVuY3Rpb24oU3RvcmFnZVR5cGUpIHtcbiAgICBTdG9yYWdlVHlwZVtcIkZpbGVcIl0gPSBcImZpbGVcIjtcbiAgICBTdG9yYWdlVHlwZVtcIk1lbW9yeVwiXSA9IFwibWVtb3J5XCI7XG59KShTdG9yYWdlVHlwZSB8fCAoU3RvcmFnZVR5cGUgPSB7fSkpO1xudmFyIERlbGl2ZXJQb2xpY3k7XG4oZnVuY3Rpb24oRGVsaXZlclBvbGljeSkge1xuICAgIERlbGl2ZXJQb2xpY3lbXCJBbGxcIl0gPSBcImFsbFwiO1xuICAgIERlbGl2ZXJQb2xpY3lbXCJMYXN0XCJdID0gXCJsYXN0XCI7XG4gICAgRGVsaXZlclBvbGljeVtcIk5ld1wiXSA9IFwibmV3XCI7XG4gICAgRGVsaXZlclBvbGljeVtcIlN0YXJ0U2VxdWVuY2VcIl0gPSBcImJ5X3N0YXJ0X3NlcXVlbmNlXCI7XG4gICAgRGVsaXZlclBvbGljeVtcIlN0YXJ0VGltZVwiXSA9IFwiYnlfc3RhcnRfdGltZVwiO1xuICAgIERlbGl2ZXJQb2xpY3lbXCJMYXN0UGVyU3ViamVjdFwiXSA9IFwibGFzdF9wZXJfc3ViamVjdFwiO1xufSkoRGVsaXZlclBvbGljeSB8fCAoRGVsaXZlclBvbGljeSA9IHt9KSk7XG52YXIgQWNrUG9saWN5O1xuKGZ1bmN0aW9uKEFja1BvbGljeSkge1xuICAgIEFja1BvbGljeVtcIk5vbmVcIl0gPSBcIm5vbmVcIjtcbiAgICBBY2tQb2xpY3lbXCJBbGxcIl0gPSBcImFsbFwiO1xuICAgIEFja1BvbGljeVtcIkV4cGxpY2l0XCJdID0gXCJleHBsaWNpdFwiO1xuICAgIEFja1BvbGljeVtcIk5vdFNldFwiXSA9IFwiXCI7XG59KShBY2tQb2xpY3kgfHwgKEFja1BvbGljeSA9IHt9KSk7XG52YXIgUmVwbGF5UG9saWN5O1xuKGZ1bmN0aW9uKFJlcGxheVBvbGljeSkge1xuICAgIFJlcGxheVBvbGljeVtcIkluc3RhbnRcIl0gPSBcImluc3RhbnRcIjtcbiAgICBSZXBsYXlQb2xpY3lbXCJPcmlnaW5hbFwiXSA9IFwib3JpZ2luYWxcIjtcbn0pKFJlcGxheVBvbGljeSB8fCAoUmVwbGF5UG9saWN5ID0ge30pKTtcbnZhciBTdG9yZUNvbXByZXNzaW9uO1xuKGZ1bmN0aW9uKFN0b3JlQ29tcHJlc3Npb24pIHtcbiAgICBTdG9yZUNvbXByZXNzaW9uW1wiTm9uZVwiXSA9IFwibm9uZVwiO1xuICAgIFN0b3JlQ29tcHJlc3Npb25bXCJTMlwiXSA9IFwiczJcIjtcbn0pKFN0b3JlQ29tcHJlc3Npb24gfHwgKFN0b3JlQ29tcHJlc3Npb24gPSB7fSkpO1xudmFyIENvbnN1bWVyQXBpQWN0aW9uO1xuKGZ1bmN0aW9uKENvbnN1bWVyQXBpQWN0aW9uKSB7XG4gICAgQ29uc3VtZXJBcGlBY3Rpb25bXCJDcmVhdGVPclVwZGF0ZVwiXSA9IFwiXCI7XG4gICAgQ29uc3VtZXJBcGlBY3Rpb25bXCJVcGRhdGVcIl0gPSBcInVwZGF0ZVwiO1xuICAgIENvbnN1bWVyQXBpQWN0aW9uW1wiQ3JlYXRlXCJdID0gXCJjcmVhdGVcIjtcbn0pKENvbnN1bWVyQXBpQWN0aW9uIHx8IChDb25zdW1lckFwaUFjdGlvbiA9IHt9KSk7XG5mdW5jdGlvbiBkZWZhdWx0Q29uc3VtZXIobmFtZSwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBkZWxpdmVyX3BvbGljeTogRGVsaXZlclBvbGljeS5BbGwsXG4gICAgICAgIGFja19wb2xpY3k6IEFja1BvbGljeS5FeHBsaWNpdCxcbiAgICAgICAgYWNrX3dhaXQ6IG5hbm9zKDMwICogMTAwMCksXG4gICAgICAgIHJlcGxheV9wb2xpY3k6IFJlcGxheVBvbGljeS5JbnN0YW50XG4gICAgfSwgb3B0cyk7XG59XG52YXIgQWR2aXNvcnlLaW5kO1xuKGZ1bmN0aW9uKEFkdmlzb3J5S2luZCkge1xuICAgIEFkdmlzb3J5S2luZFtcIkFQSVwiXSA9IFwiYXBpX2F1ZGl0XCI7XG4gICAgQWR2aXNvcnlLaW5kW1wiU3RyZWFtQWN0aW9uXCJdID0gXCJzdHJlYW1fYWN0aW9uXCI7XG4gICAgQWR2aXNvcnlLaW5kW1wiQ29uc3VtZXJBY3Rpb25cIl0gPSBcImNvbnN1bWVyX2FjdGlvblwiO1xuICAgIEFkdmlzb3J5S2luZFtcIlNuYXBzaG90Q3JlYXRlXCJdID0gXCJzbmFwc2hvdF9jcmVhdGVcIjtcbiAgICBBZHZpc29yeUtpbmRbXCJTbmFwc2hvdENvbXBsZXRlXCJdID0gXCJzbmFwc2hvdF9jb21wbGV0ZVwiO1xuICAgIEFkdmlzb3J5S2luZFtcIlJlc3RvcmVDcmVhdGVcIl0gPSBcInJlc3RvcmVfY3JlYXRlXCI7XG4gICAgQWR2aXNvcnlLaW5kW1wiUmVzdG9yZUNvbXBsZXRlXCJdID0gXCJyZXN0b3JlX2NvbXBsZXRlXCI7XG4gICAgQWR2aXNvcnlLaW5kW1wiTWF4RGVsaXZlclwiXSA9IFwibWF4X2RlbGl2ZXJcIjtcbiAgICBBZHZpc29yeUtpbmRbXCJUZXJtaW5hdGVkXCJdID0gXCJ0ZXJtaW5hdGVkXCI7XG4gICAgQWR2aXNvcnlLaW5kW1wiQWNrXCJdID0gXCJjb25zdW1lcl9hY2tcIjtcbiAgICBBZHZpc29yeUtpbmRbXCJTdHJlYW1MZWFkZXJFbGVjdGVkXCJdID0gXCJzdHJlYW1fbGVhZGVyX2VsZWN0ZWRcIjtcbiAgICBBZHZpc29yeUtpbmRbXCJTdHJlYW1RdW9ydW1Mb3N0XCJdID0gXCJzdHJlYW1fcXVvcnVtX2xvc3RcIjtcbiAgICBBZHZpc29yeUtpbmRbXCJDb25zdW1lckxlYWRlckVsZWN0ZWRcIl0gPSBcImNvbnN1bWVyX2xlYWRlcl9lbGVjdGVkXCI7XG4gICAgQWR2aXNvcnlLaW5kW1wiQ29uc3VtZXJRdW9ydW1Mb3N0XCJdID0gXCJjb25zdW1lcl9xdW9ydW1fbG9zdFwiO1xufSkoQWR2aXNvcnlLaW5kIHx8IChBZHZpc29yeUtpbmQgPSB7fSkpO1xudmFyIEpzSGVhZGVycztcbihmdW5jdGlvbihKc0hlYWRlcnMpIHtcbiAgICBKc0hlYWRlcnNbXCJTdHJlYW1Tb3VyY2VIZHJcIl0gPSBcIk5hdHMtU3RyZWFtLVNvdXJjZVwiO1xuICAgIEpzSGVhZGVyc1tcIkxhc3RDb25zdW1lclNlcUhkclwiXSA9IFwiTmF0cy1MYXN0LUNvbnN1bWVyXCI7XG4gICAgSnNIZWFkZXJzW1wiTGFzdFN0cmVhbVNlcUhkclwiXSA9IFwiTmF0cy1MYXN0LVN0cmVhbVwiO1xuICAgIEpzSGVhZGVyc1tcIkNvbnN1bWVyU3RhbGxlZEhkclwiXSA9IFwiTmF0cy1Db25zdW1lci1TdGFsbGVkXCI7XG4gICAgSnNIZWFkZXJzW1wiTWVzc2FnZVNpemVIZHJcIl0gPSBcIk5hdHMtTXNnLVNpemVcIjtcbiAgICBKc0hlYWRlcnNbXCJSb2xsdXBIZHJcIl0gPSBcIk5hdHMtUm9sbHVwXCI7XG4gICAgSnNIZWFkZXJzW1wiUm9sbHVwVmFsdWVTdWJqZWN0XCJdID0gXCJzdWJcIjtcbiAgICBKc0hlYWRlcnNbXCJSb2xsdXBWYWx1ZUFsbFwiXSA9IFwiYWxsXCI7XG4gICAgSnNIZWFkZXJzW1wiUGVuZGluZ01lc3NhZ2VzSGRyXCJdID0gXCJOYXRzLVBlbmRpbmctTWVzc2FnZXNcIjtcbiAgICBKc0hlYWRlcnNbXCJQZW5kaW5nQnl0ZXNIZHJcIl0gPSBcIk5hdHMtUGVuZGluZy1CeXRlc1wiO1xufSkoSnNIZWFkZXJzIHx8IChKc0hlYWRlcnMgPSB7fSkpO1xudmFyIEt2V2F0Y2hJbmNsdWRlO1xuKGZ1bmN0aW9uKEt2V2F0Y2hJbmNsdWRlKSB7XG4gICAgS3ZXYXRjaEluY2x1ZGVbXCJMYXN0VmFsdWVcIl0gPSBcIlwiO1xuICAgIEt2V2F0Y2hJbmNsdWRlW1wiQWxsSGlzdG9yeVwiXSA9IFwiaGlzdG9yeVwiO1xuICAgIEt2V2F0Y2hJbmNsdWRlW1wiVXBkYXRlc09ubHlcIl0gPSBcInVwZGF0ZXNcIjtcbn0pKEt2V2F0Y2hJbmNsdWRlIHx8IChLdldhdGNoSW5jbHVkZSA9IHt9KSk7XG52YXIgRGlyZWN0TXNnSGVhZGVycztcbihmdW5jdGlvbihEaXJlY3RNc2dIZWFkZXJzKSB7XG4gICAgRGlyZWN0TXNnSGVhZGVyc1tcIlN0cmVhbVwiXSA9IFwiTmF0cy1TdHJlYW1cIjtcbiAgICBEaXJlY3RNc2dIZWFkZXJzW1wiU2VxdWVuY2VcIl0gPSBcIk5hdHMtU2VxdWVuY2VcIjtcbiAgICBEaXJlY3RNc2dIZWFkZXJzW1wiVGltZVN0YW1wXCJdID0gXCJOYXRzLVRpbWUtU3RhbXBcIjtcbiAgICBEaXJlY3RNc2dIZWFkZXJzW1wiU3ViamVjdFwiXSA9IFwiTmF0cy1TdWJqZWN0XCI7XG59KShEaXJlY3RNc2dIZWFkZXJzIHx8IChEaXJlY3RNc2dIZWFkZXJzID0ge30pKTtcbnZhciBSZXB1Ymxpc2hIZWFkZXJzO1xuKGZ1bmN0aW9uKFJlcHVibGlzaEhlYWRlcnMpIHtcbiAgICBSZXB1Ymxpc2hIZWFkZXJzW1wiU3RyZWFtXCJdID0gXCJOYXRzLVN0cmVhbVwiO1xuICAgIFJlcHVibGlzaEhlYWRlcnNbXCJTdWJqZWN0XCJdID0gXCJOYXRzLVN1YmplY3RcIjtcbiAgICBSZXB1Ymxpc2hIZWFkZXJzW1wiU2VxdWVuY2VcIl0gPSBcIk5hdHMtU2VxdWVuY2VcIjtcbiAgICBSZXB1Ymxpc2hIZWFkZXJzW1wiTGFzdFNlcXVlbmNlXCJdID0gXCJOYXRzLUxhc3QtU2VxdWVuY2VcIjtcbiAgICBSZXB1Ymxpc2hIZWFkZXJzW1wiU2l6ZVwiXSA9IFwiTmF0cy1Nc2ctU2l6ZVwiO1xufSkoUmVwdWJsaXNoSGVhZGVycyB8fCAoUmVwdWJsaXNoSGVhZGVycyA9IHt9KSk7XG5jb25zdCBrdlByZWZpeCA9IFwiS1ZfXCI7XG5jbGFzcyBDb25zdW1lck9wdHNCdWlsZGVySW1wbCB7XG4gICAgY29uZmlnO1xuICAgIG9yZGVyZWQ7XG4gICAgbWFjaztcbiAgICBzdHJlYW07XG4gICAgY2FsbGJhY2tGbjtcbiAgICBtYXg7XG4gICAgcW5hbWU7XG4gICAgaXNCaW5kO1xuICAgIGZpbHRlcnM7XG4gICAgY29uc3RydWN0b3Iob3B0cyl7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gXCJcIjtcbiAgICAgICAgdGhpcy5tYWNrID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3JkZXJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGRlZmF1bHRDb25zdW1lcihcIlwiLCBvcHRzIHx8IHt9KTtcbiAgICB9XG4gICAgZ2V0T3B0cygpIHtcbiAgICAgICAgY29uc3QgbyA9IHt9O1xuICAgICAgICBvLmNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY29uZmlnKTtcbiAgICAgICAgaWYgKG8uY29uZmlnLmZpbHRlcl9zdWJqZWN0KSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlclN1YmplY3Qoby5jb25maWcuZmlsdGVyX3N1YmplY3QpO1xuICAgICAgICAgICAgby5jb25maWcuZmlsdGVyX3N1YmplY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG8uY29uZmlnLmZpbHRlcl9zdWJqZWN0cykge1xuICAgICAgICAgICAgby5jb25maWcuZmlsdGVyX3N1YmplY3RzPy5mb3JFYWNoKCh2KT0+e1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyU3ViamVjdCh2KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgby5jb25maWcuZmlsdGVyX3N1YmplY3RzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIG8ubWFjayA9IHRoaXMubWFjaztcbiAgICAgICAgby5zdHJlYW0gPSB0aGlzLnN0cmVhbTtcbiAgICAgICAgby5jYWxsYmFja0ZuID0gdGhpcy5jYWxsYmFja0ZuO1xuICAgICAgICBvLm1heCA9IHRoaXMubWF4O1xuICAgICAgICBvLnF1ZXVlID0gdGhpcy5xbmFtZTtcbiAgICAgICAgby5vcmRlcmVkID0gdGhpcy5vcmRlcmVkO1xuICAgICAgICBvLmNvbmZpZy5hY2tfcG9saWN5ID0gby5vcmRlcmVkID8gQWNrUG9saWN5Lk5vbmUgOiBvLmNvbmZpZy5hY2tfcG9saWN5O1xuICAgICAgICBvLmlzQmluZCA9IG8uaXNCaW5kIHx8IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5maWx0ZXJzKSB7XG4gICAgICAgICAgICBzd2l0Y2godGhpcy5maWx0ZXJzLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG8uY29uZmlnLmZpbHRlcl9zdWJqZWN0ID0gdGhpcy5maWx0ZXJzWzBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBvLmNvbmZpZy5maWx0ZXJfc3ViamVjdHMgPSB0aGlzLmZpbHRlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG87XG4gICAgfVxuICAgIGRlc2NyaXB0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZWxpdmVyVG8oc3ViamVjdCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5kZWxpdmVyX3N1YmplY3QgPSBzdWJqZWN0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZHVyYWJsZShuYW1lKSB7XG4gICAgICAgIHZhbGlkYXRlRHVyYWJsZU5hbWUobmFtZSk7XG4gICAgICAgIHRoaXMuY29uZmlnLmR1cmFibGVfbmFtZSA9IG5hbWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdGFydFNlcXVlbmNlKHNlcSkge1xuICAgICAgICBpZiAoc2VxIDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNlcXVlbmNlIG11c3QgYmUgZ3JlYXRlciB0aGFuIDBcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25maWcuZGVsaXZlcl9wb2xpY3kgPSBEZWxpdmVyUG9saWN5LlN0YXJ0U2VxdWVuY2U7XG4gICAgICAgIHRoaXMuY29uZmlnLm9wdF9zdGFydF9zZXEgPSBzZXE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdGFydFRpbWUodGltZSkge1xuICAgICAgICB0aGlzLmNvbmZpZy5kZWxpdmVyX3BvbGljeSA9IERlbGl2ZXJQb2xpY3kuU3RhcnRUaW1lO1xuICAgICAgICB0aGlzLmNvbmZpZy5vcHRfc3RhcnRfdGltZSA9IHRpbWUudG9JU09TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlbGl2ZXJBbGwoKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmRlbGl2ZXJfcG9saWN5ID0gRGVsaXZlclBvbGljeS5BbGw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZWxpdmVyTGFzdFBlclN1YmplY3QoKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmRlbGl2ZXJfcG9saWN5ID0gRGVsaXZlclBvbGljeS5MYXN0UGVyU3ViamVjdDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlbGl2ZXJMYXN0KCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5kZWxpdmVyX3BvbGljeSA9IERlbGl2ZXJQb2xpY3kuTGFzdDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlbGl2ZXJOZXcoKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmRlbGl2ZXJfcG9saWN5ID0gRGVsaXZlclBvbGljeS5OZXc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdGFydEF0VGltZURlbHRhKG1pbGxpcykge1xuICAgICAgICB0aGlzLnN0YXJ0VGltZShuZXcgRGF0ZShEYXRlLm5vdygpIC0gbWlsbGlzKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBoZWFkZXJzT25seSgpIHtcbiAgICAgICAgdGhpcy5jb25maWcuaGVhZGVyc19vbmx5ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFja05vbmUoKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmFja19wb2xpY3kgPSBBY2tQb2xpY3kuTm9uZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFja0FsbCgpIHtcbiAgICAgICAgdGhpcy5jb25maWcuYWNrX3BvbGljeSA9IEFja1BvbGljeS5BbGw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhY2tFeHBsaWNpdCgpIHtcbiAgICAgICAgdGhpcy5jb25maWcuYWNrX3BvbGljeSA9IEFja1BvbGljeS5FeHBsaWNpdDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFja1dhaXQobWlsbGlzKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmFja193YWl0ID0gbmFub3MobWlsbGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG1heERlbGl2ZXIobWF4KSB7XG4gICAgICAgIHRoaXMuY29uZmlnLm1heF9kZWxpdmVyID0gbWF4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZmlsdGVyU3ViamVjdChzKSB7XG4gICAgICAgIHRoaXMuZmlsdGVycyA9IHRoaXMuZmlsdGVycyB8fCBbXTtcbiAgICAgICAgdGhpcy5maWx0ZXJzLnB1c2gocyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXBsYXlJbnN0YW50bHkoKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLnJlcGxheV9wb2xpY3kgPSBSZXBsYXlQb2xpY3kuSW5zdGFudDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlcGxheU9yaWdpbmFsKCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5yZXBsYXlfcG9saWN5ID0gUmVwbGF5UG9saWN5Lk9yaWdpbmFsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2FtcGxlKG4pIHtcbiAgICAgICAgbiA9IE1hdGgudHJ1bmMobik7XG4gICAgICAgIGlmIChuIDwgMCB8fCBuID4gMTAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZhbHVlIG11c3QgYmUgYmV0d2VlbiAwLTEwMGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29uZmlnLnNhbXBsZV9mcmVxID0gYCR7bn0lYDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGxpbWl0KG4pIHtcbiAgICAgICAgdGhpcy5jb25maWcucmF0ZV9saW1pdF9icHMgPSBuO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbWF4V2FpdGluZyhtYXgpIHtcbiAgICAgICAgdGhpcy5jb25maWcubWF4X3dhaXRpbmcgPSBtYXg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBtYXhBY2tQZW5kaW5nKG1heCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5tYXhfYWNrX3BlbmRpbmcgPSBtYXg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZGxlSGVhcnRiZWF0KG1pbGxpcykge1xuICAgICAgICB0aGlzLmNvbmZpZy5pZGxlX2hlYXJ0YmVhdCA9IG5hbm9zKG1pbGxpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmbG93Q29udHJvbCgpIHtcbiAgICAgICAgdGhpcy5jb25maWcuZmxvd19jb250cm9sID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlbGl2ZXJHcm91cChuYW1lKSB7XG4gICAgICAgIHRoaXMucXVldWUobmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBtYW51YWxBY2soKSB7XG4gICAgICAgIHRoaXMubWFjayA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBtYXhNZXNzYWdlcyhtYXgpIHtcbiAgICAgICAgdGhpcy5tYXggPSBtYXg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjYWxsYmFjayhmbikge1xuICAgICAgICB0aGlzLmNhbGxiYWNrRm4gPSBmbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHF1ZXVlKG4pIHtcbiAgICAgICAgdGhpcy5xbmFtZSA9IG47XG4gICAgICAgIHRoaXMuY29uZmlnLmRlbGl2ZXJfZ3JvdXAgPSBuO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb3JkZXJlZENvbnN1bWVyKCkge1xuICAgICAgICB0aGlzLm9yZGVyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYmluZChzdHJlYW0sIGR1cmFibGUpIHtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIHRoaXMuY29uZmlnLmR1cmFibGVfbmFtZSA9IGR1cmFibGU7XG4gICAgICAgIHRoaXMuaXNCaW5kID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGJpbmRTdHJlYW0oc3RyZWFtKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaW5hY3RpdmVFcGhlbWVyYWxUaHJlc2hvbGQobWlsbGlzKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmluYWN0aXZlX3RocmVzaG9sZCA9IG5hbm9zKG1pbGxpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBtYXhQdWxsQmF0Y2gobikge1xuICAgICAgICB0aGlzLmNvbmZpZy5tYXhfYmF0Y2ggPSBuO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbWF4UHVsbFJlcXVlc3RFeHBpcmVzKG1pbGxpcykge1xuICAgICAgICB0aGlzLmNvbmZpZy5tYXhfZXhwaXJlcyA9IG5hbm9zKG1pbGxpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBtZW1vcnkoKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLm1lbV9zdG9yYWdlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG51bVJlcGxpY2FzKG4pIHtcbiAgICAgICAgdGhpcy5jb25maWcubnVtX3JlcGxpY2FzID0gbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbnN1bWVyTmFtZShuKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLm5hbWUgPSBuO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5mdW5jdGlvbiBjb25zdW1lck9wdHMob3B0cykge1xuICAgIHJldHVybiBuZXcgQ29uc3VtZXJPcHRzQnVpbGRlckltcGwob3B0cyk7XG59XG5mdW5jdGlvbiBpc0NvbnN1bWVyT3B0c0J1aWxkZXIobykge1xuICAgIHJldHVybiB0eXBlb2Ygby5nZXRPcHRzID09PSBcImZ1bmN0aW9uXCI7XG59XG5jbGFzcyBCYXNlNjRDb2RlYyB7XG4gICAgc3RhdGljIGVuY29kZShieXRlcykge1xuICAgICAgICBpZiAodHlwZW9mIGJ5dGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gYnRvYShieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYSA9IEFycmF5LmZyb20oYnl0ZXMpO1xuICAgICAgICByZXR1cm4gYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLmEpKTtcbiAgICB9XG4gICAgc3RhdGljIGRlY29kZShzLCBiaW5hcnkgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBiaW4gPSBhdG9iKHMpO1xuICAgICAgICBpZiAoIWJpbmFyeSkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGJpbiwgKGMpPT5jLmNoYXJDb2RlQXQoMCkpO1xuICAgIH1cbn1cbmNsYXNzIEJhc2U2NFVybFBhZGRlZENvZGVjIHtcbiAgICBzdGF0aWMgZW5jb2RlKGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBCYXNlNjRVcmxQYWRkZWRDb2RlYy50b0I2NFVSTEVuY29kaW5nKEJhc2U2NENvZGVjLmVuY29kZShieXRlcykpO1xuICAgIH1cbiAgICBzdGF0aWMgZGVjb2RlKHMsIGJpbmFyeSA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBCYXNlNjRVcmxQYWRkZWRDb2RlYy5kZWNvZGUoQmFzZTY0VXJsUGFkZGVkQ29kZWMuZnJvbUI2NFVSTEVuY29kaW5nKHMpLCBiaW5hcnkpO1xuICAgIH1cbiAgICBzdGF0aWMgdG9CNjRVUkxFbmNvZGluZyhiNjRzdHIpIHtcbiAgICAgICAgcmV0dXJuIGI2NHN0ci5yZXBsYWNlKC9cXCsvZywgXCItXCIpLnJlcGxhY2UoL1xcLy9nLCBcIl9cIik7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQjY0VVJMRW5jb2RpbmcoYjY0c3RyKSB7XG4gICAgICAgIHJldHVybiBiNjRzdHIucmVwbGFjZSgvXy9nLCBcIi9cIikucmVwbGFjZSgvLS9nLCBcIitcIik7XG4gICAgfVxufVxuY2xhc3MgRGF0YUJ1ZmZlciB7XG4gICAgYnVmZmVycztcbiAgICBieXRlTGVuZ3RoO1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IFtdO1xuICAgICAgICB0aGlzLmJ5dGVMZW5ndGggPSAwO1xuICAgIH1cbiAgICBzdGF0aWMgY29uY2F0KC4uLmJ1ZnMpIHtcbiAgICAgICAgbGV0IG1heCA9IDA7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBidWZzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIG1heCArPSBidWZzW2ldLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheShtYXgpO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgYnVmcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBvdXQuc2V0KGJ1ZnNbaV0sIGluZGV4KTtcbiAgICAgICAgICAgIGluZGV4ICs9IGJ1ZnNbaV0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQXNjaWkobSkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIG0gPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBURS5lbmNvZGUobSk7XG4gICAgfVxuICAgIHN0YXRpYyB0b0FzY2lpKGEpIHtcbiAgICAgICAgcmV0dXJuIFRELmRlY29kZShhKTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuYnVmZmVycy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmJ5dGVMZW5ndGggPSAwO1xuICAgIH1cbiAgICBwYWNrKCkge1xuICAgICAgICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBuZXcgVWludDhBcnJheSh0aGlzLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmJ1ZmZlcnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgIHYuc2V0KHRoaXMuYnVmZmVyc1tpXSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IHRoaXMuYnVmZmVyc1tpXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVycy5wdXNoKHYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNoaWZ0KCkge1xuICAgICAgICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgYSA9IHRoaXMuYnVmZmVycy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ5dGVMZW5ndGggLT0gYS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgIH1cbiAgICBkcmFpbihuKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnBhY2soKTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLmJ1ZmZlcnMucG9wKCk7XG4gICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heCA9IHRoaXMuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gdW5kZWZpbmVkIHx8IG4gPiBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbiA9IG1heDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZCA9IHYuc3ViYXJyYXkoMCwgbik7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA+IG4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJzLnB1c2godi5zdWJhcnJheShuKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IG1heCAtIG47XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgIH1cbiAgICBmaWxsKGEsIC4uLmJ1ZnMpIHtcbiAgICAgICAgaWYgKGEpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVycy5wdXNoKGEpO1xuICAgICAgICAgICAgdGhpcy5ieXRlTGVuZ3RoICs9IGEubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBidWZzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGlmIChidWZzW2ldICYmIGJ1ZnNbaV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXJzLnB1c2goYnVmc1tpXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5ieXRlTGVuZ3RoICs9IGJ1ZnNbaV0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHBlZWsoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnBhY2soKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcnNbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgIH1cbiAgICBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcnMubGVuZ3RoO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHQodCwgZSkge1xuICAgIHJldHVybiBlLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgICAgICBlICYmIFwic3RyaW5nXCIgIT0gdHlwZW9mIGUgJiYgIUFycmF5LmlzQXJyYXkoZSkgJiYgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICBpZiAoXCJkZWZhdWx0XCIgIT09IHIgJiYgIShyIGluIHQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCByLCBpLmdldCA/IGkgOiB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVbcl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSksIE9iamVjdC5mcmVlemUodCk7XG59XG52YXIgZSA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGdsb2JhbCA/IGdsb2JhbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHNlbGYgPyBzZWxmIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygd2luZG93ID8gd2luZG93IDoge307XG5mdW5jdGlvbiByKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIik7XG59XG5mdW5jdGlvbiBpKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKTtcbn1cbnZhciBoID0gciwgcyA9IGk7XG5mdW5jdGlvbiBuKHQpIHtcbiAgICBpZiAoaCA9PT0gc2V0VGltZW91dCkgcmV0dXJuIHNldFRpbWVvdXQodCwgMCk7XG4gICAgaWYgKChoID09PSByIHx8ICFoKSAmJiBzZXRUaW1lb3V0KSByZXR1cm4gaCA9IHNldFRpbWVvdXQsIHNldFRpbWVvdXQodCwgMCk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGgodCwgMCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGguY2FsbChudWxsLCB0LCAwKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGguY2FsbCh0aGlzLCB0LCAwKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZS5zZXRUaW1lb3V0ICYmIChoID0gc2V0VGltZW91dCksIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZS5jbGVhclRpbWVvdXQgJiYgKHMgPSBjbGVhclRpbWVvdXQpO1xudmFyIG8sIGEgPSBbXSwgZiA9ICExLCB1ID0gLTE7XG5mdW5jdGlvbiBjKCkge1xuICAgIGYgJiYgbyAmJiAoZiA9ICExLCBvLmxlbmd0aCA/IGEgPSBvLmNvbmNhdChhKSA6IHUgPSAtMSwgYS5sZW5ndGggJiYgbCgpKTtcbn1cbmZ1bmN0aW9uIGwoKSB7XG4gICAgaWYgKCFmKSB7XG4gICAgICAgIHZhciB0ID0gbihjKTtcbiAgICAgICAgZiA9ICEwO1xuICAgICAgICBmb3IodmFyIGUgPSBhLmxlbmd0aDsgZTspe1xuICAgICAgICAgICAgZm9yKG8gPSBhLCBhID0gW107ICsrdSA8IGU7KW8gJiYgb1t1XS5ydW4oKTtcbiAgICAgICAgICAgIHUgPSAtMSwgZSA9IGEubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIG8gPSBudWxsLCBmID0gITEsIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIGlmIChzID09PSBjbGVhclRpbWVvdXQpIHJldHVybiBjbGVhclRpbWVvdXQodCk7XG4gICAgICAgICAgICBpZiAoKHMgPT09IGkgfHwgIXMpICYmIGNsZWFyVGltZW91dCkgcmV0dXJuIHMgPSBjbGVhclRpbWVvdXQsIGNsZWFyVGltZW91dCh0KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHModCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMuY2FsbChudWxsLCB0KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzLmNhbGwodGhpcywgdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KHQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHkodCwgZSkge1xuICAgIHRoaXMuZnVuID0gdCwgdGhpcy5hcnJheSA9IGU7XG59XG55LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5mdW5jdGlvbiBwKCkge31cbnZhciBkID0gcCwgdyA9IHAsIGIgPSBwLCB2ID0gcCwgQSA9IHAsIGcgPSBwLCBfID0gcDtcbnZhciBtID0gZS5wZXJmb3JtYW5jZSB8fCB7fSwgTyA9IG0ubm93IHx8IG0ubW96Tm93IHx8IG0ubXNOb3cgfHwgbS5vTm93IHx8IG0ud2Via2l0Tm93IHx8IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAobmV3IERhdGUpLmdldFRpbWUoKTtcbn07XG52YXIgQiA9IG5ldyBEYXRlO1xudmFyIEUgPSB7XG4gICAgbmV4dFRpY2s6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIGUgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIGZvcih2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspZVtyIC0gMV0gPSBhcmd1bWVudHNbcl07XG4gICAgICAgIGEucHVzaChuZXcgeSh0LCBlKSksIDEgIT09IGEubGVuZ3RoIHx8IGYgfHwgbihsKTtcbiAgICB9LFxuICAgIHRpdGxlOiBcImJyb3dzZXJcIixcbiAgICBicm93c2VyOiAhMCxcbiAgICBlbnY6IHt9LFxuICAgIGFyZ3Y6IFtdLFxuICAgIHZlcnNpb246IFwiXCIsXG4gICAgdmVyc2lvbnM6IHt9LFxuICAgIG9uOiBkLFxuICAgIGFkZExpc3RlbmVyOiB3LFxuICAgIG9uY2U6IGIsXG4gICAgb2ZmOiB2LFxuICAgIHJlbW92ZUxpc3RlbmVyOiBBLFxuICAgIHJlbW92ZUFsbExpc3RlbmVyczogZyxcbiAgICBlbWl0OiBfLFxuICAgIGJpbmRpbmc6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgfSxcbiAgICBjd2Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXCIvXCI7XG4gICAgfSxcbiAgICBjaGRpcjogZnVuY3Rpb24odCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgfSxcbiAgICB1bWFzazogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgaHJ0aW1lOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciBlID0gLjAwMSAqIE8uY2FsbChtKSwgciA9IE1hdGguZmxvb3IoZSksIGkgPSBNYXRoLmZsb29yKGUgJSAxICogMWU5KTtcbiAgICAgICAgcmV0dXJuIHQgJiYgKHIgLT0gdFswXSwgKGkgLT0gdFsxXSkgPCAwICYmIChyLS0sIGkgKz0gMWU5KSksIFtcbiAgICAgICAgICAgIHIsXG4gICAgICAgICAgICBpXG4gICAgICAgIF07XG4gICAgfSxcbiAgICBwbGF0Zm9ybTogXCJicm93c2VyXCIsXG4gICAgcmVsZWFzZToge30sXG4gICAgY29uZmlnOiB7fSxcbiAgICB1cHRpbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKG5ldyBEYXRlIC0gQikgLyAxZTM7XG4gICAgfVxufSwgUyA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygd2luZG93ID8gd2luZG93IDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgZ2xvYmFsID8gZ2xvYmFsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygc2VsZiA/IHNlbGYgOiB7fTtcbmZ1bmN0aW9uIFQodCkge1xuICAgIGlmICh0Ll9fZXNNb2R1bGUpIHJldHVybiB0O1xuICAgIHZhciBlID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICB2YWx1ZTogITBcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModCkuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICAgIHZhciBpID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIGkuZ2V0ID8gaSA6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdFtyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSksIGU7XG59XG52YXIgaywgeCA9IHtcbiAgICBleHBvcnRzOiB7fVxufSwgaiA9IHt9LCBOID0gVCh0KHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZGVmYXVsdDogalxufSwgW1xuICAgIGpcbl0pKTtcbmsgPSB4LCBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IFwiaW5wdXQgaXMgaW52YWxpZCB0eXBlXCIsIGUgPSBcIm9iamVjdFwiID09IHR5cGVvZiB3aW5kb3csIHIgPSBlID8gd2luZG93IDoge307XG4gICAgci5KU19TSEEyNTZfTk9fV0lORE9XICYmIChlID0gITEpO1xuICAgIHZhciBpID0gIWUgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2Ygc2VsZiwgaCA9ICFyLkpTX1NIQTI1Nl9OT19OT0RFX0pTICYmIEUudmVyc2lvbnMgJiYgRS52ZXJzaW9ucy5ub2RlO1xuICAgIGggPyByID0gUyA6IGkgJiYgKHIgPSBzZWxmKTtcbiAgICB2YXIgcyA9ICFyLkpTX1NIQTI1Nl9OT19DT01NT05fSlMgJiYgay5leHBvcnRzLCBuID0gIXIuSlNfU0hBMjU2X05PX0FSUkFZX0JVRkZFUiAmJiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBBcnJheUJ1ZmZlciwgbyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiLnNwbGl0KFwiXCIpLCBhID0gW1xuICAgICAgICAtMjE0NzQ4MzY0OCxcbiAgICAgICAgODM4ODYwOCxcbiAgICAgICAgMzI3NjgsXG4gICAgICAgIDEyOFxuICAgIF0sIGYgPSBbXG4gICAgICAgIDI0LFxuICAgICAgICAxNixcbiAgICAgICAgOCxcbiAgICAgICAgMFxuICAgIF0sIHUgPSBbXG4gICAgICAgIDExMTYzNTI0MDgsXG4gICAgICAgIDE4OTk0NDc0NDEsXG4gICAgICAgIDMwNDkzMjM0NzEsXG4gICAgICAgIDM5MjEwMDk1NzMsXG4gICAgICAgIDk2MTk4NzE2MyxcbiAgICAgICAgMTUwODk3MDk5MyxcbiAgICAgICAgMjQ1MzYzNTc0OCxcbiAgICAgICAgMjg3MDc2MzIyMSxcbiAgICAgICAgMzYyNDM4MTA4MCxcbiAgICAgICAgMzEwNTk4NDAxLFxuICAgICAgICA2MDcyMjUyNzgsXG4gICAgICAgIDE0MjY4ODE5ODcsXG4gICAgICAgIDE5MjUwNzgzODgsXG4gICAgICAgIDIxNjIwNzgyMDYsXG4gICAgICAgIDI2MTQ4ODgxMDMsXG4gICAgICAgIDMyNDgyMjI1ODAsXG4gICAgICAgIDM4MzUzOTA0MDEsXG4gICAgICAgIDQwMjIyMjQ3NzQsXG4gICAgICAgIDI2NDM0NzA3OCxcbiAgICAgICAgNjA0ODA3NjI4LFxuICAgICAgICA3NzAyNTU5ODMsXG4gICAgICAgIDEyNDkxNTAxMjIsXG4gICAgICAgIDE1NTUwODE2OTIsXG4gICAgICAgIDE5OTYwNjQ5ODYsXG4gICAgICAgIDI1NTQyMjA4ODIsXG4gICAgICAgIDI4MjE4MzQzNDksXG4gICAgICAgIDI5NTI5OTY4MDgsXG4gICAgICAgIDMyMTAzMTM2NzEsXG4gICAgICAgIDMzMzY1NzE4OTEsXG4gICAgICAgIDM1ODQ1Mjg3MTEsXG4gICAgICAgIDExMzkyNjk5MyxcbiAgICAgICAgMzM4MjQxODk1LFxuICAgICAgICA2NjYzMDcyMDUsXG4gICAgICAgIDc3MzUyOTkxMixcbiAgICAgICAgMTI5NDc1NzM3MixcbiAgICAgICAgMTM5NjE4MjI5MSxcbiAgICAgICAgMTY5NTE4MzcwMCxcbiAgICAgICAgMTk4NjY2MTA1MSxcbiAgICAgICAgMjE3NzAyNjM1MCxcbiAgICAgICAgMjQ1Njk1NjAzNyxcbiAgICAgICAgMjczMDQ4NTkyMSxcbiAgICAgICAgMjgyMDMwMjQxMSxcbiAgICAgICAgMzI1OTczMDgwMCxcbiAgICAgICAgMzM0NTc2NDc3MSxcbiAgICAgICAgMzUxNjA2NTgxNyxcbiAgICAgICAgMzYwMDM1MjgwNCxcbiAgICAgICAgNDA5NDU3MTkwOSxcbiAgICAgICAgMjc1NDIzMzQ0LFxuICAgICAgICA0MzAyMjc3MzQsXG4gICAgICAgIDUwNjk0ODYxNixcbiAgICAgICAgNjU5MDYwNTU2LFxuICAgICAgICA4ODM5OTc4NzcsXG4gICAgICAgIDk1ODEzOTU3MSxcbiAgICAgICAgMTMyMjgyMjIxOCxcbiAgICAgICAgMTUzNzAwMjA2MyxcbiAgICAgICAgMTc0Nzg3Mzc3OSxcbiAgICAgICAgMTk1NTU2MjIyMixcbiAgICAgICAgMjAyNDEwNDgxNSxcbiAgICAgICAgMjIyNzczMDQ1MixcbiAgICAgICAgMjM2MTg1MjQyNCxcbiAgICAgICAgMjQyODQzNjQ3NCxcbiAgICAgICAgMjc1NjczNDE4NyxcbiAgICAgICAgMzIwNDAzMTQ3OSxcbiAgICAgICAgMzMyOTMyNTI5OFxuICAgIF0sIGMgPSBbXG4gICAgICAgIFwiaGV4XCIsXG4gICAgICAgIFwiYXJyYXlcIixcbiAgICAgICAgXCJkaWdlc3RcIixcbiAgICAgICAgXCJhcnJheUJ1ZmZlclwiXG4gICAgXSwgbCA9IFtdO1xuICAgICFyLkpTX1NIQTI1Nl9OT19OT0RFX0pTICYmIEFycmF5LmlzQXJyYXkgfHwgKEFycmF5LmlzQXJyYXkgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiBcIltvYmplY3QgQXJyYXldXCIgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KTtcbiAgICB9KSwgIW4gfHwgIXIuSlNfU0hBMjU2X05PX0FSUkFZX0JVRkZFUl9JU19WSUVXICYmIEFycmF5QnVmZmVyLmlzVmlldyB8fCAoQXJyYXlCdWZmZXIuaXNWaWV3ID0gZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gXCJvYmplY3RcIiA9PSB0eXBlb2YgdCAmJiB0LmJ1ZmZlciAmJiB0LmJ1ZmZlci5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXI7XG4gICAgfSk7XG4gICAgdmFyIHkgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHYoZSwgITApLnVwZGF0ZShyKVt0XSgpO1xuICAgICAgICB9O1xuICAgIH0sIHAgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciBlID0geShcImhleFwiLCB0KTtcbiAgICAgICAgaCAmJiAoZSA9IGQoZSwgdCkpLCBlLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB2KHQpO1xuICAgICAgICB9LCBlLnVwZGF0ZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBlLmNyZWF0ZSgpLnVwZGF0ZSh0KTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yKHZhciByID0gMDsgciA8IGMubGVuZ3RoOyArK3Ipe1xuICAgICAgICAgICAgdmFyIGkgPSBjW3JdO1xuICAgICAgICAgICAgZVtpXSA9IHkoaSwgdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfSwgZCA9IGZ1bmN0aW9uKGUsIGkpIHtcbiAgICAgICAgdmFyIGgsIHMgPSBOLCBuID0gTi5CdWZmZXIsIG8gPSBpID8gXCJzaGEyMjRcIiA6IFwic2hhMjU2XCI7XG4gICAgICAgIHJldHVybiBoID0gbi5mcm9tICYmICFyLkpTX1NIQTI1Nl9OT19CVUZGRVJfRlJPTSA/IG4uZnJvbSA6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgbih0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBzLmNyZWF0ZUhhc2gobykudXBkYXRlKHIsIFwidXRmOFwiKS5kaWdlc3QoXCJoZXhcIik7XG4gICAgICAgICAgICBpZiAobnVsbCA9PSByKSB0aHJvdyBuZXcgRXJyb3IodCk7XG4gICAgICAgICAgICByZXR1cm4gci5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIgJiYgKHIgPSBuZXcgVWludDhBcnJheShyKSksIEFycmF5LmlzQXJyYXkocikgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHIpIHx8IHIuY29uc3RydWN0b3IgPT09IG4gPyBzLmNyZWF0ZUhhc2gobykudXBkYXRlKGgocikpLmRpZ2VzdChcImhleFwiKSA6IGUocik7XG4gICAgICAgIH07XG4gICAgfSwgdyA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHIsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQShyLCBlLCAhMCkudXBkYXRlKGkpW3RdKCk7XG4gICAgICAgIH07XG4gICAgfSwgYiA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIGUgPSB3KFwiaGV4XCIsIHQpO1xuICAgICAgICBlLmNyZWF0ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQShlLCB0KTtcbiAgICAgICAgfSwgZS51cGRhdGUgPSBmdW5jdGlvbih0LCByKSB7XG4gICAgICAgICAgICByZXR1cm4gZS5jcmVhdGUodCkudXBkYXRlKHIpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IodmFyIHIgPSAwOyByIDwgYy5sZW5ndGg7ICsrcil7XG4gICAgICAgICAgICB2YXIgaSA9IGNbcl07XG4gICAgICAgICAgICBlW2ldID0gdyhpLCB0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHYodCwgZSkge1xuICAgICAgICBlID8gKGxbMF0gPSBsWzE2XSA9IGxbMV0gPSBsWzJdID0gbFszXSA9IGxbNF0gPSBsWzVdID0gbFs2XSA9IGxbN10gPSBsWzhdID0gbFs5XSA9IGxbMTBdID0gbFsxMV0gPSBsWzEyXSA9IGxbMTNdID0gbFsxNF0gPSBsWzE1XSA9IDAsIHRoaXMuYmxvY2tzID0gbCkgOiB0aGlzLmJsb2NrcyA9IFtcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwXG4gICAgICAgIF0sIHQgPyAodGhpcy5oMCA9IDMyMzgzNzEwMzIsIHRoaXMuaDEgPSA5MTQxNTA2NjMsIHRoaXMuaDIgPSA4MTI3MDI5OTksIHRoaXMuaDMgPSA0MTQ0OTEyNjk3LCB0aGlzLmg0ID0gNDI5MDc3NTg1NywgdGhpcy5oNSA9IDE3NTA2MDMwMjUsIHRoaXMuaDYgPSAxNjk0MDc2ODM5LCB0aGlzLmg3ID0gMzIwNDA3NTQyOCkgOiAodGhpcy5oMCA9IDE3NzkwMzM3MDMsIHRoaXMuaDEgPSAzMTQ0MTM0Mjc3LCB0aGlzLmgyID0gMTAxMzkwNDI0MiwgdGhpcy5oMyA9IDI3NzM0ODA3NjIsIHRoaXMuaDQgPSAxMzU5ODkzMTE5LCB0aGlzLmg1ID0gMjYwMDgyMjkyNCwgdGhpcy5oNiA9IDUyODczNDYzNSwgdGhpcy5oNyA9IDE1NDE0NTkyMjUpLCB0aGlzLmJsb2NrID0gdGhpcy5zdGFydCA9IHRoaXMuYnl0ZXMgPSB0aGlzLmhCeXRlcyA9IDAsIHRoaXMuZmluYWxpemVkID0gdGhpcy5oYXNoZWQgPSAhMSwgdGhpcy5maXJzdCA9ICEwLCB0aGlzLmlzMjI0ID0gdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gQShlLCByLCBpKSB7XG4gICAgICAgIHZhciBoLCBzID0gdHlwZW9mIGU7XG4gICAgICAgIGlmIChcInN0cmluZ1wiID09PSBzKSB7XG4gICAgICAgICAgICB2YXIgbywgYSA9IFtdLCBmID0gZS5sZW5ndGgsIHUgPSAwO1xuICAgICAgICAgICAgZm9yKGggPSAwOyBoIDwgZjsgKytoKShvID0gZS5jaGFyQ29kZUF0KGgpKSA8IDEyOCA/IGFbdSsrXSA9IG8gOiBvIDwgMjA0OCA/IChhW3UrK10gPSAxOTIgfCBvID4+PiA2LCBhW3UrK10gPSAxMjggfCA2MyAmIG8pIDogbyA8IDU1Mjk2IHx8IG8gPj0gNTczNDQgPyAoYVt1KytdID0gMjI0IHwgbyA+Pj4gMTIsIGFbdSsrXSA9IDEyOCB8IG8gPj4+IDYgJiA2MywgYVt1KytdID0gMTI4IHwgNjMgJiBvKSA6IChvID0gNjU1MzYgKyAoKDEwMjMgJiBvKSA8PCAxMCB8IDEwMjMgJiBlLmNoYXJDb2RlQXQoKytoKSksIGFbdSsrXSA9IDI0MCB8IG8gPj4+IDE4LCBhW3UrK10gPSAxMjggfCBvID4+PiAxMiAmIDYzLCBhW3UrK10gPSAxMjggfCBvID4+PiA2ICYgNjMsIGFbdSsrXSA9IDEyOCB8IDYzICYgbyk7XG4gICAgICAgICAgICBlID0gYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChcIm9iamVjdFwiICE9PSBzKSB0aHJvdyBuZXcgRXJyb3IodCk7XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gZSkgdGhyb3cgbmV3IEVycm9yKHQpO1xuICAgICAgICAgICAgaWYgKG4gJiYgZS5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIGUgPSBuZXcgVWludDhBcnJheShlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCEoQXJyYXkuaXNBcnJheShlKSB8fCBuICYmIEFycmF5QnVmZmVyLmlzVmlldyhlKSkpIHRocm93IG5ldyBFcnJvcih0KTtcbiAgICAgICAgfVxuICAgICAgICBlLmxlbmd0aCA+IDY0ICYmIChlID0gbmV3IHYociwgITApLnVwZGF0ZShlKS5hcnJheSgpKTtcbiAgICAgICAgdmFyIGMgPSBbXSwgbCA9IFtdO1xuICAgICAgICBmb3IoaCA9IDA7IGggPCA2NDsgKytoKXtcbiAgICAgICAgICAgIHZhciB5ID0gZVtoXSB8fCAwO1xuICAgICAgICAgICAgY1toXSA9IDkyIF4geSwgbFtoXSA9IDU0IF4geTtcbiAgICAgICAgfVxuICAgICAgICB2LmNhbGwodGhpcywgciwgaSksIHRoaXMudXBkYXRlKGwpLCB0aGlzLm9LZXlQYWQgPSBjLCB0aGlzLmlubmVyID0gITAsIHRoaXMuc2hhcmVkTWVtb3J5ID0gaTtcbiAgICB9XG4gICAgdi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIXRoaXMuZmluYWxpemVkKSB7XG4gICAgICAgICAgICB2YXIgciwgaSA9IHR5cGVvZiBlO1xuICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgIT09IGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiAhPT0gaSkgdGhyb3cgbmV3IEVycm9yKHQpO1xuICAgICAgICAgICAgICAgIGlmIChudWxsID09PSBlKSB0aHJvdyBuZXcgRXJyb3IodCk7XG4gICAgICAgICAgICAgICAgaWYgKG4gJiYgZS5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIGUgPSBuZXcgVWludDhBcnJheShlKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghKEFycmF5LmlzQXJyYXkoZSkgfHwgbiAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcoZSkpKSB0aHJvdyBuZXcgRXJyb3IodCk7XG4gICAgICAgICAgICAgICAgciA9ICEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yKHZhciBoLCBzLCBvID0gMCwgYSA9IGUubGVuZ3RoLCB1ID0gdGhpcy5ibG9ja3M7IG8gPCBhOyl7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzaGVkICYmICh0aGlzLmhhc2hlZCA9ICExLCB1WzBdID0gdGhpcy5ibG9jaywgdGhpcy5ibG9jayA9IHVbMTZdID0gdVsxXSA9IHVbMl0gPSB1WzNdID0gdVs0XSA9IHVbNV0gPSB1WzZdID0gdVs3XSA9IHVbOF0gPSB1WzldID0gdVsxMF0gPSB1WzExXSA9IHVbMTJdID0gdVsxM10gPSB1WzE0XSA9IHVbMTVdID0gMCksIHIpIGZvcihzID0gdGhpcy5zdGFydDsgbyA8IGEgJiYgcyA8IDY0OyArK28pdVtzID4+PiAyXSB8PSBlW29dIDw8IGZbMyAmIHMrK107XG4gICAgICAgICAgICAgICAgZWxzZSBmb3IocyA9IHRoaXMuc3RhcnQ7IG8gPCBhICYmIHMgPCA2NDsgKytvKShoID0gZS5jaGFyQ29kZUF0KG8pKSA8IDEyOCA/IHVbcyA+Pj4gMl0gfD0gaCA8PCBmWzMgJiBzKytdIDogaCA8IDIwNDggPyAodVtzID4+PiAyXSB8PSAoMTkyIHwgaCA+Pj4gNikgPDwgZlszICYgcysrXSwgdVtzID4+PiAyXSB8PSAoMTI4IHwgNjMgJiBoKSA8PCBmWzMgJiBzKytdKSA6IGggPCA1NTI5NiB8fCBoID49IDU3MzQ0ID8gKHVbcyA+Pj4gMl0gfD0gKDIyNCB8IGggPj4+IDEyKSA8PCBmWzMgJiBzKytdLCB1W3MgPj4+IDJdIHw9ICgxMjggfCBoID4+PiA2ICYgNjMpIDw8IGZbMyAmIHMrK10sIHVbcyA+Pj4gMl0gfD0gKDEyOCB8IDYzICYgaCkgPDwgZlszICYgcysrXSkgOiAoaCA9IDY1NTM2ICsgKCgxMDIzICYgaCkgPDwgMTAgfCAxMDIzICYgZS5jaGFyQ29kZUF0KCsrbykpLCB1W3MgPj4+IDJdIHw9ICgyNDAgfCBoID4+PiAxOCkgPDwgZlszICYgcysrXSwgdVtzID4+PiAyXSB8PSAoMTI4IHwgaCA+Pj4gMTIgJiA2MykgPDwgZlszICYgcysrXSwgdVtzID4+PiAyXSB8PSAoMTI4IHwgaCA+Pj4gNiAmIDYzKSA8PCBmWzMgJiBzKytdLCB1W3MgPj4+IDJdIHw9ICgxMjggfCA2MyAmIGgpIDw8IGZbMyAmIHMrK10pO1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdEJ5dGVJbmRleCA9IHMsIHRoaXMuYnl0ZXMgKz0gcyAtIHRoaXMuc3RhcnQsIHMgPj0gNjQgPyAodGhpcy5ibG9jayA9IHVbMTZdLCB0aGlzLnN0YXJ0ID0gcyAtIDY0LCB0aGlzLmhhc2goKSwgdGhpcy5oYXNoZWQgPSAhMCkgOiB0aGlzLnN0YXJ0ID0gcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ5dGVzID4gNDI5NDk2NzI5NSAmJiAodGhpcy5oQnl0ZXMgKz0gdGhpcy5ieXRlcyAvIDQyOTQ5NjcyOTYgfCAwLCB0aGlzLmJ5dGVzID0gdGhpcy5ieXRlcyAlIDQyOTQ5NjcyOTYpLCB0aGlzO1xuICAgICAgICB9XG4gICAgfSwgdi5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpbmFsaXplZCkge1xuICAgICAgICAgICAgdGhpcy5maW5hbGl6ZWQgPSAhMDtcbiAgICAgICAgICAgIHZhciB0ID0gdGhpcy5ibG9ja3MsIGUgPSB0aGlzLmxhc3RCeXRlSW5kZXg7XG4gICAgICAgICAgICB0WzE2XSA9IHRoaXMuYmxvY2ssIHRbZSA+Pj4gMl0gfD0gYVszICYgZV0sIHRoaXMuYmxvY2sgPSB0WzE2XSwgZSA+PSA1NiAmJiAodGhpcy5oYXNoZWQgfHwgdGhpcy5oYXNoKCksIHRbMF0gPSB0aGlzLmJsb2NrLCB0WzE2XSA9IHRbMV0gPSB0WzJdID0gdFszXSA9IHRbNF0gPSB0WzVdID0gdFs2XSA9IHRbN10gPSB0WzhdID0gdFs5XSA9IHRbMTBdID0gdFsxMV0gPSB0WzEyXSA9IHRbMTNdID0gdFsxNF0gPSB0WzE1XSA9IDApLCB0WzE0XSA9IHRoaXMuaEJ5dGVzIDw8IDMgfCB0aGlzLmJ5dGVzID4+PiAyOSwgdFsxNV0gPSB0aGlzLmJ5dGVzIDw8IDMsIHRoaXMuaGFzaCgpO1xuICAgICAgICB9XG4gICAgfSwgdi5wcm90b3R5cGUuaGFzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdCwgZSwgciwgaSwgaCwgcywgbiwgbywgYSwgZiA9IHRoaXMuaDAsIGMgPSB0aGlzLmgxLCBsID0gdGhpcy5oMiwgeSA9IHRoaXMuaDMsIHAgPSB0aGlzLmg0LCBkID0gdGhpcy5oNSwgdyA9IHRoaXMuaDYsIGIgPSB0aGlzLmg3LCB2ID0gdGhpcy5ibG9ja3M7XG4gICAgICAgIGZvcih0ID0gMTY7IHQgPCA2NDsgKyt0KWUgPSAoKGggPSB2W3QgLSAxNV0pID4+PiA3IHwgaCA8PCAyNSkgXiAoaCA+Pj4gMTggfCBoIDw8IDE0KSBeIGggPj4+IDMsIHIgPSAoKGggPSB2W3QgLSAyXSkgPj4+IDE3IHwgaCA8PCAxNSkgXiAoaCA+Pj4gMTkgfCBoIDw8IDEzKSBeIGggPj4+IDEwLCB2W3RdID0gdlt0IC0gMTZdICsgZSArIHZbdCAtIDddICsgciB8IDA7XG4gICAgICAgIGZvcihhID0gYyAmIGwsIHQgPSAwOyB0IDwgNjQ7IHQgKz0gNCl0aGlzLmZpcnN0ID8gKHRoaXMuaXMyMjQgPyAocyA9IDMwMDAzMiwgYiA9IChoID0gdlswXSAtIDE0MTMyNTc4MTkpIC0gMTUwMDU0NTk5IHwgMCwgeSA9IGggKyAyNDE3NzA3NyB8IDApIDogKHMgPSA3MDQ3NTExMDksIGIgPSAoaCA9IHZbMF0gLSAyMTAyNDQyNDgpIC0gMTUyMTQ4NjUzNCB8IDAsIHkgPSBoICsgMTQzNjk0NTY1IHwgMCksIHRoaXMuZmlyc3QgPSAhMSkgOiAoZSA9IChmID4+PiAyIHwgZiA8PCAzMCkgXiAoZiA+Pj4gMTMgfCBmIDw8IDE5KSBeIChmID4+PiAyMiB8IGYgPDwgMTApLCBpID0gKHMgPSBmICYgYykgXiBmICYgbCBeIGEsIGIgPSB5ICsgKGggPSBiICsgKHIgPSAocCA+Pj4gNiB8IHAgPDwgMjYpIF4gKHAgPj4+IDExIHwgcCA8PCAyMSkgXiAocCA+Pj4gMjUgfCBwIDw8IDcpKSArIChwICYgZCBeIH5wICYgdykgKyB1W3RdICsgdlt0XSkgfCAwLCB5ID0gaCArIChlICsgaSkgfCAwKSwgZSA9ICh5ID4+PiAyIHwgeSA8PCAzMCkgXiAoeSA+Pj4gMTMgfCB5IDw8IDE5KSBeICh5ID4+PiAyMiB8IHkgPDwgMTApLCBpID0gKG4gPSB5ICYgZikgXiB5ICYgYyBeIHMsIHcgPSBsICsgKGggPSB3ICsgKHIgPSAoYiA+Pj4gNiB8IGIgPDwgMjYpIF4gKGIgPj4+IDExIHwgYiA8PCAyMSkgXiAoYiA+Pj4gMjUgfCBiIDw8IDcpKSArIChiICYgcCBeIH5iICYgZCkgKyB1W3QgKyAxXSArIHZbdCArIDFdKSB8IDAsIGUgPSAoKGwgPSBoICsgKGUgKyBpKSB8IDApID4+PiAyIHwgbCA8PCAzMCkgXiAobCA+Pj4gMTMgfCBsIDw8IDE5KSBeIChsID4+PiAyMiB8IGwgPDwgMTApLCBpID0gKG8gPSBsICYgeSkgXiBsICYgZiBeIG4sIGQgPSBjICsgKGggPSBkICsgKHIgPSAodyA+Pj4gNiB8IHcgPDwgMjYpIF4gKHcgPj4+IDExIHwgdyA8PCAyMSkgXiAodyA+Pj4gMjUgfCB3IDw8IDcpKSArICh3ICYgYiBeIH53ICYgcCkgKyB1W3QgKyAyXSArIHZbdCArIDJdKSB8IDAsIGUgPSAoKGMgPSBoICsgKGUgKyBpKSB8IDApID4+PiAyIHwgYyA8PCAzMCkgXiAoYyA+Pj4gMTMgfCBjIDw8IDE5KSBeIChjID4+PiAyMiB8IGMgPDwgMTApLCBpID0gKGEgPSBjICYgbCkgXiBjICYgeSBeIG8sIHAgPSBmICsgKGggPSBwICsgKHIgPSAoZCA+Pj4gNiB8IGQgPDwgMjYpIF4gKGQgPj4+IDExIHwgZCA8PCAyMSkgXiAoZCA+Pj4gMjUgfCBkIDw8IDcpKSArIChkICYgdyBeIH5kICYgYikgKyB1W3QgKyAzXSArIHZbdCArIDNdKSB8IDAsIGYgPSBoICsgKGUgKyBpKSB8IDAsIHRoaXMuY2hyb21lQnVnV29ya0Fyb3VuZCA9ICEwO1xuICAgICAgICB0aGlzLmgwID0gdGhpcy5oMCArIGYgfCAwLCB0aGlzLmgxID0gdGhpcy5oMSArIGMgfCAwLCB0aGlzLmgyID0gdGhpcy5oMiArIGwgfCAwLCB0aGlzLmgzID0gdGhpcy5oMyArIHkgfCAwLCB0aGlzLmg0ID0gdGhpcy5oNCArIHAgfCAwLCB0aGlzLmg1ID0gdGhpcy5oNSArIGQgfCAwLCB0aGlzLmg2ID0gdGhpcy5oNiArIHcgfCAwLCB0aGlzLmg3ID0gdGhpcy5oNyArIGIgfCAwO1xuICAgIH0sIHYucHJvdG90eXBlLmhleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmZpbmFsaXplKCk7XG4gICAgICAgIHZhciB0ID0gdGhpcy5oMCwgZSA9IHRoaXMuaDEsIHIgPSB0aGlzLmgyLCBpID0gdGhpcy5oMywgaCA9IHRoaXMuaDQsIHMgPSB0aGlzLmg1LCBuID0gdGhpcy5oNiwgYSA9IHRoaXMuaDcsIGYgPSBvW3QgPj4+IDI4ICYgMTVdICsgb1t0ID4+PiAyNCAmIDE1XSArIG9bdCA+Pj4gMjAgJiAxNV0gKyBvW3QgPj4+IDE2ICYgMTVdICsgb1t0ID4+PiAxMiAmIDE1XSArIG9bdCA+Pj4gOCAmIDE1XSArIG9bdCA+Pj4gNCAmIDE1XSArIG9bMTUgJiB0XSArIG9bZSA+Pj4gMjggJiAxNV0gKyBvW2UgPj4+IDI0ICYgMTVdICsgb1tlID4+PiAyMCAmIDE1XSArIG9bZSA+Pj4gMTYgJiAxNV0gKyBvW2UgPj4+IDEyICYgMTVdICsgb1tlID4+PiA4ICYgMTVdICsgb1tlID4+PiA0ICYgMTVdICsgb1sxNSAmIGVdICsgb1tyID4+PiAyOCAmIDE1XSArIG9bciA+Pj4gMjQgJiAxNV0gKyBvW3IgPj4+IDIwICYgMTVdICsgb1tyID4+PiAxNiAmIDE1XSArIG9bciA+Pj4gMTIgJiAxNV0gKyBvW3IgPj4+IDggJiAxNV0gKyBvW3IgPj4+IDQgJiAxNV0gKyBvWzE1ICYgcl0gKyBvW2kgPj4+IDI4ICYgMTVdICsgb1tpID4+PiAyNCAmIDE1XSArIG9baSA+Pj4gMjAgJiAxNV0gKyBvW2kgPj4+IDE2ICYgMTVdICsgb1tpID4+PiAxMiAmIDE1XSArIG9baSA+Pj4gOCAmIDE1XSArIG9baSA+Pj4gNCAmIDE1XSArIG9bMTUgJiBpXSArIG9baCA+Pj4gMjggJiAxNV0gKyBvW2ggPj4+IDI0ICYgMTVdICsgb1toID4+PiAyMCAmIDE1XSArIG9baCA+Pj4gMTYgJiAxNV0gKyBvW2ggPj4+IDEyICYgMTVdICsgb1toID4+PiA4ICYgMTVdICsgb1toID4+PiA0ICYgMTVdICsgb1sxNSAmIGhdICsgb1tzID4+PiAyOCAmIDE1XSArIG9bcyA+Pj4gMjQgJiAxNV0gKyBvW3MgPj4+IDIwICYgMTVdICsgb1tzID4+PiAxNiAmIDE1XSArIG9bcyA+Pj4gMTIgJiAxNV0gKyBvW3MgPj4+IDggJiAxNV0gKyBvW3MgPj4+IDQgJiAxNV0gKyBvWzE1ICYgc10gKyBvW24gPj4+IDI4ICYgMTVdICsgb1tuID4+PiAyNCAmIDE1XSArIG9bbiA+Pj4gMjAgJiAxNV0gKyBvW24gPj4+IDE2ICYgMTVdICsgb1tuID4+PiAxMiAmIDE1XSArIG9bbiA+Pj4gOCAmIDE1XSArIG9bbiA+Pj4gNCAmIDE1XSArIG9bMTUgJiBuXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXMyMjQgfHwgKGYgKz0gb1thID4+PiAyOCAmIDE1XSArIG9bYSA+Pj4gMjQgJiAxNV0gKyBvW2EgPj4+IDIwICYgMTVdICsgb1thID4+PiAxNiAmIDE1XSArIG9bYSA+Pj4gMTIgJiAxNV0gKyBvW2EgPj4+IDggJiAxNV0gKyBvW2EgPj4+IDQgJiAxNV0gKyBvWzE1ICYgYV0pLCBmO1xuICAgIH0sIHYucHJvdG90eXBlLnRvU3RyaW5nID0gdi5wcm90b3R5cGUuaGV4LCB2LnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5maW5hbGl6ZSgpO1xuICAgICAgICB2YXIgdCA9IHRoaXMuaDAsIGUgPSB0aGlzLmgxLCByID0gdGhpcy5oMiwgaSA9IHRoaXMuaDMsIGggPSB0aGlzLmg0LCBzID0gdGhpcy5oNSwgbiA9IHRoaXMuaDYsIG8gPSB0aGlzLmg3LCBhID0gW1xuICAgICAgICAgICAgdCA+Pj4gMjQgJiAyNTUsXG4gICAgICAgICAgICB0ID4+PiAxNiAmIDI1NSxcbiAgICAgICAgICAgIHQgPj4+IDggJiAyNTUsXG4gICAgICAgICAgICAyNTUgJiB0LFxuICAgICAgICAgICAgZSA+Pj4gMjQgJiAyNTUsXG4gICAgICAgICAgICBlID4+PiAxNiAmIDI1NSxcbiAgICAgICAgICAgIGUgPj4+IDggJiAyNTUsXG4gICAgICAgICAgICAyNTUgJiBlLFxuICAgICAgICAgICAgciA+Pj4gMjQgJiAyNTUsXG4gICAgICAgICAgICByID4+PiAxNiAmIDI1NSxcbiAgICAgICAgICAgIHIgPj4+IDggJiAyNTUsXG4gICAgICAgICAgICAyNTUgJiByLFxuICAgICAgICAgICAgaSA+Pj4gMjQgJiAyNTUsXG4gICAgICAgICAgICBpID4+PiAxNiAmIDI1NSxcbiAgICAgICAgICAgIGkgPj4+IDggJiAyNTUsXG4gICAgICAgICAgICAyNTUgJiBpLFxuICAgICAgICAgICAgaCA+Pj4gMjQgJiAyNTUsXG4gICAgICAgICAgICBoID4+PiAxNiAmIDI1NSxcbiAgICAgICAgICAgIGggPj4+IDggJiAyNTUsXG4gICAgICAgICAgICAyNTUgJiBoLFxuICAgICAgICAgICAgcyA+Pj4gMjQgJiAyNTUsXG4gICAgICAgICAgICBzID4+PiAxNiAmIDI1NSxcbiAgICAgICAgICAgIHMgPj4+IDggJiAyNTUsXG4gICAgICAgICAgICAyNTUgJiBzLFxuICAgICAgICAgICAgbiA+Pj4gMjQgJiAyNTUsXG4gICAgICAgICAgICBuID4+PiAxNiAmIDI1NSxcbiAgICAgICAgICAgIG4gPj4+IDggJiAyNTUsXG4gICAgICAgICAgICAyNTUgJiBuXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiB0aGlzLmlzMjI0IHx8IGEucHVzaChvID4+PiAyNCAmIDI1NSwgbyA+Pj4gMTYgJiAyNTUsIG8gPj4+IDggJiAyNTUsIDI1NSAmIG8pLCBhO1xuICAgIH0sIHYucHJvdG90eXBlLmFycmF5ID0gdi5wcm90b3R5cGUuZGlnZXN0LCB2LnByb3RvdHlwZS5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmZpbmFsaXplKCk7XG4gICAgICAgIHZhciB0ID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuaXMyMjQgPyAyOCA6IDMyKSwgZSA9IG5ldyBEYXRhVmlldyh0KTtcbiAgICAgICAgcmV0dXJuIGUuc2V0VWludDMyKDAsIHRoaXMuaDApLCBlLnNldFVpbnQzMig0LCB0aGlzLmgxKSwgZS5zZXRVaW50MzIoOCwgdGhpcy5oMiksIGUuc2V0VWludDMyKDEyLCB0aGlzLmgzKSwgZS5zZXRVaW50MzIoMTYsIHRoaXMuaDQpLCBlLnNldFVpbnQzMigyMCwgdGhpcy5oNSksIGUuc2V0VWludDMyKDI0LCB0aGlzLmg2KSwgdGhpcy5pczIyNCB8fCBlLnNldFVpbnQzMigyOCwgdGhpcy5oNyksIHQ7XG4gICAgfSwgQS5wcm90b3R5cGUgPSBuZXcgdiwgQS5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHYucHJvdG90eXBlLmZpbmFsaXplLmNhbGwodGhpcyksIHRoaXMuaW5uZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSAhMTtcbiAgICAgICAgICAgIHZhciB0ID0gdGhpcy5hcnJheSgpO1xuICAgICAgICAgICAgdi5jYWxsKHRoaXMsIHRoaXMuaXMyMjQsIHRoaXMuc2hhcmVkTWVtb3J5KSwgdGhpcy51cGRhdGUodGhpcy5vS2V5UGFkKSwgdGhpcy51cGRhdGUodCksIHYucHJvdG90eXBlLmZpbmFsaXplLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBnID0gcCgpO1xuICAgIGcuc2hhMjU2ID0gZywgZy5zaGEyMjQgPSBwKCEwKSwgZy5zaGEyNTYuaG1hYyA9IGIoKSwgZy5zaGEyMjQuaG1hYyA9IGIoITApLCBzID8gay5leHBvcnRzID0gZyA6IChyLnNoYTI1NiA9IGcuc2hhMjU2LCByLnNoYTIyNCA9IGcuc2hhMjI0KTtcbn0oKTtcbnZhciBVID0geC5leHBvcnRzLCB6ID0geC5leHBvcnRzLnNoYTIyNCwgSiA9IHguZXhwb3J0cy5zaGEyNTY7XG5mdW5jdGlvbiBwYXJzZVNoYTI1NihzKSB7XG4gICAgcmV0dXJuIHRvQnl0ZUFycmF5KHMpO1xufVxuZnVuY3Rpb24gaXNIZXgocykge1xuICAgIGNvbnN0IGhleFJlZ2V4ID0gL15bMC05QS1GYS1mXSskLztcbiAgICBpZiAoIWhleFJlZ2V4LnRlc3QocykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBpc0FsbFVwcGVyQ2FzZSA9IC9eWzAtOUEtRl0rJC8udGVzdChzKTtcbiAgICBjb25zdCBpc0FsbExvd2VyQ2FzZSA9IC9eWzAtOWEtZl0rJC8udGVzdChzKTtcbiAgICBpZiAoIShpc0FsbFVwcGVyQ2FzZSB8fCBpc0FsbExvd2VyQ2FzZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gcy5sZW5ndGggJSAyID09PSAwO1xufVxuZnVuY3Rpb24gaXNCYXNlNjQocykge1xuICAgIHJldHVybiAvXltBLVphLXowLTlcXC1fXSooPXswLDJ9KT8kLy50ZXN0KHMpIHx8IC9eW0EtWmEtejAtOSsvXSooPXswLDJ9KT8kLy50ZXN0KHMpO1xufVxuZnVuY3Rpb24gZGV0ZWN0RW5jb2RpbmcoaW5wdXQpIHtcbiAgICBpZiAoaXNIZXgoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBcImhleFwiO1xuICAgIH0gZWxzZSBpZiAoaXNCYXNlNjQoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBcImI2NFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbn1cbmZ1bmN0aW9uIGhleFRvQnl0ZUFycmF5KHMpIHtcbiAgICBpZiAocy5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImhleCBzdHJpbmcgbXVzdCBoYXZlIGFuIGV2ZW4gbGVuZ3RoXCIpO1xuICAgIH1cbiAgICBjb25zdCBhID0gbmV3IFVpbnQ4QXJyYXkocy5sZW5ndGggLyAyKTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkgKz0gMil7XG4gICAgICAgIGFbaSAvIDJdID0gcGFyc2VJbnQocy5zdWJzdHJpbmcoaSwgaSArIDIpLCAxNik7XG4gICAgfVxuICAgIHJldHVybiBhO1xufVxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlQXJyYXkocykge1xuICAgIHMgPSBzLnJlcGxhY2UoLy0vZywgXCIrXCIpO1xuICAgIHMgPSBzLnJlcGxhY2UoL18vZywgXCIvXCIpO1xuICAgIGNvbnN0IHNiaW4gPSBhdG9iKHMpO1xuICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oc2JpbiwgKGMpPT5jLmNoYXJDb2RlQXQoMCkpO1xufVxuZnVuY3Rpb24gdG9CeXRlQXJyYXkoaW5wdXQpIHtcbiAgICBjb25zdCBlbmNvZGluZyA9IGRldGVjdEVuY29kaW5nKGlucHV0KTtcbiAgICBzd2l0Y2goZW5jb2Rpbmcpe1xuICAgICAgICBjYXNlIFwiaGV4XCI6XG4gICAgICAgICAgICByZXR1cm4gaGV4VG9CeXRlQXJyYXkoaW5wdXQpO1xuICAgICAgICBjYXNlIFwiYjY0XCI6XG4gICAgICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlQXJyYXkoaW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNoZWNrU2hhMjU2KGEsIGIpIHtcbiAgICBjb25zdCBhQnl0ZXMgPSB0eXBlb2YgYSA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlU2hhMjU2KGEpIDogYTtcbiAgICBjb25zdCBiQnl0ZXMgPSB0eXBlb2YgYiA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlU2hhMjU2KGIpIDogYjtcbiAgICBpZiAoYUJ5dGVzID09PSBudWxsIHx8IGJCeXRlcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhQnl0ZXMubGVuZ3RoICE9PSBiQnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGFCeXRlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGlmIChhQnl0ZXNbaV0gIT09IGJCeXRlc1tpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuY2xhc3MgQmFzZVJlcXVlc3Qge1xuICAgIHRva2VuO1xuICAgIHJlY2VpdmVkO1xuICAgIGN0eDtcbiAgICByZXF1ZXN0U3ViamVjdDtcbiAgICBtdXg7XG4gICAgY29uc3RydWN0b3IobXV4LCByZXF1ZXN0U3ViamVjdCwgYXN5bmNUcmFjZXMgPSB0cnVlKXtcbiAgICAgICAgdGhpcy5tdXggPSBtdXg7XG4gICAgICAgIHRoaXMucmVxdWVzdFN1YmplY3QgPSByZXF1ZXN0U3ViamVjdDtcbiAgICAgICAgdGhpcy5yZWNlaXZlZCA9IDA7XG4gICAgICAgIHRoaXMudG9rZW4gPSBudWlkLm5leHQoKTtcbiAgICAgICAgaWYgKGFzeW5jVHJhY2VzKSB7XG4gICAgICAgICAgICB0aGlzLmN0eCA9IG5ldyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgUmVxdWVzdE1hbnkgZXh0ZW5kcyBCYXNlUmVxdWVzdCB7XG4gICAgY2FsbGJhY2s7XG4gICAgZG9uZTtcbiAgICB0aW1lcjtcbiAgICBtYXg7XG4gICAgb3B0cztcbiAgICBjb25zdHJ1Y3RvcihtdXgsIHJlcXVlc3RTdWJqZWN0LCBvcHRzID0ge1xuICAgICAgICBtYXhXYWl0OiAxMDAwXG4gICAgfSl7XG4gICAgICAgIHN1cGVyKG11eCwgcmVxdWVzdFN1YmplY3QpO1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0cy5jYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYWxsYmFjayBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGxiYWNrID0gdGhpcy5vcHRzLmNhbGxiYWNrO1xuICAgICAgICB0aGlzLm1heCA9IHR5cGVvZiBvcHRzLm1heE1lc3NhZ2VzID09PSBcIm51bWJlclwiICYmIG9wdHMubWF4TWVzc2FnZXMgPiAwID8gb3B0cy5tYXhNZXNzYWdlcyA6IC0xO1xuICAgICAgICB0aGlzLmRvbmUgPSBkZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLmRvbmUudGhlbigoKT0+e1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFjayhudWxsLCBudWxsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICB9LCBvcHRzLm1heFdhaXQpO1xuICAgIH1cbiAgICBjYW5jZWwoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgIHRoaXMubXV4LmNhbmNlbCh0aGlzKTtcbiAgICAgICAgdGhpcy5kb25lLnJlc29sdmUoKTtcbiAgICB9XG4gICAgcmVzb2x2ZXIoZXJyLCBtc2cpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3R4KSB7XG4gICAgICAgICAgICAgICAgZXJyLnN0YWNrICs9IGBcXG5cXG4ke3RoaXMuY3R4LnN0YWNrfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNhbmNlbChlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFjayhudWxsLCBtc2cpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5zdHJhdGVneSA9PT0gUmVxdWVzdFN0cmF0ZWd5LkNvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXgtLTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLnN0cmF0ZWd5ID09PSBSZXF1ZXN0U3RyYXRlZ3kuSml0dGVyVGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzLm9wdHMuaml0dGVyIHx8IDMwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLnN0cmF0ZWd5ID09PSBSZXF1ZXN0U3RyYXRlZ3kuU2VudGluZWxNc2cpIHtcbiAgICAgICAgICAgICAgICBpZiAobXNnICYmIG1zZy5kYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFJlcXVlc3RPbmUgZXh0ZW5kcyBCYXNlUmVxdWVzdCB7XG4gICAgZGVmZXJyZWQ7XG4gICAgdGltZXI7XG4gICAgY29uc3RydWN0b3IobXV4LCByZXF1ZXN0U3ViamVjdCwgb3B0cyA9IHtcbiAgICAgICAgdGltZW91dDogMTAwMFxuICAgIH0sIGFzeW5jVHJhY2VzID0gdHJ1ZSl7XG4gICAgICAgIHN1cGVyKG11eCwgcmVxdWVzdFN1YmplY3QsIGFzeW5jVHJhY2VzKTtcbiAgICAgICAgdGhpcy5kZWZlcnJlZCA9IGRlZmVycmVkKCk7XG4gICAgICAgIHRoaXMudGltZXIgPSB0aW1lb3V0KG9wdHMudGltZW91dCwgYXN5bmNUcmFjZXMpO1xuICAgIH1cbiAgICByZXNvbHZlcihlcnIsIG1zZykge1xuICAgICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICAgICAgdGhpcy50aW1lci5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdHgpIHtcbiAgICAgICAgICAgICAgICBlcnIuc3RhY2sgKz0gYFxcblxcbiR7dGhpcy5jdHguc3RhY2t9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlZmVycmVkLnJlc29sdmUobXNnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgIH1cbiAgICBjYW5jZWwoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVyLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubXV4LmNhbmNlbCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZWZlcnJlZC5yZWplY3QoZXJyID8gZXJyIDogTmF0c0Vycm9yLmVycm9yRm9yQ29kZShFcnJvckNvZGUuQ2FuY2VsbGVkKSk7XG4gICAgfVxufVxuY29uc3QgZGVmYXVsdFByZWZpeCA9IFwiJEpTLkFQSVwiO1xuZnVuY3Rpb24gZGVmYXVsdEpzT3B0aW9ucyhvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgaWYgKG9wdHMuZG9tYWluKSB7XG4gICAgICAgIG9wdHMuYXBpUHJlZml4ID0gYCRKUy4ke29wdHMuZG9tYWlufS5BUElgO1xuICAgICAgICBkZWxldGUgb3B0cy5kb21haW47XG4gICAgfVxuICAgIHJldHVybiBleHRlbmQoe1xuICAgICAgICBhcGlQcmVmaXg6IGRlZmF1bHRQcmVmaXgsXG4gICAgICAgIHRpbWVvdXQ6IDUwMDBcbiAgICB9LCBvcHRzKTtcbn1cbmNsYXNzIEJhc2VBcGlDbGllbnQge1xuICAgIG5jO1xuICAgIG9wdHM7XG4gICAgcHJlZml4O1xuICAgIHRpbWVvdXQ7XG4gICAgamM7XG4gICAgY29uc3RydWN0b3IobmMsIG9wdHMpe1xuICAgICAgICB0aGlzLm5jID0gbmM7XG4gICAgICAgIHRoaXMub3B0cyA9IGRlZmF1bHRKc09wdGlvbnMob3B0cyk7XG4gICAgICAgIHRoaXMuX3BhcnNlT3B0cygpO1xuICAgICAgICB0aGlzLnByZWZpeCA9IHRoaXMub3B0cy5hcGlQcmVmaXg7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHRoaXMub3B0cy50aW1lb3V0O1xuICAgICAgICB0aGlzLmpjID0gSlNPTkNvZGVjKCk7XG4gICAgfVxuICAgIGdldE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdHMpO1xuICAgIH1cbiAgICBfcGFyc2VPcHRzKCkge1xuICAgICAgICBsZXQgcHJlZml4ID0gdGhpcy5vcHRzLmFwaVByZWZpeDtcbiAgICAgICAgaWYgKCFwcmVmaXggfHwgcHJlZml4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBlbXB0eSBwcmVmaXhcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYyA9IHByZWZpeFtwcmVmaXgubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChjID09PSBcIi5cIikge1xuICAgICAgICAgICAgcHJlZml4ID0gcHJlZml4LnN1YnN0cigwLCBwcmVmaXgubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRzLmFwaVByZWZpeCA9IHByZWZpeDtcbiAgICB9XG4gICAgYXN5bmMgX3JlcXVlc3Qoc3ViaiwgZGF0YSA9IG51bGwsIG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIG9wdHMudGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICAgICAgbGV0IGEgPSBFbXB0eTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIGEgPSB0aGlzLmpjLmVuY29kZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyByZXRyaWVzIH0gPSBvcHRzO1xuICAgICAgICByZXRyaWVzID0gcmV0cmllcyB8fCAxO1xuICAgICAgICByZXRyaWVzID0gcmV0cmllcyA9PT0gLTEgPyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiA6IHJldHJpZXM7XG4gICAgICAgIGNvbnN0IGJvID0gYmFja29mZigpO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgcmV0cmllczsgaSsrKXtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IGF3YWl0IHRoaXMubmMucmVxdWVzdChzdWJqLCBhLCBvcHRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUpzUmVzcG9uc2UobSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZSA9IGVycjtcbiAgICAgICAgICAgICAgICBpZiAoKG5lLmNvZGUgPT09IFwiNTAzXCIgfHwgbmUuY29kZSA9PT0gRXJyb3JDb2RlLlRpbWVvdXQpICYmIGkgKyAxIDwgcmV0cmllcykge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBkZWxheShiby5iYWNrb2ZmKGkpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZpbmRTdHJlYW0oc3ViamVjdCkge1xuICAgICAgICBjb25zdCBxID0ge1xuICAgICAgICAgICAgc3ViamVjdFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByID0gYXdhaXQgdGhpcy5fcmVxdWVzdChgJHt0aGlzLnByZWZpeH0uU1RSRUFNLk5BTUVTYCwgcSk7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gcjtcbiAgICAgICAgaWYgKCFuYW1lcy5zdHJlYW1zIHx8IG5hbWVzLnN0cmVhbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBzdHJlYW0gbWF0Y2hlcyBzdWJqZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYW1lcy5zdHJlYW1zWzBdO1xuICAgIH1cbiAgICBnZXRDb25uZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYztcbiAgICB9XG4gICAgcGFyc2VKc1Jlc3BvbnNlKG0pIHtcbiAgICAgICAgY29uc3QgdiA9IHRoaXMuamMuZGVjb2RlKG0uZGF0YSk7XG4gICAgICAgIGNvbnN0IHIgPSB2O1xuICAgICAgICBpZiAoci5lcnJvcikge1xuICAgICAgICAgICAgY29uc3QgZXJyID0gY2hlY2tKc0Vycm9yQ29kZShyLmVycm9yLmNvZGUsIHIuZXJyb3IuZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgaWYgKGVyciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGVyci5hcGlfZXJyb3IgPSByLmVycm9yO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG59XG5jbGFzcyBMaXN0ZXJJbXBsIHtcbiAgICBlcnI7XG4gICAgb2Zmc2V0O1xuICAgIHBhZ2VJbmZvO1xuICAgIHN1YmplY3Q7XG4gICAganNtO1xuICAgIGZpbHRlcjtcbiAgICBwYXlsb2FkO1xuICAgIGNvbnN0cnVjdG9yKHN1YmplY3QsIGZpbHRlciwganNtLCBwYXlsb2FkKXtcbiAgICAgICAgaWYgKCFzdWJqZWN0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWJqZWN0IGlzIHJlcXVpcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IHN1YmplY3Q7XG4gICAgICAgIHRoaXMuanNtID0ganNtO1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMucGFnZUluZm8gPSB7fTtcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQgfHwge307XG4gICAgfVxuICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICAgIGlmICh0aGlzLmVycikge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhZ2VJbmZvICYmIHRoaXMub2Zmc2V0ID49IHRoaXMucGFnZUluZm8udG90YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZzZXQgPSB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnBheWxvYWQpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob2Zmc2V0LCB0aGlzLnBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByID0gYXdhaXQgdGhpcy5qc20uX3JlcXVlc3QodGhpcy5zdWJqZWN0LCBvZmZzZXQsIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aGlzLmpzbS50aW1lb3V0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucGFnZUluZm8gPSByO1xuICAgICAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLmNvdW50UmVzcG9uc2Uocik7XG4gICAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9mZnNldCArPSBjb3VudDtcbiAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzLmZpbHRlcihyKTtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyID0gZXJyO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvdW50UmVzcG9uc2Uocikge1xuICAgICAgICBzd2l0Y2gocj8udHlwZSl7XG4gICAgICAgICAgICBjYXNlIFwiaW8ubmF0cy5qZXRzdHJlYW0uYXBpLnYxLnN0cmVhbV9uYW1lc19yZXNwb25zZVwiOlxuICAgICAgICAgICAgY2FzZSBcImlvLm5hdHMuamV0c3RyZWFtLmFwaS52MS5zdHJlYW1fbGlzdF9yZXNwb25zZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiByLnN0cmVhbXM/Lmxlbmd0aCB8fCAwO1xuICAgICAgICAgICAgY2FzZSBcImlvLm5hdHMuamV0c3RyZWFtLmFwaS52MS5jb25zdW1lcl9saXN0X3Jlc3BvbnNlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIuY29uc3VtZXJzPy5sZW5ndGggfHwgMDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihganNsaXN0ZXIudHM6IHVua25vd24gQVBJIHJlc3BvbnNlIGZvciBwYWdlZCBvdXRwdXQ6ICR7cj8udHlwZX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gci5zdHJlYW1zPy5sZW5ndGggfHwgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIGxldCBwYWdlID0gYXdhaXQgdGhpcy5uZXh0KCk7XG4gICAgICAgIHdoaWxlKHBhZ2UubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgcGFnZSl7XG4gICAgICAgICAgICAgICAgeWllbGQgaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhZ2UgPSBhd2FpdCB0aGlzLm5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlU2VtVmVyKHMgPSBcIlwiKSB7XG4gICAgY29uc3QgbSA9IHMubWF0Y2goLyhcXGQrKS4oXFxkKykuKFxcZCspLyk7XG4gICAgaWYgKG0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1ham9yOiBwYXJzZUludChtWzFdKSxcbiAgICAgICAgICAgIG1pbm9yOiBwYXJzZUludChtWzJdKSxcbiAgICAgICAgICAgIG1pY3JvOiBwYXJzZUludChtWzNdKVxuICAgICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYCcke3N9JyBpcyBub3QgYSBzZW12ZXIgdmFsdWVgKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgIGlmIChhLm1ham9yIDwgYi5tYWpvcikgcmV0dXJuIC0xO1xuICAgIGlmIChhLm1ham9yID4gYi5tYWpvcikgcmV0dXJuIDE7XG4gICAgaWYgKGEubWlub3IgPCBiLm1pbm9yKSByZXR1cm4gLTE7XG4gICAgaWYgKGEubWlub3IgPiBiLm1pbm9yKSByZXR1cm4gMTtcbiAgICBpZiAoYS5taWNybyA8IGIubWljcm8pIHJldHVybiAtMTtcbiAgICBpZiAoYS5taWNybyA+IGIubWljcm8pIHJldHVybiAxO1xuICAgIHJldHVybiAwO1xufVxudmFyIEZlYXR1cmU7XG4oZnVuY3Rpb24oRmVhdHVyZSkge1xuICAgIEZlYXR1cmVbXCJKU19LVlwiXSA9IFwianNfa3ZcIjtcbiAgICBGZWF0dXJlW1wiSlNfT0JKRUNUU1RPUkVcIl0gPSBcImpzX29iamVjdHN0b3JlXCI7XG4gICAgRmVhdHVyZVtcIkpTX1BVTExfTUFYX0JZVEVTXCJdID0gXCJqc19wdWxsX21heF9ieXRlc1wiO1xuICAgIEZlYXR1cmVbXCJKU19ORVdfQ09OU1VNRVJfQ1JFQVRFX0FQSVwiXSA9IFwianNfbmV3X2NvbnN1bWVyX2NyZWF0ZVwiO1xuICAgIEZlYXR1cmVbXCJKU19BTExPV19ESVJFQ1RcIl0gPSBcImpzX2FsbG93X2RpcmVjdFwiO1xuICAgIEZlYXR1cmVbXCJKU19NVUxUSVBMRV9DT05TVU1FUl9GSUxURVJcIl0gPSBcImpzX211bHRpcGxlX2NvbnN1bWVyX2ZpbHRlclwiO1xuICAgIEZlYXR1cmVbXCJKU19TSU1QTElGSUNBVElPTlwiXSA9IFwianNfc2ltcGxpZmljYXRpb25cIjtcbiAgICBGZWF0dXJlW1wiSlNfU1RSRUFNX0NPTlNVTUVSX01FVEFEQVRBXCJdID0gXCJqc19zdHJlYW1fY29uc3VtZXJfbWV0YWRhdGFcIjtcbiAgICBGZWF0dXJlW1wiSlNfQ09OU1VNRVJfRklMVEVSX1NVQkpFQ1RTXCJdID0gXCJqc19jb25zdW1lcl9maWx0ZXJfc3ViamVjdHNcIjtcbiAgICBGZWF0dXJlW1wiSlNfU1RSRUFNX0ZJUlNUX1NFUVwiXSA9IFwianNfc3RyZWFtX2ZpcnN0X3NlcVwiO1xuICAgIEZlYXR1cmVbXCJKU19TVFJFQU1fU1VCSkVDVF9UUkFOU0ZPUk1cIl0gPSBcImpzX3N0cmVhbV9zdWJqZWN0X3RyYW5zZm9ybVwiO1xuICAgIEZlYXR1cmVbXCJKU19TVFJFQU1fU09VUkNFX1NVQkpFQ1RfVFJBTlNGT1JNXCJdID0gXCJqc19zdHJlYW1fc291cmNlX3N1YmplY3RfdHJhbnNmb3JtXCI7XG4gICAgRmVhdHVyZVtcIkpTX1NUUkVBTV9DT01QUkVTU0lPTlwiXSA9IFwianNfc3RyZWFtX2NvbXByZXNzaW9uXCI7XG4gICAgRmVhdHVyZVtcIkpTX0RFRkFVTFRfQ09OU1VNRVJfTElNSVRTXCJdID0gXCJqc19kZWZhdWx0X2NvbnN1bWVyX2xpbWl0c1wiO1xuICAgIEZlYXR1cmVbXCJKU19CQVRDSF9ESVJFQ1RfR0VUXCJdID0gXCJqc19iYXRjaF9kaXJlY3RfZ2V0XCI7XG59KShGZWF0dXJlIHx8IChGZWF0dXJlID0ge30pKTtcbmNsYXNzIEZlYXR1cmVzIHtcbiAgICBzZXJ2ZXI7XG4gICAgZmVhdHVyZXM7XG4gICAgZGlzYWJsZWQ7XG4gICAgY29uc3RydWN0b3Iodil7XG4gICAgICAgIHRoaXMuZmVhdHVyZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBbXTtcbiAgICAgICAgdGhpcy51cGRhdGUodik7XG4gICAgfVxuICAgIHJlc2V0RGlzYWJsZWQoKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy51cGRhdGUodGhpcy5zZXJ2ZXIpO1xuICAgIH1cbiAgICBkaXNhYmxlKGYpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZC5wdXNoKGYpO1xuICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLnNlcnZlcik7XG4gICAgfVxuICAgIGlzRGlzYWJsZWQoZikge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZC5pbmRleE9mKGYpICE9PSAtMTtcbiAgICB9XG4gICAgdXBkYXRlKHYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB2ID0gcGFyc2VTZW1WZXIodik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXJ2ZXIgPSB2O1xuICAgICAgICB0aGlzLnNldChGZWF0dXJlLkpTX0tWLCBcIjIuNi4yXCIpO1xuICAgICAgICB0aGlzLnNldChGZWF0dXJlLkpTX09CSkVDVFNUT1JFLCBcIjIuNi4zXCIpO1xuICAgICAgICB0aGlzLnNldChGZWF0dXJlLkpTX1BVTExfTUFYX0JZVEVTLCBcIjIuOC4zXCIpO1xuICAgICAgICB0aGlzLnNldChGZWF0dXJlLkpTX05FV19DT05TVU1FUl9DUkVBVEVfQVBJLCBcIjIuOS4wXCIpO1xuICAgICAgICB0aGlzLnNldChGZWF0dXJlLkpTX0FMTE9XX0RJUkVDVCwgXCIyLjkuMFwiKTtcbiAgICAgICAgdGhpcy5zZXQoRmVhdHVyZS5KU19NVUxUSVBMRV9DT05TVU1FUl9GSUxURVIsIFwiMi4xMC4wXCIpO1xuICAgICAgICB0aGlzLnNldChGZWF0dXJlLkpTX1NJTVBMSUZJQ0FUSU9OLCBcIjIuOS40XCIpO1xuICAgICAgICB0aGlzLnNldChGZWF0dXJlLkpTX1NUUkVBTV9DT05TVU1FUl9NRVRBREFUQSwgXCIyLjEwLjBcIik7XG4gICAgICAgIHRoaXMuc2V0KEZlYXR1cmUuSlNfQ09OU1VNRVJfRklMVEVSX1NVQkpFQ1RTLCBcIjIuMTAuMFwiKTtcbiAgICAgICAgdGhpcy5zZXQoRmVhdHVyZS5KU19TVFJFQU1fRklSU1RfU0VRLCBcIjIuMTAuMFwiKTtcbiAgICAgICAgdGhpcy5zZXQoRmVhdHVyZS5KU19TVFJFQU1fU1VCSkVDVF9UUkFOU0ZPUk0sIFwiMi4xMC4wXCIpO1xuICAgICAgICB0aGlzLnNldChGZWF0dXJlLkpTX1NUUkVBTV9TT1VSQ0VfU1VCSkVDVF9UUkFOU0ZPUk0sIFwiMi4xMC4wXCIpO1xuICAgICAgICB0aGlzLnNldChGZWF0dXJlLkpTX1NUUkVBTV9DT01QUkVTU0lPTiwgXCIyLjEwLjBcIik7XG4gICAgICAgIHRoaXMuc2V0KEZlYXR1cmUuSlNfREVGQVVMVF9DT05TVU1FUl9MSU1JVFMsIFwiMi4xMC4wXCIpO1xuICAgICAgICB0aGlzLnNldChGZWF0dXJlLkpTX0JBVENIX0RJUkVDVF9HRVQsIFwiMi4xMS4wXCIpO1xuICAgICAgICB0aGlzLmRpc2FibGVkLmZvckVhY2goKGYpPT57XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVzLmRlbGV0ZShmKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldChmLCByZXF1aXJlcykge1xuICAgICAgICB0aGlzLmZlYXR1cmVzLnNldChmLCB7XG4gICAgICAgICAgICBtaW46IHJlcXVpcmVzLFxuICAgICAgICAgICAgb2s6IGNvbXBhcmUodGhpcy5zZXJ2ZXIsIHBhcnNlU2VtVmVyKHJlcXVpcmVzKSkgPj0gMFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0KGYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZXMuZ2V0KGYpIHx8IHtcbiAgICAgICAgICAgIG1pbjogXCJ1bmtub3duXCIsXG4gICAgICAgICAgICBvazogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3VwcG9ydHMoZikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoZik/Lm9rIHx8IGZhbHNlO1xuICAgIH1cbiAgICByZXF1aXJlKHYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB2ID0gcGFyc2VTZW1WZXIodik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcy5zZXJ2ZXIsIHYpID49IDA7XG4gICAgfVxufVxuY2xhc3MgQ29uc3VtZXJBUElJbXBsIGV4dGVuZHMgQmFzZUFwaUNsaWVudCB7XG4gICAgY29uc3RydWN0b3IobmMsIG9wdHMpe1xuICAgICAgICBzdXBlcihuYywgb3B0cyk7XG4gICAgfVxuICAgIGFzeW5jIGFkZChzdHJlYW0sIGNmZywgYWN0aW9uID0gQ29uc3VtZXJBcGlBY3Rpb24uQ3JlYXRlKSB7XG4gICAgICAgIHZhbGlkYXRlU3RyZWFtTmFtZShzdHJlYW0pO1xuICAgICAgICBpZiAoY2ZnLmRlbGl2ZXJfZ3JvdXAgJiYgY2ZnLmZsb3dfY29udHJvbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiamV0c3RyZWFtIGZsb3cgY29udHJvbCBpcyBub3Qgc3VwcG9ydGVkIHdpdGggcXVldWUgZ3JvdXBzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjZmcuZGVsaXZlcl9ncm91cCAmJiBjZmcuaWRsZV9oZWFydGJlYXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImpldHN0cmVhbSBpZGxlIGhlYXJ0YmVhdCBpcyBub3Qgc3VwcG9ydGVkIHdpdGggcXVldWUgZ3JvdXBzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNyID0ge307XG4gICAgICAgIGNyLmNvbmZpZyA9IGNmZztcbiAgICAgICAgY3Iuc3RyZWFtX25hbWUgPSBzdHJlYW07XG4gICAgICAgIGNyLmFjdGlvbiA9IGFjdGlvbjtcbiAgICAgICAgaWYgKGNyLmNvbmZpZy5kdXJhYmxlX25hbWUpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRHVyYWJsZU5hbWUoY3IuY29uZmlnLmR1cmFibGVfbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmNpID0gdGhpcy5uYztcbiAgICAgICAgbGV0IHsgbWluLCBvazogbmV3QVBJIH0gPSBuY2kuZmVhdHVyZXMuZ2V0KEZlYXR1cmUuSlNfTkVXX0NPTlNVTUVSX0NSRUFURV9BUEkpO1xuICAgICAgICBjb25zdCBuYW1lID0gY2ZnLm5hbWUgPT09IFwiXCIgPyB1bmRlZmluZWQgOiBjZmcubmFtZTtcbiAgICAgICAgaWYgKG5hbWUgJiYgIW5ld0FQSSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb25zdW1lciAnbmFtZScgcmVxdWlyZXMgc2VydmVyICR7bWlufWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG1pblZhbGlkYXRpb24oXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IGVyci5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9IG0uaW5kZXhPZihcImNhbm5vdCBjb250YWluXCIpO1xuICAgICAgICAgICAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29uc3VtZXIgJ25hbWUnICR7bS5zdWJzdHJpbmcoaWR4KX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBzdWJqO1xuICAgICAgICBsZXQgY29uc3VtZXJOYW1lID0gXCJcIjtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2ZnLmZpbHRlcl9zdWJqZWN0cykpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbWluLCBvayB9ID0gbmNpLmZlYXR1cmVzLmdldChGZWF0dXJlLkpTX01VTFRJUExFX0NPTlNVTUVSX0ZJTFRFUik7XG4gICAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb25zdW1lciAnZmlsdGVyX3N1YmplY3RzJyByZXF1aXJlcyBzZXJ2ZXIgJHttaW59YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdBUEkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ZnLm1ldGFkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCB7IG1pbiwgb2sgfSA9IG5jaS5mZWF0dXJlcy5nZXQoRmVhdHVyZS5KU19TVFJFQU1fQ09OU1VNRVJfTUVUQURBVEEpO1xuICAgICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29uc3VtZXIgJ21ldGFkYXRhJyByZXF1aXJlcyBzZXJ2ZXIgJHttaW59YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0FQSSkge1xuICAgICAgICAgICAgY29uc3VtZXJOYW1lID0gY2ZnLm5hbWUgPz8gY2ZnLmR1cmFibGVfbmFtZSA/PyBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zdW1lck5hbWUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIGxldCBmcyA9IGNmZy5maWx0ZXJfc3ViamVjdCA/PyB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoZnMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICAgICAgZnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJqID0gZnMgIT09IHVuZGVmaW5lZCA/IGAke3RoaXMucHJlZml4fS5DT05TVU1FUi5DUkVBVEUuJHtzdHJlYW19LiR7Y29uc3VtZXJOYW1lfS4ke2ZzfWAgOiBgJHt0aGlzLnByZWZpeH0uQ09OU1VNRVIuQ1JFQVRFLiR7c3RyZWFtfS4ke2NvbnN1bWVyTmFtZX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3ViaiA9IGNmZy5kdXJhYmxlX25hbWUgPyBgJHt0aGlzLnByZWZpeH0uQ09OU1VNRVIuRFVSQUJMRS5DUkVBVEUuJHtzdHJlYW19LiR7Y2ZnLmR1cmFibGVfbmFtZX1gIDogYCR7dGhpcy5wcmVmaXh9LkNPTlNVTUVSLkNSRUFURS4ke3N0cmVhbX1gO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLl9yZXF1ZXN0KHN1YmosIGNyKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZShzdHJlYW0sIGR1cmFibGUsIGNmZykge1xuICAgICAgICBjb25zdCBjaSA9IGF3YWl0IHRoaXMuaW5mbyhzdHJlYW0sIGR1cmFibGUpO1xuICAgICAgICBjb25zdCBjaGFuZ2FibGUgPSBjZmc7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChzdHJlYW0sIE9iamVjdC5hc3NpZ24oY2kuY29uZmlnLCBjaGFuZ2FibGUpLCBDb25zdW1lckFwaUFjdGlvbi5VcGRhdGUpO1xuICAgIH1cbiAgICBhc3luYyBpbmZvKHN0cmVhbSwgbmFtZSkge1xuICAgICAgICB2YWxpZGF0ZVN0cmVhbU5hbWUoc3RyZWFtKTtcbiAgICAgICAgdmFsaWRhdGVEdXJhYmxlTmFtZShuYW1lKTtcbiAgICAgICAgY29uc3QgciA9IGF3YWl0IHRoaXMuX3JlcXVlc3QoYCR7dGhpcy5wcmVmaXh9LkNPTlNVTUVSLklORk8uJHtzdHJlYW19LiR7bmFtZX1gKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZShzdHJlYW0sIG5hbWUpIHtcbiAgICAgICAgdmFsaWRhdGVTdHJlYW1OYW1lKHN0cmVhbSk7XG4gICAgICAgIHZhbGlkYXRlRHVyYWJsZU5hbWUobmFtZSk7XG4gICAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLl9yZXF1ZXN0KGAke3RoaXMucHJlZml4fS5DT05TVU1FUi5ERUxFVEUuJHtzdHJlYW19LiR7bmFtZX1gKTtcbiAgICAgICAgY29uc3QgY3IgPSByO1xuICAgICAgICByZXR1cm4gY3Iuc3VjY2VzcztcbiAgICB9XG4gICAgbGlzdChzdHJlYW0pIHtcbiAgICAgICAgdmFsaWRhdGVTdHJlYW1OYW1lKHN0cmVhbSk7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9ICh2KT0+e1xuICAgICAgICAgICAgY29uc3QgY2xyID0gdjtcbiAgICAgICAgICAgIHJldHVybiBjbHIuY29uc3VtZXJzO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdWJqID0gYCR7dGhpcy5wcmVmaXh9LkNPTlNVTUVSLkxJU1QuJHtzdHJlYW19YDtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXN0ZXJJbXBsKHN1YmosIGZpbHRlciwgdGhpcyk7XG4gICAgfVxuICAgIHBhdXNlKHN0cmVhbSwgbmFtZSwgdW50aWwpIHtcbiAgICAgICAgY29uc3Qgc3ViaiA9IGAke3RoaXMucHJlZml4fS5DT05TVU1FUi5QQVVTRS4ke3N0cmVhbX0uJHtuYW1lfWA7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgICAgICBwYXVzZV91bnRpbDogdW50aWwudG9JU09TdHJpbmcoKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdChzdWJqLCBvcHRzKTtcbiAgICB9XG4gICAgcmVzdW1lKHN0cmVhbSwgbmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXVzZShzdHJlYW0sIG5hbWUsIG5ldyBEYXRlKDApKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja0ZuKGZuLCBuYW1lLCByZXF1aXJlZCA9IGZhbHNlKSB7XG4gICAgaWYgKHJlcXVpcmVkID09PSB0cnVlICYmICFmbikge1xuICAgICAgICB0aHJvdyBOYXRzRXJyb3IuZXJyb3JGb3JDb2RlKEVycm9yQ29kZS5BcGlFcnJvciwgbmV3IEVycm9yKGAke25hbWV9IGlzIG5vdCBhIGZ1bmN0aW9uYCkpO1xuICAgIH1cbiAgICBpZiAoZm4gJiYgdHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgTmF0c0Vycm9yLmVycm9yRm9yQ29kZShFcnJvckNvZGUuQXBpRXJyb3IsIG5ldyBFcnJvcihgJHtuYW1lfSBpcyBub3QgYSBmdW5jdGlvbmApKTtcbiAgICB9XG59XG5jbGFzcyBUeXBlZFN1YnNjcmlwdGlvbiBleHRlbmRzIFF1ZXVlZEl0ZXJhdG9ySW1wbCB7XG4gICAgc3ViO1xuICAgIGFkYXB0ZXI7XG4gICAgc3ViSXRlckRvbmU7XG4gICAgY29uc3RydWN0b3IobmMsIHN1YmplY3QsIG9wdHMpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBjaGVja0ZuKG9wdHMuYWRhcHRlciwgXCJhZGFwdGVyXCIsIHRydWUpO1xuICAgICAgICB0aGlzLmFkYXB0ZXIgPSBvcHRzLmFkYXB0ZXI7XG4gICAgICAgIGlmIChvcHRzLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjaGVja0ZuKG9wdHMuY2FsbGJhY2ssIFwiY2FsbGJhY2tcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub0l0ZXJhdG9yID0gdHlwZW9mIG9wdHMuY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgaWYgKG9wdHMuaW5nZXN0aW9uRmlsdGVyRm4pIHtcbiAgICAgICAgICAgIGNoZWNrRm4ob3B0cy5pbmdlc3Rpb25GaWx0ZXJGbiwgXCJpbmdlc3Rpb25GaWx0ZXJGblwiKTtcbiAgICAgICAgICAgIHRoaXMuaW5nZXN0aW9uRmlsdGVyRm4gPSBvcHRzLmluZ2VzdGlvbkZpbHRlckZuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLnByb3RvY29sRmlsdGVyRm4pIHtcbiAgICAgICAgICAgIGNoZWNrRm4ob3B0cy5wcm90b2NvbEZpbHRlckZuLCBcInByb3RvY29sRmlsdGVyRm5cIik7XG4gICAgICAgICAgICB0aGlzLnByb3RvY29sRmlsdGVyRm4gPSBvcHRzLnByb3RvY29sRmlsdGVyRm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuZGlzcGF0Y2hlZEZuKSB7XG4gICAgICAgICAgICBjaGVja0ZuKG9wdHMuZGlzcGF0Y2hlZEZuLCBcImRpc3BhdGNoZWRGblwiKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hlZEZuID0gb3B0cy5kaXNwYXRjaGVkRm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuY2xlYW51cEZuKSB7XG4gICAgICAgICAgICBjaGVja0ZuKG9wdHMuY2xlYW51cEZuLCBcImNsZWFudXBGblwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2FsbGJhY2sgPSAoZXJyLCBtc2cpPT57XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrKGVyciwgbXNnKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdHMuY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNvbnN0IHVoID0gb3B0cy5jYWxsYmFjaztcbiAgICAgICAgICAgIGNhbGxiYWNrID0gKGVyciwgbXNnKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IFtqZXIsIHRtXSA9IHRoaXMuYWRhcHRlcihlcnIsIG1zZyk7XG4gICAgICAgICAgICAgICAgaWYgKGplcikge1xuICAgICAgICAgICAgICAgICAgICB1aChqZXIsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgaW5nZXN0IH0gPSB0aGlzLmluZ2VzdGlvbkZpbHRlckZuID8gdGhpcy5pbmdlc3Rpb25GaWx0ZXJGbih0bSwgdGhpcykgOiB7XG4gICAgICAgICAgICAgICAgICAgIGluZ2VzdDogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKGluZ2VzdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvayA9IHRoaXMucHJvdG9jb2xGaWx0ZXJGbiA/IHRoaXMucHJvdG9jb2xGaWx0ZXJGbih0bSkgOiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVoKGplciwgdG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlzcGF0Y2hlZEZuICYmIHRtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGVkRm4odG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG1heCwgcXVldWUsIHRpbWVvdXQgfSA9IG9wdHM7XG4gICAgICAgIGNvbnN0IHNvcHRzID0ge1xuICAgICAgICAgICAgcXVldWUsXG4gICAgICAgICAgICB0aW1lb3V0LFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG1heCAmJiBtYXggPiAwKSB7XG4gICAgICAgICAgICBzb3B0cy5tYXggPSBtYXg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWIgPSBuYy5zdWJzY3JpYmUoc3ViamVjdCwgc29wdHMpO1xuICAgICAgICBpZiAob3B0cy5jbGVhbnVwRm4pIHtcbiAgICAgICAgICAgIHRoaXMuc3ViLmNsZWFudXBGbiA9IG9wdHMuY2xlYW51cEZuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5ub0l0ZXJhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLml0ZXJDbG9zZWQudGhlbigoKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3ViSXRlckRvbmUgPSBkZWZlcnJlZCgpO1xuICAgICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICB0aGlzLnN1Yi5jbG9zZWQsXG4gICAgICAgICAgICB0aGlzLml0ZXJDbG9zZWRcbiAgICAgICAgXSkudGhlbigoKT0+e1xuICAgICAgICAgICAgdGhpcy5zdWJJdGVyRG9uZS5yZXNvbHZlKCk7XG4gICAgICAgIH0pLmNhdGNoKCgpPT57XG4gICAgICAgICAgICB0aGlzLnN1Ykl0ZXJEb25lLnJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIChhc3luYyAocyk9PntcbiAgICAgICAgICAgIGF3YWl0IHMuY2xvc2VkO1xuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIH0pKHRoaXMuc3ViKS50aGVuKCkuY2F0Y2goKTtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmUobWF4KSB7XG4gICAgICAgIHRoaXMuc3ViLnVuc3Vic2NyaWJlKG1heCk7XG4gICAgfVxuICAgIGRyYWluKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIuZHJhaW4oKTtcbiAgICB9XG4gICAgaXNEcmFpbmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViLmlzRHJhaW5pbmcoKTtcbiAgICB9XG4gICAgaXNDbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1Yi5pc0Nsb3NlZCgpO1xuICAgIH1cbiAgICBjYWxsYmFjayhlLCBtc2cpIHtcbiAgICAgICAgdGhpcy5zdWIuY2FuY2VsVGltZW91dCgpO1xuICAgICAgICBjb25zdCBbZXJyLCB0bV0gPSB0aGlzLmFkYXB0ZXIoZSwgbXNnKTtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdGhpcy5zdG9wKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRtKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2godG0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFN1YmplY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1Yi5nZXRTdWJqZWN0KCk7XG4gICAgfVxuICAgIGdldFJlY2VpdmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIuZ2V0UmVjZWl2ZWQoKTtcbiAgICB9XG4gICAgZ2V0UHJvY2Vzc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIuZ2V0UHJvY2Vzc2VkKCk7XG4gICAgfVxuICAgIGdldFBlbmRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1Yi5nZXRQZW5kaW5nKCk7XG4gICAgfVxuICAgIGdldElEKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIuZ2V0SUQoKTtcbiAgICB9XG4gICAgZ2V0TWF4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIuZ2V0TWF4KCk7XG4gICAgfVxuICAgIGdldCBjbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1Yi5jbG9zZWQ7XG4gICAgfVxufVxubGV0IHRyYW5zcG9ydENvbmZpZztcbmZ1bmN0aW9uIHNldFRyYW5zcG9ydEZhY3RvcnkoY29uZmlnKSB7XG4gICAgdHJhbnNwb3J0Q29uZmlnID0gY29uZmlnO1xufVxuZnVuY3Rpb24gZGVmYXVsdFBvcnQoKSB7XG4gICAgcmV0dXJuIHRyYW5zcG9ydENvbmZpZyAhPT0gdW5kZWZpbmVkICYmIHRyYW5zcG9ydENvbmZpZy5kZWZhdWx0UG9ydCAhPT0gdW5kZWZpbmVkID8gdHJhbnNwb3J0Q29uZmlnLmRlZmF1bHRQb3J0IDogNDIyMjtcbn1cbmZ1bmN0aW9uIGdldFVybFBhcnNlRm4oKSB7XG4gICAgcmV0dXJuIHRyYW5zcG9ydENvbmZpZyAhPT0gdW5kZWZpbmVkICYmIHRyYW5zcG9ydENvbmZpZy51cmxQYXJzZUZuID8gdHJhbnNwb3J0Q29uZmlnLnVybFBhcnNlRm4gOiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBuZXdUcmFuc3BvcnQoKSB7XG4gICAgaWYgKCF0cmFuc3BvcnRDb25maWcgfHwgdHlwZW9mIHRyYW5zcG9ydENvbmZpZy5mYWN0b3J5ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJhbnNwb3J0IGZuIGlzIG5vdCBzZXRcIik7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc3BvcnRDb25maWcuZmFjdG9yeSgpO1xufVxuZnVuY3Rpb24gZ2V0UmVzb2x2ZUZuKCkge1xuICAgIHJldHVybiB0cmFuc3BvcnRDb25maWcgIT09IHVuZGVmaW5lZCAmJiB0cmFuc3BvcnRDb25maWcuZG5zUmVzb2x2ZUZuID8gdHJhbnNwb3J0Q29uZmlnLmRuc1Jlc29sdmVGbiA6IHVuZGVmaW5lZDtcbn1cbmNvbnN0IENSX0xGID0gXCJcXHJcXG5cIjtcbkNSX0xGLmxlbmd0aDtcbmNvbnN0IENSTEYgPSBEYXRhQnVmZmVyLmZyb21Bc2NpaShDUl9MRik7XG5jb25zdCBDUiA9IG5ldyBVaW50OEFycmF5KENSTEYpWzBdO1xuY29uc3QgTEYgPSBuZXcgVWludDhBcnJheShDUkxGKVsxXTtcbmZ1bmN0aW9uIHByb3RvTGVuKGJhKSB7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGJhLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgY29uc3QgbiA9IGkgKyAxO1xuICAgICAgICBpZiAoYmEuYnl0ZUxlbmd0aCA+IG4gJiYgYmFbaV0gPT09IENSICYmIGJhW25dID09PSBMRikge1xuICAgICAgICAgICAgcmV0dXJuIG4gKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gZXh0cmFjdFByb3RvY29sTWVzc2FnZShhKSB7XG4gICAgY29uc3QgbGVuID0gcHJvdG9MZW4oYSk7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgY29uc3QgYmEgPSBuZXcgVWludDhBcnJheShhKTtcbiAgICAgICAgY29uc3Qgb3V0ID0gYmEuc2xpY2UoMCwgbGVuKTtcbiAgICAgICAgcmV0dXJuIFRELmRlY29kZShvdXQpO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbn1cbmNvbnN0IElQdjRMRU4gPSA0O1xuY29uc3QgQVNDSUkwID0gNDg7XG5jb25zdCBBU0NJSUEgPSA2NTtcbmNvbnN0IEFTQ0lJYSA9IDk3O1xuZnVuY3Rpb24gaXBWNChhLCBiLCBjLCBkKSB7XG4gICAgY29uc3QgaXAgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgY29uc3QgcHJlZml4ID0gW1xuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAweGZmLFxuICAgICAgICAweGZmXG4gICAgXTtcbiAgICBwcmVmaXguZm9yRWFjaCgodiwgaWR4KT0+e1xuICAgICAgICBpcFtpZHhdID0gdjtcbiAgICB9KTtcbiAgICBpcFsxMl0gPSBhO1xuICAgIGlwWzEzXSA9IGI7XG4gICAgaXBbMTRdID0gYztcbiAgICBpcFsxNV0gPSBkO1xuICAgIHJldHVybiBpcDtcbn1cbmZ1bmN0aW9uIGlzSVAoaCkge1xuICAgIHJldHVybiBwYXJzZUlQKGgpICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBwYXJzZUlQKGgpIHtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgaC5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHN3aXRjaChoW2ldKXtcbiAgICAgICAgICAgIGNhc2UgXCIuXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSVB2NChoKTtcbiAgICAgICAgICAgIGNhc2UgXCI6XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSVB2NihoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG59XG5mdW5jdGlvbiBwYXJzZUlQdjQocykge1xuICAgIGNvbnN0IGlwID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IDQ7IGkrKyl7XG4gICAgICAgIGlmIChzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGlmIChzWzBdICE9PSBcIi5cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzID0gcy5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBuLCBjLCBvayB9ID0gZHRvaShzKTtcbiAgICAgICAgaWYgKCFvayB8fCBuID4gMHhGRikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBzID0gcy5zdWJzdHJpbmcoYyk7XG4gICAgICAgIGlwW2ldID0gbjtcbiAgICB9XG4gICAgcmV0dXJuIGlwVjQoaXBbMF0sIGlwWzFdLCBpcFsyXSwgaXBbM10pO1xufVxuZnVuY3Rpb24gcGFyc2VJUHY2KHMpIHtcbiAgICBjb25zdCBpcCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICBsZXQgZWxsaXBzaXMgPSAtMTtcbiAgICBpZiAocy5sZW5ndGggPj0gMiAmJiBzWzBdID09PSBcIjpcIiAmJiBzWzFdID09PSBcIjpcIikge1xuICAgICAgICBlbGxpcHNpcyA9IDA7XG4gICAgICAgIHMgPSBzLnN1YnN0cmluZygyKTtcbiAgICAgICAgaWYgKHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gaXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlKGkgPCAxNil7XG4gICAgICAgIGNvbnN0IHsgbiwgYywgb2sgfSA9IHh0b2kocyk7XG4gICAgICAgIGlmICghb2sgfHwgbiA+IDB4RkZGRikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA8IHMubGVuZ3RoICYmIHNbY10gPT09IFwiLlwiKSB7XG4gICAgICAgICAgICBpZiAoZWxsaXBzaXMgPCAwICYmIGkgIT0gMTYgLSA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpICsgNCA+IDE2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlwNCA9IHBhcnNlSVB2NChzKTtcbiAgICAgICAgICAgIGlmIChpcDQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpcFtpXSA9IGlwNFsxMl07XG4gICAgICAgICAgICBpcFtpICsgMV0gPSBpcDRbMTNdO1xuICAgICAgICAgICAgaXBbaSArIDJdID0gaXA0WzE0XTtcbiAgICAgICAgICAgIGlwW2kgKyAzXSA9IGlwNFsxNV07XG4gICAgICAgICAgICBzID0gXCJcIjtcbiAgICAgICAgICAgIGkgKz0gSVB2NExFTjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlwW2ldID0gbiA+PiA4O1xuICAgICAgICBpcFtpICsgMV0gPSBuO1xuICAgICAgICBpICs9IDI7XG4gICAgICAgIHMgPSBzLnN1YnN0cmluZyhjKTtcbiAgICAgICAgaWYgKHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc1swXSAhPT0gXCI6XCIgfHwgcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBzID0gcy5zdWJzdHJpbmcoMSk7XG4gICAgICAgIGlmIChzWzBdID09PSBcIjpcIikge1xuICAgICAgICAgICAgaWYgKGVsbGlwc2lzID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxsaXBzaXMgPSBpO1xuICAgICAgICAgICAgcyA9IHMuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgaWYgKHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChpIDwgMTYpIHtcbiAgICAgICAgaWYgKGVsbGlwc2lzIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuID0gMTYgLSBpO1xuICAgICAgICBmb3IobGV0IGogPSBpIC0gMTsgaiA+PSBlbGxpcHNpczsgai0tKXtcbiAgICAgICAgICAgIGlwW2ogKyBuXSA9IGlwW2pdO1xuICAgICAgICB9XG4gICAgICAgIGZvcihsZXQgaiA9IGVsbGlwc2lzICsgbiAtIDE7IGogPj0gZWxsaXBzaXM7IGotLSl7XG4gICAgICAgICAgICBpcFtqXSA9IDA7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsbGlwc2lzID49IDApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGlwO1xufVxuZnVuY3Rpb24gZHRvaShzKSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBuID0gMDtcbiAgICBmb3IoaSA9IDA7IGkgPCBzLmxlbmd0aCAmJiA0OCA8PSBzLmNoYXJDb2RlQXQoaSkgJiYgcy5jaGFyQ29kZUF0KGkpIDw9IDU3OyBpKyspe1xuICAgICAgICBuID0gbiAqIDEwICsgKHMuY2hhckNvZGVBdChpKSAtIEFTQ0lJMCk7XG4gICAgICAgIGlmIChuID49IDB4RkZGRkZGKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG46IDB4RkZGRkZGLFxuICAgICAgICAgICAgICAgIGM6IGksXG4gICAgICAgICAgICAgICAgb2s6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuOiAwLFxuICAgICAgICAgICAgYzogMCxcbiAgICAgICAgICAgIG9rOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBuOiBuLFxuICAgICAgICBjOiBpLFxuICAgICAgICBvazogdHJ1ZVxuICAgIH07XG59XG5mdW5jdGlvbiB4dG9pKHMpIHtcbiAgICBsZXQgbiA9IDA7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvcihpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspe1xuICAgICAgICBpZiAoNDggPD0gcy5jaGFyQ29kZUF0KGkpICYmIHMuY2hhckNvZGVBdChpKSA8PSA1Nykge1xuICAgICAgICAgICAgbiAqPSAxNjtcbiAgICAgICAgICAgIG4gKz0gcy5jaGFyQ29kZUF0KGkpIC0gQVNDSUkwO1xuICAgICAgICB9IGVsc2UgaWYgKDk3IDw9IHMuY2hhckNvZGVBdChpKSAmJiBzLmNoYXJDb2RlQXQoaSkgPD0gMTAyKSB7XG4gICAgICAgICAgICBuICo9IDE2O1xuICAgICAgICAgICAgbiArPSBzLmNoYXJDb2RlQXQoaSkgLSBBU0NJSWEgKyAxMDtcbiAgICAgICAgfSBlbHNlIGlmICg2NSA8PSBzLmNoYXJDb2RlQXQoaSkgJiYgcy5jaGFyQ29kZUF0KGkpIDw9IDcwKSB7XG4gICAgICAgICAgICBuICo9IDE2O1xuICAgICAgICAgICAgbiArPSBzLmNoYXJDb2RlQXQoaSkgLSBBU0NJSUEgKyAxMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuID49IDB4RkZGRkZGKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG46IDAsXG4gICAgICAgICAgICAgICAgYzogaSxcbiAgICAgICAgICAgICAgICBvazogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG46IDAsXG4gICAgICAgICAgICBjOiBpLFxuICAgICAgICAgICAgb2s6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG46IG4sXG4gICAgICAgIGM6IGksXG4gICAgICAgIG9rOiB0cnVlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGlzSVBWNE9ySG9zdG5hbWUoaHApIHtcbiAgICBpZiAoaHAuaW5kZXhPZihcIltcIikgIT09IC0xIHx8IGhwLmluZGV4T2YoXCI6OlwiKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaHAuaW5kZXhPZihcIi5cIikgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoaHAuc3BsaXQoXCI6XCIpLmxlbmd0aCA8PSAyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0lQVjYoaHApIHtcbiAgICByZXR1cm4gIWlzSVBWNE9ySG9zdG5hbWUoaHApO1xufVxuZnVuY3Rpb24gZmlsdGVySXB2Nk1hcHBlZFRvSXB2NChocCkge1xuICAgIGNvbnN0IHByZWZpeCA9IFwiOjpGRkZGOlwiO1xuICAgIGNvbnN0IGlkeCA9IGhwLnRvVXBwZXJDYXNlKCkuaW5kZXhPZihwcmVmaXgpO1xuICAgIGlmIChpZHggIT09IC0xICYmIGhwLmluZGV4T2YoXCIuXCIpICE9PSAtMSkge1xuICAgICAgICBsZXQgaXAgPSBocC5zdWJzdHJpbmcoaWR4ICsgcHJlZml4Lmxlbmd0aCk7XG4gICAgICAgIGlwID0gaXAucmVwbGFjZShcIltcIiwgXCJcIik7XG4gICAgICAgIHJldHVybiBpcC5yZXBsYWNlKFwiXVwiLCBcIlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGhwO1xufVxuZnVuY3Rpb24gaG9zdFBvcnQodSkge1xuICAgIHUgPSB1LnRyaW0oKTtcbiAgICBpZiAodS5tYXRjaCgvXiguKjpcXC9cXC8pKC4qKS9tKSkge1xuICAgICAgICB1ID0gdS5yZXBsYWNlKC9eKC4qOlxcL1xcLykoLiopL2dtLCBcIiQyXCIpO1xuICAgIH1cbiAgICB1ID0gZmlsdGVySXB2Nk1hcHBlZFRvSXB2NCh1KTtcbiAgICBpZiAoaXNJUFY2KHUpICYmIHUuaW5kZXhPZihcIltcIikgPT09IC0xKSB7XG4gICAgICAgIHUgPSBgWyR7dX1dYDtcbiAgICB9XG4gICAgY29uc3Qgb3AgPSBpc0lQVjYodSkgPyB1Lm1hdGNoKC8oXTopKFxcZCspLykgOiB1Lm1hdGNoKC8oOikoXFxkKykvKTtcbiAgICBjb25zdCBwb3J0ID0gb3AgJiYgb3AubGVuZ3RoID09PSAzICYmIG9wWzFdICYmIG9wWzJdID8gcGFyc2VJbnQob3BbMl0pIDogNDIyMjtcbiAgICBjb25zdCBwcm90b2NvbCA9IHBvcnQgPT09IDgwID8gXCJodHRwc1wiIDogXCJodHRwXCI7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHtwcm90b2NvbH06Ly8ke3V9YCk7XG4gICAgdXJsLnBvcnQgPSBgJHtwb3J0fWA7XG4gICAgbGV0IGhvc3RuYW1lID0gdXJsLmhvc3RuYW1lO1xuICAgIGlmIChob3N0bmFtZS5jaGFyQXQoMCkgPT09IFwiW1wiKSB7XG4gICAgICAgIGhvc3RuYW1lID0gaG9zdG5hbWUuc3Vic3RyaW5nKDEsIGhvc3RuYW1lLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICBjb25zdCBsaXN0ZW4gPSB1cmwuaG9zdDtcbiAgICByZXR1cm4ge1xuICAgICAgICBsaXN0ZW4sXG4gICAgICAgIGhvc3RuYW1lLFxuICAgICAgICBwb3J0XG4gICAgfTtcbn1cbmNsYXNzIFNlcnZlckltcGwge1xuICAgIHNyYztcbiAgICBsaXN0ZW47XG4gICAgaG9zdG5hbWU7XG4gICAgcG9ydDtcbiAgICBkaWRDb25uZWN0O1xuICAgIHJlY29ubmVjdHM7XG4gICAgbGFzdENvbm5lY3Q7XG4gICAgZ29zc2lwZWQ7XG4gICAgdGxzTmFtZTtcbiAgICByZXNvbHZlcztcbiAgICBjb25zdHJ1Y3Rvcih1LCBnb3NzaXBlZCA9IGZhbHNlKXtcbiAgICAgICAgdGhpcy5zcmMgPSB1O1xuICAgICAgICB0aGlzLnRsc05hbWUgPSBcIlwiO1xuICAgICAgICBjb25zdCB2ID0gaG9zdFBvcnQodSk7XG4gICAgICAgIHRoaXMubGlzdGVuID0gdi5saXN0ZW47XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2Lmhvc3RuYW1lO1xuICAgICAgICB0aGlzLnBvcnQgPSB2LnBvcnQ7XG4gICAgICAgIHRoaXMuZGlkQ29ubmVjdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlY29ubmVjdHMgPSAwO1xuICAgICAgICB0aGlzLmxhc3RDb25uZWN0ID0gMDtcbiAgICAgICAgdGhpcy5nb3NzaXBlZCA9IGdvc3NpcGVkO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuO1xuICAgIH1cbiAgICBhc3luYyByZXNvbHZlKG9wdHMpIHtcbiAgICAgICAgaWYgKCFvcHRzLmZuIHx8IG9wdHMucmVzb2x2ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWYgPSBbXTtcbiAgICAgICAgaWYgKGlzSVAodGhpcy5ob3N0bmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGlwcyA9IGF3YWl0IG9wdHMuZm4odGhpcy5ob3N0bmFtZSk7XG4gICAgICAgICAgICBpZiAob3B0cy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGByZXNvbHZlICR7dGhpcy5ob3N0bmFtZX0gPSAke2lwcy5qb2luKFwiLFwiKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgaXAgb2YgaXBzKXtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm90byA9IHRoaXMucG9ydCA9PT0gODAgPyBcImh0dHBzXCIgOiBcImh0dHBcIjtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke3Byb3RvfTovLyR7aXNJUFY2KGlwKSA/IFwiW1wiICsgaXAgKyBcIl1cIiA6IGlwfWApO1xuICAgICAgICAgICAgICAgIHVybC5wb3J0ID0gYCR7dGhpcy5wb3J0fWA7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3MgPSBuZXcgU2VydmVySW1wbCh1cmwuaG9zdCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHNzLnRsc05hbWUgPSB0aGlzLmhvc3RuYW1lO1xuICAgICAgICAgICAgICAgIGJ1Zi5wdXNoKHNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5yYW5kb21pemUpIHtcbiAgICAgICAgICAgIHNodWZmbGUoYnVmKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc29sdmVzID0gYnVmO1xuICAgICAgICByZXR1cm4gYnVmO1xuICAgIH1cbn1cbmNsYXNzIFNlcnZlcnMge1xuICAgIGZpcnN0U2VsZWN0O1xuICAgIHNlcnZlcnM7XG4gICAgY3VycmVudFNlcnZlcjtcbiAgICB0bHNOYW1lO1xuICAgIHJhbmRvbWl6ZTtcbiAgICBjb25zdHJ1Y3RvcihsaXN0ZW5zID0gW10sIG9wdHMgPSB7fSl7XG4gICAgICAgIHRoaXMuZmlyc3RTZWxlY3QgPSB0cnVlO1xuICAgICAgICB0aGlzLnNlcnZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy50bHNOYW1lID0gXCJcIjtcbiAgICAgICAgdGhpcy5yYW5kb21pemUgPSBvcHRzLnJhbmRvbWl6ZSB8fCBmYWxzZTtcbiAgICAgICAgY29uc3QgdXJsUGFyc2VGbiA9IGdldFVybFBhcnNlRm4oKTtcbiAgICAgICAgaWYgKGxpc3RlbnMpIHtcbiAgICAgICAgICAgIGxpc3RlbnMuZm9yRWFjaCgoaHApPT57XG4gICAgICAgICAgICAgICAgaHAgPSB1cmxQYXJzZUZuID8gdXJsUGFyc2VGbihocCkgOiBocDtcbiAgICAgICAgICAgICAgICB0aGlzLnNlcnZlcnMucHVzaChuZXcgU2VydmVySW1wbChocCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5yYW5kb21pemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlcnZlcnMgPSBzaHVmZmxlKHRoaXMuc2VydmVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2VydmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuYWRkU2VydmVyKGAke0RFRkFVTFRfSE9TVH06JHtkZWZhdWx0UG9ydCgpfWAsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRTZXJ2ZXIgPSB0aGlzLnNlcnZlcnNbMF07XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnNlcnZlcnMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgdXBkYXRlVExTTmFtZSgpIHtcbiAgICAgICAgY29uc3QgY3MgPSB0aGlzLmdldEN1cnJlbnRTZXJ2ZXIoKTtcbiAgICAgICAgaWYgKCFpc0lQKGNzLmhvc3RuYW1lKSkge1xuICAgICAgICAgICAgdGhpcy50bHNOYW1lID0gY3MuaG9zdG5hbWU7XG4gICAgICAgICAgICB0aGlzLnNlcnZlcnMuZm9yRWFjaCgocyk9PntcbiAgICAgICAgICAgICAgICBpZiAocy5nb3NzaXBlZCkge1xuICAgICAgICAgICAgICAgICAgICBzLnRsc05hbWUgPSB0aGlzLnRsc05hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q3VycmVudFNlcnZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFNlcnZlcjtcbiAgICB9XG4gICAgYWRkU2VydmVyKHUsIGltcGxpY2l0ID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgdXJsUGFyc2VGbiA9IGdldFVybFBhcnNlRm4oKTtcbiAgICAgICAgdSA9IHVybFBhcnNlRm4gPyB1cmxQYXJzZUZuKHUpIDogdTtcbiAgICAgICAgY29uc3QgcyA9IG5ldyBTZXJ2ZXJJbXBsKHUsIGltcGxpY2l0KTtcbiAgICAgICAgaWYgKGlzSVAocy5ob3N0bmFtZSkpIHtcbiAgICAgICAgICAgIHMudGxzTmFtZSA9IHRoaXMudGxzTmFtZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlcnZlcnMucHVzaChzKTtcbiAgICB9XG4gICAgc2VsZWN0U2VydmVyKCkge1xuICAgICAgICBpZiAodGhpcy5maXJzdFNlbGVjdCkge1xuICAgICAgICAgICAgdGhpcy5maXJzdFNlbGVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFNlcnZlcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ID0gdGhpcy5zZXJ2ZXJzLnNoaWZ0KCk7XG4gICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgICB0aGlzLnNlcnZlcnMucHVzaCh0KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNlcnZlciA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuICAgIHJlbW92ZUN1cnJlbnRTZXJ2ZXIoKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlU2VydmVyKHRoaXMuY3VycmVudFNlcnZlcik7XG4gICAgfVxuICAgIHJlbW92ZVNlcnZlcihzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKHNlcnZlcikge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnNlcnZlcnMuaW5kZXhPZihzZXJ2ZXIpO1xuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2ZXJzLmxlbmd0aDtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmVycy5sZW5ndGggPyB0aGlzLnNlcnZlcnNbMF0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldFNlcnZlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZlcnM7XG4gICAgfVxuICAgIHVwZGF0ZShpbmZvLCBlbmNyeXB0ZWQpIHtcbiAgICAgICAgY29uc3QgYWRkZWQgPSBbXTtcbiAgICAgICAgbGV0IGRlbGV0ZWQgPSBbXTtcbiAgICAgICAgY29uc3QgdXJsUGFyc2VGbiA9IGdldFVybFBhcnNlRm4oKTtcbiAgICAgICAgY29uc3QgZGlzY292ZXJlZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKGluZm8uY29ubmVjdF91cmxzICYmIGluZm8uY29ubmVjdF91cmxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGluZm8uY29ubmVjdF91cmxzLmZvckVhY2goKGhwKT0+e1xuICAgICAgICAgICAgICAgIGhwID0gdXJsUGFyc2VGbiA/IHVybFBhcnNlRm4oaHAsIGVuY3J5cHRlZCkgOiBocDtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gbmV3IFNlcnZlckltcGwoaHAsIHRydWUpO1xuICAgICAgICAgICAgICAgIGRpc2NvdmVyZWQuc2V0KGhwLCBzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvRGVsZXRlID0gW107XG4gICAgICAgIHRoaXMuc2VydmVycy5mb3JFYWNoKChzLCBpbmRleCk9PntcbiAgICAgICAgICAgIGNvbnN0IHUgPSBzLmxpc3RlbjtcbiAgICAgICAgICAgIGlmIChzLmdvc3NpcGVkICYmIHRoaXMuY3VycmVudFNlcnZlci5saXN0ZW4gIT09IHUgJiYgZGlzY292ZXJlZC5nZXQodSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRvRGVsZXRlLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzY292ZXJlZC5kZWxldGUodSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0b0RlbGV0ZS5yZXZlcnNlKCk7XG4gICAgICAgIHRvRGVsZXRlLmZvckVhY2goKGluZGV4KT0+e1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZCA9IHRoaXMuc2VydmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgZGVsZXRlZCA9IGRlbGV0ZWQuY29uY2F0KHJlbW92ZWRbMF0ubGlzdGVuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRpc2NvdmVyZWQuZm9yRWFjaCgodiwgayk9PntcbiAgICAgICAgICAgIHRoaXMuc2VydmVycy5wdXNoKHYpO1xuICAgICAgICAgICAgYWRkZWQucHVzaChrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRlZCxcbiAgICAgICAgICAgIGRlbGV0ZWRcbiAgICAgICAgfTtcbiAgICB9XG59XG5jbGFzcyBNdXhTdWJzY3JpcHRpb24ge1xuICAgIGJhc2VJbmJveDtcbiAgICByZXFzO1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMucmVxcyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxcy5zaXplO1xuICAgIH1cbiAgICBpbml0KHByZWZpeCkge1xuICAgICAgICB0aGlzLmJhc2VJbmJveCA9IGAke2NyZWF0ZUluYm94KHByZWZpeCl9LmA7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VJbmJveDtcbiAgICB9XG4gICAgYWRkKHIpIHtcbiAgICAgICAgaWYgKCFpc05hTihyLnJlY2VpdmVkKSkge1xuICAgICAgICAgICAgci5yZWNlaXZlZCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXFzLnNldChyLnRva2VuLCByKTtcbiAgICB9XG4gICAgZ2V0KHRva2VuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXMuZ2V0KHRva2VuKTtcbiAgICB9XG4gICAgY2FuY2VsKHIpIHtcbiAgICAgICAgdGhpcy5yZXFzLmRlbGV0ZShyLnRva2VuKTtcbiAgICB9XG4gICAgZ2V0VG9rZW4obSkge1xuICAgICAgICBjb25zdCBzID0gbS5zdWJqZWN0IHx8IFwiXCI7XG4gICAgICAgIGlmIChzLmluZGV4T2YodGhpcy5iYXNlSW5ib3gpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcy5zdWJzdHJpbmcodGhpcy5iYXNlSW5ib3gubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYWxsKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnJlcXMudmFsdWVzKCkpO1xuICAgIH1cbiAgICBoYW5kbGVFcnJvcihpc011eFBlcm1pc3Npb25FcnJvciwgZXJyKSB7XG4gICAgICAgIGlmIChlcnIgJiYgZXJyLnBlcm1pc3Npb25Db250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoaXNNdXhQZXJtaXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFsbCgpLmZvckVhY2goKHIpPT57XG4gICAgICAgICAgICAgICAgICAgIHIucmVzb2x2ZXIoZXJyLCB7fSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjdHggPSBlcnIucGVybWlzc2lvbkNvbnRleHQ7XG4gICAgICAgICAgICBpZiAoY3R4Lm9wZXJhdGlvbiA9PT0gXCJwdWJsaXNoXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXEgPSB0aGlzLmFsbCgpLmZpbmQoKHMpPT57XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzLnJlcXVlc3RTdWJqZWN0ID09PSBjdHguc3ViamVjdDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5yZXNvbHZlcihlcnIsIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGlzcGF0Y2hlcigpIHtcbiAgICAgICAgcmV0dXJuIChlcnIsIG0pPT57XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMuZ2V0VG9rZW4obSk7XG4gICAgICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCByID0gdGhpcy5nZXQodG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIgPT09IG51bGwgJiYgbS5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBpc1JlcXVlc3RFcnJvcihtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByLnJlc29sdmVyKGVyciwgbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgY29uc3QgZXJyID0gTmF0c0Vycm9yLmVycm9yRm9yQ29kZShFcnJvckNvZGUuVGltZW91dCk7XG4gICAgICAgIHRoaXMucmVxcy5mb3JFYWNoKChyZXEpPT57XG4gICAgICAgICAgICByZXEucmVzb2x2ZXIoZXJyLCB7fSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIEhlYXJ0YmVhdCB7XG4gICAgcGg7XG4gICAgaW50ZXJ2YWw7XG4gICAgbWF4T3V0O1xuICAgIHRpbWVyO1xuICAgIHBlbmRpbmdzO1xuICAgIGNvbnN0cnVjdG9yKHBoLCBpbnRlcnZhbCwgbWF4T3V0KXtcbiAgICAgICAgdGhpcy5waCA9IHBoO1xuICAgICAgICB0aGlzLmludGVydmFsID0gaW50ZXJ2YWw7XG4gICAgICAgIHRoaXMubWF4T3V0ID0gbWF4T3V0O1xuICAgICAgICB0aGlzLnBlbmRpbmdzID0gW107XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICB0aGlzLl9zY2hlZHVsZSgpO1xuICAgIH1cbiAgICBjYW5jZWwoc3RhbGUpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMudGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgICAgaWYgKHN0YWxlKSB7XG4gICAgICAgICAgICB0aGlzLnBoLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfc2NoZWR1bGUoKSB7XG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICB0aGlzLnBoLmRpc3BhdGNoU3RhdHVzKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBEZWJ1Z0V2ZW50cy5QaW5nVGltZXIsXG4gICAgICAgICAgICAgICAgZGF0YTogYCR7dGhpcy5wZW5kaW5ncy5sZW5ndGggKyAxfWBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ3MubGVuZ3RoID09PSB0aGlzLm1heE91dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsKHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBpbmcgPSBkZWZlcnJlZCgpO1xuICAgICAgICAgICAgdGhpcy5waC5mbHVzaChwaW5nKS50aGVuKCgpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKCgpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5ncy5wdXNoKHBpbmcpO1xuICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGUoKTtcbiAgICAgICAgfSwgdGhpcy5pbnRlcnZhbCk7XG4gICAgfVxuICAgIF9yZXNldCgpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5ncyA9IHRoaXMucGVuZGluZ3MuZmlsdGVyKChwKT0+e1xuICAgICAgICAgICAgY29uc3QgZCA9IHA7XG4gICAgICAgICAgICBkLnJlc29sdmUoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgQXNzZXJ0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobXNnKXtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJBc3NlcnRpb25FcnJvclwiO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2VydChjb25kLCBtc2cgPSBcIkFzc2VydGlvbiBmYWlsZWQuXCIpIHtcbiAgICBpZiAoIWNvbmQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKG1zZyk7XG4gICAgfVxufVxuY29uc3QgTUlOX1JFQUQgPSAzMiAqIDEwMjQ7XG5jb25zdCBNQVhfU0laRSA9IDIgKiogMzIgLSAyO1xuZnVuY3Rpb24gY29weShzcmMsIGRzdCwgb2ZmID0gMCkge1xuICAgIGNvbnN0IHIgPSBkc3QuYnl0ZUxlbmd0aCAtIG9mZjtcbiAgICBpZiAoc3JjLmJ5dGVMZW5ndGggPiByKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJhcnJheSgwLCByKTtcbiAgICB9XG4gICAgZHN0LnNldChzcmMsIG9mZik7XG4gICAgcmV0dXJuIHNyYy5ieXRlTGVuZ3RoO1xufVxuY2xhc3MgRGVub0J1ZmZlciB7XG4gICAgX2J1ZjtcbiAgICBfb2ZmO1xuICAgIGNvbnN0cnVjdG9yKGFiKXtcbiAgICAgICAgdGhpcy5fb2ZmID0gMDtcbiAgICAgICAgaWYgKGFiID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZiA9IG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2J1ZiA9IG5ldyBVaW50OEFycmF5KGFiKTtcbiAgICB9XG4gICAgYnl0ZXMob3B0aW9ucyA9IHtcbiAgICAgICAgY29weTogdHJ1ZVxuICAgIH0pIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29weSA9PT0gZmFsc2UpIHJldHVybiB0aGlzLl9idWYuc3ViYXJyYXkodGhpcy5fb2ZmKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1Zi5zbGljZSh0aGlzLl9vZmYpO1xuICAgIH1cbiAgICBlbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1Zi5ieXRlTGVuZ3RoIDw9IHRoaXMuX29mZjtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1Zi5ieXRlTGVuZ3RoIC0gdGhpcy5fb2ZmO1xuICAgIH1cbiAgICBnZXQgY2FwYWNpdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWYuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHRydW5jYXRlKG4pIHtcbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobiA8IDAgfHwgbiA+IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImJ5dGVzLkJ1ZmZlcjogdHJ1bmNhdGlvbiBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVzbGljZSh0aGlzLl9vZmYgKyBuKTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuX3Jlc2xpY2UoMCk7XG4gICAgICAgIHRoaXMuX29mZiA9IDA7XG4gICAgfVxuICAgIF90cnlHcm93QnlSZXNsaWNlKG4pIHtcbiAgICAgICAgY29uc3QgbCA9IHRoaXMuX2J1Zi5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAobiA8PSB0aGlzLmNhcGFjaXR5IC0gbCkge1xuICAgICAgICAgICAgdGhpcy5fcmVzbGljZShsICsgbik7XG4gICAgICAgICAgICByZXR1cm4gbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIF9yZXNsaWNlKGxlbikge1xuICAgICAgICBhc3NlcnQobGVuIDw9IHRoaXMuX2J1Zi5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHRoaXMuX2J1ZiA9IG5ldyBVaW50OEFycmF5KHRoaXMuX2J1Zi5idWZmZXIsIDAsIGxlbik7XG4gICAgfVxuICAgIHJlYWRCeXRlKCkge1xuICAgICAgICBjb25zdCBhID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgICAgIGlmICh0aGlzLnJlYWQoYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBhWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZWFkKHApIHtcbiAgICAgICAgaWYgKHRoaXMuZW1wdHkoKSkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgaWYgKHAuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbnJlYWQgPSBjb3B5KHRoaXMuX2J1Zi5zdWJhcnJheSh0aGlzLl9vZmYpLCBwKTtcbiAgICAgICAgdGhpcy5fb2ZmICs9IG5yZWFkO1xuICAgICAgICByZXR1cm4gbnJlYWQ7XG4gICAgfVxuICAgIHdyaXRlQnl0ZShuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlKFVpbnQ4QXJyYXkub2YobikpO1xuICAgIH1cbiAgICB3cml0ZVN0cmluZyhzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlKFRFLmVuY29kZShzKSk7XG4gICAgfVxuICAgIHdyaXRlKHApIHtcbiAgICAgICAgY29uc3QgbSA9IHRoaXMuX2dyb3cocC5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGNvcHkocCwgdGhpcy5fYnVmLCBtKTtcbiAgICB9XG4gICAgX2dyb3cobikge1xuICAgICAgICBjb25zdCBtID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmIChtID09PSAwICYmIHRoaXMuX29mZiAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLl90cnlHcm93QnlSZXNsaWNlKG4pO1xuICAgICAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjID0gdGhpcy5jYXBhY2l0eTtcbiAgICAgICAgaWYgKG4gPD0gTWF0aC5mbG9vcihjIC8gMikgLSBtKSB7XG4gICAgICAgICAgICBjb3B5KHRoaXMuX2J1Zi5zdWJhcnJheSh0aGlzLl9vZmYpLCB0aGlzLl9idWYpO1xuICAgICAgICB9IGVsc2UgaWYgKGMgKyBuID4gTUFYX1NJWkUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBidWZmZXIgY2Fubm90IGJlIGdyb3duIGJleW9uZCB0aGUgbWF4aW11bSBzaXplLlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KE1hdGgubWluKDIgKiBjICsgbiwgTUFYX1NJWkUpKTtcbiAgICAgICAgICAgIGNvcHkodGhpcy5fYnVmLnN1YmFycmF5KHRoaXMuX29mZiksIGJ1Zik7XG4gICAgICAgICAgICB0aGlzLl9idWYgPSBidWY7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb2ZmID0gMDtcbiAgICAgICAgdGhpcy5fcmVzbGljZShNYXRoLm1pbihtICsgbiwgTUFYX1NJWkUpKTtcbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuICAgIGdyb3cobikge1xuICAgICAgICBpZiAobiA8IDApIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiQnVmZmVyLl9ncm93OiBuZWdhdGl2ZSBjb3VudFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtID0gdGhpcy5fZ3JvdyhuKTtcbiAgICAgICAgdGhpcy5fcmVzbGljZShtKTtcbiAgICB9XG4gICAgcmVhZEZyb20ocikge1xuICAgICAgICBsZXQgbiA9IDA7XG4gICAgICAgIGNvbnN0IHRtcCA9IG5ldyBVaW50OEFycmF5KE1JTl9SRUFEKTtcbiAgICAgICAgd2hpbGUodHJ1ZSl7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRHcm93ID0gdGhpcy5jYXBhY2l0eSAtIHRoaXMubGVuZ3RoIDwgTUlOX1JFQUQ7XG4gICAgICAgICAgICBjb25zdCBidWYgPSBzaG91bGRHcm93ID8gdG1wIDogbmV3IFVpbnQ4QXJyYXkodGhpcy5fYnVmLmJ1ZmZlciwgdGhpcy5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgbnJlYWQgPSByLnJlYWQoYnVmKTtcbiAgICAgICAgICAgIGlmIChucmVhZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNob3VsZEdyb3cpIHRoaXMud3JpdGUoYnVmLnN1YmFycmF5KDAsIG5yZWFkKSk7XG4gICAgICAgICAgICBlbHNlIHRoaXMuX3Jlc2xpY2UodGhpcy5sZW5ndGggKyBucmVhZCk7XG4gICAgICAgICAgICBuICs9IG5yZWFkO1xuICAgICAgICB9XG4gICAgfVxufVxudmFyIEtpbmQ7XG4oZnVuY3Rpb24oS2luZCkge1xuICAgIEtpbmRbS2luZFtcIk9LXCJdID0gMF0gPSBcIk9LXCI7XG4gICAgS2luZFtLaW5kW1wiRVJSXCJdID0gMV0gPSBcIkVSUlwiO1xuICAgIEtpbmRbS2luZFtcIk1TR1wiXSA9IDJdID0gXCJNU0dcIjtcbiAgICBLaW5kW0tpbmRbXCJJTkZPXCJdID0gM10gPSBcIklORk9cIjtcbiAgICBLaW5kW0tpbmRbXCJQSU5HXCJdID0gNF0gPSBcIlBJTkdcIjtcbiAgICBLaW5kW0tpbmRbXCJQT05HXCJdID0gNV0gPSBcIlBPTkdcIjtcbn0pKEtpbmQgfHwgKEtpbmQgPSB7fSkpO1xuZnVuY3Rpb24gbmV3TXNnQXJnKCkge1xuICAgIGNvbnN0IG1hID0ge307XG4gICAgbWEuc2lkID0gLTE7XG4gICAgbWEuaGRyID0gLTE7XG4gICAgbWEuc2l6ZSA9IC0xO1xuICAgIHJldHVybiBtYTtcbn1cbmNvbnN0IEFTQ0lJXzAgPSA0ODtcbmNsYXNzIFBhcnNlciB7XG4gICAgZGlzcGF0Y2hlcjtcbiAgICBzdGF0ZTtcbiAgICBhcztcbiAgICBkcm9wO1xuICAgIGhkcjtcbiAgICBtYTtcbiAgICBhcmdCdWY7XG4gICAgbXNnQnVmO1xuICAgIGNvbnN0cnVjdG9yKGRpc3BhdGNoZXIpe1xuICAgICAgICB0aGlzLmRpc3BhdGNoZXIgPSBkaXNwYXRjaGVyO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfU1RBUlQ7XG4gICAgICAgIHRoaXMuYXMgPSAwO1xuICAgICAgICB0aGlzLmRyb3AgPSAwO1xuICAgICAgICB0aGlzLmhkciA9IDA7XG4gICAgfVxuICAgIHBhcnNlKGJ1Zikge1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGNvbnN0IGIgPSBidWZbaV07XG4gICAgICAgICAgICBzd2l0Y2godGhpcy5zdGF0ZSl7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9TVEFSVDpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5NOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5tOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9NO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGRyID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYSA9IG5ld01zZ0FyZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5IOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5oOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9IO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGRyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hID0gbmV3TXNnQXJnKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLlA6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLnA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX1A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLlBMVVM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX1BMVVM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLk1JTlVTOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9NSU5VUztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuSTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuaTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfSTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGJ1Zi5zdWJhcnJheShpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9IOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goYil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLk06XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLm06XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX007XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfTTpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5TOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5zOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9NUztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGJ1Zi5zdWJhcnJheShpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9NUzpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5HOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9NU0c7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfTVNHOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goYil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLlNQQUNFOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5UQUI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX01TR19TUEM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfTVNHX1NQQzpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5TUEFDRTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuVEFCOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuTVNHX0FSRztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFzID0gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLk1TR19BUkc6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuQ1I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuTkw6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmcgPSB0aGlzLmFyZ0J1ZiA/IHRoaXMuYXJnQnVmLmJ5dGVzKCkgOiBidWYuc3ViYXJyYXkodGhpcy5hcywgaSAtIHRoaXMuZHJvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc01zZ0FyZ3MoYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcyA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuTVNHX1BBWUxPQUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSB0aGlzLmFzICsgdGhpcy5tYS5zaXplIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hcmdCdWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmdCdWYud3JpdGVCeXRlKGIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLk1TR19QQVlMT0FEOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tc2dCdWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1zZ0J1Zi5sZW5ndGggPj0gdGhpcy5tYS5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMubXNnQnVmLmJ5dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoZXIucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEtpbmQuTVNHLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtc2c6IHRoaXMubWEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFyZ0J1ZiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1zZ0J1ZiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuTVNHX0VORDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRvQ29weSA9IHRoaXMubWEuc2l6ZSAtIHRoaXMubXNnQnVmLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhdmFpbCA9IGJ1Zi5sZW5ndGggLSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdmFpbCA8IHRvQ29weSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0NvcHkgPSBhdmFpbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvQ29weSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tc2dCdWYud3JpdGUoYnVmLnN1YmFycmF5KGksIGkgKyB0b0NvcHkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGkgKyB0b0NvcHkgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubXNnQnVmLndyaXRlQnl0ZShiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSAtIHRoaXMuYXMgPj0gdGhpcy5tYS5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoZXIucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogS2luZC5NU0csXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXNnOiB0aGlzLm1hLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGJ1Zi5zdWJhcnJheSh0aGlzLmFzLCBpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFyZ0J1ZiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubXNnQnVmID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk1TR19FTkQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5NU0dfRU5EOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goYil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLk5MOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcyA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9TVEFSVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9QTFVTOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goYil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLk86XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLm86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX1BMVVNfTztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGJ1Zi5zdWJhcnJheShpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9QTFVTX086XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuSzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuazpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfUExVU19PSztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGJ1Zi5zdWJhcnJheShpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9QTFVTX09LOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goYil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLk5MOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hlci5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogS2luZC5PS1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX1NUQVJUO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfTUlOVVM6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuRTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfTUlOVVNfRTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGJ1Zi5zdWJhcnJheShpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9NSU5VU19FOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goYil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLlI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLnI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX01JTlVTX0VSO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYnVmLnN1YmFycmF5KGkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLk9QX01JTlVTX0VSOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goYil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLlI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLnI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX01JTlVTX0VSUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGJ1Zi5zdWJhcnJheShpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9NSU5VU19FUlI6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuU1BBQ0U6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLlRBQjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfTUlOVVNfRVJSX1NQQztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGJ1Zi5zdWJhcnJheShpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9NSU5VU19FUlJfU1BDOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goYil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLlNQQUNFOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5UQUI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5NSU5VU19FUlJfQVJHO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXMgPSBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuTUlOVVNfRVJSX0FSRzpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5DUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3AgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5OTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhcmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFyZ0J1Zikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gdGhpcy5hcmdCdWYuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXJnQnVmID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYnVmLnN1YmFycmF5KHRoaXMuYXMsIGkgLSB0aGlzLmRyb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hlci5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEtpbmQuRVJSLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogYXJnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3AgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFzID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9TVEFSVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hcmdCdWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmdCdWYud3JpdGUoVWludDhBcnJheS5vZihiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfUDpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5JOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5pOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9QSTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuTzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MubzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfUE87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfUE86XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuTjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MubjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfUE9OO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYnVmLnN1YmFycmF5KGkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLk9QX1BPTjpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5HOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9QT05HO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYnVmLnN1YmFycmF5KGkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLk9QX1BPTkc6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuTkw6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGVyLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBLaW5kLlBPTkdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3AgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9TVEFSVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLk9QX1BJOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goYil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLk46XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLm46XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX1BJTjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGJ1Zi5zdWJhcnJheShpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9QSU46XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuRzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuZzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfUElORztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGJ1Zi5zdWJhcnJheShpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9QSU5HOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goYil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLk5MOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hlci5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogS2luZC5QSU5HXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfU1RBUlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9JOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goYil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLk46XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLm46XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX0lOO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYnVmLnN1YmFycmF5KGkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLk9QX0lOOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goYil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLkY6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLmY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX0lORjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGJ1Zi5zdWJhcnJheShpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9JTkY6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuTzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MubzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfSU5GTztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGJ1Zi5zdWJhcnJheShpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9JTkZPOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goYil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLlNQQUNFOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5UQUI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX0lORk9fU1BDO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYnVmLnN1YmFycmF5KGkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLk9QX0lORk9fU1BDOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goYil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLlNQQUNFOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5UQUI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JTkZPX0FSRztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFzID0gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLklORk9fQVJHOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goYil7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLkNSOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLk5MOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFyZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXJnQnVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSB0aGlzLmFyZ0J1Zi5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmdCdWYgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBidWYuc3ViYXJyYXkodGhpcy5hcywgaSAtIHRoaXMuZHJvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGVyLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogS2luZC5JTkZPLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogYXJnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3AgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFzID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9TVEFSVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hcmdCdWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmdCdWYud3JpdGVCeXRlKGIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYnVmLnN1YmFycmF5KGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoKHRoaXMuc3RhdGUgPT09IFN0YXRlLk1TR19BUkcgfHwgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuTUlOVVNfRVJSX0FSRyB8fCB0aGlzLnN0YXRlID09PSBTdGF0ZS5JTkZPX0FSRykgJiYgIXRoaXMuYXJnQnVmKSB7XG4gICAgICAgICAgICB0aGlzLmFyZ0J1ZiA9IG5ldyBEZW5vQnVmZmVyKGJ1Zi5zdWJhcnJheSh0aGlzLmFzLCBpIC0gdGhpcy5kcm9wKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLk1TR19QQVlMT0FEICYmICF0aGlzLm1zZ0J1Zikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFyZ0J1Zikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvbmVNc2dBcmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubXNnQnVmID0gbmV3IERlbm9CdWZmZXIoYnVmLnN1YmFycmF5KHRoaXMuYXMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9uZU1zZ0FyZygpIHtcbiAgICAgICAgY29uc3QgcyA9IHRoaXMubWEuc3ViamVjdC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHIgPSB0aGlzLm1hLnJlcGx5ID8gdGhpcy5tYS5yZXBseS5sZW5ndGggOiAwO1xuICAgICAgICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShzICsgcik7XG4gICAgICAgIGJ1Zi5zZXQodGhpcy5tYS5zdWJqZWN0KTtcbiAgICAgICAgaWYgKHRoaXMubWEucmVwbHkpIHtcbiAgICAgICAgICAgIGJ1Zi5zZXQodGhpcy5tYS5yZXBseSwgcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcmdCdWYgPSBuZXcgRGVub0J1ZmZlcihidWYpO1xuICAgICAgICB0aGlzLm1hLnN1YmplY3QgPSBidWYuc3ViYXJyYXkoMCwgcyk7XG4gICAgICAgIGlmICh0aGlzLm1hLnJlcGx5KSB7XG4gICAgICAgICAgICB0aGlzLm1hLnJlcGx5ID0gYnVmLnN1YmFycmF5KHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NNc2dBcmdzKGFyZykge1xuICAgICAgICBpZiAodGhpcy5oZHIgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc0hlYWRlck1zZ0FyZ3MoYXJnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcmdzID0gW107XG4gICAgICAgIGxldCBzdGFydCA9IC0xO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgYXJnLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGNvbnN0IGIgPSBhcmdbaV07XG4gICAgICAgICAgICBzd2l0Y2goYil7XG4gICAgICAgICAgICAgICAgY2FzZSBjYy5TUEFDRTpcbiAgICAgICAgICAgICAgICBjYXNlIGNjLlRBQjpcbiAgICAgICAgICAgICAgICBjYXNlIGNjLkNSOlxuICAgICAgICAgICAgICAgIGNhc2UgY2MuTkw6XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goYXJnLnN1YmFycmF5KHN0YXJ0LCBpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA+PSAwKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2goYXJnLnN1YmFycmF5KHN0YXJ0KSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoKGFyZ3MubGVuZ3RoKXtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICB0aGlzLm1hLnN1YmplY3QgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIHRoaXMubWEuc2lkID0gdGhpcy5wcm90b1BhcnNlSW50KGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgIHRoaXMubWEucmVwbHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5tYS5zaXplID0gdGhpcy5wcm90b1BhcnNlSW50KGFyZ3NbMl0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHRoaXMubWEuc3ViamVjdCA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgdGhpcy5tYS5zaWQgPSB0aGlzLnByb3RvUGFyc2VJbnQoYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYS5yZXBseSA9IGFyZ3NbMl07XG4gICAgICAgICAgICAgICAgdGhpcy5tYS5zaXplID0gdGhpcy5wcm90b1BhcnNlSW50KGFyZ3NbM10pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYXJnLCBcInByb2Nlc3NNc2dBcmdzIFBhcnNlIEVycm9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hLnNpZCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChhcmcsIFwicHJvY2Vzc01zZ0FyZ3MgQmFkIG9yIE1pc3NpbmcgU2lkIEVycm9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hLnNpemUgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYXJnLCBcInByb2Nlc3NNc2dBcmdzIEJhZCBvciBNaXNzaW5nIFNpemUgRXJyb3JcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmFpbChkYXRhLCBsYWJlbCA9IFwiXCIpIHtcbiAgICAgICAgaWYgKCFsYWJlbCkge1xuICAgICAgICAgICAgbGFiZWwgPSBgcGFyc2UgZXJyb3IgWyR7dGhpcy5zdGF0ZX1dYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhYmVsID0gYCR7bGFiZWx9IFske3RoaXMuc3RhdGV9XWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgJHtsYWJlbH06ICR7VEQuZGVjb2RlKGRhdGEpfWApO1xuICAgIH1cbiAgICBwcm9jZXNzSGVhZGVyTXNnQXJncyhhcmcpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IFtdO1xuICAgICAgICBsZXQgc3RhcnQgPSAtMTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGFyZy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBjb25zdCBiID0gYXJnW2ldO1xuICAgICAgICAgICAgc3dpdGNoKGIpe1xuICAgICAgICAgICAgICAgIGNhc2UgY2MuU1BBQ0U6XG4gICAgICAgICAgICAgICAgY2FzZSBjYy5UQUI6XG4gICAgICAgICAgICAgICAgY2FzZSBjYy5DUjpcbiAgICAgICAgICAgICAgICBjYXNlIGNjLk5MOlxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGFyZy5zdWJhcnJheShzdGFydCwgaSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgYXJncy5wdXNoKGFyZy5zdWJhcnJheShzdGFydCkpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaChhcmdzLmxlbmd0aCl7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgdGhpcy5tYS5zdWJqZWN0ID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hLnNpZCA9IHRoaXMucHJvdG9QYXJzZUludChhcmdzWzFdKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hLnJlcGx5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMubWEuaGRyID0gdGhpcy5wcm90b1BhcnNlSW50KGFyZ3NbMl0pO1xuICAgICAgICAgICAgICAgIHRoaXMubWEuc2l6ZSA9IHRoaXMucHJvdG9QYXJzZUludChhcmdzWzNdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICB0aGlzLm1hLnN1YmplY3QgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIHRoaXMubWEuc2lkID0gdGhpcy5wcm90b1BhcnNlSW50KGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgIHRoaXMubWEucmVwbHkgPSBhcmdzWzJdO1xuICAgICAgICAgICAgICAgIHRoaXMubWEuaGRyID0gdGhpcy5wcm90b1BhcnNlSW50KGFyZ3NbM10pO1xuICAgICAgICAgICAgICAgIHRoaXMubWEuc2l6ZSA9IHRoaXMucHJvdG9QYXJzZUludChhcmdzWzRdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGFyZywgXCJwcm9jZXNzSGVhZGVyTXNnQXJncyBQYXJzZSBFcnJvclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYS5zaWQgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYXJnLCBcInByb2Nlc3NIZWFkZXJNc2dBcmdzIEJhZCBvciBNaXNzaW5nIFNpZCBFcnJvclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYS5oZHIgPCAwIHx8IHRoaXMubWEuaGRyID4gdGhpcy5tYS5zaXplKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYXJnLCBcInByb2Nlc3NIZWFkZXJNc2dBcmdzIEJhZCBvciBNaXNzaW5nIEhlYWRlciBTaXplIEVycm9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hLnNpemUgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYXJnLCBcInByb2Nlc3NIZWFkZXJNc2dBcmdzIEJhZCBvciBNaXNzaW5nIFNpemUgRXJyb3JcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvdG9QYXJzZUludChhKSB7XG4gICAgICAgIGlmIChhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuID0gMDtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgaWYgKGFbaV0gPCA0OCB8fCBhW2ldID4gNTcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuID0gbiAqIDEwICsgKGFbaV0gLSBBU0NJSV8wKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG59XG52YXIgU3RhdGU7XG4oZnVuY3Rpb24oU3RhdGUpIHtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX1NUQVJUXCJdID0gMF0gPSBcIk9QX1NUQVJUXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJPUF9QTFVTXCJdID0gMV0gPSBcIk9QX1BMVVNcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX1BMVVNfT1wiXSA9IDJdID0gXCJPUF9QTFVTX09cIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX1BMVVNfT0tcIl0gPSAzXSA9IFwiT1BfUExVU19PS1wiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BfTUlOVVNcIl0gPSA0XSA9IFwiT1BfTUlOVVNcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX01JTlVTX0VcIl0gPSA1XSA9IFwiT1BfTUlOVVNfRVwiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BfTUlOVVNfRVJcIl0gPSA2XSA9IFwiT1BfTUlOVVNfRVJcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX01JTlVTX0VSUlwiXSA9IDddID0gXCJPUF9NSU5VU19FUlJcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX01JTlVTX0VSUl9TUENcIl0gPSA4XSA9IFwiT1BfTUlOVVNfRVJSX1NQQ1wiO1xuICAgIFN0YXRlW1N0YXRlW1wiTUlOVVNfRVJSX0FSR1wiXSA9IDldID0gXCJNSU5VU19FUlJfQVJHXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJPUF9NXCJdID0gMTBdID0gXCJPUF9NXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJPUF9NU1wiXSA9IDExXSA9IFwiT1BfTVNcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX01TR1wiXSA9IDEyXSA9IFwiT1BfTVNHXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJPUF9NU0dfU1BDXCJdID0gMTNdID0gXCJPUF9NU0dfU1BDXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJNU0dfQVJHXCJdID0gMTRdID0gXCJNU0dfQVJHXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJNU0dfUEFZTE9BRFwiXSA9IDE1XSA9IFwiTVNHX1BBWUxPQURcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk1TR19FTkRcIl0gPSAxNl0gPSBcIk1TR19FTkRcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX0hcIl0gPSAxN10gPSBcIk9QX0hcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX1BcIl0gPSAxOF0gPSBcIk9QX1BcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX1BJXCJdID0gMTldID0gXCJPUF9QSVwiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BfUElOXCJdID0gMjBdID0gXCJPUF9QSU5cIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX1BJTkdcIl0gPSAyMV0gPSBcIk9QX1BJTkdcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX1BPXCJdID0gMjJdID0gXCJPUF9QT1wiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BfUE9OXCJdID0gMjNdID0gXCJPUF9QT05cIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX1BPTkdcIl0gPSAyNF0gPSBcIk9QX1BPTkdcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX0lcIl0gPSAyNV0gPSBcIk9QX0lcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX0lOXCJdID0gMjZdID0gXCJPUF9JTlwiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BfSU5GXCJdID0gMjddID0gXCJPUF9JTkZcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX0lORk9cIl0gPSAyOF0gPSBcIk9QX0lORk9cIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX0lORk9fU1BDXCJdID0gMjldID0gXCJPUF9JTkZPX1NQQ1wiO1xuICAgIFN0YXRlW1N0YXRlW1wiSU5GT19BUkdcIl0gPSAzMF0gPSBcIklORk9fQVJHXCI7XG59KShTdGF0ZSB8fCAoU3RhdGUgPSB7fSkpO1xudmFyIGNjO1xuKGZ1bmN0aW9uKGNjKSB7XG4gICAgY2NbY2NbXCJDUlwiXSA9IFwiXFxyXCIuY2hhckNvZGVBdCgwKV0gPSBcIkNSXCI7XG4gICAgY2NbY2NbXCJFXCJdID0gXCJFXCIuY2hhckNvZGVBdCgwKV0gPSBcIkVcIjtcbiAgICBjY1tjY1tcImVcIl0gPSBcImVcIi5jaGFyQ29kZUF0KDApXSA9IFwiZVwiO1xuICAgIGNjW2NjW1wiRlwiXSA9IFwiRlwiLmNoYXJDb2RlQXQoMCldID0gXCJGXCI7XG4gICAgY2NbY2NbXCJmXCJdID0gXCJmXCIuY2hhckNvZGVBdCgwKV0gPSBcImZcIjtcbiAgICBjY1tjY1tcIkdcIl0gPSBcIkdcIi5jaGFyQ29kZUF0KDApXSA9IFwiR1wiO1xuICAgIGNjW2NjW1wiZ1wiXSA9IFwiZ1wiLmNoYXJDb2RlQXQoMCldID0gXCJnXCI7XG4gICAgY2NbY2NbXCJIXCJdID0gXCJIXCIuY2hhckNvZGVBdCgwKV0gPSBcIkhcIjtcbiAgICBjY1tjY1tcImhcIl0gPSBcImhcIi5jaGFyQ29kZUF0KDApXSA9IFwiaFwiO1xuICAgIGNjW2NjW1wiSVwiXSA9IFwiSVwiLmNoYXJDb2RlQXQoMCldID0gXCJJXCI7XG4gICAgY2NbY2NbXCJpXCJdID0gXCJpXCIuY2hhckNvZGVBdCgwKV0gPSBcImlcIjtcbiAgICBjY1tjY1tcIktcIl0gPSBcIktcIi5jaGFyQ29kZUF0KDApXSA9IFwiS1wiO1xuICAgIGNjW2NjW1wia1wiXSA9IFwia1wiLmNoYXJDb2RlQXQoMCldID0gXCJrXCI7XG4gICAgY2NbY2NbXCJNXCJdID0gXCJNXCIuY2hhckNvZGVBdCgwKV0gPSBcIk1cIjtcbiAgICBjY1tjY1tcIm1cIl0gPSBcIm1cIi5jaGFyQ29kZUF0KDApXSA9IFwibVwiO1xuICAgIGNjW2NjW1wiTUlOVVNcIl0gPSBcIi1cIi5jaGFyQ29kZUF0KDApXSA9IFwiTUlOVVNcIjtcbiAgICBjY1tjY1tcIk5cIl0gPSBcIk5cIi5jaGFyQ29kZUF0KDApXSA9IFwiTlwiO1xuICAgIGNjW2NjW1wiblwiXSA9IFwiblwiLmNoYXJDb2RlQXQoMCldID0gXCJuXCI7XG4gICAgY2NbY2NbXCJOTFwiXSA9IFwiXFxuXCIuY2hhckNvZGVBdCgwKV0gPSBcIk5MXCI7XG4gICAgY2NbY2NbXCJPXCJdID0gXCJPXCIuY2hhckNvZGVBdCgwKV0gPSBcIk9cIjtcbiAgICBjY1tjY1tcIm9cIl0gPSBcIm9cIi5jaGFyQ29kZUF0KDApXSA9IFwib1wiO1xuICAgIGNjW2NjW1wiUFwiXSA9IFwiUFwiLmNoYXJDb2RlQXQoMCldID0gXCJQXCI7XG4gICAgY2NbY2NbXCJwXCJdID0gXCJwXCIuY2hhckNvZGVBdCgwKV0gPSBcInBcIjtcbiAgICBjY1tjY1tcIlBMVVNcIl0gPSBcIitcIi5jaGFyQ29kZUF0KDApXSA9IFwiUExVU1wiO1xuICAgIGNjW2NjW1wiUlwiXSA9IFwiUlwiLmNoYXJDb2RlQXQoMCldID0gXCJSXCI7XG4gICAgY2NbY2NbXCJyXCJdID0gXCJyXCIuY2hhckNvZGVBdCgwKV0gPSBcInJcIjtcbiAgICBjY1tjY1tcIlNcIl0gPSBcIlNcIi5jaGFyQ29kZUF0KDApXSA9IFwiU1wiO1xuICAgIGNjW2NjW1wic1wiXSA9IFwic1wiLmNoYXJDb2RlQXQoMCldID0gXCJzXCI7XG4gICAgY2NbY2NbXCJTUEFDRVwiXSA9IFwiIFwiLmNoYXJDb2RlQXQoMCldID0gXCJTUEFDRVwiO1xuICAgIGNjW2NjW1wiVEFCXCJdID0gXCJcXHRcIi5jaGFyQ29kZUF0KDApXSA9IFwiVEFCXCI7XG59KShjYyB8fCAoY2MgPSB7fSkpO1xuKGZ1bmN0aW9uKG5hY2wpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIHU2NCA9IGZ1bmN0aW9uKGgsIGwpIHtcbiAgICAgICAgdGhpcy5oaSA9IGggfCAwID4+PiAwO1xuICAgICAgICB0aGlzLmxvID0gbCB8IDAgPj4+IDA7XG4gICAgfTtcbiAgICB2YXIgZ2YgPSBmdW5jdGlvbihpbml0KSB7XG4gICAgICAgIHZhciBpLCByID0gbmV3IEZsb2F0NjRBcnJheSgxNik7XG4gICAgICAgIGlmIChpbml0KSBmb3IoaSA9IDA7IGkgPCBpbml0Lmxlbmd0aDsgaSsrKXJbaV0gPSBpbml0W2ldO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIHZhciByYW5kb21ieXRlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIFBSTkcnKTtcbiAgICB9O1xuICAgIHZhciBfMCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICB2YXIgXzkgPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgXzlbMF0gPSA5O1xuICAgIHZhciBnZjAgPSBnZigpLCBnZjEgPSBnZihbXG4gICAgICAgIDFcbiAgICBdKSwgXzEyMTY2NSA9IGdmKFtcbiAgICAgICAgMHhkYjQxLFxuICAgICAgICAxXG4gICAgXSksIEQgPSBnZihbXG4gICAgICAgIDB4NzhhMyxcbiAgICAgICAgMHgxMzU5LFxuICAgICAgICAweDRkY2EsXG4gICAgICAgIDB4NzVlYixcbiAgICAgICAgMHhkOGFiLFxuICAgICAgICAweDQxNDEsXG4gICAgICAgIDB4MGE0ZCxcbiAgICAgICAgMHgwMDcwLFxuICAgICAgICAweGU4OTgsXG4gICAgICAgIDB4Nzc3OSxcbiAgICAgICAgMHg0MDc5LFxuICAgICAgICAweDhjYzcsXG4gICAgICAgIDB4ZmU3MyxcbiAgICAgICAgMHgyYjZmLFxuICAgICAgICAweDZjZWUsXG4gICAgICAgIDB4NTIwM1xuICAgIF0pLCBEMiA9IGdmKFtcbiAgICAgICAgMHhmMTU5LFxuICAgICAgICAweDI2YjIsXG4gICAgICAgIDB4OWI5NCxcbiAgICAgICAgMHhlYmQ2LFxuICAgICAgICAweGIxNTYsXG4gICAgICAgIDB4ODI4MyxcbiAgICAgICAgMHgxNDlhLFxuICAgICAgICAweDAwZTAsXG4gICAgICAgIDB4ZDEzMCxcbiAgICAgICAgMHhlZWYzLFxuICAgICAgICAweDgwZjIsXG4gICAgICAgIDB4MTk4ZSxcbiAgICAgICAgMHhmY2U3LFxuICAgICAgICAweDU2ZGYsXG4gICAgICAgIDB4ZDlkYyxcbiAgICAgICAgMHgyNDA2XG4gICAgXSksIFggPSBnZihbXG4gICAgICAgIDB4ZDUxYSxcbiAgICAgICAgMHg4ZjI1LFxuICAgICAgICAweDJkNjAsXG4gICAgICAgIDB4Yzk1NixcbiAgICAgICAgMHhhN2IyLFxuICAgICAgICAweDk1MjUsXG4gICAgICAgIDB4Yzc2MCxcbiAgICAgICAgMHg2OTJjLFxuICAgICAgICAweGRjNWMsXG4gICAgICAgIDB4ZmRkNixcbiAgICAgICAgMHhlMjMxLFxuICAgICAgICAweGMwYTQsXG4gICAgICAgIDB4NTNmZSxcbiAgICAgICAgMHhjZDZlLFxuICAgICAgICAweDM2ZDMsXG4gICAgICAgIDB4MjE2OVxuICAgIF0pLCBZID0gZ2YoW1xuICAgICAgICAweDY2NTgsXG4gICAgICAgIDB4NjY2NixcbiAgICAgICAgMHg2NjY2LFxuICAgICAgICAweDY2NjYsXG4gICAgICAgIDB4NjY2NixcbiAgICAgICAgMHg2NjY2LFxuICAgICAgICAweDY2NjYsXG4gICAgICAgIDB4NjY2NixcbiAgICAgICAgMHg2NjY2LFxuICAgICAgICAweDY2NjYsXG4gICAgICAgIDB4NjY2NixcbiAgICAgICAgMHg2NjY2LFxuICAgICAgICAweDY2NjYsXG4gICAgICAgIDB4NjY2NixcbiAgICAgICAgMHg2NjY2LFxuICAgICAgICAweDY2NjZcbiAgICBdKSwgSSA9IGdmKFtcbiAgICAgICAgMHhhMGIwLFxuICAgICAgICAweDRhMGUsXG4gICAgICAgIDB4MWIyNyxcbiAgICAgICAgMHhjNGVlLFxuICAgICAgICAweGU0NzgsXG4gICAgICAgIDB4YWQyZixcbiAgICAgICAgMHgxODA2LFxuICAgICAgICAweDJmNDMsXG4gICAgICAgIDB4ZDdhNyxcbiAgICAgICAgMHgzZGZiLFxuICAgICAgICAweDAwOTksXG4gICAgICAgIDB4MmI0ZCxcbiAgICAgICAgMHhkZjBiLFxuICAgICAgICAweDRmYzEsXG4gICAgICAgIDB4MjQ4MCxcbiAgICAgICAgMHgyYjgzXG4gICAgXSk7XG4gICAgZnVuY3Rpb24gTDMyKHgsIGMpIHtcbiAgICAgICAgcmV0dXJuIHggPDwgYyB8IHggPj4+IDMyIC0gYztcbiAgICB9XG4gICAgZnVuY3Rpb24gbGQzMih4LCBpKSB7XG4gICAgICAgIHZhciB1ID0geFtpICsgM10gJiAweGZmO1xuICAgICAgICB1ID0gdSA8PCA4IHwgeFtpICsgMl0gJiAweGZmO1xuICAgICAgICB1ID0gdSA8PCA4IHwgeFtpICsgMV0gJiAweGZmO1xuICAgICAgICByZXR1cm4gdSA8PCA4IHwgeFtpICsgMF0gJiAweGZmO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkbDY0KHgsIGkpIHtcbiAgICAgICAgdmFyIGggPSB4W2ldIDw8IDI0IHwgeFtpICsgMV0gPDwgMTYgfCB4W2kgKyAyXSA8PCA4IHwgeFtpICsgM107XG4gICAgICAgIHZhciBsID0geFtpICsgNF0gPDwgMjQgfCB4W2kgKyA1XSA8PCAxNiB8IHhbaSArIDZdIDw8IDggfCB4W2kgKyA3XTtcbiAgICAgICAgcmV0dXJuIG5ldyB1NjQoaCwgbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0MzIoeCwgaiwgdSkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgNDsgaSsrKXtcbiAgICAgICAgICAgIHhbaiArIGldID0gdSAmIDI1NTtcbiAgICAgICAgICAgIHUgPj4+PSA4O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRzNjQoeCwgaSwgdSkge1xuICAgICAgICB4W2ldID0gdS5oaSA+PiAyNCAmIDB4ZmY7XG4gICAgICAgIHhbaSArIDFdID0gdS5oaSA+PiAxNiAmIDB4ZmY7XG4gICAgICAgIHhbaSArIDJdID0gdS5oaSA+PiA4ICYgMHhmZjtcbiAgICAgICAgeFtpICsgM10gPSB1LmhpICYgMHhmZjtcbiAgICAgICAgeFtpICsgNF0gPSB1LmxvID4+IDI0ICYgMHhmZjtcbiAgICAgICAgeFtpICsgNV0gPSB1LmxvID4+IDE2ICYgMHhmZjtcbiAgICAgICAgeFtpICsgNl0gPSB1LmxvID4+IDggJiAweGZmO1xuICAgICAgICB4W2kgKyA3XSA9IHUubG8gJiAweGZmO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2bih4LCB4aSwgeSwgeWksIG4pIHtcbiAgICAgICAgdmFyIGksIGQgPSAwO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBuOyBpKyspZCB8PSB4W3hpICsgaV0gXiB5W3lpICsgaV07XG4gICAgICAgIHJldHVybiAoMSAmIGQgLSAxID4+PiA4KSAtIDE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyeXB0b192ZXJpZnlfMTYoeCwgeGksIHksIHlpKSB7XG4gICAgICAgIHJldHVybiB2bih4LCB4aSwgeSwgeWksIDE2KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3J5cHRvX3ZlcmlmeV8zMih4LCB4aSwgeSwgeWkpIHtcbiAgICAgICAgcmV0dXJuIHZuKHgsIHhpLCB5LCB5aSwgMzIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb3JlKG91dCwgaW5wLCBrLCBjLCBoKSB7XG4gICAgICAgIHZhciB3ID0gbmV3IFVpbnQzMkFycmF5KDE2KSwgeCA9IG5ldyBVaW50MzJBcnJheSgxNiksIHkgPSBuZXcgVWludDMyQXJyYXkoMTYpLCB0ID0gbmV3IFVpbnQzMkFycmF5KDQpO1xuICAgICAgICB2YXIgaSwgaiwgbTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgNDsgaSsrKXtcbiAgICAgICAgICAgIHhbNSAqIGldID0gbGQzMihjLCA0ICogaSk7XG4gICAgICAgICAgICB4WzEgKyBpXSA9IGxkMzIoaywgNCAqIGkpO1xuICAgICAgICAgICAgeFs2ICsgaV0gPSBsZDMyKGlucCwgNCAqIGkpO1xuICAgICAgICAgICAgeFsxMSArIGldID0gbGQzMihrLCAxNiArIDQgKiBpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IoaSA9IDA7IGkgPCAxNjsgaSsrKXlbaV0gPSB4W2ldO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCAyMDsgaSsrKXtcbiAgICAgICAgICAgIGZvcihqID0gMDsgaiA8IDQ7IGorKyl7XG4gICAgICAgICAgICAgICAgZm9yKG0gPSAwOyBtIDwgNDsgbSsrKXRbbV0gPSB4Wyg1ICogaiArIDQgKiBtKSAlIDE2XTtcbiAgICAgICAgICAgICAgICB0WzFdIF49IEwzMih0WzBdICsgdFszXSB8IDAsIDcpO1xuICAgICAgICAgICAgICAgIHRbMl0gXj0gTDMyKHRbMV0gKyB0WzBdIHwgMCwgOSk7XG4gICAgICAgICAgICAgICAgdFszXSBePSBMMzIodFsyXSArIHRbMV0gfCAwLCAxMyk7XG4gICAgICAgICAgICAgICAgdFswXSBePSBMMzIodFszXSArIHRbMl0gfCAwLCAxOCk7XG4gICAgICAgICAgICAgICAgZm9yKG0gPSAwOyBtIDwgNDsgbSsrKXdbNCAqIGogKyAoaiArIG0pICUgNF0gPSB0W21dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yKG0gPSAwOyBtIDwgMTY7IG0rKyl4W21dID0gd1ttXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaCkge1xuICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgMTY7IGkrKyl4W2ldID0geFtpXSArIHlbaV0gfCAwO1xuICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgNDsgaSsrKXtcbiAgICAgICAgICAgICAgICB4WzUgKiBpXSA9IHhbNSAqIGldIC0gbGQzMihjLCA0ICogaSkgfCAwO1xuICAgICAgICAgICAgICAgIHhbNiArIGldID0geFs2ICsgaV0gLSBsZDMyKGlucCwgNCAqIGkpIHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IDQ7IGkrKyl7XG4gICAgICAgICAgICAgICAgc3QzMihvdXQsIDQgKiBpLCB4WzUgKiBpXSk7XG4gICAgICAgICAgICAgICAgc3QzMihvdXQsIDE2ICsgNCAqIGksIHhbNiArIGldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IDE2OyBpKyspc3QzMihvdXQsIDQgKiBpLCB4W2ldICsgeVtpXSB8IDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyeXB0b19jb3JlX3NhbHNhMjAob3V0LCBpbnAsIGssIGMpIHtcbiAgICAgICAgY29yZShvdXQsIGlucCwgaywgYywgZmFsc2UpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3J5cHRvX2NvcmVfaHNhbHNhMjAob3V0LCBpbnAsIGssIGMpIHtcbiAgICAgICAgY29yZShvdXQsIGlucCwgaywgYywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICB2YXIgc2lnbWEgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgIDEwMSxcbiAgICAgICAgMTIwLFxuICAgICAgICAxMTIsXG4gICAgICAgIDk3LFxuICAgICAgICAxMTAsXG4gICAgICAgIDEwMCxcbiAgICAgICAgMzIsXG4gICAgICAgIDUxLFxuICAgICAgICA1MCxcbiAgICAgICAgNDUsXG4gICAgICAgIDk4LFxuICAgICAgICAxMjEsXG4gICAgICAgIDExNixcbiAgICAgICAgMTAxLFxuICAgICAgICAzMixcbiAgICAgICAgMTA3XG4gICAgXSk7XG4gICAgZnVuY3Rpb24gY3J5cHRvX3N0cmVhbV9zYWxzYTIwX3hvcihjLCBjcG9zLCBtLCBtcG9zLCBiLCBuLCBrKSB7XG4gICAgICAgIHZhciB6ID0gbmV3IFVpbnQ4QXJyYXkoMTYpLCB4ID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICAgICAgICB2YXIgdSwgaTtcbiAgICAgICAgaWYgKCFiKSByZXR1cm4gMDtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgMTY7IGkrKyl6W2ldID0gMDtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgODsgaSsrKXpbaV0gPSBuW2ldO1xuICAgICAgICB3aGlsZShiID49IDY0KXtcbiAgICAgICAgICAgIGNyeXB0b19jb3JlX3NhbHNhMjAoeCwgeiwgaywgc2lnbWEpO1xuICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgNjQ7IGkrKyljW2Nwb3MgKyBpXSA9IChtID8gbVttcG9zICsgaV0gOiAwKSBeIHhbaV07XG4gICAgICAgICAgICB1ID0gMTtcbiAgICAgICAgICAgIGZvcihpID0gODsgaSA8IDE2OyBpKyspe1xuICAgICAgICAgICAgICAgIHUgPSB1ICsgKHpbaV0gJiAweGZmKSB8IDA7XG4gICAgICAgICAgICAgICAgeltpXSA9IHUgJiAweGZmO1xuICAgICAgICAgICAgICAgIHUgPj4+PSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYiAtPSA2NDtcbiAgICAgICAgICAgIGNwb3MgKz0gNjQ7XG4gICAgICAgICAgICBpZiAobSkgbXBvcyArPSA2NDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYiA+IDApIHtcbiAgICAgICAgICAgIGNyeXB0b19jb3JlX3NhbHNhMjAoeCwgeiwgaywgc2lnbWEpO1xuICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgYjsgaSsrKWNbY3BvcyArIGldID0gKG0gPyBtW21wb3MgKyBpXSA6IDApIF4geFtpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3J5cHRvX3N0cmVhbV9zYWxzYTIwKGMsIGNwb3MsIGQsIG4sIGspIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0b19zdHJlYW1fc2Fsc2EyMF94b3IoYywgY3BvcywgbnVsbCwgMCwgZCwgbiwgayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyeXB0b19zdHJlYW0oYywgY3BvcywgZCwgbiwgaykge1xuICAgICAgICB2YXIgcyA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICAgICAgY3J5cHRvX2NvcmVfaHNhbHNhMjAocywgbiwgaywgc2lnbWEpO1xuICAgICAgICByZXR1cm4gY3J5cHRvX3N0cmVhbV9zYWxzYTIwKGMsIGNwb3MsIGQsIG4uc3ViYXJyYXkoMTYpLCBzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3J5cHRvX3N0cmVhbV94b3IoYywgY3BvcywgbSwgbXBvcywgZCwgbiwgaykge1xuICAgICAgICB2YXIgcyA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICAgICAgY3J5cHRvX2NvcmVfaHNhbHNhMjAocywgbiwgaywgc2lnbWEpO1xuICAgICAgICByZXR1cm4gY3J5cHRvX3N0cmVhbV9zYWxzYTIwX3hvcihjLCBjcG9zLCBtLCBtcG9zLCBkLCBuLnN1YmFycmF5KDE2KSwgcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZDEzMDUoaCwgYykge1xuICAgICAgICB2YXIgaiwgdSA9IDA7XG4gICAgICAgIGZvcihqID0gMDsgaiA8IDE3OyBqKyspe1xuICAgICAgICAgICAgdSA9IHUgKyAoaFtqXSArIGNbal0gfCAwKSB8IDA7XG4gICAgICAgICAgICBoW2pdID0gdSAmIDI1NTtcbiAgICAgICAgICAgIHUgPj4+PSA4O1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBtaW51c3AgPSBuZXcgVWludDMyQXJyYXkoW1xuICAgICAgICA1LFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAyNTJcbiAgICBdKTtcbiAgICBmdW5jdGlvbiBjcnlwdG9fb25ldGltZWF1dGgob3V0LCBvdXRwb3MsIG0sIG1wb3MsIG4sIGspIHtcbiAgICAgICAgdmFyIHMsIGksIGosIHU7XG4gICAgICAgIHZhciB4ID0gbmV3IFVpbnQzMkFycmF5KDE3KSwgciA9IG5ldyBVaW50MzJBcnJheSgxNyksIGggPSBuZXcgVWludDMyQXJyYXkoMTcpLCBjID0gbmV3IFVpbnQzMkFycmF5KDE3KSwgZyA9IG5ldyBVaW50MzJBcnJheSgxNyk7XG4gICAgICAgIGZvcihqID0gMDsgaiA8IDE3OyBqKyspcltqXSA9IGhbal0gPSAwO1xuICAgICAgICBmb3IoaiA9IDA7IGogPCAxNjsgaisrKXJbal0gPSBrW2pdO1xuICAgICAgICByWzNdICY9IDE1O1xuICAgICAgICByWzRdICY9IDI1MjtcbiAgICAgICAgcls3XSAmPSAxNTtcbiAgICAgICAgcls4XSAmPSAyNTI7XG4gICAgICAgIHJbMTFdICY9IDE1O1xuICAgICAgICByWzEyXSAmPSAyNTI7XG4gICAgICAgIHJbMTVdICY9IDE1O1xuICAgICAgICB3aGlsZShuID4gMCl7XG4gICAgICAgICAgICBmb3IoaiA9IDA7IGogPCAxNzsgaisrKWNbal0gPSAwO1xuICAgICAgICAgICAgZm9yKGogPSAwOyBqIDwgMTYgJiYgaiA8IG47ICsrailjW2pdID0gbVttcG9zICsgal07XG4gICAgICAgICAgICBjW2pdID0gMTtcbiAgICAgICAgICAgIG1wb3MgKz0gajtcbiAgICAgICAgICAgIG4gLT0gajtcbiAgICAgICAgICAgIGFkZDEzMDUoaCwgYyk7XG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCAxNzsgaSsrKXtcbiAgICAgICAgICAgICAgICB4W2ldID0gMDtcbiAgICAgICAgICAgICAgICBmb3IoaiA9IDA7IGogPCAxNzsgaisrKXhbaV0gPSB4W2ldICsgaFtqXSAqIChqIDw9IGkgPyByW2kgLSBqXSA6IDMyMCAqIHJbaSArIDE3IC0gal0gfCAwKSB8IDAgfCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgMTc7IGkrKyloW2ldID0geFtpXTtcbiAgICAgICAgICAgIHUgPSAwO1xuICAgICAgICAgICAgZm9yKGogPSAwOyBqIDwgMTY7IGorKyl7XG4gICAgICAgICAgICAgICAgdSA9IHUgKyBoW2pdIHwgMDtcbiAgICAgICAgICAgICAgICBoW2pdID0gdSAmIDI1NTtcbiAgICAgICAgICAgICAgICB1ID4+Pj0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHUgPSB1ICsgaFsxNl0gfCAwO1xuICAgICAgICAgICAgaFsxNl0gPSB1ICYgMztcbiAgICAgICAgICAgIHUgPSA1ICogKHUgPj4+IDIpIHwgMDtcbiAgICAgICAgICAgIGZvcihqID0gMDsgaiA8IDE2OyBqKyspe1xuICAgICAgICAgICAgICAgIHUgPSB1ICsgaFtqXSB8IDA7XG4gICAgICAgICAgICAgICAgaFtqXSA9IHUgJiAyNTU7XG4gICAgICAgICAgICAgICAgdSA+Pj49IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1ID0gdSArIGhbMTZdIHwgMDtcbiAgICAgICAgICAgIGhbMTZdID0gdTtcbiAgICAgICAgfVxuICAgICAgICBmb3IoaiA9IDA7IGogPCAxNzsgaisrKWdbal0gPSBoW2pdO1xuICAgICAgICBhZGQxMzA1KGgsIG1pbnVzcCk7XG4gICAgICAgIHMgPSAtKGhbMTZdID4+PiA3KSB8IDA7XG4gICAgICAgIGZvcihqID0gMDsgaiA8IDE3OyBqKyspaFtqXSBePSBzICYgKGdbal0gXiBoW2pdKTtcbiAgICAgICAgZm9yKGogPSAwOyBqIDwgMTY7IGorKyljW2pdID0ga1tqICsgMTZdO1xuICAgICAgICBjWzE2XSA9IDA7XG4gICAgICAgIGFkZDEzMDUoaCwgYyk7XG4gICAgICAgIGZvcihqID0gMDsgaiA8IDE2OyBqKyspb3V0W291dHBvcyArIGpdID0gaFtqXTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyeXB0b19vbmV0aW1lYXV0aF92ZXJpZnkoaCwgaHBvcywgbSwgbXBvcywgbiwgaykge1xuICAgICAgICB2YXIgeCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICAgICAgY3J5cHRvX29uZXRpbWVhdXRoKHgsIDAsIG0sIG1wb3MsIG4sIGspO1xuICAgICAgICByZXR1cm4gY3J5cHRvX3ZlcmlmeV8xNihoLCBocG9zLCB4LCAwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3J5cHRvX3NlY3JldGJveChjLCBtLCBkLCBuLCBrKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBpZiAoZCA8IDMyKSByZXR1cm4gLTE7XG4gICAgICAgIGNyeXB0b19zdHJlYW1feG9yKGMsIDAsIG0sIDAsIGQsIG4sIGspO1xuICAgICAgICBjcnlwdG9fb25ldGltZWF1dGgoYywgMTYsIGMsIDMyLCBkIC0gMzIsIGMpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCAxNjsgaSsrKWNbaV0gPSAwO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3J5cHRvX3NlY3JldGJveF9vcGVuKG0sIGMsIGQsIG4sIGspIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciB4ID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICAgICAgICBpZiAoZCA8IDMyKSByZXR1cm4gLTE7XG4gICAgICAgIGNyeXB0b19zdHJlYW0oeCwgMCwgMzIsIG4sIGspO1xuICAgICAgICBpZiAoY3J5cHRvX29uZXRpbWVhdXRoX3ZlcmlmeShjLCAxNiwgYywgMzIsIGQgLSAzMiwgeCkgIT09IDApIHJldHVybiAtMTtcbiAgICAgICAgY3J5cHRvX3N0cmVhbV94b3IobSwgMCwgYywgMCwgZCwgbiwgayk7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDMyOyBpKyspbVtpXSA9IDA7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXQyNTUxOShyLCBhKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCAxNjsgaSsrKXJbaV0gPSBhW2ldIHwgMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FyMjU1MTkobykge1xuICAgICAgICB2YXIgYztcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDE2OyBpKyspe1xuICAgICAgICAgICAgb1tpXSArPSA2NTUzNjtcbiAgICAgICAgICAgIGMgPSBNYXRoLmZsb29yKG9baV0gLyA2NTUzNik7XG4gICAgICAgICAgICBvWyhpICsgMSkgKiAoaSA8IDE1ID8gMSA6IDApXSArPSBjIC0gMSArIDM3ICogKGMgLSAxKSAqIChpID09PSAxNSA/IDEgOiAwKTtcbiAgICAgICAgICAgIG9baV0gLT0gYyAqIDY1NTM2O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNlbDI1NTE5KHAsIHEsIGIpIHtcbiAgICAgICAgdmFyIHQsIGMgPSB+KGIgLSAxKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IDE2OyBpKyspe1xuICAgICAgICAgICAgdCA9IGMgJiAocFtpXSBeIHFbaV0pO1xuICAgICAgICAgICAgcFtpXSBePSB0O1xuICAgICAgICAgICAgcVtpXSBePSB0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhY2syNTUxOShvLCBuKSB7XG4gICAgICAgIHZhciBpLCBqLCBiO1xuICAgICAgICB2YXIgbSA9IGdmKCksIHQgPSBnZigpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCAxNjsgaSsrKXRbaV0gPSBuW2ldO1xuICAgICAgICBjYXIyNTUxOSh0KTtcbiAgICAgICAgY2FyMjU1MTkodCk7XG4gICAgICAgIGNhcjI1NTE5KHQpO1xuICAgICAgICBmb3IoaiA9IDA7IGogPCAyOyBqKyspe1xuICAgICAgICAgICAgbVswXSA9IHRbMF0gLSAweGZmZWQ7XG4gICAgICAgICAgICBmb3IoaSA9IDE7IGkgPCAxNTsgaSsrKXtcbiAgICAgICAgICAgICAgICBtW2ldID0gdFtpXSAtIDB4ZmZmZiAtIChtW2kgLSAxXSA+PiAxNiAmIDEpO1xuICAgICAgICAgICAgICAgIG1baSAtIDFdICY9IDB4ZmZmZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1bMTVdID0gdFsxNV0gLSAweDdmZmYgLSAobVsxNF0gPj4gMTYgJiAxKTtcbiAgICAgICAgICAgIGIgPSBtWzE1XSA+PiAxNiAmIDE7XG4gICAgICAgICAgICBtWzE0XSAmPSAweGZmZmY7XG4gICAgICAgICAgICBzZWwyNTUxOSh0LCBtLCAxIC0gYik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgMTY7IGkrKyl7XG4gICAgICAgICAgICBvWzIgKiBpXSA9IHRbaV0gJiAweGZmO1xuICAgICAgICAgICAgb1syICogaSArIDFdID0gdFtpXSA+PiA4O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5lcTI1NTE5KGEsIGIpIHtcbiAgICAgICAgdmFyIGMgPSBuZXcgVWludDhBcnJheSgzMiksIGQgPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgICAgIHBhY2syNTUxOShjLCBhKTtcbiAgICAgICAgcGFjazI1NTE5KGQsIGIpO1xuICAgICAgICByZXR1cm4gY3J5cHRvX3ZlcmlmeV8zMihjLCAwLCBkLCAwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyMjU1MTkoYSkge1xuICAgICAgICB2YXIgZCA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICAgICAgcGFjazI1NTE5KGQsIGEpO1xuICAgICAgICByZXR1cm4gZFswXSAmIDE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVucGFjazI1NTE5KG8sIG4pIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDE2OyBpKyspb1tpXSA9IG5bMiAqIGldICsgKG5bMiAqIGkgKyAxXSA8PCA4KTtcbiAgICAgICAgb1sxNV0gJj0gMHg3ZmZmO1xuICAgIH1cbiAgICBmdW5jdGlvbiBBKG8sIGEsIGIpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDE2OyBpKyspb1tpXSA9IGFbaV0gKyBiW2ldIHwgMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gWihvLCBhLCBiKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCAxNjsgaSsrKW9baV0gPSBhW2ldIC0gYltpXSB8IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE0obywgYSwgYikge1xuICAgICAgICB2YXIgaSwgaiwgdCA9IG5ldyBGbG9hdDY0QXJyYXkoMzEpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCAzMTsgaSsrKXRbaV0gPSAwO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCAxNjsgaSsrKXtcbiAgICAgICAgICAgIGZvcihqID0gMDsgaiA8IDE2OyBqKyspe1xuICAgICAgICAgICAgICAgIHRbaSArIGpdICs9IGFbaV0gKiBiW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDE1OyBpKyspe1xuICAgICAgICAgICAgdFtpXSArPSAzOCAqIHRbaSArIDE2XTtcbiAgICAgICAgfVxuICAgICAgICBmb3IoaSA9IDA7IGkgPCAxNjsgaSsrKW9baV0gPSB0W2ldO1xuICAgICAgICBjYXIyNTUxOShvKTtcbiAgICAgICAgY2FyMjU1MTkobyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFMobywgYSkge1xuICAgICAgICBNKG8sIGEsIGEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnYyNTUxOShvLCBpKSB7XG4gICAgICAgIHZhciBjID0gZ2YoKTtcbiAgICAgICAgdmFyIGE7XG4gICAgICAgIGZvcihhID0gMDsgYSA8IDE2OyBhKyspY1thXSA9IGlbYV07XG4gICAgICAgIGZvcihhID0gMjUzOyBhID49IDA7IGEtLSl7XG4gICAgICAgICAgICBTKGMsIGMpO1xuICAgICAgICAgICAgaWYgKGEgIT09IDIgJiYgYSAhPT0gNCkgTShjLCBjLCBpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IoYSA9IDA7IGEgPCAxNjsgYSsrKW9bYV0gPSBjW2FdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3cyNTIzKG8sIGkpIHtcbiAgICAgICAgdmFyIGMgPSBnZigpO1xuICAgICAgICB2YXIgYTtcbiAgICAgICAgZm9yKGEgPSAwOyBhIDwgMTY7IGErKyljW2FdID0gaVthXTtcbiAgICAgICAgZm9yKGEgPSAyNTA7IGEgPj0gMDsgYS0tKXtcbiAgICAgICAgICAgIFMoYywgYyk7XG4gICAgICAgICAgICBpZiAoYSAhPT0gMSkgTShjLCBjLCBpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IoYSA9IDA7IGEgPCAxNjsgYSsrKW9bYV0gPSBjW2FdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcnlwdG9fc2NhbGFybXVsdChxLCBuLCBwKSB7XG4gICAgICAgIHZhciB6ID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICAgICAgICB2YXIgeCA9IG5ldyBGbG9hdDY0QXJyYXkoODApLCByLCBpO1xuICAgICAgICB2YXIgYSA9IGdmKCksIGIgPSBnZigpLCBjID0gZ2YoKSwgZCA9IGdmKCksIGUgPSBnZigpLCBmID0gZ2YoKTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgMzE7IGkrKyl6W2ldID0gbltpXTtcbiAgICAgICAgelszMV0gPSBuWzMxXSAmIDEyNyB8IDY0O1xuICAgICAgICB6WzBdICY9IDI0ODtcbiAgICAgICAgdW5wYWNrMjU1MTkoeCwgcCk7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDE2OyBpKyspe1xuICAgICAgICAgICAgYltpXSA9IHhbaV07XG4gICAgICAgICAgICBkW2ldID0gYVtpXSA9IGNbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGFbMF0gPSBkWzBdID0gMTtcbiAgICAgICAgZm9yKGkgPSAyNTQ7IGkgPj0gMDsgLS1pKXtcbiAgICAgICAgICAgIHIgPSB6W2kgPj4+IDNdID4+PiAoaSAmIDcpICYgMTtcbiAgICAgICAgICAgIHNlbDI1NTE5KGEsIGIsIHIpO1xuICAgICAgICAgICAgc2VsMjU1MTkoYywgZCwgcik7XG4gICAgICAgICAgICBBKGUsIGEsIGMpO1xuICAgICAgICAgICAgWihhLCBhLCBjKTtcbiAgICAgICAgICAgIEEoYywgYiwgZCk7XG4gICAgICAgICAgICBaKGIsIGIsIGQpO1xuICAgICAgICAgICAgUyhkLCBlKTtcbiAgICAgICAgICAgIFMoZiwgYSk7XG4gICAgICAgICAgICBNKGEsIGMsIGEpO1xuICAgICAgICAgICAgTShjLCBiLCBlKTtcbiAgICAgICAgICAgIEEoZSwgYSwgYyk7XG4gICAgICAgICAgICBaKGEsIGEsIGMpO1xuICAgICAgICAgICAgUyhiLCBhKTtcbiAgICAgICAgICAgIFooYywgZCwgZik7XG4gICAgICAgICAgICBNKGEsIGMsIF8xMjE2NjUpO1xuICAgICAgICAgICAgQShhLCBhLCBkKTtcbiAgICAgICAgICAgIE0oYywgYywgYSk7XG4gICAgICAgICAgICBNKGEsIGQsIGYpO1xuICAgICAgICAgICAgTShkLCBiLCB4KTtcbiAgICAgICAgICAgIFMoYiwgZSk7XG4gICAgICAgICAgICBzZWwyNTUxOShhLCBiLCByKTtcbiAgICAgICAgICAgIHNlbDI1NTE5KGMsIGQsIHIpO1xuICAgICAgICB9XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDE2OyBpKyspe1xuICAgICAgICAgICAgeFtpICsgMTZdID0gYVtpXTtcbiAgICAgICAgICAgIHhbaSArIDMyXSA9IGNbaV07XG4gICAgICAgICAgICB4W2kgKyA0OF0gPSBiW2ldO1xuICAgICAgICAgICAgeFtpICsgNjRdID0gZFtpXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeDMyID0geC5zdWJhcnJheSgzMik7XG4gICAgICAgIHZhciB4MTYgPSB4LnN1YmFycmF5KDE2KTtcbiAgICAgICAgaW52MjU1MTkoeDMyLCB4MzIpO1xuICAgICAgICBNKHgxNiwgeDE2LCB4MzIpO1xuICAgICAgICBwYWNrMjU1MTkocSwgeDE2KTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyeXB0b19zY2FsYXJtdWx0X2Jhc2UocSwgbikge1xuICAgICAgICByZXR1cm4gY3J5cHRvX3NjYWxhcm11bHQocSwgbiwgXzkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcnlwdG9fYm94X2tleXBhaXIoeSwgeCkge1xuICAgICAgICByYW5kb21ieXRlcyh4LCAzMik7XG4gICAgICAgIHJldHVybiBjcnlwdG9fc2NhbGFybXVsdF9iYXNlKHksIHgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcnlwdG9fYm94X2JlZm9yZW5tKGssIHksIHgpIHtcbiAgICAgICAgdmFyIHMgPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgICAgIGNyeXB0b19zY2FsYXJtdWx0KHMsIHgsIHkpO1xuICAgICAgICByZXR1cm4gY3J5cHRvX2NvcmVfaHNhbHNhMjAoaywgXzAsIHMsIHNpZ21hKTtcbiAgICB9XG4gICAgdmFyIGNyeXB0b19ib3hfYWZ0ZXJubSA9IGNyeXB0b19zZWNyZXRib3g7XG4gICAgdmFyIGNyeXB0b19ib3hfb3Blbl9hZnRlcm5tID0gY3J5cHRvX3NlY3JldGJveF9vcGVuO1xuICAgIGZ1bmN0aW9uIGNyeXB0b19ib3goYywgbSwgZCwgbiwgeSwgeCkge1xuICAgICAgICB2YXIgayA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICAgICAgY3J5cHRvX2JveF9iZWZvcmVubShrLCB5LCB4KTtcbiAgICAgICAgcmV0dXJuIGNyeXB0b19ib3hfYWZ0ZXJubShjLCBtLCBkLCBuLCBrKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3J5cHRvX2JveF9vcGVuKG0sIGMsIGQsIG4sIHksIHgpIHtcbiAgICAgICAgdmFyIGsgPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgICAgIGNyeXB0b19ib3hfYmVmb3Jlbm0oaywgeSwgeCk7XG4gICAgICAgIHJldHVybiBjcnlwdG9fYm94X29wZW5fYWZ0ZXJubShtLCBjLCBkLCBuLCBrKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkNjQoKSB7XG4gICAgICAgIHZhciBhID0gMCwgYiA9IDAsIGMgPSAwLCBkID0gMCwgbTE2ID0gNjU1MzUsIGwsIGgsIGk7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBsID0gYXJndW1lbnRzW2ldLmxvO1xuICAgICAgICAgICAgaCA9IGFyZ3VtZW50c1tpXS5oaTtcbiAgICAgICAgICAgIGEgKz0gbCAmIG0xNjtcbiAgICAgICAgICAgIGIgKz0gbCA+Pj4gMTY7XG4gICAgICAgICAgICBjICs9IGggJiBtMTY7XG4gICAgICAgICAgICBkICs9IGggPj4+IDE2O1xuICAgICAgICB9XG4gICAgICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgICAgIGQgKz0gYyA+Pj4gMTY7XG4gICAgICAgIHJldHVybiBuZXcgdTY0KGMgJiBtMTYgfCBkIDw8IDE2LCBhICYgbTE2IHwgYiA8PCAxNik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNocjY0KHgsIGMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB1NjQoeC5oaSA+Pj4gYywgeC5sbyA+Pj4gYyB8IHguaGkgPDwgMzIgLSBjKTtcbiAgICB9XG4gICAgZnVuY3Rpb24geG9yNjQoKSB7XG4gICAgICAgIHZhciBsID0gMCwgaCA9IDAsIGk7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBsIF49IGFyZ3VtZW50c1tpXS5sbztcbiAgICAgICAgICAgIGggXj0gYXJndW1lbnRzW2ldLmhpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdTY0KGgsIGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSKHgsIGMpIHtcbiAgICAgICAgdmFyIGgsIGwsIGMxID0gMzIgLSBjO1xuICAgICAgICBpZiAoYyA8IDMyKSB7XG4gICAgICAgICAgICBoID0geC5oaSA+Pj4gYyB8IHgubG8gPDwgYzE7XG4gICAgICAgICAgICBsID0geC5sbyA+Pj4gYyB8IHguaGkgPDwgYzE7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA8IDY0KSB7XG4gICAgICAgICAgICBoID0geC5sbyA+Pj4gYyB8IHguaGkgPDwgYzE7XG4gICAgICAgICAgICBsID0geC5oaSA+Pj4gYyB8IHgubG8gPDwgYzE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyB1NjQoaCwgbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIENoKHgsIHksIHopIHtcbiAgICAgICAgdmFyIGggPSB4LmhpICYgeS5oaSBeIH54LmhpICYgei5oaSwgbCA9IHgubG8gJiB5LmxvIF4gfngubG8gJiB6LmxvO1xuICAgICAgICByZXR1cm4gbmV3IHU2NChoLCBsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gTWFqKHgsIHksIHopIHtcbiAgICAgICAgdmFyIGggPSB4LmhpICYgeS5oaSBeIHguaGkgJiB6LmhpIF4geS5oaSAmIHouaGksIGwgPSB4LmxvICYgeS5sbyBeIHgubG8gJiB6LmxvIF4geS5sbyAmIHoubG87XG4gICAgICAgIHJldHVybiBuZXcgdTY0KGgsIGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBTaWdtYTAoeCkge1xuICAgICAgICByZXR1cm4geG9yNjQoUih4LCAyOCksIFIoeCwgMzQpLCBSKHgsIDM5KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFNpZ21hMSh4KSB7XG4gICAgICAgIHJldHVybiB4b3I2NChSKHgsIDE0KSwgUih4LCAxOCksIFIoeCwgNDEpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2lnbWEwKHgpIHtcbiAgICAgICAgcmV0dXJuIHhvcjY0KFIoeCwgMSksIFIoeCwgOCksIHNocjY0KHgsIDcpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2lnbWExKHgpIHtcbiAgICAgICAgcmV0dXJuIHhvcjY0KFIoeCwgMTkpLCBSKHgsIDYxKSwgc2hyNjQoeCwgNikpO1xuICAgIH1cbiAgICB2YXIgSyA9IFtcbiAgICAgICAgbmV3IHU2NCgweDQyOGEyZjk4LCAweGQ3MjhhZTIyKSxcbiAgICAgICAgbmV3IHU2NCgweDcxMzc0NDkxLCAweDIzZWY2NWNkKSxcbiAgICAgICAgbmV3IHU2NCgweGI1YzBmYmNmLCAweGVjNGQzYjJmKSxcbiAgICAgICAgbmV3IHU2NCgweGU5YjVkYmE1LCAweDgxODlkYmJjKSxcbiAgICAgICAgbmV3IHU2NCgweDM5NTZjMjViLCAweGYzNDhiNTM4KSxcbiAgICAgICAgbmV3IHU2NCgweDU5ZjExMWYxLCAweGI2MDVkMDE5KSxcbiAgICAgICAgbmV3IHU2NCgweDkyM2Y4MmE0LCAweGFmMTk0ZjliKSxcbiAgICAgICAgbmV3IHU2NCgweGFiMWM1ZWQ1LCAweGRhNmQ4MTE4KSxcbiAgICAgICAgbmV3IHU2NCgweGQ4MDdhYTk4LCAweGEzMDMwMjQyKSxcbiAgICAgICAgbmV3IHU2NCgweDEyODM1YjAxLCAweDQ1NzA2ZmJlKSxcbiAgICAgICAgbmV3IHU2NCgweDI0MzE4NWJlLCAweDRlZTRiMjhjKSxcbiAgICAgICAgbmV3IHU2NCgweDU1MGM3ZGMzLCAweGQ1ZmZiNGUyKSxcbiAgICAgICAgbmV3IHU2NCgweDcyYmU1ZDc0LCAweGYyN2I4OTZmKSxcbiAgICAgICAgbmV3IHU2NCgweDgwZGViMWZlLCAweDNiMTY5NmIxKSxcbiAgICAgICAgbmV3IHU2NCgweDliZGMwNmE3LCAweDI1YzcxMjM1KSxcbiAgICAgICAgbmV3IHU2NCgweGMxOWJmMTc0LCAweGNmNjkyNjk0KSxcbiAgICAgICAgbmV3IHU2NCgweGU0OWI2OWMxLCAweDllZjE0YWQyKSxcbiAgICAgICAgbmV3IHU2NCgweGVmYmU0Nzg2LCAweDM4NGYyNWUzKSxcbiAgICAgICAgbmV3IHU2NCgweDBmYzE5ZGM2LCAweDhiOGNkNWI1KSxcbiAgICAgICAgbmV3IHU2NCgweDI0MGNhMWNjLCAweDc3YWM5YzY1KSxcbiAgICAgICAgbmV3IHU2NCgweDJkZTkyYzZmLCAweDU5MmIwMjc1KSxcbiAgICAgICAgbmV3IHU2NCgweDRhNzQ4NGFhLCAweDZlYTZlNDgzKSxcbiAgICAgICAgbmV3IHU2NCgweDVjYjBhOWRjLCAweGJkNDFmYmQ0KSxcbiAgICAgICAgbmV3IHU2NCgweDc2Zjk4OGRhLCAweDgzMTE1M2I1KSxcbiAgICAgICAgbmV3IHU2NCgweDk4M2U1MTUyLCAweGVlNjZkZmFiKSxcbiAgICAgICAgbmV3IHU2NCgweGE4MzFjNjZkLCAweDJkYjQzMjEwKSxcbiAgICAgICAgbmV3IHU2NCgweGIwMDMyN2M4LCAweDk4ZmIyMTNmKSxcbiAgICAgICAgbmV3IHU2NCgweGJmNTk3ZmM3LCAweGJlZWYwZWU0KSxcbiAgICAgICAgbmV3IHU2NCgweGM2ZTAwYmYzLCAweDNkYTg4ZmMyKSxcbiAgICAgICAgbmV3IHU2NCgweGQ1YTc5MTQ3LCAweDkzMGFhNzI1KSxcbiAgICAgICAgbmV3IHU2NCgweDA2Y2E2MzUxLCAweGUwMDM4MjZmKSxcbiAgICAgICAgbmV3IHU2NCgweDE0MjkyOTY3LCAweDBhMGU2ZTcwKSxcbiAgICAgICAgbmV3IHU2NCgweDI3YjcwYTg1LCAweDQ2ZDIyZmZjKSxcbiAgICAgICAgbmV3IHU2NCgweDJlMWIyMTM4LCAweDVjMjZjOTI2KSxcbiAgICAgICAgbmV3IHU2NCgweDRkMmM2ZGZjLCAweDVhYzQyYWVkKSxcbiAgICAgICAgbmV3IHU2NCgweDUzMzgwZDEzLCAweDlkOTViM2RmKSxcbiAgICAgICAgbmV3IHU2NCgweDY1MGE3MzU0LCAweDhiYWY2M2RlKSxcbiAgICAgICAgbmV3IHU2NCgweDc2NmEwYWJiLCAweDNjNzdiMmE4KSxcbiAgICAgICAgbmV3IHU2NCgweDgxYzJjOTJlLCAweDQ3ZWRhZWU2KSxcbiAgICAgICAgbmV3IHU2NCgweDkyNzIyYzg1LCAweDE0ODIzNTNiKSxcbiAgICAgICAgbmV3IHU2NCgweGEyYmZlOGExLCAweDRjZjEwMzY0KSxcbiAgICAgICAgbmV3IHU2NCgweGE4MWE2NjRiLCAweGJjNDIzMDAxKSxcbiAgICAgICAgbmV3IHU2NCgweGMyNGI4YjcwLCAweGQwZjg5NzkxKSxcbiAgICAgICAgbmV3IHU2NCgweGM3NmM1MWEzLCAweDA2NTRiZTMwKSxcbiAgICAgICAgbmV3IHU2NCgweGQxOTJlODE5LCAweGQ2ZWY1MjE4KSxcbiAgICAgICAgbmV3IHU2NCgweGQ2OTkwNjI0LCAweDU1NjVhOTEwKSxcbiAgICAgICAgbmV3IHU2NCgweGY0MGUzNTg1LCAweDU3NzEyMDJhKSxcbiAgICAgICAgbmV3IHU2NCgweDEwNmFhMDcwLCAweDMyYmJkMWI4KSxcbiAgICAgICAgbmV3IHU2NCgweDE5YTRjMTE2LCAweGI4ZDJkMGM4KSxcbiAgICAgICAgbmV3IHU2NCgweDFlMzc2YzA4LCAweDUxNDFhYjUzKSxcbiAgICAgICAgbmV3IHU2NCgweDI3NDg3NzRjLCAweGRmOGVlYjk5KSxcbiAgICAgICAgbmV3IHU2NCgweDM0YjBiY2I1LCAweGUxOWI0OGE4KSxcbiAgICAgICAgbmV3IHU2NCgweDM5MWMwY2IzLCAweGM1Yzk1YTYzKSxcbiAgICAgICAgbmV3IHU2NCgweDRlZDhhYTRhLCAweGUzNDE4YWNiKSxcbiAgICAgICAgbmV3IHU2NCgweDViOWNjYTRmLCAweDc3NjNlMzczKSxcbiAgICAgICAgbmV3IHU2NCgweDY4MmU2ZmYzLCAweGQ2YjJiOGEzKSxcbiAgICAgICAgbmV3IHU2NCgweDc0OGY4MmVlLCAweDVkZWZiMmZjKSxcbiAgICAgICAgbmV3IHU2NCgweDc4YTU2MzZmLCAweDQzMTcyZjYwKSxcbiAgICAgICAgbmV3IHU2NCgweDg0Yzg3ODE0LCAweGExZjBhYjcyKSxcbiAgICAgICAgbmV3IHU2NCgweDhjYzcwMjA4LCAweDFhNjQzOWVjKSxcbiAgICAgICAgbmV3IHU2NCgweDkwYmVmZmZhLCAweDIzNjMxZTI4KSxcbiAgICAgICAgbmV3IHU2NCgweGE0NTA2Y2ViLCAweGRlODJiZGU5KSxcbiAgICAgICAgbmV3IHU2NCgweGJlZjlhM2Y3LCAweGIyYzY3OTE1KSxcbiAgICAgICAgbmV3IHU2NCgweGM2NzE3OGYyLCAweGUzNzI1MzJiKSxcbiAgICAgICAgbmV3IHU2NCgweGNhMjczZWNlLCAweGVhMjY2MTljKSxcbiAgICAgICAgbmV3IHU2NCgweGQxODZiOGM3LCAweDIxYzBjMjA3KSxcbiAgICAgICAgbmV3IHU2NCgweGVhZGE3ZGQ2LCAweGNkZTBlYjFlKSxcbiAgICAgICAgbmV3IHU2NCgweGY1N2Q0ZjdmLCAweGVlNmVkMTc4KSxcbiAgICAgICAgbmV3IHU2NCgweDA2ZjA2N2FhLCAweDcyMTc2ZmJhKSxcbiAgICAgICAgbmV3IHU2NCgweDBhNjM3ZGM1LCAweGEyYzg5OGE2KSxcbiAgICAgICAgbmV3IHU2NCgweDExM2Y5ODA0LCAweGJlZjkwZGFlKSxcbiAgICAgICAgbmV3IHU2NCgweDFiNzEwYjM1LCAweDEzMWM0NzFiKSxcbiAgICAgICAgbmV3IHU2NCgweDI4ZGI3N2Y1LCAweDIzMDQ3ZDg0KSxcbiAgICAgICAgbmV3IHU2NCgweDMyY2FhYjdiLCAweDQwYzcyNDkzKSxcbiAgICAgICAgbmV3IHU2NCgweDNjOWViZTBhLCAweDE1YzliZWJjKSxcbiAgICAgICAgbmV3IHU2NCgweDQzMWQ2N2M0LCAweDljMTAwZDRjKSxcbiAgICAgICAgbmV3IHU2NCgweDRjYzVkNGJlLCAweGNiM2U0MmI2KSxcbiAgICAgICAgbmV3IHU2NCgweDU5N2YyOTljLCAweGZjNjU3ZTJhKSxcbiAgICAgICAgbmV3IHU2NCgweDVmY2I2ZmFiLCAweDNhZDZmYWVjKSxcbiAgICAgICAgbmV3IHU2NCgweDZjNDQxOThjLCAweDRhNDc1ODE3KVxuICAgIF07XG4gICAgZnVuY3Rpb24gY3J5cHRvX2hhc2hibG9ja3MoeCwgbSwgbikge1xuICAgICAgICB2YXIgeiA9IFtdLCBiID0gW10sIGEgPSBbXSwgdyA9IFtdLCB0LCBpLCBqO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCA4OyBpKyspeltpXSA9IGFbaV0gPSBkbDY0KHgsIDggKiBpKTtcbiAgICAgICAgdmFyIHBvcyA9IDA7XG4gICAgICAgIHdoaWxlKG4gPj0gMTI4KXtcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IDE2OyBpKyspd1tpXSA9IGRsNjQobSwgOCAqIGkgKyBwb3MpO1xuICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgODA7IGkrKyl7XG4gICAgICAgICAgICAgICAgZm9yKGogPSAwOyBqIDwgODsgaisrKWJbal0gPSBhW2pdO1xuICAgICAgICAgICAgICAgIHQgPSBhZGQ2NChhWzddLCBTaWdtYTEoYVs0XSksIENoKGFbNF0sIGFbNV0sIGFbNl0pLCBLW2ldLCB3W2kgJSAxNl0pO1xuICAgICAgICAgICAgICAgIGJbN10gPSBhZGQ2NCh0LCBTaWdtYTAoYVswXSksIE1haihhWzBdLCBhWzFdLCBhWzJdKSk7XG4gICAgICAgICAgICAgICAgYlszXSA9IGFkZDY0KGJbM10sIHQpO1xuICAgICAgICAgICAgICAgIGZvcihqID0gMDsgaiA8IDg7IGorKylhWyhqICsgMSkgJSA4XSA9IGJbal07XG4gICAgICAgICAgICAgICAgaWYgKGkgJSAxNiA9PT0gMTUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGogPSAwOyBqIDwgMTY7IGorKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICB3W2pdID0gYWRkNjQod1tqXSwgd1soaiArIDkpICUgMTZdLCBzaWdtYTAod1soaiArIDEpICUgMTZdKSwgc2lnbWExKHdbKGogKyAxNCkgJSAxNl0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IDg7IGkrKyl7XG4gICAgICAgICAgICAgICAgYVtpXSA9IGFkZDY0KGFbaV0sIHpbaV0pO1xuICAgICAgICAgICAgICAgIHpbaV0gPSBhW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zICs9IDEyODtcbiAgICAgICAgICAgIG4gLT0gMTI4O1xuICAgICAgICB9XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDg7IGkrKyl0czY0KHgsIDggKiBpLCB6W2ldKTtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgIHZhciBpdiA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgMHg2YSxcbiAgICAgICAgMHgwOSxcbiAgICAgICAgMHhlNixcbiAgICAgICAgMHg2NyxcbiAgICAgICAgMHhmMyxcbiAgICAgICAgMHhiYyxcbiAgICAgICAgMHhjOSxcbiAgICAgICAgMHgwOCxcbiAgICAgICAgMHhiYixcbiAgICAgICAgMHg2NyxcbiAgICAgICAgMHhhZSxcbiAgICAgICAgMHg4NSxcbiAgICAgICAgMHg4NCxcbiAgICAgICAgMHhjYSxcbiAgICAgICAgMHhhNyxcbiAgICAgICAgMHgzYixcbiAgICAgICAgMHgzYyxcbiAgICAgICAgMHg2ZSxcbiAgICAgICAgMHhmMyxcbiAgICAgICAgMHg3MixcbiAgICAgICAgMHhmZSxcbiAgICAgICAgMHg5NCxcbiAgICAgICAgMHhmOCxcbiAgICAgICAgMHgyYixcbiAgICAgICAgMHhhNSxcbiAgICAgICAgMHg0ZixcbiAgICAgICAgMHhmNSxcbiAgICAgICAgMHgzYSxcbiAgICAgICAgMHg1ZixcbiAgICAgICAgMHgxZCxcbiAgICAgICAgMHgzNixcbiAgICAgICAgMHhmMSxcbiAgICAgICAgMHg1MSxcbiAgICAgICAgMHgwZSxcbiAgICAgICAgMHg1MixcbiAgICAgICAgMHg3ZixcbiAgICAgICAgMHhhZCxcbiAgICAgICAgMHhlNixcbiAgICAgICAgMHg4MixcbiAgICAgICAgMHhkMSxcbiAgICAgICAgMHg5YixcbiAgICAgICAgMHgwNSxcbiAgICAgICAgMHg2OCxcbiAgICAgICAgMHg4YyxcbiAgICAgICAgMHgyYixcbiAgICAgICAgMHgzZSxcbiAgICAgICAgMHg2YyxcbiAgICAgICAgMHgxZixcbiAgICAgICAgMHgxZixcbiAgICAgICAgMHg4MyxcbiAgICAgICAgMHhkOSxcbiAgICAgICAgMHhhYixcbiAgICAgICAgMHhmYixcbiAgICAgICAgMHg0MSxcbiAgICAgICAgMHhiZCxcbiAgICAgICAgMHg2YixcbiAgICAgICAgMHg1YixcbiAgICAgICAgMHhlMCxcbiAgICAgICAgMHhjZCxcbiAgICAgICAgMHgxOSxcbiAgICAgICAgMHgxMyxcbiAgICAgICAgMHg3ZSxcbiAgICAgICAgMHgyMSxcbiAgICAgICAgMHg3OVxuICAgIF0pO1xuICAgIGZ1bmN0aW9uIGNyeXB0b19oYXNoKG91dCwgbSwgbikge1xuICAgICAgICB2YXIgaCA9IG5ldyBVaW50OEFycmF5KDY0KSwgeCA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG4gICAgICAgIHZhciBpLCBiID0gbjtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgNjQ7IGkrKyloW2ldID0gaXZbaV07XG4gICAgICAgIGNyeXB0b19oYXNoYmxvY2tzKGgsIG0sIG4pO1xuICAgICAgICBuICU9IDEyODtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgMjU2OyBpKyspeFtpXSA9IDA7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IG47IGkrKyl4W2ldID0gbVtiIC0gbiArIGldO1xuICAgICAgICB4W25dID0gMTI4O1xuICAgICAgICBuID0gMjU2IC0gMTI4ICogKG4gPCAxMTIgPyAxIDogMCk7XG4gICAgICAgIHhbbiAtIDldID0gMDtcbiAgICAgICAgdHM2NCh4LCBuIC0gOCwgbmV3IHU2NChiIC8gMHgyMDAwMDAwMCB8IDAsIGIgPDwgMykpO1xuICAgICAgICBjcnlwdG9faGFzaGJsb2NrcyhoLCB4LCBuKTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgNjQ7IGkrKylvdXRbaV0gPSBoW2ldO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkKHAsIHEpIHtcbiAgICAgICAgdmFyIGEgPSBnZigpLCBiID0gZ2YoKSwgYyA9IGdmKCksIGQgPSBnZigpLCBlID0gZ2YoKSwgZiA9IGdmKCksIGcgPSBnZigpLCBoID0gZ2YoKSwgdCA9IGdmKCk7XG4gICAgICAgIFooYSwgcFsxXSwgcFswXSk7XG4gICAgICAgIFoodCwgcVsxXSwgcVswXSk7XG4gICAgICAgIE0oYSwgYSwgdCk7XG4gICAgICAgIEEoYiwgcFswXSwgcFsxXSk7XG4gICAgICAgIEEodCwgcVswXSwgcVsxXSk7XG4gICAgICAgIE0oYiwgYiwgdCk7XG4gICAgICAgIE0oYywgcFszXSwgcVszXSk7XG4gICAgICAgIE0oYywgYywgRDIpO1xuICAgICAgICBNKGQsIHBbMl0sIHFbMl0pO1xuICAgICAgICBBKGQsIGQsIGQpO1xuICAgICAgICBaKGUsIGIsIGEpO1xuICAgICAgICBaKGYsIGQsIGMpO1xuICAgICAgICBBKGcsIGQsIGMpO1xuICAgICAgICBBKGgsIGIsIGEpO1xuICAgICAgICBNKHBbMF0sIGUsIGYpO1xuICAgICAgICBNKHBbMV0sIGgsIGcpO1xuICAgICAgICBNKHBbMl0sIGcsIGYpO1xuICAgICAgICBNKHBbM10sIGUsIGgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjc3dhcChwLCBxLCBiKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCA0OyBpKyspe1xuICAgICAgICAgICAgc2VsMjU1MTkocFtpXSwgcVtpXSwgYik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcGFjayhyLCBwKSB7XG4gICAgICAgIHZhciB0eCA9IGdmKCksIHR5ID0gZ2YoKSwgemkgPSBnZigpO1xuICAgICAgICBpbnYyNTUxOSh6aSwgcFsyXSk7XG4gICAgICAgIE0odHgsIHBbMF0sIHppKTtcbiAgICAgICAgTSh0eSwgcFsxXSwgemkpO1xuICAgICAgICBwYWNrMjU1MTkociwgdHkpO1xuICAgICAgICByWzMxXSBePSBwYXIyNTUxOSh0eCkgPDwgNztcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NhbGFybXVsdChwLCBxLCBzKSB7XG4gICAgICAgIHZhciBiLCBpO1xuICAgICAgICBzZXQyNTUxOShwWzBdLCBnZjApO1xuICAgICAgICBzZXQyNTUxOShwWzFdLCBnZjEpO1xuICAgICAgICBzZXQyNTUxOShwWzJdLCBnZjEpO1xuICAgICAgICBzZXQyNTUxOShwWzNdLCBnZjApO1xuICAgICAgICBmb3IoaSA9IDI1NTsgaSA+PSAwOyAtLWkpe1xuICAgICAgICAgICAgYiA9IHNbaSAvIDggfCAwXSA+PiAoaSAmIDcpICYgMTtcbiAgICAgICAgICAgIGNzd2FwKHAsIHEsIGIpO1xuICAgICAgICAgICAgYWRkKHEsIHApO1xuICAgICAgICAgICAgYWRkKHAsIHApO1xuICAgICAgICAgICAgY3N3YXAocCwgcSwgYik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2NhbGFyYmFzZShwLCBzKSB7XG4gICAgICAgIHZhciBxID0gW1xuICAgICAgICAgICAgZ2YoKSxcbiAgICAgICAgICAgIGdmKCksXG4gICAgICAgICAgICBnZigpLFxuICAgICAgICAgICAgZ2YoKVxuICAgICAgICBdO1xuICAgICAgICBzZXQyNTUxOShxWzBdLCBYKTtcbiAgICAgICAgc2V0MjU1MTkocVsxXSwgWSk7XG4gICAgICAgIHNldDI1NTE5KHFbMl0sIGdmMSk7XG4gICAgICAgIE0ocVszXSwgWCwgWSk7XG4gICAgICAgIHNjYWxhcm11bHQocCwgcSwgcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyeXB0b19zaWduX2tleXBhaXIocGssIHNrLCBzZWVkZWQpIHtcbiAgICAgICAgdmFyIGQgPSBuZXcgVWludDhBcnJheSg2NCk7XG4gICAgICAgIHZhciBwID0gW1xuICAgICAgICAgICAgZ2YoKSxcbiAgICAgICAgICAgIGdmKCksXG4gICAgICAgICAgICBnZigpLFxuICAgICAgICAgICAgZ2YoKVxuICAgICAgICBdO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgaWYgKCFzZWVkZWQpIHJhbmRvbWJ5dGVzKHNrLCAzMik7XG4gICAgICAgIGNyeXB0b19oYXNoKGQsIHNrLCAzMik7XG4gICAgICAgIGRbMF0gJj0gMjQ4O1xuICAgICAgICBkWzMxXSAmPSAxMjc7XG4gICAgICAgIGRbMzFdIHw9IDY0O1xuICAgICAgICBzY2FsYXJiYXNlKHAsIGQpO1xuICAgICAgICBwYWNrKHBrLCBwKTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgMzI7IGkrKylza1tpICsgMzJdID0gcGtbaV07XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICB2YXIgTCA9IG5ldyBGbG9hdDY0QXJyYXkoW1xuICAgICAgICAweGVkLFxuICAgICAgICAweGQzLFxuICAgICAgICAweGY1LFxuICAgICAgICAweDVjLFxuICAgICAgICAweDFhLFxuICAgICAgICAweDYzLFxuICAgICAgICAweDEyLFxuICAgICAgICAweDU4LFxuICAgICAgICAweGQ2LFxuICAgICAgICAweDljLFxuICAgICAgICAweGY3LFxuICAgICAgICAweGEyLFxuICAgICAgICAweGRlLFxuICAgICAgICAweGY5LFxuICAgICAgICAweGRlLFxuICAgICAgICAweDE0LFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAweDEwXG4gICAgXSk7XG4gICAgZnVuY3Rpb24gbW9kTChyLCB4KSB7XG4gICAgICAgIHZhciBjYXJyeSwgaSwgaiwgaztcbiAgICAgICAgZm9yKGkgPSA2MzsgaSA+PSAzMjsgLS1pKXtcbiAgICAgICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgICAgICAgIGZvcihqID0gaSAtIDMyLCBrID0gaSAtIDEyOyBqIDwgazsgKytqKXtcbiAgICAgICAgICAgICAgICB4W2pdICs9IGNhcnJ5IC0gMTYgKiB4W2ldICogTFtqIC0gKGkgLSAzMildO1xuICAgICAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcigoeFtqXSArIDEyOCkgLyAyNTYpO1xuICAgICAgICAgICAgICAgIHhbal0gLT0gY2FycnkgKiAyNTY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4W2pdICs9IGNhcnJ5O1xuICAgICAgICAgICAgeFtpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY2FycnkgPSAwO1xuICAgICAgICBmb3IoaiA9IDA7IGogPCAzMjsgaisrKXtcbiAgICAgICAgICAgIHhbal0gKz0gY2FycnkgLSAoeFszMV0gPj4gNCkgKiBMW2pdO1xuICAgICAgICAgICAgY2FycnkgPSB4W2pdID4+IDg7XG4gICAgICAgICAgICB4W2pdICY9IDI1NTtcbiAgICAgICAgfVxuICAgICAgICBmb3IoaiA9IDA7IGogPCAzMjsgaisrKXhbal0gLT0gY2FycnkgKiBMW2pdO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCAzMjsgaSsrKXtcbiAgICAgICAgICAgIHhbaSArIDFdICs9IHhbaV0gPj4gODtcbiAgICAgICAgICAgIHJbaV0gPSB4W2ldICYgMjU1O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZHVjZShyKSB7XG4gICAgICAgIHZhciB4ID0gbmV3IEZsb2F0NjRBcnJheSg2NCksIGk7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDY0OyBpKyspeFtpXSA9IHJbaV07XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDY0OyBpKyspcltpXSA9IDA7XG4gICAgICAgIG1vZEwociwgeCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyeXB0b19zaWduKHNtLCBtLCBuLCBzaykge1xuICAgICAgICB2YXIgZCA9IG5ldyBVaW50OEFycmF5KDY0KSwgaCA9IG5ldyBVaW50OEFycmF5KDY0KSwgciA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgICAgICAgdmFyIGksIGosIHggPSBuZXcgRmxvYXQ2NEFycmF5KDY0KTtcbiAgICAgICAgdmFyIHAgPSBbXG4gICAgICAgICAgICBnZigpLFxuICAgICAgICAgICAgZ2YoKSxcbiAgICAgICAgICAgIGdmKCksXG4gICAgICAgICAgICBnZigpXG4gICAgICAgIF07XG4gICAgICAgIGNyeXB0b19oYXNoKGQsIHNrLCAzMik7XG4gICAgICAgIGRbMF0gJj0gMjQ4O1xuICAgICAgICBkWzMxXSAmPSAxMjc7XG4gICAgICAgIGRbMzFdIHw9IDY0O1xuICAgICAgICB2YXIgc21sZW4gPSBuICsgNjQ7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IG47IGkrKylzbVs2NCArIGldID0gbVtpXTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgMzI7IGkrKylzbVszMiArIGldID0gZFszMiArIGldO1xuICAgICAgICBjcnlwdG9faGFzaChyLCBzbS5zdWJhcnJheSgzMiksIG4gKyAzMik7XG4gICAgICAgIHJlZHVjZShyKTtcbiAgICAgICAgc2NhbGFyYmFzZShwLCByKTtcbiAgICAgICAgcGFjayhzbSwgcCk7XG4gICAgICAgIGZvcihpID0gMzI7IGkgPCA2NDsgaSsrKXNtW2ldID0gc2tbaV07XG4gICAgICAgIGNyeXB0b19oYXNoKGgsIHNtLCBuICsgNjQpO1xuICAgICAgICByZWR1Y2UoaCk7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDY0OyBpKyspeFtpXSA9IDA7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDMyOyBpKyspeFtpXSA9IHJbaV07XG4gICAgICAgIGZvcihpID0gMDsgaSA8IDMyOyBpKyspe1xuICAgICAgICAgICAgZm9yKGogPSAwOyBqIDwgMzI7IGorKyl7XG4gICAgICAgICAgICAgICAgeFtpICsgal0gKz0gaFtpXSAqIGRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbW9kTChzbS5zdWJhcnJheSgzMiksIHgpO1xuICAgICAgICByZXR1cm4gc21sZW47XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVucGFja25lZyhyLCBwKSB7XG4gICAgICAgIHZhciB0ID0gZ2YoKSwgY2hrID0gZ2YoKSwgbnVtID0gZ2YoKSwgZGVuID0gZ2YoKSwgZGVuMiA9IGdmKCksIGRlbjQgPSBnZigpLCBkZW42ID0gZ2YoKTtcbiAgICAgICAgc2V0MjU1MTkoclsyXSwgZ2YxKTtcbiAgICAgICAgdW5wYWNrMjU1MTkoclsxXSwgcCk7XG4gICAgICAgIFMobnVtLCByWzFdKTtcbiAgICAgICAgTShkZW4sIG51bSwgRCk7XG4gICAgICAgIFoobnVtLCBudW0sIHJbMl0pO1xuICAgICAgICBBKGRlbiwgclsyXSwgZGVuKTtcbiAgICAgICAgUyhkZW4yLCBkZW4pO1xuICAgICAgICBTKGRlbjQsIGRlbjIpO1xuICAgICAgICBNKGRlbjYsIGRlbjQsIGRlbjIpO1xuICAgICAgICBNKHQsIGRlbjYsIG51bSk7XG4gICAgICAgIE0odCwgdCwgZGVuKTtcbiAgICAgICAgcG93MjUyMyh0LCB0KTtcbiAgICAgICAgTSh0LCB0LCBudW0pO1xuICAgICAgICBNKHQsIHQsIGRlbik7XG4gICAgICAgIE0odCwgdCwgZGVuKTtcbiAgICAgICAgTShyWzBdLCB0LCBkZW4pO1xuICAgICAgICBTKGNoaywgclswXSk7XG4gICAgICAgIE0oY2hrLCBjaGssIGRlbik7XG4gICAgICAgIGlmIChuZXEyNTUxOShjaGssIG51bSkpIE0oclswXSwgclswXSwgSSk7XG4gICAgICAgIFMoY2hrLCByWzBdKTtcbiAgICAgICAgTShjaGssIGNoaywgZGVuKTtcbiAgICAgICAgaWYgKG5lcTI1NTE5KGNoaywgbnVtKSkgcmV0dXJuIC0xO1xuICAgICAgICBpZiAocGFyMjU1MTkoclswXSkgPT09IHBbMzFdID4+IDcpIFooclswXSwgZ2YwLCByWzBdKTtcbiAgICAgICAgTShyWzNdLCByWzBdLCByWzFdKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyeXB0b19zaWduX29wZW4obSwgc20sIG4sIHBrKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgdCA9IG5ldyBVaW50OEFycmF5KDMyKSwgaCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgICAgICAgdmFyIHAgPSBbXG4gICAgICAgICAgICBnZigpLFxuICAgICAgICAgICAgZ2YoKSxcbiAgICAgICAgICAgIGdmKCksXG4gICAgICAgICAgICBnZigpXG4gICAgICAgIF0sIHEgPSBbXG4gICAgICAgICAgICBnZigpLFxuICAgICAgICAgICAgZ2YoKSxcbiAgICAgICAgICAgIGdmKCksXG4gICAgICAgICAgICBnZigpXG4gICAgICAgIF07XG4gICAgICAgIGlmIChuIDwgNjQpIHJldHVybiAtMTtcbiAgICAgICAgaWYgKHVucGFja25lZyhxLCBwaykpIHJldHVybiAtMTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgbjsgaSsrKW1baV0gPSBzbVtpXTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgMzI7IGkrKyltW2kgKyAzMl0gPSBwa1tpXTtcbiAgICAgICAgY3J5cHRvX2hhc2goaCwgbSwgbik7XG4gICAgICAgIHJlZHVjZShoKTtcbiAgICAgICAgc2NhbGFybXVsdChwLCBxLCBoKTtcbiAgICAgICAgc2NhbGFyYmFzZShxLCBzbS5zdWJhcnJheSgzMikpO1xuICAgICAgICBhZGQocCwgcSk7XG4gICAgICAgIHBhY2sodCwgcCk7XG4gICAgICAgIG4gLT0gNjQ7XG4gICAgICAgIGlmIChjcnlwdG9fdmVyaWZ5XzMyKHNtLCAwLCB0LCAwKSkge1xuICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgbjsgaSsrKW1baV0gPSAwO1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGZvcihpID0gMDsgaSA8IG47IGkrKyltW2ldID0gc21baSArIDY0XTtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgIHZhciBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTID0gMzIsIGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUyA9IDI0LCBjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUyA9IDMyLCBjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUyA9IDE2LCBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUyA9IDMyLCBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUyA9IDMyLCBjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTID0gMzIsIGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVMgPSAzMiwgY3J5cHRvX2JveF9CRUZPUkVOTUJZVEVTID0gMzIsIGNyeXB0b19ib3hfTk9OQ0VCWVRFUyA9IGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUywgY3J5cHRvX2JveF9aRVJPQllURVMgPSBjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUywgY3J5cHRvX2JveF9CT1haRVJPQllURVMgPSBjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUywgY3J5cHRvX3NpZ25fQllURVMgPSA2NCwgY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMgPSAzMiwgY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMgPSA2NCwgY3J5cHRvX3NpZ25fU0VFREJZVEVTID0gMzIsIGNyeXB0b19oYXNoX0JZVEVTID0gNjQ7XG4gICAgbmFjbC5sb3dsZXZlbCA9IHtcbiAgICAgICAgY3J5cHRvX2NvcmVfaHNhbHNhMjA6IGNyeXB0b19jb3JlX2hzYWxzYTIwLFxuICAgICAgICBjcnlwdG9fc3RyZWFtX3hvcjogY3J5cHRvX3N0cmVhbV94b3IsXG4gICAgICAgIGNyeXB0b19zdHJlYW06IGNyeXB0b19zdHJlYW0sXG4gICAgICAgIGNyeXB0b19zdHJlYW1fc2Fsc2EyMF94b3I6IGNyeXB0b19zdHJlYW1fc2Fsc2EyMF94b3IsXG4gICAgICAgIGNyeXB0b19zdHJlYW1fc2Fsc2EyMDogY3J5cHRvX3N0cmVhbV9zYWxzYTIwLFxuICAgICAgICBjcnlwdG9fb25ldGltZWF1dGg6IGNyeXB0b19vbmV0aW1lYXV0aCxcbiAgICAgICAgY3J5cHRvX29uZXRpbWVhdXRoX3ZlcmlmeTogY3J5cHRvX29uZXRpbWVhdXRoX3ZlcmlmeSxcbiAgICAgICAgY3J5cHRvX3ZlcmlmeV8xNjogY3J5cHRvX3ZlcmlmeV8xNixcbiAgICAgICAgY3J5cHRvX3ZlcmlmeV8zMjogY3J5cHRvX3ZlcmlmeV8zMixcbiAgICAgICAgY3J5cHRvX3NlY3JldGJveDogY3J5cHRvX3NlY3JldGJveCxcbiAgICAgICAgY3J5cHRvX3NlY3JldGJveF9vcGVuOiBjcnlwdG9fc2VjcmV0Ym94X29wZW4sXG4gICAgICAgIGNyeXB0b19zY2FsYXJtdWx0OiBjcnlwdG9fc2NhbGFybXVsdCxcbiAgICAgICAgY3J5cHRvX3NjYWxhcm11bHRfYmFzZTogY3J5cHRvX3NjYWxhcm11bHRfYmFzZSxcbiAgICAgICAgY3J5cHRvX2JveF9iZWZvcmVubTogY3J5cHRvX2JveF9iZWZvcmVubSxcbiAgICAgICAgY3J5cHRvX2JveF9hZnRlcm5tOiBjcnlwdG9fYm94X2FmdGVybm0sXG4gICAgICAgIGNyeXB0b19ib3g6IGNyeXB0b19ib3gsXG4gICAgICAgIGNyeXB0b19ib3hfb3BlbjogY3J5cHRvX2JveF9vcGVuLFxuICAgICAgICBjcnlwdG9fYm94X2tleXBhaXI6IGNyeXB0b19ib3hfa2V5cGFpcixcbiAgICAgICAgY3J5cHRvX2hhc2g6IGNyeXB0b19oYXNoLFxuICAgICAgICBjcnlwdG9fc2lnbjogY3J5cHRvX3NpZ24sXG4gICAgICAgIGNyeXB0b19zaWduX2tleXBhaXI6IGNyeXB0b19zaWduX2tleXBhaXIsXG4gICAgICAgIGNyeXB0b19zaWduX29wZW46IGNyeXB0b19zaWduX29wZW4sXG4gICAgICAgIGNyeXB0b19zZWNyZXRib3hfS0VZQllURVM6IGNyeXB0b19zZWNyZXRib3hfS0VZQllURVMsXG4gICAgICAgIGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUzogY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTLFxuICAgICAgICBjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUzogY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVMsXG4gICAgICAgIGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTOiBjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUyxcbiAgICAgICAgY3J5cHRvX3NjYWxhcm11bHRfQllURVM6IGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTLFxuICAgICAgICBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUzogY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVMsXG4gICAgICAgIGNyeXB0b19ib3hfUFVCTElDS0VZQllURVM6IGNyeXB0b19ib3hfUFVCTElDS0VZQllURVMsXG4gICAgICAgIGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVM6IGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVMsXG4gICAgICAgIGNyeXB0b19ib3hfQkVGT1JFTk1CWVRFUzogY3J5cHRvX2JveF9CRUZPUkVOTUJZVEVTLFxuICAgICAgICBjcnlwdG9fYm94X05PTkNFQllURVM6IGNyeXB0b19ib3hfTk9OQ0VCWVRFUyxcbiAgICAgICAgY3J5cHRvX2JveF9aRVJPQllURVM6IGNyeXB0b19ib3hfWkVST0JZVEVTLFxuICAgICAgICBjcnlwdG9fYm94X0JPWFpFUk9CWVRFUzogY3J5cHRvX2JveF9CT1haRVJPQllURVMsXG4gICAgICAgIGNyeXB0b19zaWduX0JZVEVTOiBjcnlwdG9fc2lnbl9CWVRFUyxcbiAgICAgICAgY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVM6IGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTLFxuICAgICAgICBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUzogY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMsXG4gICAgICAgIGNyeXB0b19zaWduX1NFRURCWVRFUzogY3J5cHRvX3NpZ25fU0VFREJZVEVTLFxuICAgICAgICBjcnlwdG9faGFzaF9CWVRFUzogY3J5cHRvX2hhc2hfQllURVMsXG4gICAgICAgIGdmOiBnZixcbiAgICAgICAgRDogRCxcbiAgICAgICAgTDogTCxcbiAgICAgICAgcGFjazI1NTE5OiBwYWNrMjU1MTksXG4gICAgICAgIHVucGFjazI1NTE5OiB1bnBhY2syNTUxOSxcbiAgICAgICAgTTogTSxcbiAgICAgICAgQTogQSxcbiAgICAgICAgUzogUyxcbiAgICAgICAgWjogWixcbiAgICAgICAgcG93MjUyMzogcG93MjUyMyxcbiAgICAgICAgYWRkOiBhZGQsXG4gICAgICAgIHNldDI1NTE5OiBzZXQyNTUxOSxcbiAgICAgICAgbW9kTDogbW9kTCxcbiAgICAgICAgc2NhbGFybXVsdDogc2NhbGFybXVsdCxcbiAgICAgICAgc2NhbGFyYmFzZTogc2NhbGFyYmFzZVxuICAgIH07XG4gICAgZnVuY3Rpb24gY2hlY2tMZW5ndGhzKGssIG4pIHtcbiAgICAgICAgaWYgKGsubGVuZ3RoICE9PSBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBrZXkgc2l6ZScpO1xuICAgICAgICBpZiAobi5sZW5ndGggIT09IGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgbm9uY2Ugc2l6ZScpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0JveExlbmd0aHMocGssIHNrKSB7XG4gICAgICAgIGlmIChway5sZW5ndGggIT09IGNyeXB0b19ib3hfUFVCTElDS0VZQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIHB1YmxpYyBrZXkgc2l6ZScpO1xuICAgICAgICBpZiAoc2subGVuZ3RoICE9PSBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWNyZXQga2V5IHNpemUnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tBcnJheVR5cGVzKCkge1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGlmICghKGFyZ3VtZW50c1tpXSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bmV4cGVjdGVkIHR5cGUsIHVzZSBVaW50OEFycmF5Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYW51cChhcnIpIHtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKylhcnJbaV0gPSAwO1xuICAgIH1cbiAgICBuYWNsLnJhbmRvbUJ5dGVzID0gZnVuY3Rpb24obikge1xuICAgICAgICB2YXIgYiA9IG5ldyBVaW50OEFycmF5KG4pO1xuICAgICAgICByYW5kb21ieXRlcyhiLCBuKTtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgfTtcbiAgICBuYWNsLnNlY3JldGJveCA9IGZ1bmN0aW9uKG1zZywgbm9uY2UsIGtleSkge1xuICAgICAgICBjaGVja0FycmF5VHlwZXMobXNnLCBub25jZSwga2V5KTtcbiAgICAgICAgY2hlY2tMZW5ndGhzKGtleSwgbm9uY2UpO1xuICAgICAgICB2YXIgbSA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTICsgbXNnLmxlbmd0aCk7XG4gICAgICAgIHZhciBjID0gbmV3IFVpbnQ4QXJyYXkobS5sZW5ndGgpO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKW1baSArIGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTXSA9IG1zZ1tpXTtcbiAgICAgICAgY3J5cHRvX3NlY3JldGJveChjLCBtLCBtLmxlbmd0aCwgbm9uY2UsIGtleSk7XG4gICAgICAgIHJldHVybiBjLnN1YmFycmF5KGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTKTtcbiAgICB9O1xuICAgIG5hY2wuc2VjcmV0Ym94Lm9wZW4gPSBmdW5jdGlvbihib3gsIG5vbmNlLCBrZXkpIHtcbiAgICAgICAgY2hlY2tBcnJheVR5cGVzKGJveCwgbm9uY2UsIGtleSk7XG4gICAgICAgIGNoZWNrTGVuZ3RocyhrZXksIG5vbmNlKTtcbiAgICAgICAgdmFyIGMgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUyArIGJveC5sZW5ndGgpO1xuICAgICAgICB2YXIgbSA9IG5ldyBVaW50OEFycmF5KGMubGVuZ3RoKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGJveC5sZW5ndGg7IGkrKyljW2kgKyBjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFU10gPSBib3hbaV07XG4gICAgICAgIGlmIChjLmxlbmd0aCA8IDMyKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKGNyeXB0b19zZWNyZXRib3hfb3BlbihtLCBjLCBjLmxlbmd0aCwgbm9uY2UsIGtleSkgIT09IDApIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbS5zdWJhcnJheShjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUyk7XG4gICAgfTtcbiAgICBuYWNsLnNlY3JldGJveC5rZXlMZW5ndGggPSBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTO1xuICAgIG5hY2wuc2VjcmV0Ym94Lm5vbmNlTGVuZ3RoID0gY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTO1xuICAgIG5hY2wuc2VjcmV0Ym94Lm92ZXJoZWFkTGVuZ3RoID0gY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVM7XG4gICAgbmFjbC5zY2FsYXJNdWx0ID0gZnVuY3Rpb24obiwgcCkge1xuICAgICAgICBjaGVja0FycmF5VHlwZXMobiwgcCk7XG4gICAgICAgIGlmIChuLmxlbmd0aCAhPT0gY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIG4gc2l6ZScpO1xuICAgICAgICBpZiAocC5sZW5ndGggIT09IGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwIHNpemUnKTtcbiAgICAgICAgdmFyIHEgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2NhbGFybXVsdF9CWVRFUyk7XG4gICAgICAgIGNyeXB0b19zY2FsYXJtdWx0KHEsIG4sIHApO1xuICAgICAgICByZXR1cm4gcTtcbiAgICB9O1xuICAgIG5hY2wuc2NhbGFyTXVsdC5iYXNlID0gZnVuY3Rpb24obikge1xuICAgICAgICBjaGVja0FycmF5VHlwZXMobik7XG4gICAgICAgIGlmIChuLmxlbmd0aCAhPT0gY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIG4gc2l6ZScpO1xuICAgICAgICB2YXIgcSA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTKTtcbiAgICAgICAgY3J5cHRvX3NjYWxhcm11bHRfYmFzZShxLCBuKTtcbiAgICAgICAgcmV0dXJuIHE7XG4gICAgfTtcbiAgICBuYWNsLnNjYWxhck11bHQuc2NhbGFyTGVuZ3RoID0gY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVM7XG4gICAgbmFjbC5zY2FsYXJNdWx0Lmdyb3VwRWxlbWVudExlbmd0aCA9IGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTO1xuICAgIG5hY2wuYm94ID0gZnVuY3Rpb24obXNnLCBub25jZSwgcHVibGljS2V5LCBzZWNyZXRLZXkpIHtcbiAgICAgICAgdmFyIGsgPSBuYWNsLmJveC5iZWZvcmUocHVibGljS2V5LCBzZWNyZXRLZXkpO1xuICAgICAgICByZXR1cm4gbmFjbC5zZWNyZXRib3gobXNnLCBub25jZSwgayk7XG4gICAgfTtcbiAgICBuYWNsLmJveC5iZWZvcmUgPSBmdW5jdGlvbihwdWJsaWNLZXksIHNlY3JldEtleSkge1xuICAgICAgICBjaGVja0FycmF5VHlwZXMocHVibGljS2V5LCBzZWNyZXRLZXkpO1xuICAgICAgICBjaGVja0JveExlbmd0aHMocHVibGljS2V5LCBzZWNyZXRLZXkpO1xuICAgICAgICB2YXIgayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19ib3hfQkVGT1JFTk1CWVRFUyk7XG4gICAgICAgIGNyeXB0b19ib3hfYmVmb3Jlbm0oaywgcHVibGljS2V5LCBzZWNyZXRLZXkpO1xuICAgICAgICByZXR1cm4gaztcbiAgICB9O1xuICAgIG5hY2wuYm94LmFmdGVyID0gbmFjbC5zZWNyZXRib3g7XG4gICAgbmFjbC5ib3gub3BlbiA9IGZ1bmN0aW9uKG1zZywgbm9uY2UsIHB1YmxpY0tleSwgc2VjcmV0S2V5KSB7XG4gICAgICAgIHZhciBrID0gbmFjbC5ib3guYmVmb3JlKHB1YmxpY0tleSwgc2VjcmV0S2V5KTtcbiAgICAgICAgcmV0dXJuIG5hY2wuc2VjcmV0Ym94Lm9wZW4obXNnLCBub25jZSwgayk7XG4gICAgfTtcbiAgICBuYWNsLmJveC5vcGVuLmFmdGVyID0gbmFjbC5zZWNyZXRib3gub3BlbjtcbiAgICBuYWNsLmJveC5rZXlQYWlyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19ib3hfUFVCTElDS0VZQllURVMpO1xuICAgICAgICB2YXIgc2sgPSBuZXcgVWludDhBcnJheShjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTKTtcbiAgICAgICAgY3J5cHRvX2JveF9rZXlwYWlyKHBrLCBzayk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwdWJsaWNLZXk6IHBrLFxuICAgICAgICAgICAgc2VjcmV0S2V5OiBza1xuICAgICAgICB9O1xuICAgIH07XG4gICAgbmFjbC5ib3gua2V5UGFpci5mcm9tU2VjcmV0S2V5ID0gZnVuY3Rpb24oc2VjcmV0S2V5KSB7XG4gICAgICAgIGNoZWNrQXJyYXlUeXBlcyhzZWNyZXRLZXkpO1xuICAgICAgICBpZiAoc2VjcmV0S2V5Lmxlbmd0aCAhPT0gY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VjcmV0IGtleSBzaXplJyk7XG4gICAgICAgIHZhciBwayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19ib3hfUFVCTElDS0VZQllURVMpO1xuICAgICAgICBjcnlwdG9fc2NhbGFybXVsdF9iYXNlKHBrLCBzZWNyZXRLZXkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHVibGljS2V5OiBwayxcbiAgICAgICAgICAgIHNlY3JldEtleTogbmV3IFVpbnQ4QXJyYXkoc2VjcmV0S2V5KVxuICAgICAgICB9O1xuICAgIH07XG4gICAgbmFjbC5ib3gucHVibGljS2V5TGVuZ3RoID0gY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUztcbiAgICBuYWNsLmJveC5zZWNyZXRLZXlMZW5ndGggPSBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTO1xuICAgIG5hY2wuYm94LnNoYXJlZEtleUxlbmd0aCA9IGNyeXB0b19ib3hfQkVGT1JFTk1CWVRFUztcbiAgICBuYWNsLmJveC5ub25jZUxlbmd0aCA9IGNyeXB0b19ib3hfTk9OQ0VCWVRFUztcbiAgICBuYWNsLmJveC5vdmVyaGVhZExlbmd0aCA9IG5hY2wuc2VjcmV0Ym94Lm92ZXJoZWFkTGVuZ3RoO1xuICAgIG5hY2wuc2lnbiA9IGZ1bmN0aW9uKG1zZywgc2VjcmV0S2V5KSB7XG4gICAgICAgIGNoZWNrQXJyYXlUeXBlcyhtc2csIHNlY3JldEtleSk7XG4gICAgICAgIGlmIChzZWNyZXRLZXkubGVuZ3RoICE9PSBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VjcmV0IGtleSBzaXplJyk7XG4gICAgICAgIHZhciBzaWduZWRNc2cgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9CWVRFUyArIG1zZy5sZW5ndGgpO1xuICAgICAgICBjcnlwdG9fc2lnbihzaWduZWRNc2csIG1zZywgbXNnLmxlbmd0aCwgc2VjcmV0S2V5KTtcbiAgICAgICAgcmV0dXJuIHNpZ25lZE1zZztcbiAgICB9O1xuICAgIG5hY2wuc2lnbi5vcGVuID0gZnVuY3Rpb24oc2lnbmVkTXNnLCBwdWJsaWNLZXkpIHtcbiAgICAgICAgY2hlY2tBcnJheVR5cGVzKHNpZ25lZE1zZywgcHVibGljS2V5KTtcbiAgICAgICAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwdWJsaWMga2V5IHNpemUnKTtcbiAgICAgICAgdmFyIHRtcCA9IG5ldyBVaW50OEFycmF5KHNpZ25lZE1zZy5sZW5ndGgpO1xuICAgICAgICB2YXIgbWxlbiA9IGNyeXB0b19zaWduX29wZW4odG1wLCBzaWduZWRNc2csIHNpZ25lZE1zZy5sZW5ndGgsIHB1YmxpY0tleSk7XG4gICAgICAgIGlmIChtbGVuIDwgMCkgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBtID0gbmV3IFVpbnQ4QXJyYXkobWxlbik7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKW1baV0gPSB0bXBbaV07XG4gICAgICAgIHJldHVybiBtO1xuICAgIH07XG4gICAgbmFjbC5zaWduLmRldGFjaGVkID0gZnVuY3Rpb24obXNnLCBzZWNyZXRLZXkpIHtcbiAgICAgICAgdmFyIHNpZ25lZE1zZyA9IG5hY2wuc2lnbihtc2csIHNlY3JldEtleSk7XG4gICAgICAgIHZhciBzaWcgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9CWVRFUyk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaWcubGVuZ3RoOyBpKyspc2lnW2ldID0gc2lnbmVkTXNnW2ldO1xuICAgICAgICByZXR1cm4gc2lnO1xuICAgIH07XG4gICAgbmFjbC5zaWduLmRldGFjaGVkLnZlcmlmeSA9IGZ1bmN0aW9uKG1zZywgc2lnLCBwdWJsaWNLZXkpIHtcbiAgICAgICAgY2hlY2tBcnJheVR5cGVzKG1zZywgc2lnLCBwdWJsaWNLZXkpO1xuICAgICAgICBpZiAoc2lnLmxlbmd0aCAhPT0gY3J5cHRvX3NpZ25fQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIHNpZ25hdHVyZSBzaXplJyk7XG4gICAgICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgcHVibGljIGtleSBzaXplJyk7XG4gICAgICAgIHZhciBzbSA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX0JZVEVTICsgbXNnLmxlbmd0aCk7XG4gICAgICAgIHZhciBtID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fQllURVMgKyBtc2cubGVuZ3RoKTtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IGNyeXB0b19zaWduX0JZVEVTOyBpKyspc21baV0gPSBzaWdbaV07XG4gICAgICAgIGZvcihpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylzbVtpICsgY3J5cHRvX3NpZ25fQllURVNdID0gbXNnW2ldO1xuICAgICAgICByZXR1cm4gY3J5cHRvX3NpZ25fb3BlbihtLCBzbSwgc20ubGVuZ3RoLCBwdWJsaWNLZXkpID49IDA7XG4gICAgfTtcbiAgICBuYWNsLnNpZ24ua2V5UGFpciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyk7XG4gICAgICAgIHZhciBzayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTKTtcbiAgICAgICAgY3J5cHRvX3NpZ25fa2V5cGFpcihwaywgc2spO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHVibGljS2V5OiBwayxcbiAgICAgICAgICAgIHNlY3JldEtleTogc2tcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIG5hY2wuc2lnbi5rZXlQYWlyLmZyb21TZWNyZXRLZXkgPSBmdW5jdGlvbihzZWNyZXRLZXkpIHtcbiAgICAgICAgY2hlY2tBcnJheVR5cGVzKHNlY3JldEtleSk7XG4gICAgICAgIGlmIChzZWNyZXRLZXkubGVuZ3RoICE9PSBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VjcmV0IGtleSBzaXplJyk7XG4gICAgICAgIHZhciBwayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHBrLmxlbmd0aDsgaSsrKXBrW2ldID0gc2VjcmV0S2V5WzMyICsgaV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwdWJsaWNLZXk6IHBrLFxuICAgICAgICAgICAgc2VjcmV0S2V5OiBuZXcgVWludDhBcnJheShzZWNyZXRLZXkpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBuYWNsLnNpZ24ua2V5UGFpci5mcm9tU2VlZCA9IGZ1bmN0aW9uKHNlZWQpIHtcbiAgICAgICAgY2hlY2tBcnJheVR5cGVzKHNlZWQpO1xuICAgICAgICBpZiAoc2VlZC5sZW5ndGggIT09IGNyeXB0b19zaWduX1NFRURCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VlZCBzaXplJyk7XG4gICAgICAgIHZhciBwayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTKTtcbiAgICAgICAgdmFyIHNrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMpO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMzI7IGkrKylza1tpXSA9IHNlZWRbaV07XG4gICAgICAgIGNyeXB0b19zaWduX2tleXBhaXIocGssIHNrLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHB1YmxpY0tleTogcGssXG4gICAgICAgICAgICBzZWNyZXRLZXk6IHNrXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBuYWNsLnNpZ24ucHVibGljS2V5TGVuZ3RoID0gY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVM7XG4gICAgbmFjbC5zaWduLnNlY3JldEtleUxlbmd0aCA9IGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTO1xuICAgIG5hY2wuc2lnbi5zZWVkTGVuZ3RoID0gY3J5cHRvX3NpZ25fU0VFREJZVEVTO1xuICAgIG5hY2wuc2lnbi5zaWduYXR1cmVMZW5ndGggPSBjcnlwdG9fc2lnbl9CWVRFUztcbiAgICBuYWNsLmhhc2ggPSBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgY2hlY2tBcnJheVR5cGVzKG1zZyk7XG4gICAgICAgIHZhciBoID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX2hhc2hfQllURVMpO1xuICAgICAgICBjcnlwdG9faGFzaChoLCBtc2csIG1zZy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gaDtcbiAgICB9O1xuICAgIG5hY2wuaGFzaC5oYXNoTGVuZ3RoID0gY3J5cHRvX2hhc2hfQllURVM7XG4gICAgbmFjbC52ZXJpZnkgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIGNoZWNrQXJyYXlUeXBlcyh4LCB5KTtcbiAgICAgICAgaWYgKHgubGVuZ3RoID09PSAwIHx8IHkubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh4Lmxlbmd0aCAhPT0geS5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHZuKHgsIDAsIHksIDAsIHgubGVuZ3RoKSA9PT0gMCA/IHRydWUgOiBmYWxzZTtcbiAgICB9O1xuICAgIG5hY2wuc2V0UFJORyA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgIHJhbmRvbWJ5dGVzID0gZm47XG4gICAgfTtcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjcnlwdG8xID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcy5jcnlwdG8gfHwgZ2xvYmFsVGhpcy5tc0NyeXB0byA6IG51bGw7XG4gICAgICAgIGlmIChjcnlwdG8xICYmIGNyeXB0bzEuZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICAgICAgICB2YXIgUVVPVEEgPSA2NTUzNjtcbiAgICAgICAgICAgIG5hY2wuc2V0UFJORyhmdW5jdGlvbih4LCBuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGksIHYgPSBuZXcgVWludDhBcnJheShuKTtcbiAgICAgICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBuOyBpICs9IFFVT1RBKXtcbiAgICAgICAgICAgICAgICAgICAgY3J5cHRvMS5nZXRSYW5kb21WYWx1ZXModi5zdWJhcnJheShpLCBpICsgTWF0aC5taW4obiAtIGksIFFVT1RBKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBuOyBpKyspeFtpXSA9IHZbaV07XG4gICAgICAgICAgICAgICAgY2xlYW51cCh2KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY3J5cHRvMSA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuICAgICAgICAgICAgaWYgKGNyeXB0bzEgJiYgY3J5cHRvMS5yYW5kb21CeXRlcykge1xuICAgICAgICAgICAgICAgIG5hY2wuc2V0UFJORyhmdW5jdGlvbih4LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpLCB2ID0gY3J5cHRvMS5yYW5kb21CeXRlcyhuKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgbjsgaSsrKXhbaV0gPSB2W2ldO1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKHYpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSkoKTtcbn0pKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzID8gbW9kdWxlLmV4cG9ydHMgOiBnbG9iYWxUaGlzLm5hY2wgPSBnbG9iYWxUaGlzLm5hY2wgfHwge30pO1xuY29uc3QgbmFjbCA9IHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzID8gbW9kdWxlLmV4cG9ydHMgOiBnbG9iYWxUaGlzLm5hY2w7XG5jb25zdCBkZW5vSGVscGVyID0ge1xuICAgIGZyb21TZWVkOiBuYWNsLnNpZ24ua2V5UGFpci5mcm9tU2VlZCxcbiAgICBzaWduOiBuYWNsLnNpZ24uZGV0YWNoZWQsXG4gICAgdmVyaWZ5OiBuYWNsLnNpZ24uZGV0YWNoZWQudmVyaWZ5LFxuICAgIHJhbmRvbUJ5dGVzOiBuYWNsLnJhbmRvbUJ5dGVzXG59O1xubGV0IGhlbHBlcjtcbmZ1bmN0aW9uIHNldEVkMjU1MTlIZWxwZXIobGliKSB7XG4gICAgaGVscGVyID0gbGliO1xufVxuZnVuY3Rpb24gZ2V0RWQyNTUxOUhlbHBlcigpIHtcbiAgICByZXR1cm4gaGVscGVyO1xufVxuY29uc3QgY3JjMTZ0YWIgPSBuZXcgVWludDE2QXJyYXkoW1xuICAgIDB4MDAwMCxcbiAgICAweDEwMjEsXG4gICAgMHgyMDQyLFxuICAgIDB4MzA2MyxcbiAgICAweDQwODQsXG4gICAgMHg1MGE1LFxuICAgIDB4NjBjNixcbiAgICAweDcwZTcsXG4gICAgMHg4MTA4LFxuICAgIDB4OTEyOSxcbiAgICAweGExNGEsXG4gICAgMHhiMTZiLFxuICAgIDB4YzE4YyxcbiAgICAweGQxYWQsXG4gICAgMHhlMWNlLFxuICAgIDB4ZjFlZixcbiAgICAweDEyMzEsXG4gICAgMHgwMjEwLFxuICAgIDB4MzI3MyxcbiAgICAweDIyNTIsXG4gICAgMHg1MmI1LFxuICAgIDB4NDI5NCxcbiAgICAweDcyZjcsXG4gICAgMHg2MmQ2LFxuICAgIDB4OTMzOSxcbiAgICAweDgzMTgsXG4gICAgMHhiMzdiLFxuICAgIDB4YTM1YSxcbiAgICAweGQzYmQsXG4gICAgMHhjMzljLFxuICAgIDB4ZjNmZixcbiAgICAweGUzZGUsXG4gICAgMHgyNDYyLFxuICAgIDB4MzQ0MyxcbiAgICAweDA0MjAsXG4gICAgMHgxNDAxLFxuICAgIDB4NjRlNixcbiAgICAweDc0YzcsXG4gICAgMHg0NGE0LFxuICAgIDB4NTQ4NSxcbiAgICAweGE1NmEsXG4gICAgMHhiNTRiLFxuICAgIDB4ODUyOCxcbiAgICAweDk1MDksXG4gICAgMHhlNWVlLFxuICAgIDB4ZjVjZixcbiAgICAweGM1YWMsXG4gICAgMHhkNThkLFxuICAgIDB4MzY1MyxcbiAgICAweDI2NzIsXG4gICAgMHgxNjExLFxuICAgIDB4MDYzMCxcbiAgICAweDc2ZDcsXG4gICAgMHg2NmY2LFxuICAgIDB4NTY5NSxcbiAgICAweDQ2YjQsXG4gICAgMHhiNzViLFxuICAgIDB4YTc3YSxcbiAgICAweDk3MTksXG4gICAgMHg4NzM4LFxuICAgIDB4ZjdkZixcbiAgICAweGU3ZmUsXG4gICAgMHhkNzlkLFxuICAgIDB4YzdiYyxcbiAgICAweDQ4YzQsXG4gICAgMHg1OGU1LFxuICAgIDB4Njg4NixcbiAgICAweDc4YTcsXG4gICAgMHgwODQwLFxuICAgIDB4MTg2MSxcbiAgICAweDI4MDIsXG4gICAgMHgzODIzLFxuICAgIDB4YzljYyxcbiAgICAweGQ5ZWQsXG4gICAgMHhlOThlLFxuICAgIDB4ZjlhZixcbiAgICAweDg5NDgsXG4gICAgMHg5OTY5LFxuICAgIDB4YTkwYSxcbiAgICAweGI5MmIsXG4gICAgMHg1YWY1LFxuICAgIDB4NGFkNCxcbiAgICAweDdhYjcsXG4gICAgMHg2YTk2LFxuICAgIDB4MWE3MSxcbiAgICAweDBhNTAsXG4gICAgMHgzYTMzLFxuICAgIDB4MmExMixcbiAgICAweGRiZmQsXG4gICAgMHhjYmRjLFxuICAgIDB4ZmJiZixcbiAgICAweGViOWUsXG4gICAgMHg5Yjc5LFxuICAgIDB4OGI1OCxcbiAgICAweGJiM2IsXG4gICAgMHhhYjFhLFxuICAgIDB4NmNhNixcbiAgICAweDdjODcsXG4gICAgMHg0Y2U0LFxuICAgIDB4NWNjNSxcbiAgICAweDJjMjIsXG4gICAgMHgzYzAzLFxuICAgIDB4MGM2MCxcbiAgICAweDFjNDEsXG4gICAgMHhlZGFlLFxuICAgIDB4ZmQ4ZixcbiAgICAweGNkZWMsXG4gICAgMHhkZGNkLFxuICAgIDB4YWQyYSxcbiAgICAweGJkMGIsXG4gICAgMHg4ZDY4LFxuICAgIDB4OWQ0OSxcbiAgICAweDdlOTcsXG4gICAgMHg2ZWI2LFxuICAgIDB4NWVkNSxcbiAgICAweDRlZjQsXG4gICAgMHgzZTEzLFxuICAgIDB4MmUzMixcbiAgICAweDFlNTEsXG4gICAgMHgwZTcwLFxuICAgIDB4ZmY5ZixcbiAgICAweGVmYmUsXG4gICAgMHhkZmRkLFxuICAgIDB4Y2ZmYyxcbiAgICAweGJmMWIsXG4gICAgMHhhZjNhLFxuICAgIDB4OWY1OSxcbiAgICAweDhmNzgsXG4gICAgMHg5MTg4LFxuICAgIDB4ODFhOSxcbiAgICAweGIxY2EsXG4gICAgMHhhMWViLFxuICAgIDB4ZDEwYyxcbiAgICAweGMxMmQsXG4gICAgMHhmMTRlLFxuICAgIDB4ZTE2ZixcbiAgICAweDEwODAsXG4gICAgMHgwMGExLFxuICAgIDB4MzBjMixcbiAgICAweDIwZTMsXG4gICAgMHg1MDA0LFxuICAgIDB4NDAyNSxcbiAgICAweDcwNDYsXG4gICAgMHg2MDY3LFxuICAgIDB4ODNiOSxcbiAgICAweDkzOTgsXG4gICAgMHhhM2ZiLFxuICAgIDB4YjNkYSxcbiAgICAweGMzM2QsXG4gICAgMHhkMzFjLFxuICAgIDB4ZTM3ZixcbiAgICAweGYzNWUsXG4gICAgMHgwMmIxLFxuICAgIDB4MTI5MCxcbiAgICAweDIyZjMsXG4gICAgMHgzMmQyLFxuICAgIDB4NDIzNSxcbiAgICAweDUyMTQsXG4gICAgMHg2Mjc3LFxuICAgIDB4NzI1NixcbiAgICAweGI1ZWEsXG4gICAgMHhhNWNiLFxuICAgIDB4OTVhOCxcbiAgICAweDg1ODksXG4gICAgMHhmNTZlLFxuICAgIDB4ZTU0ZixcbiAgICAweGQ1MmMsXG4gICAgMHhjNTBkLFxuICAgIDB4MzRlMixcbiAgICAweDI0YzMsXG4gICAgMHgxNGEwLFxuICAgIDB4MDQ4MSxcbiAgICAweDc0NjYsXG4gICAgMHg2NDQ3LFxuICAgIDB4NTQyNCxcbiAgICAweDQ0MDUsXG4gICAgMHhhN2RiLFxuICAgIDB4YjdmYSxcbiAgICAweDg3OTksXG4gICAgMHg5N2I4LFxuICAgIDB4ZTc1ZixcbiAgICAweGY3N2UsXG4gICAgMHhjNzFkLFxuICAgIDB4ZDczYyxcbiAgICAweDI2ZDMsXG4gICAgMHgzNmYyLFxuICAgIDB4MDY5MSxcbiAgICAweDE2YjAsXG4gICAgMHg2NjU3LFxuICAgIDB4NzY3NixcbiAgICAweDQ2MTUsXG4gICAgMHg1NjM0LFxuICAgIDB4ZDk0YyxcbiAgICAweGM5NmQsXG4gICAgMHhmOTBlLFxuICAgIDB4ZTkyZixcbiAgICAweDk5YzgsXG4gICAgMHg4OWU5LFxuICAgIDB4Yjk4YSxcbiAgICAweGE5YWIsXG4gICAgMHg1ODQ0LFxuICAgIDB4NDg2NSxcbiAgICAweDc4MDYsXG4gICAgMHg2ODI3LFxuICAgIDB4MThjMCxcbiAgICAweDA4ZTEsXG4gICAgMHgzODgyLFxuICAgIDB4MjhhMyxcbiAgICAweGNiN2QsXG4gICAgMHhkYjVjLFxuICAgIDB4ZWIzZixcbiAgICAweGZiMWUsXG4gICAgMHg4YmY5LFxuICAgIDB4OWJkOCxcbiAgICAweGFiYmIsXG4gICAgMHhiYjlhLFxuICAgIDB4NGE3NSxcbiAgICAweDVhNTQsXG4gICAgMHg2YTM3LFxuICAgIDB4N2ExNixcbiAgICAweDBhZjEsXG4gICAgMHgxYWQwLFxuICAgIDB4MmFiMyxcbiAgICAweDNhOTIsXG4gICAgMHhmZDJlLFxuICAgIDB4ZWQwZixcbiAgICAweGRkNmMsXG4gICAgMHhjZDRkLFxuICAgIDB4YmRhYSxcbiAgICAweGFkOGIsXG4gICAgMHg5ZGU4LFxuICAgIDB4OGRjOSxcbiAgICAweDdjMjYsXG4gICAgMHg2YzA3LFxuICAgIDB4NWM2NCxcbiAgICAweDRjNDUsXG4gICAgMHgzY2EyLFxuICAgIDB4MmM4MyxcbiAgICAweDFjZTAsXG4gICAgMHgwY2MxLFxuICAgIDB4ZWYxZixcbiAgICAweGZmM2UsXG4gICAgMHhjZjVkLFxuICAgIDB4ZGY3YyxcbiAgICAweGFmOWIsXG4gICAgMHhiZmJhLFxuICAgIDB4OGZkOSxcbiAgICAweDlmZjgsXG4gICAgMHg2ZTE3LFxuICAgIDB4N2UzNixcbiAgICAweDRlNTUsXG4gICAgMHg1ZTc0LFxuICAgIDB4MmU5MyxcbiAgICAweDNlYjIsXG4gICAgMHgwZWQxLFxuICAgIDB4MWVmMFxuXSk7XG5jbGFzcyBjcmMxNiB7XG4gICAgc3RhdGljIGNoZWNrc3VtKGRhdGEpIHtcbiAgICAgICAgbGV0IGNyYyA9IDA7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBkYXRhLmJ5dGVMZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBsZXQgYiA9IGRhdGFbaV07XG4gICAgICAgICAgICBjcmMgPSBjcmMgPDwgOCAmIDB4ZmZmZiBeIGNyYzE2dGFiWyhjcmMgPj4gOCBeIGIpICYgMHgwMEZGXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JjO1xuICAgIH1cbiAgICBzdGF0aWMgdmFsaWRhdGUoZGF0YSwgZXhwZWN0ZWQpIHtcbiAgICAgICAgbGV0IGJhID0gY3JjMTYuY2hlY2tzdW0oZGF0YSk7XG4gICAgICAgIHJldHVybiBiYSA9PSBleHBlY3RlZDtcbiAgICB9XG59XG5jb25zdCBiMzJBbHBoYWJldCA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjdcIjtcbmNsYXNzIGJhc2UzMiB7XG4gICAgc3RhdGljIGVuY29kZShzcmMpIHtcbiAgICAgICAgbGV0IGJpdHMgPSAwO1xuICAgICAgICBsZXQgdmFsdWUgPSAwO1xuICAgICAgICBsZXQgYSA9IG5ldyBVaW50OEFycmF5KHNyYyk7XG4gICAgICAgIGxldCBidWYgPSBuZXcgVWludDhBcnJheShzcmMuYnl0ZUxlbmd0aCAqIDIpO1xuICAgICAgICBsZXQgaiA9IDA7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBhLmJ5dGVMZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIDw8IDggfCBhW2ldO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgd2hpbGUoYml0cyA+PSA1KXtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSB2YWx1ZSA+Pj4gYml0cyAtIDUgJiAzMTtcbiAgICAgICAgICAgICAgICBidWZbaisrXSA9IGIzMkFscGhhYmV0LmNoYXJBdChpbmRleCkuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICBiaXRzIC09IDU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJpdHMgPiAwKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSB2YWx1ZSA8PCA1IC0gYml0cyAmIDMxO1xuICAgICAgICAgICAgYnVmW2orK10gPSBiMzJBbHBoYWJldC5jaGFyQXQoaW5kZXgpLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1Zi5zbGljZSgwLCBqKTtcbiAgICB9XG4gICAgc3RhdGljIGRlY29kZShzcmMpIHtcbiAgICAgICAgbGV0IGJpdHMgPSAwO1xuICAgICAgICBsZXQgX19ieXRlID0gMDtcbiAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICBsZXQgYSA9IG5ldyBVaW50OEFycmF5KHNyYyk7XG4gICAgICAgIGxldCBvdXQgPSBuZXcgVWludDhBcnJheShhLmJ5dGVMZW5ndGggKiA1IC8gOCB8IDApO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgYS5ieXRlTGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgbGV0IHYgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFbaV0pO1xuICAgICAgICAgICAgbGV0IHZ2ID0gYjMyQWxwaGFiZXQuaW5kZXhPZih2KTtcbiAgICAgICAgICAgIGlmICh2diA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIEJhc2UzMiBjaGFyYWN0ZXI6IFwiICsgYVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX2J5dGUgPSBfX2J5dGUgPDwgNSB8IHZ2O1xuICAgICAgICAgICAgYml0cyArPSA1O1xuICAgICAgICAgICAgaWYgKGJpdHMgPj0gOCkge1xuICAgICAgICAgICAgICAgIG91dFtqKytdID0gX19ieXRlID4+PiBiaXRzIC0gOCAmIDI1NTtcbiAgICAgICAgICAgICAgICBiaXRzIC09IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dC5zbGljZSgwLCBqKTtcbiAgICB9XG59XG5jbGFzcyBOS2V5c0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIG5hbWU7XG4gICAgY29kZTtcbiAgICBjaGFpbmVkRXJyb3I7XG4gICAgY29uc3RydWN0b3IoY29kZSwgY2hhaW5lZEVycm9yKXtcbiAgICAgICAgc3VwZXIoY29kZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiTktleXNFcnJvclwiO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLmNoYWluZWRFcnJvciA9IGNoYWluZWRFcnJvcjtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVPcGVyYXRvcigpIHtcbiAgICByZXR1cm4gY3JlYXRlUGFpcihQcmVmaXguT3BlcmF0b3IpO1xufVxuZnVuY3Rpb24gY3JlYXRlQWNjb3VudCgpIHtcbiAgICByZXR1cm4gY3JlYXRlUGFpcihQcmVmaXguQWNjb3VudCk7XG59XG5mdW5jdGlvbiBjcmVhdGVVc2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVQYWlyKFByZWZpeC5Vc2VyKTtcbn1cbnZhciBOS2V5c0Vycm9yQ29kZTtcbihmdW5jdGlvbihOS2V5c0Vycm9yQ29kZSkge1xuICAgIE5LZXlzRXJyb3JDb2RlW1wiSW52YWxpZFByZWZpeEJ5dGVcIl0gPSBcIm5rZXlzOiBpbnZhbGlkIHByZWZpeCBieXRlXCI7XG4gICAgTktleXNFcnJvckNvZGVbXCJJbnZhbGlkS2V5XCJdID0gXCJua2V5czogaW52YWxpZCBrZXlcIjtcbiAgICBOS2V5c0Vycm9yQ29kZVtcIkludmFsaWRQdWJsaWNLZXlcIl0gPSBcIm5rZXlzOiBpbnZhbGlkIHB1YmxpYyBrZXlcIjtcbiAgICBOS2V5c0Vycm9yQ29kZVtcIkludmFsaWRTZWVkTGVuXCJdID0gXCJua2V5czogaW52YWxpZCBzZWVkIGxlbmd0aFwiO1xuICAgIE5LZXlzRXJyb3JDb2RlW1wiSW52YWxpZFNlZWRcIl0gPSBcIm5rZXlzOiBpbnZhbGlkIHNlZWRcIjtcbiAgICBOS2V5c0Vycm9yQ29kZVtcIkludmFsaWRFbmNvZGluZ1wiXSA9IFwibmtleXM6IGludmFsaWQgZW5jb2RlZCBrZXlcIjtcbiAgICBOS2V5c0Vycm9yQ29kZVtcIkludmFsaWRTaWduYXR1cmVcIl0gPSBcIm5rZXlzOiBzaWduYXR1cmUgdmVyaWZpY2F0aW9uIGZhaWxlZFwiO1xuICAgIE5LZXlzRXJyb3JDb2RlW1wiQ2Fubm90U2lnblwiXSA9IFwibmtleXM6IGNhbm5vdCBzaWduLCBubyBwcml2YXRlIGtleSBhdmFpbGFibGVcIjtcbiAgICBOS2V5c0Vycm9yQ29kZVtcIlB1YmxpY0tleU9ubHlcIl0gPSBcIm5rZXlzOiBubyBzZWVkIG9yIHByaXZhdGUga2V5IGF2YWlsYWJsZVwiO1xuICAgIE5LZXlzRXJyb3JDb2RlW1wiSW52YWxpZENoZWNrc3VtXCJdID0gXCJua2V5czogaW52YWxpZCBjaGVja3N1bVwiO1xuICAgIE5LZXlzRXJyb3JDb2RlW1wiU2VyaWFsaXphdGlvbkVycm9yXCJdID0gXCJua2V5czogc2VyaWFsaXphdGlvbiBlcnJvclwiO1xuICAgIE5LZXlzRXJyb3JDb2RlW1wiQXBpRXJyb3JcIl0gPSBcIm5rZXlzOiBhcGkgZXJyb3JcIjtcbiAgICBOS2V5c0Vycm9yQ29kZVtcIkNsZWFyZWRQYWlyXCJdID0gXCJua2V5czogcGFpciBpcyBjbGVhcmVkXCI7XG59KShOS2V5c0Vycm9yQ29kZSB8fCAoTktleXNFcnJvckNvZGUgPSB7fSkpO1xudmFyIFByZWZpeDtcbihmdW5jdGlvbihQcmVmaXgpIHtcbiAgICBQcmVmaXhbUHJlZml4W1wiU2VlZFwiXSA9IDE0NF0gPSBcIlNlZWRcIjtcbiAgICBQcmVmaXhbUHJlZml4W1wiUHJpdmF0ZVwiXSA9IDEyMF0gPSBcIlByaXZhdGVcIjtcbiAgICBQcmVmaXhbUHJlZml4W1wiT3BlcmF0b3JcIl0gPSAxMTJdID0gXCJPcGVyYXRvclwiO1xuICAgIFByZWZpeFtQcmVmaXhbXCJTZXJ2ZXJcIl0gPSAxMDRdID0gXCJTZXJ2ZXJcIjtcbiAgICBQcmVmaXhbUHJlZml4W1wiQ2x1c3RlclwiXSA9IDE2XSA9IFwiQ2x1c3RlclwiO1xuICAgIFByZWZpeFtQcmVmaXhbXCJBY2NvdW50XCJdID0gMF0gPSBcIkFjY291bnRcIjtcbiAgICBQcmVmaXhbUHJlZml4W1wiVXNlclwiXSA9IDE2MF0gPSBcIlVzZXJcIjtcbn0pKFByZWZpeCB8fCAoUHJlZml4ID0ge30pKTtcbmNsYXNzIFByZWZpeGVzIHtcbiAgICBzdGF0aWMgaXNWYWxpZFB1YmxpY1ByZWZpeChwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeCA9PSBQcmVmaXguU2VydmVyIHx8IHByZWZpeCA9PSBQcmVmaXguT3BlcmF0b3IgfHwgcHJlZml4ID09IFByZWZpeC5DbHVzdGVyIHx8IHByZWZpeCA9PSBQcmVmaXguQWNjb3VudCB8fCBwcmVmaXggPT0gUHJlZml4LlVzZXI7XG4gICAgfVxuICAgIHN0YXRpYyBzdGFydHNXaXRoVmFsaWRQcmVmaXgocykge1xuICAgICAgICBsZXQgYyA9IHNbMF07XG4gICAgICAgIHJldHVybiBjID09IFwiU1wiIHx8IGMgPT0gXCJQXCIgfHwgYyA9PSBcIk9cIiB8fCBjID09IFwiTlwiIHx8IGMgPT0gXCJDXCIgfHwgYyA9PSBcIkFcIiB8fCBjID09IFwiVVwiO1xuICAgIH1cbiAgICBzdGF0aWMgaXNWYWxpZFByZWZpeChwcmVmaXgpIHtcbiAgICAgICAgbGV0IHYgPSB0aGlzLnBhcnNlUHJlZml4KHByZWZpeCk7XG4gICAgICAgIHJldHVybiB2ICE9IC0xO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2VQcmVmaXgodikge1xuICAgICAgICBzd2l0Y2godil7XG4gICAgICAgICAgICBjYXNlIFByZWZpeC5TZWVkOlxuICAgICAgICAgICAgICAgIHJldHVybiBQcmVmaXguU2VlZDtcbiAgICAgICAgICAgIGNhc2UgUHJlZml4LlByaXZhdGU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByZWZpeC5Qcml2YXRlO1xuICAgICAgICAgICAgY2FzZSBQcmVmaXguT3BlcmF0b3I6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByZWZpeC5PcGVyYXRvcjtcbiAgICAgICAgICAgIGNhc2UgUHJlZml4LlNlcnZlcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJlZml4LlNlcnZlcjtcbiAgICAgICAgICAgIGNhc2UgUHJlZml4LkNsdXN0ZXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByZWZpeC5DbHVzdGVyO1xuICAgICAgICAgICAgY2FzZSBQcmVmaXguQWNjb3VudDpcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJlZml4LkFjY291bnQ7XG4gICAgICAgICAgICBjYXNlIFByZWZpeC5Vc2VyOlxuICAgICAgICAgICAgICAgIHJldHVybiBQcmVmaXguVXNlcjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgQ29kZWMge1xuICAgIHN0YXRpYyBlbmNvZGUocHJlZml4LCBzcmMpIHtcbiAgICAgICAgaWYgKCFzcmMgfHwgIShzcmMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5LZXlzRXJyb3IoTktleXNFcnJvckNvZGUuU2VyaWFsaXphdGlvbkVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIVByZWZpeGVzLmlzVmFsaWRQcmVmaXgocHJlZml4KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5LZXlzRXJyb3IoTktleXNFcnJvckNvZGUuSW52YWxpZFByZWZpeEJ5dGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDb2RlYy5fZW5jb2RlKGZhbHNlLCBwcmVmaXgsIHNyYyk7XG4gICAgfVxuICAgIHN0YXRpYyBlbmNvZGVTZWVkKHJvbGUsIHNyYykge1xuICAgICAgICBpZiAoIXNyYykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5LZXlzRXJyb3IoTktleXNFcnJvckNvZGUuQXBpRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghUHJlZml4ZXMuaXNWYWxpZFB1YmxpY1ByZWZpeChyb2xlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5LZXlzRXJyb3IoTktleXNFcnJvckNvZGUuSW52YWxpZFByZWZpeEJ5dGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzcmMuYnl0ZUxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkludmFsaWRTZWVkTGVuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ29kZWMuX2VuY29kZSh0cnVlLCByb2xlLCBzcmMpO1xuICAgIH1cbiAgICBzdGF0aWMgZGVjb2RlKGV4cGVjdGVkLCBzcmMpIHtcbiAgICAgICAgaWYgKCFQcmVmaXhlcy5pc1ZhbGlkUHJlZml4KGV4cGVjdGVkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5LZXlzRXJyb3IoTktleXNFcnJvckNvZGUuSW52YWxpZFByZWZpeEJ5dGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhdyA9IENvZGVjLl9kZWNvZGUoc3JjKTtcbiAgICAgICAgaWYgKHJhd1swXSAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkludmFsaWRQcmVmaXhCeXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmF3LnNsaWNlKDEpO1xuICAgIH1cbiAgICBzdGF0aWMgZGVjb2RlU2VlZChzcmMpIHtcbiAgICAgICAgY29uc3QgcmF3ID0gQ29kZWMuX2RlY29kZShzcmMpO1xuICAgICAgICBjb25zdCBwcmVmaXggPSBDb2RlYy5fZGVjb2RlUHJlZml4KHJhdyk7XG4gICAgICAgIGlmIChwcmVmaXhbMF0gIT0gUHJlZml4LlNlZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkludmFsaWRTZWVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIVByZWZpeGVzLmlzVmFsaWRQdWJsaWNQcmVmaXgocHJlZml4WzFdKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5LZXlzRXJyb3IoTktleXNFcnJvckNvZGUuSW52YWxpZFByZWZpeEJ5dGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBidWY6IHJhdy5zbGljZSgyKSxcbiAgICAgICAgICAgIHByZWZpeDogcHJlZml4WzFdXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBfZW5jb2RlKHNlZWQsIHJvbGUsIHBheWxvYWQpIHtcbiAgICAgICAgY29uc3QgcGF5bG9hZE9mZnNldCA9IHNlZWQgPyAyIDogMTtcbiAgICAgICAgY29uc3QgcGF5bG9hZExlbiA9IHBheWxvYWQuYnl0ZUxlbmd0aDtcbiAgICAgICAgY29uc3QgY2FwID0gcGF5bG9hZE9mZnNldCArIHBheWxvYWRMZW4gKyAyO1xuICAgICAgICBjb25zdCBjaGVja09mZnNldCA9IHBheWxvYWRPZmZzZXQgKyBwYXlsb2FkTGVuO1xuICAgICAgICBjb25zdCByYXcgPSBuZXcgVWludDhBcnJheShjYXApO1xuICAgICAgICBpZiAoc2VlZCkge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlZFByZWZpeCA9IENvZGVjLl9lbmNvZGVQcmVmaXgoUHJlZml4LlNlZWQsIHJvbGUpO1xuICAgICAgICAgICAgcmF3LnNldChlbmNvZGVkUHJlZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhd1swXSA9IHJvbGU7XG4gICAgICAgIH1cbiAgICAgICAgcmF3LnNldChwYXlsb2FkLCBwYXlsb2FkT2Zmc2V0KTtcbiAgICAgICAgY29uc3QgY2hlY2tzdW0gPSBjcmMxNi5jaGVja3N1bShyYXcuc2xpY2UoMCwgY2hlY2tPZmZzZXQpKTtcbiAgICAgICAgY29uc3QgZHYgPSBuZXcgRGF0YVZpZXcocmF3LmJ1ZmZlcik7XG4gICAgICAgIGR2LnNldFVpbnQxNihjaGVja09mZnNldCwgY2hlY2tzdW0sIHRydWUpO1xuICAgICAgICByZXR1cm4gYmFzZTMyLmVuY29kZShyYXcpO1xuICAgIH1cbiAgICBzdGF0aWMgX2RlY29kZShzcmMpIHtcbiAgICAgICAgaWYgKHNyYy5ieXRlTGVuZ3RoIDwgNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5LZXlzRXJyb3IoTktleXNFcnJvckNvZGUuSW52YWxpZEVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmF3O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmF3ID0gYmFzZTMyLmRlY29kZShzcmMpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5LZXlzRXJyb3IoTktleXNFcnJvckNvZGUuSW52YWxpZEVuY29kaW5nLCBleCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hlY2tPZmZzZXQgPSByYXcuYnl0ZUxlbmd0aCAtIDI7XG4gICAgICAgIGNvbnN0IGR2ID0gbmV3IERhdGFWaWV3KHJhdy5idWZmZXIpO1xuICAgICAgICBjb25zdCBjaGVja3N1bSA9IGR2LmdldFVpbnQxNihjaGVja09mZnNldCwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSByYXcuc2xpY2UoMCwgY2hlY2tPZmZzZXQpO1xuICAgICAgICBpZiAoIWNyYzE2LnZhbGlkYXRlKHBheWxvYWQsIGNoZWNrc3VtKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5LZXlzRXJyb3IoTktleXNFcnJvckNvZGUuSW52YWxpZENoZWNrc3VtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9XG4gICAgc3RhdGljIF9lbmNvZGVQcmVmaXgoa2luZCwgcm9sZSkge1xuICAgICAgICBjb25zdCBiMSA9IGtpbmQgfCByb2xlID4+IDU7XG4gICAgICAgIGNvbnN0IGIyID0gKHJvbGUgJiAzMSkgPDwgMztcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIGIxLFxuICAgICAgICAgICAgYjJcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHN0YXRpYyBfZGVjb2RlUHJlZml4KHJhdykge1xuICAgICAgICBjb25zdCBiMSA9IHJhd1swXSAmIDI0ODtcbiAgICAgICAgY29uc3QgYjIgPSAocmF3WzBdICYgNykgPDwgNSB8IChyYXdbMV0gJiAyNDgpID4+IDM7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICBiMSxcbiAgICAgICAgICAgIGIyXG4gICAgICAgIF0pO1xuICAgIH1cbn1cbmNsYXNzIEtQIHtcbiAgICBzZWVkO1xuICAgIGNvbnN0cnVjdG9yKHNlZWQpe1xuICAgICAgICB0aGlzLnNlZWQgPSBzZWVkO1xuICAgIH1cbiAgICBnZXRSYXdTZWVkKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2VlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5LZXlzRXJyb3IoTktleXNFcnJvckNvZGUuQ2xlYXJlZFBhaXIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZCA9IENvZGVjLmRlY29kZVNlZWQodGhpcy5zZWVkKTtcbiAgICAgICAgcmV0dXJuIHNkLmJ1ZjtcbiAgICB9XG4gICAgZ2V0U2VlZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkNsZWFyZWRQYWlyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zZWVkO1xuICAgIH1cbiAgICBnZXRQdWJsaWNLZXkoKSB7XG4gICAgICAgIGlmICghdGhpcy5zZWVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTktleXNFcnJvcihOS2V5c0Vycm9yQ29kZS5DbGVhcmVkUGFpcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2QgPSBDb2RlYy5kZWNvZGVTZWVkKHRoaXMuc2VlZCk7XG4gICAgICAgIGNvbnN0IGtwID0gZ2V0RWQyNTUxOUhlbHBlcigpLmZyb21TZWVkKHRoaXMuZ2V0UmF3U2VlZCgpKTtcbiAgICAgICAgY29uc3QgYnVmID0gQ29kZWMuZW5jb2RlKHNkLnByZWZpeCwga3AucHVibGljS2V5KTtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShidWYpO1xuICAgIH1cbiAgICBnZXRQcml2YXRlS2V5KCkge1xuICAgICAgICBpZiAoIXRoaXMuc2VlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5LZXlzRXJyb3IoTktleXNFcnJvckNvZGUuQ2xlYXJlZFBhaXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtwID0gZ2V0RWQyNTUxOUhlbHBlcigpLmZyb21TZWVkKHRoaXMuZ2V0UmF3U2VlZCgpKTtcbiAgICAgICAgcmV0dXJuIENvZGVjLmVuY29kZShQcmVmaXguUHJpdmF0ZSwga3Auc2VjcmV0S2V5KTtcbiAgICB9XG4gICAgc2lnbihpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuc2VlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5LZXlzRXJyb3IoTktleXNFcnJvckNvZGUuQ2xlYXJlZFBhaXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtwID0gZ2V0RWQyNTUxOUhlbHBlcigpLmZyb21TZWVkKHRoaXMuZ2V0UmF3U2VlZCgpKTtcbiAgICAgICAgcmV0dXJuIGdldEVkMjU1MTlIZWxwZXIoKS5zaWduKGlucHV0LCBrcC5zZWNyZXRLZXkpO1xuICAgIH1cbiAgICB2ZXJpZnkoaW5wdXQsIHNpZykge1xuICAgICAgICBpZiAoIXRoaXMuc2VlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5LZXlzRXJyb3IoTktleXNFcnJvckNvZGUuQ2xlYXJlZFBhaXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtwID0gZ2V0RWQyNTUxOUhlbHBlcigpLmZyb21TZWVkKHRoaXMuZ2V0UmF3U2VlZCgpKTtcbiAgICAgICAgcmV0dXJuIGdldEVkMjU1MTlIZWxwZXIoKS52ZXJpZnkoaW5wdXQsIHNpZywga3AucHVibGljS2V5KTtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5zZWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWVkLmZpbGwoMCk7XG4gICAgICAgIHRoaXMuc2VlZCA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQYWlyKHByZWZpeCkge1xuICAgIGNvbnN0IHJhd1NlZWQgPSBnZXRFZDI1NTE5SGVscGVyKCkucmFuZG9tQnl0ZXMoMzIpO1xuICAgIGxldCBzdHIgPSBDb2RlYy5lbmNvZGVTZWVkKHByZWZpeCwgbmV3IFVpbnQ4QXJyYXkocmF3U2VlZCkpO1xuICAgIHJldHVybiBuZXcgS1Aoc3RyKTtcbn1cbmNsYXNzIFB1YmxpY0tleSB7XG4gICAgcHVibGljS2V5O1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpY0tleSl7XG4gICAgICAgIHRoaXMucHVibGljS2V5ID0gcHVibGljS2V5O1xuICAgIH1cbiAgICBnZXRQdWJsaWNLZXkoKSB7XG4gICAgICAgIGlmICghdGhpcy5wdWJsaWNLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkNsZWFyZWRQYWlyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHRoaXMucHVibGljS2V5KTtcbiAgICB9XG4gICAgZ2V0UHJpdmF0ZUtleSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnB1YmxpY0tleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5LZXlzRXJyb3IoTktleXNFcnJvckNvZGUuQ2xlYXJlZFBhaXIpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLlB1YmxpY0tleU9ubHkpO1xuICAgIH1cbiAgICBnZXRTZWVkKCkge1xuICAgICAgICBpZiAoIXRoaXMucHVibGljS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTktleXNFcnJvcihOS2V5c0Vycm9yQ29kZS5DbGVhcmVkUGFpcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE5LZXlzRXJyb3IoTktleXNFcnJvckNvZGUuUHVibGljS2V5T25seSk7XG4gICAgfVxuICAgIHNpZ24oXykge1xuICAgICAgICBpZiAoIXRoaXMucHVibGljS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTktleXNFcnJvcihOS2V5c0Vycm9yQ29kZS5DbGVhcmVkUGFpcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE5LZXlzRXJyb3IoTktleXNFcnJvckNvZGUuQ2Fubm90U2lnbik7XG4gICAgfVxuICAgIHZlcmlmeShpbnB1dCwgc2lnKSB7XG4gICAgICAgIGlmICghdGhpcy5wdWJsaWNLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkNsZWFyZWRQYWlyKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYnVmID0gQ29kZWMuX2RlY29kZSh0aGlzLnB1YmxpY0tleSk7XG4gICAgICAgIHJldHVybiBnZXRFZDI1NTE5SGVscGVyKCkudmVyaWZ5KGlucHV0LCBzaWcsIGJ1Zi5zbGljZSgxKSk7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICBpZiAoIXRoaXMucHVibGljS2V5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wdWJsaWNLZXkuZmlsbCgwKTtcbiAgICAgICAgdGhpcy5wdWJsaWNLZXkgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gZnJvbVB1YmxpYyhzcmMpIHtcbiAgICBjb25zdCBiYSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzcmMpO1xuICAgIGNvbnN0IHJhdyA9IENvZGVjLl9kZWNvZGUoYmEpO1xuICAgIGNvbnN0IHByZWZpeCA9IFByZWZpeGVzLnBhcnNlUHJlZml4KHJhd1swXSk7XG4gICAgaWYgKFByZWZpeGVzLmlzVmFsaWRQdWJsaWNQcmVmaXgocHJlZml4KSkge1xuICAgICAgICByZXR1cm4gbmV3IFB1YmxpY0tleShiYSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBOS2V5c0Vycm9yKE5LZXlzRXJyb3JDb2RlLkludmFsaWRQdWJsaWNLZXkpO1xufVxuZnVuY3Rpb24gZnJvbVNlZWQoc3JjKSB7XG4gICAgQ29kZWMuZGVjb2RlU2VlZChzcmMpO1xuICAgIHJldHVybiBuZXcgS1Aoc3JjKTtcbn1cbmZ1bmN0aW9uIGVuY29kZTEoYnl0ZXMpIHtcbiAgICByZXR1cm4gYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLmJ5dGVzKSk7XG59XG5mdW5jdGlvbiBkZWNvZGUxKGI2NHN0cikge1xuICAgIGNvbnN0IGJpbiA9IGF0b2IoYjY0c3RyKTtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJpbi5sZW5ndGgpO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBiaW4ubGVuZ3RoOyBpKyspe1xuICAgICAgICBieXRlc1tpXSA9IGJpbi5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5zZXRFZDI1NTE5SGVscGVyKGRlbm9IZWxwZXIpO1xuY29uc3QgbW9kID0ge1xuICAgIGNyZWF0ZUFjY291bnQsXG4gICAgY3JlYXRlT3BlcmF0b3IsXG4gICAgY3JlYXRlUGFpcixcbiAgICBjcmVhdGVVc2VyLFxuICAgIGZyb21QdWJsaWMsXG4gICAgZnJvbVNlZWQsXG4gICAgTktleXNFcnJvcixcbiAgICBOS2V5c0Vycm9yQ29kZSxcbiAgICBQcmVmaXgsXG4gICAgZGVjb2RlOiBkZWNvZGUxLFxuICAgIGVuY29kZTogZW5jb2RlMVxufTtcbmZ1bmN0aW9uIG11bHRpQXV0aGVudGljYXRvcihhdXRoZW50aWNhdG9ycykge1xuICAgIHJldHVybiAobm9uY2UpPT57XG4gICAgICAgIGxldCBhdXRoID0ge307XG4gICAgICAgIGF1dGhlbnRpY2F0b3JzLmZvckVhY2goKGEpPT57XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gYShub25jZSkgfHwge307XG4gICAgICAgICAgICBhdXRoID0gT2JqZWN0LmFzc2lnbihhdXRoLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhdXRoO1xuICAgIH07XG59XG5mdW5jdGlvbiBub0F1dGhGbigpIHtcbiAgICByZXR1cm4gKCk9PntcbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG59XG5mdW5jdGlvbiB1c2VybmFtZVBhc3N3b3JkQXV0aGVudGljYXRvcih1c2VyLCBwYXNzKSB7XG4gICAgcmV0dXJuICgpPT57XG4gICAgICAgIGNvbnN0IHUgPSB0eXBlb2YgdXNlciA9PT0gXCJmdW5jdGlvblwiID8gdXNlcigpIDogdXNlcjtcbiAgICAgICAgY29uc3QgcCA9IHR5cGVvZiBwYXNzID09PSBcImZ1bmN0aW9uXCIgPyBwYXNzKCkgOiBwYXNzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlcjogdSxcbiAgICAgICAgICAgIHBhc3M6IHBcbiAgICAgICAgfTtcbiAgICB9O1xufVxuZnVuY3Rpb24gdG9rZW5BdXRoZW50aWNhdG9yKHRva2VuKSB7XG4gICAgcmV0dXJuICgpPT57XG4gICAgICAgIGNvbnN0IGF1dGhfdG9rZW4gPSB0eXBlb2YgdG9rZW4gPT09IFwiZnVuY3Rpb25cIiA/IHRva2VuKCkgOiB0b2tlbjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGF1dGhfdG9rZW5cbiAgICAgICAgfTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbmtleUF1dGhlbnRpY2F0b3Ioc2VlZCkge1xuICAgIHJldHVybiAobm9uY2UpPT57XG4gICAgICAgIGNvbnN0IHMgPSB0eXBlb2Ygc2VlZCA9PT0gXCJmdW5jdGlvblwiID8gc2VlZCgpIDogc2VlZDtcbiAgICAgICAgY29uc3Qga3AgPSBzID8gbW9kLmZyb21TZWVkKHMpIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBua2V5ID0ga3AgPyBrcC5nZXRQdWJsaWNLZXkoKSA6IFwiXCI7XG4gICAgICAgIGNvbnN0IGNoYWxsZW5nZSA9IFRFLmVuY29kZShub25jZSB8fCBcIlwiKTtcbiAgICAgICAgY29uc3Qgc2lnQnl0ZXMgPSBrcCAhPT0gdW5kZWZpbmVkICYmIG5vbmNlID8ga3Auc2lnbihjaGFsbGVuZ2UpIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzaWcgPSBzaWdCeXRlcyA/IG1vZC5lbmNvZGUoc2lnQnl0ZXMpIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5rZXksXG4gICAgICAgICAgICBzaWdcbiAgICAgICAgfTtcbiAgICB9O1xufVxuZnVuY3Rpb24gand0QXV0aGVudGljYXRvcihhand0LCBzZWVkKSB7XG4gICAgcmV0dXJuIChub25jZSk9PntcbiAgICAgICAgY29uc3Qgand0ID0gdHlwZW9mIGFqd3QgPT09IFwiZnVuY3Rpb25cIiA/IGFqd3QoKSA6IGFqd3Q7XG4gICAgICAgIGNvbnN0IGZuID0gbmtleUF1dGhlbnRpY2F0b3Ioc2VlZCk7XG4gICAgICAgIGNvbnN0IHsgbmtleSwgc2lnIH0gPSBmbihub25jZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBqd3QsXG4gICAgICAgICAgICBua2V5LFxuICAgICAgICAgICAgc2lnXG4gICAgICAgIH07XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWRzQXV0aGVudGljYXRvcihjcmVkcykge1xuICAgIGNvbnN0IGZuID0gdHlwZW9mIGNyZWRzICE9PSBcImZ1bmN0aW9uXCIgPyAoKT0+Y3JlZHMgOiBjcmVkcztcbiAgICBjb25zdCBwYXJzZSA9ICgpPT57XG4gICAgICAgIGNvbnN0IENSRURTID0gL1xccyooPzooPzpbLV17Myx9W15cXG5dKlstXXszLH1cXG4pKC4rKSg/OlxcblxccypbLV17Myx9W15cXG5dKlstXXszLH1cXG4pKS9pZztcbiAgICAgICAgY29uc3QgcyA9IFRELmRlY29kZShmbigpKTtcbiAgICAgICAgbGV0IG0gPSBDUkVEUy5leGVjKHMpO1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHRocm93IE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLkJhZENyZWRzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBqd3QgPSBtWzFdLnRyaW0oKTtcbiAgICAgICAgbSA9IENSRURTLmV4ZWMocyk7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgdGhyb3cgTmF0c0Vycm9yLmVycm9yRm9yQ29kZShFcnJvckNvZGUuQmFkQ3JlZHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgdGhyb3cgTmF0c0Vycm9yLmVycm9yRm9yQ29kZShFcnJvckNvZGUuQmFkQ3JlZHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZWQgPSBURS5lbmNvZGUobVsxXS50cmltKCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgand0LFxuICAgICAgICAgICAgc2VlZFxuICAgICAgICB9O1xuICAgIH07XG4gICAgY29uc3Qgand0Rm4gPSAoKT0+e1xuICAgICAgICBjb25zdCB7IGp3dCB9ID0gcGFyc2UoKTtcbiAgICAgICAgcmV0dXJuIGp3dDtcbiAgICB9O1xuICAgIGNvbnN0IG5rZXlGbiA9ICgpPT57XG4gICAgICAgIGNvbnN0IHsgc2VlZCB9ID0gcGFyc2UoKTtcbiAgICAgICAgcmV0dXJuIHNlZWQ7XG4gICAgfTtcbiAgICByZXR1cm4gand0QXV0aGVudGljYXRvcihqd3RGbiwgbmtleUZuKTtcbn1cbmNvbnN0IERFRkFVTFRfUElOR19JTlRFUlZBTCA9IDIgKiA2MCAqIDEwMDA7XG5jb25zdCBERUZBVUxUX01BWF9QSU5HX09VVCA9IDI7XG5jb25zdCBERUZBVUxUX1JFQ09OTkVDVF9USU1FX1dBSVQgPSAyICogMTAwMDtcbmZ1bmN0aW9uIGRlZmF1bHRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG1heFBpbmdPdXQ6IDIsXG4gICAgICAgIG1heFJlY29ubmVjdEF0dGVtcHRzOiAxMCxcbiAgICAgICAgbm9SYW5kb21pemU6IGZhbHNlLFxuICAgICAgICBwZWRhbnRpYzogZmFsc2UsXG4gICAgICAgIHBpbmdJbnRlcnZhbDogREVGQVVMVF9QSU5HX0lOVEVSVkFMLFxuICAgICAgICByZWNvbm5lY3Q6IHRydWUsXG4gICAgICAgIHJlY29ubmVjdEppdHRlcjogMTAwLFxuICAgICAgICByZWNvbm5lY3RKaXR0ZXJUTFM6IDEwMDAsXG4gICAgICAgIHJlY29ubmVjdFRpbWVXYWl0OiBERUZBVUxUX1JFQ09OTkVDVF9USU1FX1dBSVQsXG4gICAgICAgIHRsczogdW5kZWZpbmVkLFxuICAgICAgICB2ZXJib3NlOiBmYWxzZSxcbiAgICAgICAgd2FpdE9uRmlyc3RDb25uZWN0OiBmYWxzZSxcbiAgICAgICAgaWdub3JlQXV0aEVycm9yQWJvcnQ6IGZhbHNlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkQXV0aGVudGljYXRvcihvcHRzKSB7XG4gICAgY29uc3QgYnVmID0gW107XG4gICAgaWYgKHR5cGVvZiBvcHRzLmF1dGhlbnRpY2F0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBidWYucHVzaChvcHRzLmF1dGhlbnRpY2F0b3IpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRzLmF1dGhlbnRpY2F0b3IpKSB7XG4gICAgICAgIGJ1Zi5wdXNoKC4uLm9wdHMuYXV0aGVudGljYXRvcik7XG4gICAgfVxuICAgIGlmIChvcHRzLnRva2VuKSB7XG4gICAgICAgIGJ1Zi5wdXNoKHRva2VuQXV0aGVudGljYXRvcihvcHRzLnRva2VuKSk7XG4gICAgfVxuICAgIGlmIChvcHRzLnVzZXIpIHtcbiAgICAgICAgYnVmLnB1c2godXNlcm5hbWVQYXNzd29yZEF1dGhlbnRpY2F0b3Iob3B0cy51c2VyLCBvcHRzLnBhc3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1Zi5sZW5ndGggPT09IDAgPyBub0F1dGhGbigpIDogbXVsdGlBdXRoZW50aWNhdG9yKGJ1Zik7XG59XG5mdW5jdGlvbiBwYXJzZU9wdGlvbnMob3B0cykge1xuICAgIGNvbnN0IGRocCA9IGAke0RFRkFVTFRfSE9TVH06JHtkZWZhdWx0UG9ydCgpfWA7XG4gICAgb3B0cyA9IG9wdHMgfHwge1xuICAgICAgICBzZXJ2ZXJzOiBbXG4gICAgICAgICAgICBkaHBcbiAgICAgICAgXVxuICAgIH07XG4gICAgb3B0cy5zZXJ2ZXJzID0gb3B0cy5zZXJ2ZXJzIHx8IFtdO1xuICAgIGlmICh0eXBlb2Ygb3B0cy5zZXJ2ZXJzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG9wdHMuc2VydmVycyA9IFtcbiAgICAgICAgICAgIG9wdHMuc2VydmVyc1xuICAgICAgICBdO1xuICAgIH1cbiAgICBpZiAob3B0cy5zZXJ2ZXJzLmxlbmd0aCA+IDAgJiYgb3B0cy5wb3J0KSB7XG4gICAgICAgIHRocm93IG5ldyBOYXRzRXJyb3IoXCJwb3J0IGFuZCBzZXJ2ZXJzIG9wdGlvbnMgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZVwiLCBFcnJvckNvZGUuSW52YWxpZE9wdGlvbik7XG4gICAgfVxuICAgIGlmIChvcHRzLnNlcnZlcnMubGVuZ3RoID09PSAwICYmIG9wdHMucG9ydCkge1xuICAgICAgICBvcHRzLnNlcnZlcnMgPSBbXG4gICAgICAgICAgICBgJHtERUZBVUxUX0hPU1R9OiR7b3B0cy5wb3J0fWBcbiAgICAgICAgXTtcbiAgICB9XG4gICAgaWYgKG9wdHMuc2VydmVycyAmJiBvcHRzLnNlcnZlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG9wdHMuc2VydmVycyA9IFtcbiAgICAgICAgICAgIGRocFxuICAgICAgICBdO1xuICAgIH1cbiAgICBjb25zdCBvcHRpb25zID0gZXh0ZW5kKGRlZmF1bHRPcHRpb25zKCksIG9wdHMpO1xuICAgIG9wdGlvbnMuYXV0aGVudGljYXRvciA9IGJ1aWxkQXV0aGVudGljYXRvcihvcHRpb25zKTtcbiAgICBbXG4gICAgICAgIFwicmVjb25uZWN0RGVsYXlIYW5kbGVyXCIsXG4gICAgICAgIFwiYXV0aGVudGljYXRvclwiXG4gICAgXS5mb3JFYWNoKChuKT0+e1xuICAgICAgICBpZiAob3B0aW9uc1tuXSAmJiB0eXBlb2Ygb3B0aW9uc1tuXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTmF0c0Vycm9yKGAke259IG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbmAsIEVycm9yQ29kZS5Ob3RGdW5jdGlvbik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIW9wdGlvbnMucmVjb25uZWN0RGVsYXlIYW5kbGVyKSB7XG4gICAgICAgIG9wdGlvbnMucmVjb25uZWN0RGVsYXlIYW5kbGVyID0gKCk9PntcbiAgICAgICAgICAgIGxldCBleHRyYSA9IG9wdGlvbnMudGxzID8gb3B0aW9ucy5yZWNvbm5lY3RKaXR0ZXJUTFMgOiBvcHRpb25zLnJlY29ubmVjdEppdHRlcjtcbiAgICAgICAgICAgIGlmIChleHRyYSkge1xuICAgICAgICAgICAgICAgIGV4dHJhKys7XG4gICAgICAgICAgICAgICAgZXh0cmEgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBleHRyYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5yZWNvbm5lY3RUaW1lV2FpdCArIGV4dHJhO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5pbmJveFByZWZpeCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY3JlYXRlSW5ib3gob3B0aW9ucy5pbmJveFByZWZpeCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5hdHNFcnJvcihlcnIubWVzc2FnZSwgRXJyb3JDb2RlLkFwaUVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yZXNvbHZlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5yZXNvbHZlID0gdHlwZW9mIGdldFJlc29sdmVGbigpID09PSBcImZ1bmN0aW9uXCI7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnJlc29sdmUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBnZXRSZXNvbHZlRm4oKSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTmF0c0Vycm9yKGAncmVzb2x2ZScgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGNsaWVudGAsIEVycm9yQ29kZS5JbnZhbGlkT3B0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbn1cbmZ1bmN0aW9uIGNoZWNrT3B0aW9ucyhpbmZvLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBwcm90bywgdGxzX3JlcXVpcmVkOiB0bHNSZXF1aXJlZCwgdGxzX2F2YWlsYWJsZTogdGxzQXZhaWxhYmxlIH0gPSBpbmZvO1xuICAgIGlmICgocHJvdG8gPT09IHVuZGVmaW5lZCB8fCBwcm90byA8IDEpICYmIG9wdGlvbnMubm9FY2hvKSB7XG4gICAgICAgIHRocm93IG5ldyBOYXRzRXJyb3IoXCJub0VjaG9cIiwgRXJyb3JDb2RlLlNlcnZlck9wdGlvbk5vdEF2YWlsYWJsZSk7XG4gICAgfVxuICAgIGNvbnN0IHRscyA9IHRsc1JlcXVpcmVkIHx8IHRsc0F2YWlsYWJsZSB8fCBmYWxzZTtcbiAgICBpZiAob3B0aW9ucy50bHMgJiYgIXRscykge1xuICAgICAgICB0aHJvdyBuZXcgTmF0c0Vycm9yKFwidGxzXCIsIEVycm9yQ29kZS5TZXJ2ZXJPcHRpb25Ob3RBdmFpbGFibGUpO1xuICAgIH1cbn1cbmNvbnN0IEZMVVNIX1RIUkVTSE9MRCA9IDEwMjQgKiAzMjtcbmNvbnN0IElORk8gPSAvXklORk9cXHMrKFteXFxyXFxuXSspXFxyXFxuL2k7XG5jb25zdCBQT05HX0NNRCA9IGVuY29kZShcIlBPTkdcXHJcXG5cIik7XG5jb25zdCBQSU5HX0NNRCA9IGVuY29kZShcIlBJTkdcXHJcXG5cIik7XG5jbGFzcyBDb25uZWN0IHtcbiAgICBlY2hvO1xuICAgIG5vX3Jlc3BvbmRlcnM7XG4gICAgcHJvdG9jb2w7XG4gICAgdmVyYm9zZTtcbiAgICBwZWRhbnRpYztcbiAgICBqd3Q7XG4gICAgbmtleTtcbiAgICBzaWc7XG4gICAgdXNlcjtcbiAgICBwYXNzO1xuICAgIGF1dGhfdG9rZW47XG4gICAgdGxzX3JlcXVpcmVkO1xuICAgIG5hbWU7XG4gICAgbGFuZztcbiAgICB2ZXJzaW9uO1xuICAgIGhlYWRlcnM7XG4gICAgY29uc3RydWN0b3IodHJhbnNwb3J0LCBvcHRzLCBub25jZSl7XG4gICAgICAgIHRoaXMucHJvdG9jb2wgPSAxO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB0cmFuc3BvcnQudmVyc2lvbjtcbiAgICAgICAgdGhpcy5sYW5nID0gdHJhbnNwb3J0Lmxhbmc7XG4gICAgICAgIHRoaXMuZWNobyA9IG9wdHMubm9FY2hvID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudmVyYm9zZSA9IG9wdHMudmVyYm9zZTtcbiAgICAgICAgdGhpcy5wZWRhbnRpYyA9IG9wdHMucGVkYW50aWM7XG4gICAgICAgIHRoaXMudGxzX3JlcXVpcmVkID0gb3B0cy50bHMgPyB0cnVlIDogdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm5hbWUgPSBvcHRzLm5hbWU7XG4gICAgICAgIGNvbnN0IGNyZWRzID0gKG9wdHMgJiYgdHlwZW9mIG9wdHMuYXV0aGVudGljYXRvciA9PT0gXCJmdW5jdGlvblwiID8gb3B0cy5hdXRoZW50aWNhdG9yKG5vbmNlKSA6IHt9KSB8fCB7fTtcbiAgICAgICAgZXh0ZW5kKHRoaXMsIGNyZWRzKTtcbiAgICB9XG59XG5jbGFzcyBTdWJzY3JpcHRpb25JbXBsIGV4dGVuZHMgUXVldWVkSXRlcmF0b3JJbXBsIHtcbiAgICBzaWQ7XG4gICAgcXVldWU7XG4gICAgZHJhaW5pbmc7XG4gICAgbWF4O1xuICAgIHN1YmplY3Q7XG4gICAgZHJhaW5lZDtcbiAgICBwcm90b2NvbDtcbiAgICB0aW1lcjtcbiAgICBpbmZvO1xuICAgIGNsZWFudXBGbjtcbiAgICBjbG9zZWQ7XG4gICAgcmVxdWVzdFN1YmplY3Q7XG4gICAgY29uc3RydWN0b3IocHJvdG9jb2wsIHN1YmplY3QsIG9wdHMgPSB7fSl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGV4dGVuZCh0aGlzLCBvcHRzKTtcbiAgICAgICAgdGhpcy5wcm90b2NvbCA9IHByb3RvY29sO1xuICAgICAgICB0aGlzLnN1YmplY3QgPSBzdWJqZWN0O1xuICAgICAgICB0aGlzLmRyYWluaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMubm9JdGVyYXRvciA9IHR5cGVvZiBvcHRzLmNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gZGVmZXJyZWQoKTtcbiAgICAgICAgY29uc3QgYXN5bmNUcmFjZXMgPSAhKHByb3RvY29sLm9wdGlvbnM/Lm5vQXN5bmNUcmFjZXMgfHwgZmFsc2UpO1xuICAgICAgICBpZiAob3B0cy50aW1lb3V0KSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVyID0gdGltZW91dChvcHRzLnRpbWVvdXQsIGFzeW5jVHJhY2VzKTtcbiAgICAgICAgICAgIHRoaXMudGltZXIudGhlbigoKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMudGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcChlcnIpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vSXRlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFjayhlcnIsIHt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubm9JdGVyYXRvcikge1xuICAgICAgICAgICAgdGhpcy5pdGVyQ2xvc2VkLnRoZW4oKCk9PntcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0UHJlUG9zdEhhbmRsZXJzKG9wdHMpIHtcbiAgICAgICAgaWYgKHRoaXMubm9JdGVyYXRvcikge1xuICAgICAgICAgICAgY29uc3QgdWMgPSB0aGlzLmNhbGxiYWNrO1xuICAgICAgICAgICAgY29uc3QgaW5nZXN0aW9uID0gb3B0cy5pbmdlc3Rpb25GaWx0ZXJGbiA/IG9wdHMuaW5nZXN0aW9uRmlsdGVyRm4gOiAoKT0+e1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGluZ2VzdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2w6IGZhbHNlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSBvcHRzLnByb3RvY29sRmlsdGVyRm4gPyBvcHRzLnByb3RvY29sRmlsdGVyRm4gOiAoKT0+e1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3BhdGNoZWQgPSBvcHRzLmRpc3BhdGNoZWRGbiA/IG9wdHMuZGlzcGF0Y2hlZEZuIDogKCk9Pnt9O1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFjayA9IChlcnIsIG1zZyk9PntcbiAgICAgICAgICAgICAgICBjb25zdCB7IGluZ2VzdCB9ID0gaW5nZXN0aW9uKG1zZyk7XG4gICAgICAgICAgICAgICAgaWYgKCFpbmdlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyKG1zZykpIHtcbiAgICAgICAgICAgICAgICAgICAgdWMoZXJyLCBtc2cpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaGVkKG1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJvdG9jb2xGaWx0ZXJGbiA9IG9wdHMucHJvdG9jb2xGaWx0ZXJGbjtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hlZEZuID0gb3B0cy5kaXNwYXRjaGVkRm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FsbGJhY2soZXJyLCBtc2cpIHtcbiAgICAgICAgdGhpcy5jYW5jZWxUaW1lb3V0KCk7XG4gICAgICAgIGVyciA/IHRoaXMuc3RvcChlcnIpIDogdGhpcy5wdXNoKG1zZyk7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNDbG9zZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxUaW1lb3V0KCk7XG4gICAgICAgICAgICBjb25zdCBmbiA9ICgpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2xlYW51cEZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFudXBGbih0aGlzLCB0aGlzLmluZm8pO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChfZXJyKSB7fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMubm9JdGVyYXRvcikge1xuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaChmbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5zdWJzY3JpYmUobWF4KSB7XG4gICAgICAgIHRoaXMucHJvdG9jb2wudW5zdWJzY3JpYmUodGhpcywgbWF4KTtcbiAgICB9XG4gICAgY2FuY2VsVGltZW91dCgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMudGltZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICB0aGlzLnRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRyYWluKCkge1xuICAgICAgICBpZiAodGhpcy5wcm90b2NvbC5pc0Nsb3NlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoTmF0c0Vycm9yLmVycm9yRm9yQ29kZShFcnJvckNvZGUuQ29ubmVjdGlvbkNsb3NlZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChOYXRzRXJyb3IuZXJyb3JGb3JDb2RlKEVycm9yQ29kZS5TdWJDbG9zZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZHJhaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kcmFpbmluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnByb3RvY29sLnVuc3ViKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5kcmFpbmVkID0gdGhpcy5wcm90b2NvbC5mbHVzaChkZWZlcnJlZCgpKS50aGVuKCgpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5wcm90b2NvbC5zdWJzY3JpcHRpb25zLmNhbmNlbCh0aGlzKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKCgpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5wcm90b2NvbC5zdWJzY3JpcHRpb25zLmNhbmNlbCh0aGlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRyYWluZWQ7XG4gICAgfVxuICAgIGlzRHJhaW5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYWluaW5nO1xuICAgIH1cbiAgICBpc0Nsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9uZTtcbiAgICB9XG4gICAgZ2V0U3ViamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViamVjdDtcbiAgICB9XG4gICAgZ2V0TWF4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXg7XG4gICAgfVxuICAgIGdldElEKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWQ7XG4gICAgfVxufVxuY2xhc3MgU3Vic2NyaXB0aW9ucyB7XG4gICAgbXV4O1xuICAgIHN1YnM7XG4gICAgc2lkQ291bnRlcjtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLnNpZENvdW50ZXIgPSAwO1xuICAgICAgICB0aGlzLm11eCA9IG51bGw7XG4gICAgICAgIHRoaXMuc3VicyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3Vicy5zaXplO1xuICAgIH1cbiAgICBhZGQocykge1xuICAgICAgICB0aGlzLnNpZENvdW50ZXIrKztcbiAgICAgICAgcy5zaWQgPSB0aGlzLnNpZENvdW50ZXI7XG4gICAgICAgIHRoaXMuc3Vicy5zZXQocy5zaWQsIHMpO1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgc2V0TXV4KHMpIHtcbiAgICAgICAgdGhpcy5tdXggPSBzO1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgZ2V0TXV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tdXg7XG4gICAgfVxuICAgIGdldChzaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3Vicy5nZXQoc2lkKTtcbiAgICB9XG4gICAgcmVzdWIocykge1xuICAgICAgICB0aGlzLnNpZENvdW50ZXIrKztcbiAgICAgICAgdGhpcy5zdWJzLmRlbGV0ZShzLnNpZCk7XG4gICAgICAgIHMuc2lkID0gdGhpcy5zaWRDb3VudGVyO1xuICAgICAgICB0aGlzLnN1YnMuc2V0KHMuc2lkLCBzKTtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIGFsbCgpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5zdWJzLnZhbHVlcygpKTtcbiAgICB9XG4gICAgY2FuY2VsKHMpIHtcbiAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICAgIHMuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuc3Vicy5kZWxldGUocy5zaWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUVycm9yKGVycikge1xuICAgICAgICBpZiAoZXJyICYmIGVyci5wZXJtaXNzaW9uQ29udGV4dCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gZXJyLnBlcm1pc3Npb25Db250ZXh0O1xuICAgICAgICAgICAgY29uc3Qgc3VicyA9IHRoaXMuYWxsKCk7XG4gICAgICAgICAgICBsZXQgc3ViO1xuICAgICAgICAgICAgaWYgKGN0eC5vcGVyYXRpb24gPT09IFwic3Vic2NyaXB0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBzdWIgPSBzdWJzLmZpbmQoKHMpPT57XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzLnN1YmplY3QgPT09IGN0eC5zdWJqZWN0ICYmIHMucXVldWUgPT09IGN0eC5xdWV1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdHgub3BlcmF0aW9uID09PSBcInB1Ymxpc2hcIikge1xuICAgICAgICAgICAgICAgIHN1YiA9IHN1YnMuZmluZCgocyk9PntcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMucmVxdWVzdFN1YmplY3QgPT09IGN0eC5zdWJqZWN0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1Yikge1xuICAgICAgICAgICAgICAgIHN1Yi5jYWxsYmFjayhlcnIsIHt9KTtcbiAgICAgICAgICAgICAgICBzdWIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnMuZGVsZXRlKHN1Yi5zaWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWIgIT09IHRoaXMubXV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuc3Vicy5mb3JFYWNoKChzdWIpPT57XG4gICAgICAgICAgICBzdWIuY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgUHJvdG9jb2xIYW5kbGVyIHtcbiAgICBjb25uZWN0ZWQ7XG4gICAgY29ubmVjdGVkT25jZTtcbiAgICBpbmZvUmVjZWl2ZWQ7XG4gICAgaW5mbztcbiAgICBtdXhTdWJzY3JpcHRpb25zO1xuICAgIG9wdGlvbnM7XG4gICAgb3V0Ym91bmQ7XG4gICAgcG9uZ3M7XG4gICAgc3Vic2NyaXB0aW9ucztcbiAgICB0cmFuc3BvcnQ7XG4gICAgbm9Nb3JlUHVibGlzaGluZztcbiAgICBjb25uZWN0RXJyb3I7XG4gICAgcHVibGlzaGVyO1xuICAgIF9jbG9zZWQ7XG4gICAgY2xvc2VkO1xuICAgIGxpc3RlbmVycztcbiAgICBoZWFydGJlYXRzO1xuICAgIHBhcnNlcjtcbiAgICBvdXRNc2dzO1xuICAgIGluTXNncztcbiAgICBvdXRCeXRlcztcbiAgICBpbkJ5dGVzO1xuICAgIHBlbmRpbmdMaW1pdDtcbiAgICBsYXN0RXJyb3I7XG4gICAgYWJvcnRSZWNvbm5lY3Q7XG4gICAgd2h5Q2xvc2VkO1xuICAgIHNlcnZlcnM7XG4gICAgc2VydmVyO1xuICAgIGZlYXR1cmVzO1xuICAgIGNvbm5lY3RQcm9taXNlO1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIHB1Ymxpc2hlcil7XG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZE9uY2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbmZvUmVjZWl2ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ub01vcmVQdWJsaXNoaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWJvcnRSZWNvbm5lY3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5wZW5kaW5nTGltaXQgPSBGTFVTSF9USFJFU0hPTEQ7XG4gICAgICAgIHRoaXMub3V0TXNncyA9IDA7XG4gICAgICAgIHRoaXMuaW5Nc2dzID0gMDtcbiAgICAgICAgdGhpcy5vdXRCeXRlcyA9IDA7XG4gICAgICAgIHRoaXMuaW5CeXRlcyA9IDA7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMucHVibGlzaGVyID0gcHVibGlzaGVyO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICB0aGlzLm11eFN1YnNjcmlwdGlvbnMgPSBuZXcgTXV4U3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHRoaXMub3V0Ym91bmQgPSBuZXcgRGF0YUJ1ZmZlcigpO1xuICAgICAgICB0aGlzLnBvbmdzID0gW107XG4gICAgICAgIHRoaXMud2h5Q2xvc2VkID0gXCJcIjtcbiAgICAgICAgdGhpcy5wZW5kaW5nTGltaXQgPSBvcHRpb25zLnBlbmRpbmdMaW1pdCB8fCB0aGlzLnBlbmRpbmdMaW1pdDtcbiAgICAgICAgdGhpcy5mZWF0dXJlcyA9IG5ldyBGZWF0dXJlcyh7XG4gICAgICAgICAgICBtYWpvcjogMCxcbiAgICAgICAgICAgIG1pbm9yOiAwLFxuICAgICAgICAgICAgbWljcm86IDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdFByb21pc2UgPSBudWxsO1xuICAgICAgICBjb25zdCBzZXJ2ZXJzID0gdHlwZW9mIG9wdGlvbnMuc2VydmVycyA9PT0gXCJzdHJpbmdcIiA/IFtcbiAgICAgICAgICAgIG9wdGlvbnMuc2VydmVyc1xuICAgICAgICBdIDogb3B0aW9ucy5zZXJ2ZXJzO1xuICAgICAgICB0aGlzLnNlcnZlcnMgPSBuZXcgU2VydmVycyhzZXJ2ZXJzLCB7XG4gICAgICAgICAgICByYW5kb21pemU6ICFvcHRpb25zLm5vUmFuZG9taXplXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGRlZmVycmVkKCk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gbmV3IFBhcnNlcih0aGlzKTtcbiAgICAgICAgdGhpcy5oZWFydGJlYXRzID0gbmV3IEhlYXJ0YmVhdCh0aGlzLCB0aGlzLm9wdGlvbnMucGluZ0ludGVydmFsIHx8IERFRkFVTFRfUElOR19JTlRFUlZBTCwgdGhpcy5vcHRpb25zLm1heFBpbmdPdXQgfHwgREVGQVVMVF9NQVhfUElOR19PVVQpO1xuICAgIH1cbiAgICByZXNldE91dGJvdW5kKCkge1xuICAgICAgICB0aGlzLm91dGJvdW5kLnJlc2V0KCk7XG4gICAgICAgIGNvbnN0IHBvbmdzID0gdGhpcy5wb25ncztcbiAgICAgICAgdGhpcy5wb25ncyA9IFtdO1xuICAgICAgICBjb25zdCBlcnIgPSBOYXRzRXJyb3IuZXJyb3JGb3JDb2RlKEVycm9yQ29kZS5EaXNjb25uZWN0KTtcbiAgICAgICAgZXJyLnN0YWNrID0gXCJcIjtcbiAgICAgICAgcG9uZ3MuZm9yRWFjaCgocCk9PntcbiAgICAgICAgICAgIHAucmVqZWN0KGVycik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBhcnNlciA9IG5ldyBQYXJzZXIodGhpcyk7XG4gICAgICAgIHRoaXMuaW5mb1JlY2VpdmVkID0gZmFsc2U7XG4gICAgfVxuICAgIGRpc3BhdGNoU3RhdHVzKHN0YXR1cykge1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKChxKT0+e1xuICAgICAgICAgICAgcS5wdXNoKHN0YXR1cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0dXMoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXIgPSBuZXcgUXVldWVkSXRlcmF0b3JJbXBsKCk7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLnB1c2goaXRlcik7XG4gICAgICAgIHJldHVybiBpdGVyO1xuICAgIH1cbiAgICBwcmVwYXJlKCkge1xuICAgICAgICBpZiAodGhpcy50cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmRpc2NhcmQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZm8gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmVzZXRPdXRib3VuZCgpO1xuICAgICAgICBjb25zdCBwb25nID0gZGVmZXJyZWQoKTtcbiAgICAgICAgcG9uZy5jYXRjaCgoKT0+e30pO1xuICAgICAgICB0aGlzLnBvbmdzLnVuc2hpZnQocG9uZyk7XG4gICAgICAgIHRoaXMuY29ubmVjdEVycm9yID0gKGVycik9PntcbiAgICAgICAgICAgIHBvbmcucmVqZWN0KGVycik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gbmV3VHJhbnNwb3J0KCk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlZCgpLnRoZW4oYXN5bmMgKF9lcnIpPT57XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmRpc2Nvbm5lY3RlZCh0aGlzLnRyYW5zcG9ydC5jbG9zZUVycm9yIHx8IHRoaXMubGFzdEVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcG9uZztcbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFN0YXR1cyh7XG4gICAgICAgICAgICB0eXBlOiBEZWJ1Z0V2ZW50cy5TdGFsZUNvbm5lY3Rpb24sXG4gICAgICAgICAgICBkYXRhOiBcIlwiXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIHJlY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoU3RhdHVzKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBEZWJ1Z0V2ZW50cy5DbGllbnRJbml0aWF0ZWRSZWNvbm5lY3QsXG4gICAgICAgICAgICAgICAgZGF0YTogXCJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBhc3luYyBkaXNjb25uZWN0ZWQoZXJyKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hTdGF0dXMoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRzLkRpc2Nvbm5lY3QsXG4gICAgICAgICAgICBkYXRhOiB0aGlzLnNlcnZlcnMuZ2V0Q3VycmVudFNlcnZlcigpLnRvU3RyaW5nKClcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVjb25uZWN0KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRpYWxMb29wKCkudGhlbigoKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hTdGF0dXMoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudHMuUmVjb25uZWN0LFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLnNlcnZlcnMuZ2V0Q3VycmVudFNlcnZlcigpLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXN0RXJyb3I/LmNvZGUgPT09IEVycm9yQ29kZS5BdXRoZW50aWNhdGlvbkV4cGlyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0RXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZShlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9jbG9zZShlcnIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRpYWwoc3J2KSB7XG4gICAgICAgIGNvbnN0IHBvbmcgPSB0aGlzLnByZXBhcmUoKTtcbiAgICAgICAgbGV0IHRpbWVyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGltZXIgPSB0aW1lb3V0KHRoaXMub3B0aW9ucy50aW1lb3V0IHx8IDIwMDAwKTtcbiAgICAgICAgICAgIGNvbnN0IGNwID0gdGhpcy50cmFuc3BvcnQuY29ubmVjdChzcnYsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgICAgIGNwLFxuICAgICAgICAgICAgICAgIHRpbWVyXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIChhc3luYyAoKT0+e1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgYiBvZiB0aGlzLnRyYW5zcG9ydCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlci5wYXJzZShiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInJlYWRlciBjbG9zZWRcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpLnRoZW4oKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBwb25nLnJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgICAgIHRpbWVyLFxuICAgICAgICAgICAgICAgIHBvbmdcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgICAgICAgdGltZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc2VuZFN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGVkT25jZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNlcnZlci5kaWRDb25uZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2VydmVyLnJlY29ubmVjdHMgPSAwO1xuICAgICAgICAgICAgdGhpcy5mbHVzaFBlbmRpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuaGVhcnRiZWF0cy5zdGFydCgpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgICAgIHRpbWVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy50cmFuc3BvcnQuY2xvc2UoZXJyKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfZG9EaWFsKHNydikge1xuICAgICAgICBjb25zdCB7IHJlc29sdmUgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgYWx0cyA9IGF3YWl0IHNydi5yZXNvbHZlKHtcbiAgICAgICAgICAgIGZuOiBnZXRSZXNvbHZlRm4oKSxcbiAgICAgICAgICAgIGRlYnVnOiB0aGlzLm9wdGlvbnMuZGVidWcsXG4gICAgICAgICAgICByYW5kb21pemU6ICF0aGlzLm9wdGlvbnMubm9SYW5kb21pemUsXG4gICAgICAgICAgICByZXNvbHZlXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbGFzdEVyciA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgYSBvZiBhbHRzKXtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGFzdEVyciA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IERlYnVnRXZlbnRzLlJlY29ubmVjdGluZyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogYS50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5kaWFsKGEpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGxhc3RFcnIgPSBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbGFzdEVycjtcbiAgICB9XG4gICAgZGlhbExvb3AoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RQcm9taXNlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RQcm9taXNlID0gdGhpcy5kb2RpYWxMb29wKCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RQcm9taXNlLnRoZW4oKCk9Pnt9KS5jYXRjaCgoKT0+e30pLmZpbmFsbHkoKCk9PntcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RQcm9taXNlO1xuICAgIH1cbiAgICBhc3luYyBkb2RpYWxMb29wKCkge1xuICAgICAgICBsZXQgbGFzdEVycm9yO1xuICAgICAgICB3aGlsZSh0cnVlKXtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlcnZlcnMuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdhaXQgPSB0aGlzLm9wdGlvbnMucmVjb25uZWN0RGVsYXlIYW5kbGVyID8gdGhpcy5vcHRpb25zLnJlY29ubmVjdERlbGF5SGFuZGxlcigpIDogREVGQVVMVF9SRUNPTk5FQ1RfVElNRV9XQUlUO1xuICAgICAgICAgICAgbGV0IG1heFdhaXQgPSB3YWl0O1xuICAgICAgICAgICAgY29uc3Qgc3J2ID0gdGhpcy5zZWxlY3RTZXJ2ZXIoKTtcbiAgICAgICAgICAgIGlmICghc3J2IHx8IHRoaXMuYWJvcnRSZWNvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGxhc3RFcnJvcjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGFzdEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMubGFzdEVycm9yO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLkNvbm5lY3Rpb25SZWZ1c2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgaWYgKHNydi5sYXN0Q29ubmVjdCA9PT0gMCB8fCBzcnYubGFzdENvbm5lY3QgKyB3YWl0IDw9IG5vdykge1xuICAgICAgICAgICAgICAgIHNydi5sYXN0Q29ubmVjdCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fZG9EaWFsKHNydik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBsYXN0RXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb25uZWN0ZWRPbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLndhaXRPbkZpcnN0Q29ubmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZXJzLnJlbW92ZUN1cnJlbnRTZXJ2ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzcnYucmVjb25uZWN0cysrO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtcmEgPSB0aGlzLm9wdGlvbnMubWF4UmVjb25uZWN0QXR0ZW1wdHMgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1yYSAhPT0gLTEgJiYgc3J2LnJlY29ubmVjdHMgPj0gbXJhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlcnZlcnMucmVtb3ZlQ3VycmVudFNlcnZlcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXhXYWl0ID0gTWF0aC5taW4obWF4V2FpdCwgc3J2Lmxhc3RDb25uZWN0ICsgd2FpdCAtIG5vdyk7XG4gICAgICAgICAgICAgICAgYXdhaXQgZGVsYXkobWF4V2FpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGNvbm5lY3Qob3B0aW9ucywgcHVibGlzaGVyKSB7XG4gICAgICAgIGNvbnN0IGggPSBuZXcgUHJvdG9jb2xIYW5kbGVyKG9wdGlvbnMsIHB1Ymxpc2hlcik7XG4gICAgICAgIGF3YWl0IGguZGlhbExvb3AoKTtcbiAgICAgICAgcmV0dXJuIGg7XG4gICAgfVxuICAgIHN0YXRpYyB0b0Vycm9yKHMpIHtcbiAgICAgICAgY29uc3QgdCA9IHMgPyBzLnRvTG93ZXJDYXNlKCkgOiBcIlwiO1xuICAgICAgICBpZiAodC5pbmRleE9mKFwicGVybWlzc2lvbnMgdmlvbGF0aW9uXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IE5hdHNFcnJvcihzLCBFcnJvckNvZGUuUGVybWlzc2lvbnNWaW9sYXRpb24pO1xuICAgICAgICAgICAgY29uc3QgbSA9IHMubWF0Y2goLyhQdWJsaXNofFN1YnNjcmlwdGlvbikgdG8gXCIoXFxTKylcIi8pO1xuICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICBlcnIucGVybWlzc2lvbkNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogbVsxXS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICBzdWJqZWN0OiBtWzJdLFxuICAgICAgICAgICAgICAgICAgICBxdWV1ZTogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBxbSA9IHMubWF0Y2goL3VzaW5nIHF1ZXVlIFwiKFxcUyspXCIvKTtcbiAgICAgICAgICAgICAgICBpZiAocW0pIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyLnBlcm1pc3Npb25Db250ZXh0LnF1ZXVlID0gcW1bMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfSBlbHNlIGlmICh0LmluZGV4T2YoXCJhdXRob3JpemF0aW9uIHZpb2xhdGlvblwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTmF0c0Vycm9yKHMsIEVycm9yQ29kZS5BdXRob3JpemF0aW9uVmlvbGF0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmICh0LmluZGV4T2YoXCJ1c2VyIGF1dGhlbnRpY2F0aW9uIGV4cGlyZWRcIikgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5hdHNFcnJvcihzLCBFcnJvckNvZGUuQXV0aGVudGljYXRpb25FeHBpcmVkKTtcbiAgICAgICAgfSBlbHNlIGlmICh0LmluZGV4T2YoXCJhY2NvdW50IGF1dGhlbnRpY2F0aW9uIGV4cGlyZWRcIikgIT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTmF0c0Vycm9yKHMsIEVycm9yQ29kZS5BY2NvdW50RXhwaXJlZCk7XG4gICAgICAgIH0gZWxzZSBpZiAodC5pbmRleE9mKFwiYXV0aGVudGljYXRpb24gdGltZW91dFwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTmF0c0Vycm9yKHMsIEVycm9yQ29kZS5BdXRoZW50aWNhdGlvblRpbWVvdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOYXRzRXJyb3IocywgRXJyb3JDb2RlLlByb3RvY29sRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NNc2cobXNnLCBkYXRhKSB7XG4gICAgICAgIHRoaXMuaW5Nc2dzKys7XG4gICAgICAgIHRoaXMuaW5CeXRlcyArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKCF0aGlzLnN1YnNjcmlwdGlvbnMuc2lkQ291bnRlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1YiA9IHRoaXMuc3Vic2NyaXB0aW9ucy5nZXQobXNnLnNpZCk7XG4gICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3ViLnJlY2VpdmVkICs9IDE7XG4gICAgICAgIGlmIChzdWIuY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHN1Yi5jYWxsYmFjayhudWxsLCBuZXcgTXNnSW1wbChtc2csIGRhdGEsIHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3ViLm1heCAhPT0gdW5kZWZpbmVkICYmIHN1Yi5yZWNlaXZlZCA+PSBzdWIubWF4KSB7XG4gICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9jZXNzRXJyb3IobSkge1xuICAgICAgICBjb25zdCBzID0gZGVjb2RlKG0pO1xuICAgICAgICBjb25zdCBlcnIgPSBQcm90b2NvbEhhbmRsZXIudG9FcnJvcihzKTtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0ge1xuICAgICAgICAgICAgdHlwZTogRXZlbnRzLkVycm9yLFxuICAgICAgICAgICAgZGF0YTogZXJyLmNvZGVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGVyci5pc1Blcm1pc3Npb25FcnJvcigpKSB7XG4gICAgICAgICAgICBsZXQgaXNNdXhQZXJtaXNzaW9uRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChlcnIucGVybWlzc2lvbkNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMucGVybWlzc2lvbkNvbnRleHQgPSBlcnIucGVybWlzc2lvbkNvbnRleHQ7XG4gICAgICAgICAgICAgICAgY29uc3QgbXV4ID0gdGhpcy5zdWJzY3JpcHRpb25zLmdldE11eCgpO1xuICAgICAgICAgICAgICAgIGlzTXV4UGVybWlzc2lvbkVycm9yID0gbXV4Py5zdWJqZWN0ID09PSBlcnIucGVybWlzc2lvbkNvbnRleHQuc3ViamVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5oYW5kbGVFcnJvcihlcnIpO1xuICAgICAgICAgICAgdGhpcy5tdXhTdWJzY3JpcHRpb25zLmhhbmRsZUVycm9yKGlzTXV4UGVybWlzc2lvbkVycm9yLCBlcnIpO1xuICAgICAgICAgICAgaWYgKGlzTXV4UGVybWlzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnNldE11eChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3BhdGNoU3RhdHVzKHN0YXR1cyk7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZXJyKTtcbiAgICB9XG4gICAgaGFuZGxlRXJyb3IoZXJyKSB7XG4gICAgICAgIGlmIChlcnIuaXNBdXRoRXJyb3IoKSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVBdXRoRXJyb3IoZXJyKTtcbiAgICAgICAgfSBlbHNlIGlmIChlcnIuaXNQcm90b2NvbEVycm9yKCkpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEVycm9yID0gZXJyO1xuICAgICAgICB9IGVsc2UgaWYgKGVyci5pc0F1dGhUaW1lb3V0KCkpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEVycm9yID0gZXJyO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXJyLmlzUGVybWlzc2lvbkVycm9yKCkpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEVycm9yID0gZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUF1dGhFcnJvcihlcnIpIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdEVycm9yICYmIGVyci5jb2RlID09PSB0aGlzLmxhc3RFcnJvci5jb2RlICYmIHRoaXMub3B0aW9ucy5pZ25vcmVBdXRoRXJyb3JBYm9ydCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuYWJvcnRSZWNvbm5lY3QgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RFcnJvcikge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0RXJyb3IoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NQaW5nKCkge1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKFBPTkdfQ01EKTtcbiAgICB9XG4gICAgcHJvY2Vzc1BvbmcoKSB7XG4gICAgICAgIGNvbnN0IGNiID0gdGhpcy5wb25ncy5zaGlmdCgpO1xuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgIGNiLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9jZXNzSW5mbyhtKSB7XG4gICAgICAgIGNvbnN0IGluZm8gPSBKU09OLnBhcnNlKGRlY29kZShtKSk7XG4gICAgICAgIHRoaXMuaW5mbyA9IGluZm87XG4gICAgICAgIGNvbnN0IHVwZGF0ZXMgPSB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmlnbm9yZUNsdXN0ZXJVcGRhdGVzID8gdW5kZWZpbmVkIDogdGhpcy5zZXJ2ZXJzLnVwZGF0ZShpbmZvLCB0aGlzLnRyYW5zcG9ydC5pc0VuY3J5cHRlZCgpKTtcbiAgICAgICAgaWYgKCF0aGlzLmluZm9SZWNlaXZlZCkge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlcy51cGRhdGUocGFyc2VTZW1WZXIoaW5mby52ZXJzaW9uKSk7XG4gICAgICAgICAgICB0aGlzLmluZm9SZWNlaXZlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy50cmFuc3BvcnQuaXNFbmNyeXB0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VydmVycy51cGRhdGVUTFNOYW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHZlcnNpb24sIGxhbmcgfSA9IHRoaXMudHJhbnNwb3J0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gbmV3IENvbm5lY3Qoe1xuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICBsYW5nXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5vcHRpb25zLCBpbmZvLm5vbmNlKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGMuaGVhZGVycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGMubm9fcmVzcG9uZGVycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNzID0gSlNPTi5zdHJpbmdpZnkoYyk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuc2VuZChlbmNvZGUoYENPTk5FQ1QgJHtjc30ke0NSX0xGfWApKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKFBJTkdfQ01EKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hTdGF0dXMoe1xuICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50cy5VcGRhdGUsXG4gICAgICAgICAgICAgICAgZGF0YTogdXBkYXRlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGRtID0gaW5mby5sZG0gIT09IHVuZGVmaW5lZCA/IGluZm8ubGRtIDogZmFsc2U7XG4gICAgICAgIGlmIChsZG0pIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hTdGF0dXMoe1xuICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50cy5MRE0sXG4gICAgICAgICAgICAgICAgZGF0YTogdGhpcy5zZXJ2ZXJzLmdldEN1cnJlbnRTZXJ2ZXIoKS50b1N0cmluZygpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdXNoKGUpIHtcbiAgICAgICAgc3dpdGNoKGUua2luZCl7XG4gICAgICAgICAgICBjYXNlIEtpbmQuTVNHOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBtc2csIGRhdGEgfSA9IGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc01zZyhtc2csIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEtpbmQuT0s6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtpbmQuRVJSOlxuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0Vycm9yKGUuZGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtpbmQuUElORzpcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NQaW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtpbmQuUE9ORzpcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NQb25nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtpbmQuSU5GTzpcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NJbmZvKGUuZGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VuZENvbW1hbmQoY21kLCAuLi5wYXlsb2Fkcykge1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLm91dGJvdW5kLmxlbmd0aCgpO1xuICAgICAgICBsZXQgYnVmO1xuICAgICAgICBpZiAodHlwZW9mIGNtZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYnVmID0gZW5jb2RlKGNtZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWYgPSBjbWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRib3VuZC5maWxsKGJ1ZiwgLi4ucGF5bG9hZHMpO1xuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hQZW5kaW5nKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm91dGJvdW5kLnNpemUoKSA+PSB0aGlzLnBlbmRpbmdMaW1pdCkge1xuICAgICAgICAgICAgdGhpcy5mbHVzaFBlbmRpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdWJsaXNoKHN1YmplY3QsIHBheWxvYWQgPSBFbXB0eSwgb3B0aW9ucykge1xuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgaWYgKHBheWxvYWQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICBkYXRhID0gcGF5bG9hZDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZGF0YSA9IFRFLmVuY29kZShwYXlsb2FkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLkJhZFBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIG9wdGlvbnMucmVwbHkgPSBvcHRpb25zLnJlcGx5IHx8IFwiXCI7XG4gICAgICAgIGxldCBoZWFkZXJzID0gRW1wdHk7XG4gICAgICAgIGxldCBobGVuID0gMDtcbiAgICAgICAgaWYgKG9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5mbyAmJiAhdGhpcy5pbmZvLmhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTmF0c0Vycm9yKFwiaGVhZGVyc1wiLCBFcnJvckNvZGUuU2VydmVyT3B0aW9uTm90QXZhaWxhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhkcnMgPSBvcHRpb25zLmhlYWRlcnM7XG4gICAgICAgICAgICBoZWFkZXJzID0gaGRycy5lbmNvZGUoKTtcbiAgICAgICAgICAgIGhsZW4gPSBoZWFkZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIGxlbiA9IGRhdGEubGVuZ3RoICsgaGxlbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmZvICYmIGxlbiA+IHRoaXMuaW5mby5tYXhfcGF5bG9hZCkge1xuICAgICAgICAgICAgdGhyb3cgTmF0c0Vycm9yLmVycm9yRm9yQ29kZShFcnJvckNvZGUuTWF4UGF5bG9hZEV4Y2VlZGVkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dEJ5dGVzICs9IGxlbjtcbiAgICAgICAgdGhpcy5vdXRNc2dzKys7XG4gICAgICAgIGxldCBwcm90bztcbiAgICAgICAgaWYgKG9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVwbHkpIHtcbiAgICAgICAgICAgICAgICBwcm90byA9IGBIUFVCICR7c3ViamVjdH0gJHtvcHRpb25zLnJlcGx5fSAke2hsZW59ICR7bGVufVxcclxcbmA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb3RvID0gYEhQVUIgJHtzdWJqZWN0fSAke2hsZW59ICR7bGVufVxcclxcbmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlbmRDb21tYW5kKHByb3RvLCBoZWFkZXJzLCBkYXRhLCBDUkxGKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnJlcGx5KSB7XG4gICAgICAgICAgICAgICAgcHJvdG8gPSBgUFVCICR7c3ViamVjdH0gJHtvcHRpb25zLnJlcGx5fSAke2xlbn1cXHJcXG5gO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm90byA9IGBQVUIgJHtzdWJqZWN0fSAke2xlbn1cXHJcXG5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZW5kQ29tbWFuZChwcm90bywgZGF0YSwgQ1JMRik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVxdWVzdChyKSB7XG4gICAgICAgIHRoaXMuaW5pdE11eCgpO1xuICAgICAgICB0aGlzLm11eFN1YnNjcmlwdGlvbnMuYWRkKHIpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgc3Vic2NyaWJlKHMpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChzKTtcbiAgICAgICAgdGhpcy5fc3VidW5zdWIocyk7XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBfc3ViKHMpIHtcbiAgICAgICAgaWYgKHMucXVldWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZENvbW1hbmQoYFNVQiAke3Muc3ViamVjdH0gJHtzLnF1ZXVlfSAke3Muc2lkfVxcclxcbmApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZW5kQ29tbWFuZChgU1VCICR7cy5zdWJqZWN0fSAke3Muc2lkfVxcclxcbmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9zdWJ1bnN1YihzKSB7XG4gICAgICAgIHRoaXMuX3N1YihzKTtcbiAgICAgICAgaWYgKHMubWF4KSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKHMsIHMubWF4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgdW5zdWJzY3JpYmUocywgbWF4KSB7XG4gICAgICAgIHRoaXMudW5zdWIocywgbWF4KTtcbiAgICAgICAgaWYgKHMubWF4ID09PSB1bmRlZmluZWQgfHwgcy5yZWNlaXZlZCA+PSBzLm1heCkge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmNhbmNlbChzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bnN1YihzLCBtYXgpIHtcbiAgICAgICAgaWYgKCFzIHx8IHRoaXMuaXNDbG9zZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXgpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZENvbW1hbmQoYFVOU1VCICR7cy5zaWR9ICR7bWF4fVxcclxcbmApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZW5kQ29tbWFuZChgVU5TVUIgJHtzLnNpZH1cXHJcXG5gKTtcbiAgICAgICAgfVxuICAgICAgICBzLm1heCA9IG1heDtcbiAgICB9XG4gICAgcmVzdWIocywgc3ViamVjdCkge1xuICAgICAgICBpZiAoIXMgfHwgdGhpcy5pc0Nsb3NlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bnN1YihzKTtcbiAgICAgICAgcy5zdWJqZWN0ID0gc3ViamVjdDtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnJlc3ViKHMpO1xuICAgICAgICB0aGlzLl9zdWIocyk7XG4gICAgfVxuICAgIGZsdXNoKHApIHtcbiAgICAgICAgaWYgKCFwKSB7XG4gICAgICAgICAgICBwID0gZGVmZXJyZWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvbmdzLnB1c2gocCk7XG4gICAgICAgIHRoaXMub3V0Ym91bmQuZmlsbChQSU5HX0NNRCk7XG4gICAgICAgIHRoaXMuZmx1c2hQZW5kaW5nKCk7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBzZW5kU3Vic2NyaXB0aW9ucygpIHtcbiAgICAgICAgY29uc3QgY21kcyA9IFtdO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWxsKCkuZm9yRWFjaCgocyk9PntcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IHM7XG4gICAgICAgICAgICBpZiAoc3ViLnF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY21kcy5wdXNoKGBTVUIgJHtzdWIuc3ViamVjdH0gJHtzdWIucXVldWV9ICR7c3ViLnNpZH0ke0NSX0xGfWApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbWRzLnB1c2goYFNVQiAke3N1Yi5zdWJqZWN0fSAke3N1Yi5zaWR9JHtDUl9MRn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjbWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuc2VuZChlbmNvZGUoY21kcy5qb2luKFwiXCIpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2Nsb3NlKGVycikge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53aHlDbG9zZWQgPSBuZXcgRXJyb3IoXCJjbG9zZSB0cmFjZVwiKS5zdGFjayB8fCBcIlwiO1xuICAgICAgICB0aGlzLmhlYXJ0YmVhdHMuY2FuY2VsKCk7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RFcnJvcikge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0RXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdEVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubXV4U3Vic2NyaXB0aW9ucy5jbG9zZSgpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaCgobCk9PntcbiAgICAgICAgICAgIGwuc3RvcCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgYXdhaXQgdGhpcy50cmFuc3BvcnQuY2xvc2UoZXJyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5jbG9zZWQucmVzb2x2ZShlcnIpO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlKCk7XG4gICAgfVxuICAgIGlzQ2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvc2VkO1xuICAgIH1cbiAgICBkcmFpbigpIHtcbiAgICAgICAgY29uc3Qgc3VicyA9IHRoaXMuc3Vic2NyaXB0aW9ucy5hbGwoKTtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgc3Vicy5mb3JFYWNoKChzdWIpPT57XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHN1Yi5kcmFpbigpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihhc3luYyAoKT0+e1xuICAgICAgICAgICAgdGhpcy5ub01vcmVQdWJsaXNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZmx1c2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH0pLmNhdGNoKCgpPT57fSk7XG4gICAgfVxuICAgIGZsdXNoUGVuZGluZygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmluZm9SZWNlaXZlZCB8fCAhdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vdXRib3VuZC5zaXplKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGQgPSB0aGlzLm91dGJvdW5kLmRyYWluKCk7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKGQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaXRNdXgoKSB7XG4gICAgICAgIGNvbnN0IG11eCA9IHRoaXMuc3Vic2NyaXB0aW9ucy5nZXRNdXgoKTtcbiAgICAgICAgaWYgKCFtdXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGluYm94ID0gdGhpcy5tdXhTdWJzY3JpcHRpb25zLmluaXQodGhpcy5vcHRpb25zLmluYm94UHJlZml4KTtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IG5ldyBTdWJzY3JpcHRpb25JbXBsKHRoaXMsIGAke2luYm94fSpgKTtcbiAgICAgICAgICAgIHN1Yi5jYWxsYmFjayA9IHRoaXMubXV4U3Vic2NyaXB0aW9ucy5kaXNwYXRjaGVyKCk7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuc2V0TXV4KHN1Yik7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZShzdWIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbGVjdFNlcnZlcigpIHtcbiAgICAgICAgY29uc3Qgc2VydmVyID0gdGhpcy5zZXJ2ZXJzLnNlbGVjdFNlcnZlcigpO1xuICAgICAgICBpZiAoc2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXJ2ZXIgPSBzZXJ2ZXI7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZlcjtcbiAgICB9XG4gICAgZ2V0U2VydmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2ZXI7XG4gICAgfVxufVxuY29uc3QgU2VydmljZUFwaVByZWZpeCA9IFwiJFNSVlwiO1xuY2xhc3MgU2VydmljZU1zZ0ltcGwge1xuICAgIG1zZztcbiAgICBjb25zdHJ1Y3Rvcihtc2cpe1xuICAgICAgICB0aGlzLm1zZyA9IG1zZztcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1zZy5kYXRhO1xuICAgIH1cbiAgICBnZXQgc2lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tc2cuc2lkO1xuICAgIH1cbiAgICBnZXQgc3ViamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXNnLnN1YmplY3Q7XG4gICAgfVxuICAgIGdldCByZXBseSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXNnLnJlcGx5IHx8IFwiXCI7XG4gICAgfVxuICAgIGdldCBoZWFkZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tc2cuaGVhZGVycztcbiAgICB9XG4gICAgcmVzcG9uZChkYXRhLCBvcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1zZy5yZXNwb25kKGRhdGEsIG9wdHMpO1xuICAgIH1cbiAgICByZXNwb25kRXJyb3IoY29kZSwgZGVzY3JpcHRpb24sIGRhdGEsIG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIG9wdHMuaGVhZGVycyA9IG9wdHMuaGVhZGVycyB8fCBoZWFkZXJzKCk7XG4gICAgICAgIG9wdHMuaGVhZGVycz8uc2V0KFNlcnZpY2VFcnJvckNvZGVIZWFkZXIsIGAke2NvZGV9YCk7XG4gICAgICAgIG9wdHMuaGVhZGVycz8uc2V0KFNlcnZpY2VFcnJvckhlYWRlciwgZGVzY3JpcHRpb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5tc2cucmVzcG9uZChkYXRhLCBvcHRzKTtcbiAgICB9XG4gICAganNvbihyZXZpdmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1zZy5qc29uKHJldml2ZXIpO1xuICAgIH1cbiAgICBzdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1zZy5zdHJpbmcoKTtcbiAgICB9XG59XG5jbGFzcyBTZXJ2aWNlR3JvdXBJbXBsIHtcbiAgICBzdWJqZWN0O1xuICAgIHF1ZXVlO1xuICAgIHNydjtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIG5hbWUgPSBcIlwiLCBxdWV1ZSA9IFwiXCIpe1xuICAgICAgICBpZiAobmFtZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgdmFsaWRJbnRlcm5hbFRva2VuKFwic2VydmljZSBncm91cFwiLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcm9vdCA9IFwiXCI7XG4gICAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBTZXJ2aWNlSW1wbCkge1xuICAgICAgICAgICAgdGhpcy5zcnYgPSBwYXJlbnQ7XG4gICAgICAgICAgICByb290ID0gXCJcIjtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBTZXJ2aWNlR3JvdXBJbXBsKSB7XG4gICAgICAgICAgICBjb25zdCBzZyA9IHBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuc3J2ID0gc2cuc3J2O1xuICAgICAgICAgICAgaWYgKHF1ZXVlID09PSBcIlwiICYmIHNnLnF1ZXVlICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgcXVldWUgPSBzZy5xdWV1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvb3QgPSBzZy5zdWJqZWN0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBTZXJ2aWNlR3JvdXAgdHlwZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1YmplY3QgPSB0aGlzLmNhbGNTdWJqZWN0KHJvb3QsIG5hbWUpO1xuICAgICAgICB0aGlzLnF1ZXVlID0gcXVldWU7XG4gICAgfVxuICAgIGNhbGNTdWJqZWN0KHJvb3QsIG5hbWUgPSBcIlwiKSB7XG4gICAgICAgIGlmIChuYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9vdCAhPT0gXCJcIiA/IGAke3Jvb3R9LiR7bmFtZX1gIDogbmFtZTtcbiAgICB9XG4gICAgYWRkRW5kcG9pbnQobmFtZSA9IFwiXCIsIG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge1xuICAgICAgICAgICAgc3ViamVjdDogbmFtZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhcmdzID0gdHlwZW9mIG9wdHMgPT09IFwiZnVuY3Rpb25cIiA/IHtcbiAgICAgICAgICAgIGhhbmRsZXI6IG9wdHMsXG4gICAgICAgICAgICBzdWJqZWN0OiBuYW1lXG4gICAgICAgIH0gOiBvcHRzO1xuICAgICAgICB2YWxpZGF0ZU5hbWUoXCJlbmRwb2ludFwiLCBuYW1lKTtcbiAgICAgICAgbGV0IHsgc3ViamVjdCwgaGFuZGxlciwgbWV0YWRhdGEsIHF1ZXVlIH0gPSBhcmdzO1xuICAgICAgICBzdWJqZWN0ID0gc3ViamVjdCB8fCBuYW1lO1xuICAgICAgICBxdWV1ZSA9IHF1ZXVlIHx8IHRoaXMucXVldWU7XG4gICAgICAgIHZhbGlkU3ViamVjdE5hbWUoXCJlbmRwb2ludCBzdWJqZWN0XCIsIHN1YmplY3QpO1xuICAgICAgICBzdWJqZWN0ID0gdGhpcy5jYWxjU3ViamVjdCh0aGlzLnN1YmplY3QsIHN1YmplY3QpO1xuICAgICAgICBjb25zdCBuZSA9IHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBzdWJqZWN0LFxuICAgICAgICAgICAgcXVldWUsXG4gICAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgICAgbWV0YWRhdGFcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3J2Ll9hZGRFbmRwb2ludChuZSk7XG4gICAgfVxuICAgIGFkZEdyb3VwKG5hbWUgPSBcIlwiLCBxdWV1ZSA9IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXJ2aWNlR3JvdXBJbXBsKHRoaXMsIG5hbWUsIHF1ZXVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZFN1YmplY3ROYW1lKGNvbnRleHQsIHN1YmopIHtcbiAgICBpZiAoc3ViaiA9PT0gXCJcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29udGV4dH0gY2Fubm90IGJlIGVtcHR5YCk7XG4gICAgfVxuICAgIGlmIChzdWJqLmluZGV4T2YoXCIgXCIpICE9PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29udGV4dH0gY2Fubm90IGNvbnRhaW4gc3BhY2VzOiAnJHtzdWJqfSdgKTtcbiAgICB9XG4gICAgY29uc3QgdG9rZW5zID0gc3Viai5zcGxpdChcIi5cIik7XG4gICAgdG9rZW5zLmZvckVhY2goKHYsIGlkeCk9PntcbiAgICAgICAgaWYgKHYgPT09IFwiPlwiICYmIGlkeCAhPT0gdG9rZW5zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0fSBjYW5ub3QgaGF2ZSBpbnRlcm5hbCAnPic6ICcke3N1Ymp9J2ApO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiB2YWxpZEludGVybmFsVG9rZW4oY29udGV4dCwgc3Viaikge1xuICAgIGlmIChzdWJqLmluZGV4T2YoXCIgXCIpICE9PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29udGV4dH0gY2Fubm90IGNvbnRhaW4gc3BhY2VzOiAnJHtzdWJqfSdgKTtcbiAgICB9XG4gICAgY29uc3QgdG9rZW5zID0gc3Viai5zcGxpdChcIi5cIik7XG4gICAgdG9rZW5zLmZvckVhY2goKHYpPT57XG4gICAgICAgIGlmICh2ID09PSBcIj5cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnRleHR9IG5hbWUgY2Fubm90IGNvbnRhaW4gaW50ZXJuYWwgJz4nOiAnJHtzdWJqfSdgKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuY2xhc3MgU2VydmljZUltcGwge1xuICAgIG5jO1xuICAgIF9pZDtcbiAgICBjb25maWc7XG4gICAgaGFuZGxlcnM7XG4gICAgaW50ZXJuYWw7XG4gICAgX3N0b3BwZWQ7XG4gICAgX2RvbmU7XG4gICAgc3RhcnRlZDtcbiAgICBzdGF0aWMgY29udHJvbFN1YmplY3QodmVyYiwgbmFtZSA9IFwiXCIsIGlkID0gXCJcIiwgcHJlZml4KSB7XG4gICAgICAgIGNvbnN0IHByZSA9IHByZWZpeCA/PyBTZXJ2aWNlQXBpUHJlZml4O1xuICAgICAgICBpZiAobmFtZSA9PT0gXCJcIiAmJiBpZCA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIGAke3ByZX0uJHt2ZXJifWA7XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGVOYW1lKFwiY29udHJvbCBzdWJqZWN0IG5hbWVcIiwgbmFtZSk7XG4gICAgICAgIGlmIChpZCAhPT0gXCJcIikge1xuICAgICAgICAgICAgdmFsaWRhdGVOYW1lKFwiY29udHJvbCBzdWJqZWN0IGlkXCIsIGlkKTtcbiAgICAgICAgICAgIHJldHVybiBgJHtwcmV9LiR7dmVyYn0uJHtuYW1lfS4ke2lkfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3ByZX0uJHt2ZXJifS4ke25hbWV9YDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobmMsIGNvbmZpZyA9IHtcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdmVyc2lvbjogXCJcIlxuICAgIH0pe1xuICAgICAgICB0aGlzLm5jID0gbmM7XG4gICAgICAgIHRoaXMuY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKTtcbiAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy5xdWV1ZSkge1xuICAgICAgICAgICAgdGhpcy5jb25maWcucXVldWUgPSBcInFcIjtcbiAgICAgICAgfVxuICAgICAgICB2YWxpZGF0ZU5hbWUoXCJuYW1lXCIsIHRoaXMuY29uZmlnLm5hbWUpO1xuICAgICAgICB2YWxpZGF0ZU5hbWUoXCJxdWV1ZVwiLCB0aGlzLmNvbmZpZy5xdWV1ZSk7XG4gICAgICAgIHBhcnNlU2VtVmVyKHRoaXMuY29uZmlnLnZlcnNpb24pO1xuICAgICAgICB0aGlzLl9pZCA9IG51aWQubmV4dCgpO1xuICAgICAgICB0aGlzLmludGVybmFsID0gW107XG4gICAgICAgIHRoaXMuX2RvbmUgPSBkZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMubmMuY2xvc2VkKCkudGhlbigoKT0+e1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpLmNhdGNoKCk7XG4gICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICB0aGlzLmNsb3NlKGVycikuY2F0Y2goKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBzdWJqZWN0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlcnMuZmlsdGVyKChzKT0+e1xuICAgICAgICAgICAgcmV0dXJuIHMuaW50ZXJuYWwgPT09IGZhbHNlO1xuICAgICAgICB9KS5tYXAoKHMpPT57XG4gICAgICAgICAgICByZXR1cm4gcy5zdWJqZWN0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faWQ7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcubmFtZTtcbiAgICB9XG4gICAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcuZGVzY3JpcHRpb24gPz8gXCJcIjtcbiAgICB9XG4gICAgZ2V0IHZlcnNpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy52ZXJzaW9uO1xuICAgIH1cbiAgICBnZXQgbWV0YWRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5tZXRhZGF0YTtcbiAgICB9XG4gICAgZXJyb3JUb0hlYWRlcihlcnIpIHtcbiAgICAgICAgY29uc3QgaCA9IGhlYWRlcnMoKTtcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFNlcnZpY2VFcnJvcikge1xuICAgICAgICAgICAgY29uc3Qgc2UgPSBlcnI7XG4gICAgICAgICAgICBoLnNldChTZXJ2aWNlRXJyb3JIZWFkZXIsIHNlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgaC5zZXQoU2VydmljZUVycm9yQ29kZUhlYWRlciwgYCR7c2UuY29kZX1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGguc2V0KFNlcnZpY2VFcnJvckhlYWRlciwgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgaC5zZXQoU2VydmljZUVycm9yQ29kZUhlYWRlciwgXCI1MDBcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGg7XG4gICAgfVxuICAgIHNldHVwSGFuZGxlcihoLCBpbnRlcm5hbCA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gaW50ZXJuYWwgPyBcIlwiIDogaC5xdWV1ZSA/IGgucXVldWUgOiB0aGlzLmNvbmZpZy5xdWV1ZTtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBzdWJqZWN0LCBoYW5kbGVyIH0gPSBoO1xuICAgICAgICBjb25zdCBzdiA9IGg7XG4gICAgICAgIHN2LmludGVybmFsID0gaW50ZXJuYWw7XG4gICAgICAgIGlmIChpbnRlcm5hbCkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbC5wdXNoKHN2KTtcbiAgICAgICAgfVxuICAgICAgICBzdi5zdGF0cyA9IG5ldyBOYW1lZEVuZHBvaW50U3RhdHNJbXBsKG5hbWUsIHN1YmplY3QsIHF1ZXVlKTtcbiAgICAgICAgc3YucXVldWUgPSBxdWV1ZTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBoYW5kbGVyID8gKGVyciwgbXNnKT0+e1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIoZXJyLCBuZXcgU2VydmljZU1zZ0ltcGwobXNnKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBzdi5zdGF0cy5jb3VudEVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgbXNnPy5yZXNwb25kKEVtcHR5LCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuZXJyb3JUb0hlYWRlcihlcnIpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICAgICAgc3Yuc3RhdHMuY291bnRMYXRlbmN5KHN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgc3Yuc3ViID0gdGhpcy5uYy5zdWJzY3JpYmUoc3ViamVjdCwge1xuICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICBxdWV1ZVxuICAgICAgICB9KTtcbiAgICAgICAgc3Yuc3ViLmNsb3NlZC50aGVuKCgpPT57XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKG5ldyBFcnJvcihgcmVxdWlyZWQgc3Vic2NyaXB0aW9uICR7aC5zdWJqZWN0fSBzdG9wcGVkYCkpLmNhdGNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZSA9IG5ldyBFcnJvcihgcmVxdWlyZWQgc3Vic2NyaXB0aW9uICR7aC5zdWJqZWN0fSBlcnJvcmVkOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgIG5lLnN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UobmUpLmNhdGNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3Y7XG4gICAgfVxuICAgIGluZm8oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTZXJ2aWNlUmVzcG9uc2VUeXBlLklORk8sXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIHZlcnNpb246IHRoaXMudmVyc2lvbixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHRoaXMubWV0YWRhdGEsXG4gICAgICAgICAgICBlbmRwb2ludHM6IHRoaXMuZW5kcG9pbnRzKClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZW5kcG9pbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVycy5tYXAoKHYpPT57XG4gICAgICAgICAgICBjb25zdCB7IHN1YmplY3QsIG1ldGFkYXRhLCBuYW1lLCBxdWV1ZSB9ID0gdjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3ViamVjdCxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHF1ZXVlX2dyb3VwOiBxdWV1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHN0YXRzKCkge1xuICAgICAgICBjb25zdCBlbmRwb2ludHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBoIG9mIHRoaXMuaGFuZGxlcnMpe1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNvbmZpZy5zdGF0c0hhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGguc3RhdHMuZGF0YSA9IGF3YWl0IHRoaXMuY29uZmlnLnN0YXRzSGFuZGxlcihoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaC5zdGF0cy5jb3VudEVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kcG9pbnRzLnB1c2goaC5zdGF0cy5zdGF0cyhoLnFpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFNlcnZpY2VSZXNwb25zZVR5cGUuU1RBVFMsXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIHZlcnNpb246IHRoaXMudmVyc2lvbixcbiAgICAgICAgICAgIHN0YXJ0ZWQ6IHRoaXMuc3RhcnRlZCxcbiAgICAgICAgICAgIG1ldGFkYXRhOiB0aGlzLm1ldGFkYXRhLFxuICAgICAgICAgICAgZW5kcG9pbnRzXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFkZEludGVybmFsSGFuZGxlcih2ZXJiLCBoYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IHYgPSBgJHt2ZXJifWAudG9VcHBlckNhc2UoKTtcbiAgICAgICAgdGhpcy5fZG9BZGRJbnRlcm5hbEhhbmRsZXIoYCR7dn0tYWxsYCwgdmVyYiwgaGFuZGxlcik7XG4gICAgICAgIHRoaXMuX2RvQWRkSW50ZXJuYWxIYW5kbGVyKGAke3Z9LWtpbmRgLCB2ZXJiLCBoYW5kbGVyLCB0aGlzLm5hbWUpO1xuICAgICAgICB0aGlzLl9kb0FkZEludGVybmFsSGFuZGxlcihgJHt2fWAsIHZlcmIsIGhhbmRsZXIsIHRoaXMubmFtZSwgdGhpcy5pZCk7XG4gICAgfVxuICAgIF9kb0FkZEludGVybmFsSGFuZGxlcihuYW1lLCB2ZXJiLCBoYW5kbGVyLCBraW5kID0gXCJcIiwgaWQgPSBcIlwiKSB7XG4gICAgICAgIGNvbnN0IGVuZHBvaW50ID0ge307XG4gICAgICAgIGVuZHBvaW50Lm5hbWUgPSBuYW1lO1xuICAgICAgICBlbmRwb2ludC5zdWJqZWN0ID0gU2VydmljZUltcGwuY29udHJvbFN1YmplY3QodmVyYiwga2luZCwgaWQpO1xuICAgICAgICBlbmRwb2ludC5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgdGhpcy5zZXR1cEhhbmRsZXIoZW5kcG9pbnQsIHRydWUpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgY29uc3QgamMgPSBKU09OQ29kZWMoKTtcbiAgICAgICAgY29uc3Qgc3RhdHNIYW5kbGVyID0gKGVyciwgbXNnKT0+e1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRzKCkudGhlbigocyk9PntcbiAgICAgICAgICAgICAgICBtc2c/LnJlc3BvbmQoamMuZW5jb2RlKHMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaW5mb0hhbmRsZXIgPSAoZXJyLCBtc2cpPT57XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZShlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbXNnPy5yZXNwb25kKGpjLmVuY29kZSh0aGlzLmluZm8oKSkpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwaW5nID0gamMuZW5jb2RlKHRoaXMucGluZygpKTtcbiAgICAgICAgY29uc3QgcGluZ0hhbmRsZXIgPSAoZXJyLCBtc2cpPT57XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZShlcnIpLnRoZW4oKS5jYXRjaCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbXNnLnJlc3BvbmQocGluZyk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkSW50ZXJuYWxIYW5kbGVyKFNlcnZpY2VWZXJiLlBJTkcsIHBpbmdIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5hZGRJbnRlcm5hbEhhbmRsZXIoU2VydmljZVZlcmIuU1RBVFMsIHN0YXRzSGFuZGxlcik7XG4gICAgICAgIHRoaXMuYWRkSW50ZXJuYWxIYW5kbGVyKFNlcnZpY2VWZXJiLklORk8sIGluZm9IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5oYW5kbGVycy5mb3JFYWNoKChoKT0+e1xuICAgICAgICAgICAgY29uc3QgeyBzdWJqZWN0IH0gPSBoO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdWJqZWN0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGguaGFuZGxlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0dXBIYW5kbGVyKGgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzKTtcbiAgICB9XG4gICAgY2xvc2UoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdG9wcGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZG9uZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgbGV0IGJ1ZiA9IFtdO1xuICAgICAgICBpZiAoIXRoaXMubmMuaXNDbG9zZWQoKSkge1xuICAgICAgICAgICAgYnVmID0gdGhpcy5oYW5kbGVycy5jb25jYXQodGhpcy5pbnRlcm5hbCkubWFwKChoKT0+e1xuICAgICAgICAgICAgICAgIHJldHVybiBoLnN1Yi5kcmFpbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgUHJvbWlzZS5hbGxTZXR0bGVkKGJ1ZikudGhlbigoKT0+e1xuICAgICAgICAgICAgdGhpcy5fZG9uZS5yZXNvbHZlKGVyciA/IGVyciA6IG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvbmU7XG4gICAgfVxuICAgIGdldCBzdG9wcGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZG9uZTtcbiAgICB9XG4gICAgZ2V0IGlzU3RvcHBlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQ7XG4gICAgfVxuICAgIHN0b3AoZXJyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlKGVycik7XG4gICAgfVxuICAgIHBpbmcoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTZXJ2aWNlUmVzcG9uc2VUeXBlLlBJTkcsXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIHZlcnNpb246IHRoaXMudmVyc2lvbixcbiAgICAgICAgICAgIG1ldGFkYXRhOiB0aGlzLm1ldGFkYXRhXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIGlmICh0aGlzLmhhbmRsZXJzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGggb2YgdGhpcy5oYW5kbGVycyl7XG4gICAgICAgICAgICAgICAgaC5zdGF0cy5yZXNldChoLnFpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRHcm91cChuYW1lLCBxdWV1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFNlcnZpY2VHcm91cEltcGwodGhpcywgbmFtZSwgcXVldWUpO1xuICAgIH1cbiAgICBhZGRFbmRwb2ludChuYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IHNnID0gbmV3IFNlcnZpY2VHcm91cEltcGwodGhpcyk7XG4gICAgICAgIHJldHVybiBzZy5hZGRFbmRwb2ludChuYW1lLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgX2FkZEVuZHBvaW50KGUpIHtcbiAgICAgICAgY29uc3QgcWkgPSBuZXcgUXVldWVkSXRlcmF0b3JJbXBsKCk7XG4gICAgICAgIHFpLm5vSXRlcmF0b3IgPSB0eXBlb2YgZS5oYW5kbGVyID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgIGlmICghcWkubm9JdGVyYXRvcikge1xuICAgICAgICAgICAgZS5oYW5kbGVyID0gKGVyciwgbXNnKT0+e1xuICAgICAgICAgICAgICAgIGVyciA/IHRoaXMuc3RvcChlcnIpLmNhdGNoKCkgOiBxaS5wdXNoKG5ldyBTZXJ2aWNlTXNnSW1wbChtc2cpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBxaS5pdGVyQ2xvc2VkLnRoZW4oKCk9PntcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCkuY2F0Y2goKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNzID0gdGhpcy5zZXR1cEhhbmRsZXIoZSwgZmFsc2UpO1xuICAgICAgICBzcy5xaSA9IHFpO1xuICAgICAgICB0aGlzLmhhbmRsZXJzLnB1c2goc3MpO1xuICAgICAgICByZXR1cm4gcWk7XG4gICAgfVxufVxuY2xhc3MgTmFtZWRFbmRwb2ludFN0YXRzSW1wbCB7XG4gICAgbmFtZTtcbiAgICBzdWJqZWN0O1xuICAgIGF2ZXJhZ2VfcHJvY2Vzc2luZ190aW1lO1xuICAgIG51bV9yZXF1ZXN0cztcbiAgICBwcm9jZXNzaW5nX3RpbWU7XG4gICAgbnVtX2Vycm9ycztcbiAgICBsYXN0X2Vycm9yO1xuICAgIGRhdGE7XG4gICAgbWV0YWRhdGE7XG4gICAgcXVldWU7XG4gICAgY29uc3RydWN0b3IobmFtZSwgc3ViamVjdCwgcXVldWUgPSBcIlwiKXtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zdWJqZWN0ID0gc3ViamVjdDtcbiAgICAgICAgdGhpcy5hdmVyYWdlX3Byb2Nlc3NpbmdfdGltZSA9IDA7XG4gICAgICAgIHRoaXMubnVtX2Vycm9ycyA9IDA7XG4gICAgICAgIHRoaXMubnVtX3JlcXVlc3RzID0gMDtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nX3RpbWUgPSAwO1xuICAgICAgICB0aGlzLnF1ZXVlID0gcXVldWU7XG4gICAgfVxuICAgIHJlc2V0KHFpKSB7XG4gICAgICAgIHRoaXMubnVtX3JlcXVlc3RzID0gMDtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nX3RpbWUgPSAwO1xuICAgICAgICB0aGlzLmF2ZXJhZ2VfcHJvY2Vzc2luZ190aW1lID0gMDtcbiAgICAgICAgdGhpcy5udW1fZXJyb3JzID0gMDtcbiAgICAgICAgdGhpcy5sYXN0X2Vycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHFpaSA9IHFpO1xuICAgICAgICBpZiAocWlpKSB7XG4gICAgICAgICAgICBxaWkudGltZSA9IDA7XG4gICAgICAgICAgICBxaWkucHJvY2Vzc2VkID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb3VudExhdGVuY3koc3RhcnQpIHtcbiAgICAgICAgdGhpcy5udW1fcmVxdWVzdHMrKztcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nX3RpbWUgKz0gbmFub3MoRGF0ZS5ub3coKSAtIHN0YXJ0KTtcbiAgICAgICAgdGhpcy5hdmVyYWdlX3Byb2Nlc3NpbmdfdGltZSA9IE1hdGgucm91bmQodGhpcy5wcm9jZXNzaW5nX3RpbWUgLyB0aGlzLm51bV9yZXF1ZXN0cyk7XG4gICAgfVxuICAgIGNvdW50RXJyb3IoZXJyKSB7XG4gICAgICAgIHRoaXMubnVtX2Vycm9ycysrO1xuICAgICAgICB0aGlzLmxhc3RfZXJyb3IgPSBlcnIubWVzc2FnZTtcbiAgICB9XG4gICAgX3N0YXRzKCkge1xuICAgICAgICBjb25zdCB7IG5hbWUsIHN1YmplY3QsIGF2ZXJhZ2VfcHJvY2Vzc2luZ190aW1lLCBudW1fZXJyb3JzLCBudW1fcmVxdWVzdHMsIHByb2Nlc3NpbmdfdGltZSwgbGFzdF9lcnJvciwgZGF0YSwgcXVldWUgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgc3ViamVjdCxcbiAgICAgICAgICAgIGF2ZXJhZ2VfcHJvY2Vzc2luZ190aW1lLFxuICAgICAgICAgICAgbnVtX2Vycm9ycyxcbiAgICAgICAgICAgIG51bV9yZXF1ZXN0cyxcbiAgICAgICAgICAgIHByb2Nlc3NpbmdfdGltZSxcbiAgICAgICAgICAgIGxhc3RfZXJyb3IsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcXVldWVfZ3JvdXA6IHF1ZXVlXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRzKHFpKSB7XG4gICAgICAgIGNvbnN0IHFpaSA9IHFpO1xuICAgICAgICBpZiAocWlpPy5ub0l0ZXJhdG9yID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nX3RpbWUgPSBuYW5vcyhxaWkudGltZSk7XG4gICAgICAgICAgICB0aGlzLm51bV9yZXF1ZXN0cyA9IHFpaS5wcm9jZXNzZWQ7XG4gICAgICAgICAgICB0aGlzLmF2ZXJhZ2VfcHJvY2Vzc2luZ190aW1lID0gdGhpcy5wcm9jZXNzaW5nX3RpbWUgPiAwICYmIHRoaXMubnVtX3JlcXVlc3RzID4gMCA/IHRoaXMucHJvY2Vzc2luZ190aW1lIC8gdGhpcy5udW1fcmVxdWVzdHMgOiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0cygpO1xuICAgIH1cbn1cbmNsYXNzIFNlcnZpY2VDbGllbnRJbXBsIHtcbiAgICBuYztcbiAgICBwcmVmaXg7XG4gICAgb3B0cztcbiAgICBjb25zdHJ1Y3RvcihuYywgb3B0cyA9IHtcbiAgICAgICAgc3RyYXRlZ3k6IFJlcXVlc3RTdHJhdGVneS5KaXR0ZXJUaW1lcixcbiAgICAgICAgbWF4V2FpdDogMjAwMFxuICAgIH0sIHByZWZpeCl7XG4gICAgICAgIHRoaXMubmMgPSBuYztcbiAgICAgICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgfVxuICAgIHBpbmcobmFtZSA9IFwiXCIsIGlkID0gXCJcIikge1xuICAgICAgICByZXR1cm4gdGhpcy5xKFNlcnZpY2VWZXJiLlBJTkcsIG5hbWUsIGlkKTtcbiAgICB9XG4gICAgc3RhdHMobmFtZSA9IFwiXCIsIGlkID0gXCJcIikge1xuICAgICAgICByZXR1cm4gdGhpcy5xKFNlcnZpY2VWZXJiLlNUQVRTLCBuYW1lLCBpZCk7XG4gICAgfVxuICAgIGluZm8obmFtZSA9IFwiXCIsIGlkID0gXCJcIikge1xuICAgICAgICByZXR1cm4gdGhpcy5xKFNlcnZpY2VWZXJiLklORk8sIG5hbWUsIGlkKTtcbiAgICB9XG4gICAgYXN5bmMgcSh2LCBuYW1lID0gXCJcIiwgaWQgPSBcIlwiKSB7XG4gICAgICAgIGNvbnN0IGl0ZXIgPSBuZXcgUXVldWVkSXRlcmF0b3JJbXBsKCk7XG4gICAgICAgIGNvbnN0IGpjID0gSlNPTkNvZGVjKCk7XG4gICAgICAgIGNvbnN0IHN1YmogPSBTZXJ2aWNlSW1wbC5jb250cm9sU3ViamVjdCh2LCBuYW1lLCBpZCwgdGhpcy5wcmVmaXgpO1xuICAgICAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCB0aGlzLm5jLnJlcXVlc3RNYW55KHN1YmosIEVtcHR5LCB0aGlzLm9wdHMpO1xuICAgICAgICAoYXN5bmMgKCk9PntcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgbSBvZiByZXNwb25zZXMpe1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBqYy5kZWNvZGUobS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgaXRlci5wdXNoKHMpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpdGVyLnB1c2goKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXIuc3RvcChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVyLnB1c2goKCk9PntcbiAgICAgICAgICAgICAgICBpdGVyLnN0b3AoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSgpLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICBpdGVyLnN0b3AoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpdGVyO1xuICAgIH1cbn1cbmNsYXNzIE1ldHJpYyB7XG4gICAgbmFtZTtcbiAgICBkdXJhdGlvbjtcbiAgICBkYXRlO1xuICAgIHBheWxvYWQ7XG4gICAgbXNncztcbiAgICBsYW5nO1xuICAgIHZlcnNpb247XG4gICAgYnl0ZXM7XG4gICAgYXN5bmNSZXF1ZXN0cztcbiAgICBtaW47XG4gICAgbWF4O1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGR1cmF0aW9uKXtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICB0aGlzLmRhdGUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnBheWxvYWQgPSAwO1xuICAgICAgICB0aGlzLm1zZ3MgPSAwO1xuICAgICAgICB0aGlzLmJ5dGVzID0gMDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IHNlYyA9IHRoaXMuZHVyYXRpb24gLyAxMDAwO1xuICAgICAgICBjb25zdCBtcHMgPSBNYXRoLnJvdW5kKHRoaXMubXNncyAvIHNlYyk7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gdGhpcy5hc3luY1JlcXVlc3RzID8gXCJhc3luY1JlcXVlc3RzXCIgOiBcIlwiO1xuICAgICAgICBsZXQgbWlubWF4ID0gXCJcIjtcbiAgICAgICAgaWYgKHRoaXMubWF4KSB7XG4gICAgICAgICAgICBtaW5tYXggPSBgJHt0aGlzLm1pbn0vJHt0aGlzLm1heH1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt0aGlzLm5hbWV9JHtsYWJlbCA/IFwiIFthc3luY1JlcXVlc3RzXVwiIDogXCJcIn0gJHtodW1hbml6ZU51bWJlcihtcHMpfSBtc2dzL3NlYyAtIFske3NlYy50b0ZpeGVkKDIpfSBzZWNzXSB+ICR7dGhyb3VnaHB1dCh0aGlzLmJ5dGVzLCBzZWMpfSAke21pbm1heH1gO1xuICAgIH1cbiAgICB0b0NzdigpIHtcbiAgICAgICAgcmV0dXJuIGBcIiR7dGhpcy5uYW1lfVwiLCR7bmV3IERhdGUodGhpcy5kYXRlKS50b0lTT1N0cmluZygpfSwke3RoaXMubGFuZ30sJHt0aGlzLnZlcnNpb259LCR7dGhpcy5tc2dzfSwke3RoaXMucGF5bG9hZH0sJHt0aGlzLmJ5dGVzfSwke3RoaXMuZHVyYXRpb259LCR7dGhpcy5hc3luY1JlcXVlc3RzID8gdGhpcy5hc3luY1JlcXVlc3RzIDogZmFsc2V9XFxuYDtcbiAgICB9XG4gICAgc3RhdGljIGhlYWRlcigpIHtcbiAgICAgICAgcmV0dXJuIGBUZXN0LERhdGUsTGFuZyxWZXJzaW9uLENvdW50LE1zZ1BheWxvYWQsQnl0ZXMsTWlsbGlzLEFzeW5jXFxuYDtcbiAgICB9XG59XG5jbGFzcyBCZW5jaCB7XG4gICAgbmM7XG4gICAgY2FsbGJhY2tzO1xuICAgIG1zZ3M7XG4gICAgc2l6ZTtcbiAgICBzdWJqZWN0O1xuICAgIGFzeW5jUmVxdWVzdHM7XG4gICAgcHViO1xuICAgIHN1YjtcbiAgICByZXE7XG4gICAgcmVwO1xuICAgIHBlcmY7XG4gICAgcGF5bG9hZDtcbiAgICBjb25zdHJ1Y3RvcihuYywgb3B0cyA9IHtcbiAgICAgICAgbXNnczogMTAwMDAwLFxuICAgICAgICBzaXplOiAxMjgsXG4gICAgICAgIHN1YmplY3Q6IFwiXCIsXG4gICAgICAgIGFzeW5jUmVxdWVzdHM6IGZhbHNlLFxuICAgICAgICBwdWI6IGZhbHNlLFxuICAgICAgICBzdWI6IGZhbHNlLFxuICAgICAgICByZXE6IGZhbHNlLFxuICAgICAgICByZXA6IGZhbHNlXG4gICAgfSl7XG4gICAgICAgIHRoaXMubmMgPSBuYztcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSBvcHRzLmNhbGxiYWNrcyB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5tc2dzID0gb3B0cy5tc2dzIHx8IDA7XG4gICAgICAgIHRoaXMuc2l6ZSA9IG9wdHMuc2l6ZSB8fCAwO1xuICAgICAgICB0aGlzLnN1YmplY3QgPSBvcHRzLnN1YmplY3QgfHwgbnVpZC5uZXh0KCk7XG4gICAgICAgIHRoaXMuYXN5bmNSZXF1ZXN0cyA9IG9wdHMuYXN5bmNSZXF1ZXN0cyB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5wdWIgPSBvcHRzLnB1YiB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5zdWIgPSBvcHRzLnN1YiB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXEgPSBvcHRzLnJlcSB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXAgPSBvcHRzLnJlcCB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5wZXJmID0gbmV3IFBlcmYoKTtcbiAgICAgICAgdGhpcy5wYXlsb2FkID0gdGhpcy5zaXplID8gbmV3IFVpbnQ4QXJyYXkodGhpcy5zaXplKSA6IEVtcHR5O1xuICAgICAgICBpZiAoIXRoaXMucHViICYmICF0aGlzLnN1YiAmJiAhdGhpcy5yZXEgJiYgIXRoaXMucmVwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBiZW5jaCBvcHRpb24gc2VsZWN0ZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcnVuKCkge1xuICAgICAgICB0aGlzLm5jLmNsb3NlZCgpLnRoZW4oKGVycik9PntcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTmF0c0Vycm9yKGBiZW5jaCBjbG9zZWQgd2l0aCBhbiBlcnJvcjogJHtlcnIubWVzc2FnZX1gLCBFcnJvckNvZGUuVW5rbm93biwgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmNhbGxiYWNrcykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5ydW5DYWxsYmFja3MoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucnVuQXN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzTWV0cmljcygpO1xuICAgIH1cbiAgICBwcm9jZXNzTWV0cmljcygpIHtcbiAgICAgICAgY29uc3QgbmMgPSB0aGlzLm5jO1xuICAgICAgICBjb25zdCB7IGxhbmcsIHZlcnNpb24gfSA9IG5jLnByb3RvY29sLnRyYW5zcG9ydDtcbiAgICAgICAgaWYgKHRoaXMucHViICYmIHRoaXMuc3ViKSB7XG4gICAgICAgICAgICB0aGlzLnBlcmYubWVhc3VyZShcInB1YnN1YlwiLCBcInB1YlN0YXJ0XCIsIFwic3ViU3RvcFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXEgJiYgdGhpcy5yZXApIHtcbiAgICAgICAgICAgIHRoaXMucGVyZi5tZWFzdXJlKFwicmVxcmVwXCIsIFwicmVxU3RhcnRcIiwgXCJyZXFTdG9wXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lYXN1cmVzID0gdGhpcy5wZXJmLmdldEVudHJpZXMoKTtcbiAgICAgICAgY29uc3QgcHVic3ViID0gbWVhc3VyZXMuZmluZCgobSk9Pm0ubmFtZSA9PT0gXCJwdWJzdWJcIik7XG4gICAgICAgIGNvbnN0IHJlcXJlcCA9IG1lYXN1cmVzLmZpbmQoKG0pPT5tLm5hbWUgPT09IFwicmVxcmVwXCIpO1xuICAgICAgICBjb25zdCByZXEgPSBtZWFzdXJlcy5maW5kKChtKT0+bS5uYW1lID09PSBcInJlcVwiKTtcbiAgICAgICAgY29uc3QgcmVwID0gbWVhc3VyZXMuZmluZCgobSk9Pm0ubmFtZSA9PT0gXCJyZXBcIik7XG4gICAgICAgIGNvbnN0IHB1YiA9IG1lYXN1cmVzLmZpbmQoKG0pPT5tLm5hbWUgPT09IFwicHViXCIpO1xuICAgICAgICBjb25zdCBzdWIgPSBtZWFzdXJlcy5maW5kKChtKT0+bS5uYW1lID09PSBcInN1YlwiKTtcbiAgICAgICAgY29uc3Qgc3RhdHMgPSB0aGlzLm5jLnN0YXRzKCk7XG4gICAgICAgIGNvbnN0IG1ldHJpY3MgPSBbXTtcbiAgICAgICAgaWYgKHB1YnN1Yikge1xuICAgICAgICAgICAgY29uc3QgeyBuYW1lLCBkdXJhdGlvbiB9ID0gcHVic3ViO1xuICAgICAgICAgICAgY29uc3QgbSA9IG5ldyBNZXRyaWMobmFtZSwgZHVyYXRpb24pO1xuICAgICAgICAgICAgbS5tc2dzID0gdGhpcy5tc2dzICogMjtcbiAgICAgICAgICAgIG0uYnl0ZXMgPSBzdGF0cy5pbkJ5dGVzICsgc3RhdHMub3V0Qnl0ZXM7XG4gICAgICAgICAgICBtLmxhbmcgPSBsYW5nO1xuICAgICAgICAgICAgbS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgICAgIG0ucGF5bG9hZCA9IHRoaXMucGF5bG9hZC5sZW5ndGg7XG4gICAgICAgICAgICBtZXRyaWNzLnB1c2gobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcXJlcCkge1xuICAgICAgICAgICAgY29uc3QgeyBuYW1lLCBkdXJhdGlvbiB9ID0gcmVxcmVwO1xuICAgICAgICAgICAgY29uc3QgbSA9IG5ldyBNZXRyaWMobmFtZSwgZHVyYXRpb24pO1xuICAgICAgICAgICAgbS5tc2dzID0gdGhpcy5tc2dzICogMjtcbiAgICAgICAgICAgIG0uYnl0ZXMgPSBzdGF0cy5pbkJ5dGVzICsgc3RhdHMub3V0Qnl0ZXM7XG4gICAgICAgICAgICBtLmxhbmcgPSBsYW5nO1xuICAgICAgICAgICAgbS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgICAgIG0ucGF5bG9hZCA9IHRoaXMucGF5bG9hZC5sZW5ndGg7XG4gICAgICAgICAgICBtZXRyaWNzLnB1c2gobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHB1Yikge1xuICAgICAgICAgICAgY29uc3QgeyBuYW1lLCBkdXJhdGlvbiB9ID0gcHViO1xuICAgICAgICAgICAgY29uc3QgbSA9IG5ldyBNZXRyaWMobmFtZSwgZHVyYXRpb24pO1xuICAgICAgICAgICAgbS5tc2dzID0gdGhpcy5tc2dzO1xuICAgICAgICAgICAgbS5ieXRlcyA9IHN0YXRzLm91dEJ5dGVzO1xuICAgICAgICAgICAgbS5sYW5nID0gbGFuZztcbiAgICAgICAgICAgIG0udmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgICBtLnBheWxvYWQgPSB0aGlzLnBheWxvYWQubGVuZ3RoO1xuICAgICAgICAgICAgbWV0cmljcy5wdXNoKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZSwgZHVyYXRpb24gfSA9IHN1YjtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBuZXcgTWV0cmljKG5hbWUsIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIG0ubXNncyA9IHRoaXMubXNncztcbiAgICAgICAgICAgIG0uYnl0ZXMgPSBzdGF0cy5pbkJ5dGVzO1xuICAgICAgICAgICAgbS5sYW5nID0gbGFuZztcbiAgICAgICAgICAgIG0udmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgICBtLnBheWxvYWQgPSB0aGlzLnBheWxvYWQubGVuZ3RoO1xuICAgICAgICAgICAgbWV0cmljcy5wdXNoKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZSwgZHVyYXRpb24gfSA9IHJlcDtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBuZXcgTWV0cmljKG5hbWUsIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIG0ubXNncyA9IHRoaXMubXNncztcbiAgICAgICAgICAgIG0uYnl0ZXMgPSBzdGF0cy5pbkJ5dGVzICsgc3RhdHMub3V0Qnl0ZXM7XG4gICAgICAgICAgICBtLmxhbmcgPSBsYW5nO1xuICAgICAgICAgICAgbS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgICAgIG0ucGF5bG9hZCA9IHRoaXMucGF5bG9hZC5sZW5ndGg7XG4gICAgICAgICAgICBtZXRyaWNzLnB1c2gobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcSkge1xuICAgICAgICAgICAgY29uc3QgeyBuYW1lLCBkdXJhdGlvbiB9ID0gcmVxO1xuICAgICAgICAgICAgY29uc3QgbSA9IG5ldyBNZXRyaWMobmFtZSwgZHVyYXRpb24pO1xuICAgICAgICAgICAgbS5tc2dzID0gdGhpcy5tc2dzO1xuICAgICAgICAgICAgbS5ieXRlcyA9IHN0YXRzLmluQnl0ZXMgKyBzdGF0cy5vdXRCeXRlcztcbiAgICAgICAgICAgIG0ubGFuZyA9IGxhbmc7XG4gICAgICAgICAgICBtLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICAgICAgbS5wYXlsb2FkID0gdGhpcy5wYXlsb2FkLmxlbmd0aDtcbiAgICAgICAgICAgIG1ldHJpY3MucHVzaChtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0cmljcztcbiAgICB9XG4gICAgYXN5bmMgcnVuQ2FsbGJhY2tzKCkge1xuICAgICAgICBjb25zdCBqb2JzID0gW107XG4gICAgICAgIGlmICh0aGlzLnN1Yikge1xuICAgICAgICAgICAgY29uc3QgZCA9IGRlZmVycmVkKCk7XG4gICAgICAgICAgICBqb2JzLnB1c2goZCk7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICB0aGlzLm5jLnN1YnNjcmliZSh0aGlzLnN1YmplY3QsIHtcbiAgICAgICAgICAgICAgICBtYXg6IHRoaXMubXNncyxcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogKCk9PntcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1hcmsoXCJzdWJTdGFydFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gdGhpcy5tc2dzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWFyayhcInN1YlN0b3BcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWVhc3VyZShcInN1YlwiLCBcInN1YlN0YXJ0XCIsIFwic3ViU3RvcFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVwKSB7XG4gICAgICAgICAgICBjb25zdCBkID0gZGVmZXJyZWQoKTtcbiAgICAgICAgICAgIGpvYnMucHVzaChkKTtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIHRoaXMubmMuc3Vic2NyaWJlKHRoaXMuc3ViamVjdCwge1xuICAgICAgICAgICAgICAgIG1heDogdGhpcy5tc2dzLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiAoXywgbSk9PntcbiAgICAgICAgICAgICAgICAgICAgbS5yZXNwb25kKHRoaXMucGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tYXJrKFwicmVwU3RhcnRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IHRoaXMubXNncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1hcmsoXCJyZXBTdG9wXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1lYXN1cmUoXCJyZXBcIiwgXCJyZXBTdGFydFwiLCBcInJlcFN0b3BcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnB1Yikge1xuICAgICAgICAgICAgY29uc3Qgam9iID0gKGFzeW5jICgpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1hcmsoXCJwdWJTdGFydFwiKTtcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5tc2dzOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5jLnB1Ymxpc2godGhpcy5zdWJqZWN0LCB0aGlzLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm5jLmZsdXNoKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1hcmsoXCJwdWJTdG9wXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tZWFzdXJlKFwicHViXCIsIFwicHViU3RhcnRcIiwgXCJwdWJTdG9wXCIpO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIGpvYnMucHVzaChqb2IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlcSkge1xuICAgICAgICAgICAgY29uc3Qgam9iID0gKGFzeW5jICgpPT57XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXN5bmNSZXF1ZXN0cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWFyayhcInJlcVN0YXJ0XCIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLm1zZ3M7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2godGhpcy5uYy5yZXF1ZXN0KHRoaXMuc3ViamVjdCwgdGhpcy5wYXlsb2FkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dDogMjAwMDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChhKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1hcmsoXCJyZXFTdG9wXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWVhc3VyZShcInJlcVwiLCBcInJlcVN0YXJ0XCIsIFwicmVxU3RvcFwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWFyayhcInJlcVN0YXJ0XCIpO1xuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5tc2dzOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5uYy5yZXF1ZXN0KHRoaXMuc3ViamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1hcmsoXCJyZXFTdG9wXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWVhc3VyZShcInJlcVwiLCBcInJlcVN0YXJ0XCIsIFwicmVxU3RvcFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgam9icy5wdXNoKGpvYik7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoam9icyk7XG4gICAgfVxuICAgIGFzeW5jIHJ1bkFzeW5jKCkge1xuICAgICAgICBjb25zdCBqb2JzID0gW107XG4gICAgICAgIGlmICh0aGlzLnJlcCkge1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSB0aGlzLm5jLnN1YnNjcmliZSh0aGlzLnN1YmplY3QsIHtcbiAgICAgICAgICAgICAgICBtYXg6IHRoaXMubXNnc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBqb2IgPSAoYXN5bmMgKCk9PntcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IG0gb2Ygc3ViKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1hcmsoXCJyZXBTdGFydFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtLnJlc3BvbmQodGhpcy5wYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5uYy5mbHVzaCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tYXJrKFwicmVwU3RvcFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWVhc3VyZShcInJlcFwiLCBcInJlcFN0YXJ0XCIsIFwicmVwU3RvcFwiKTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBqb2JzLnB1c2goam9iKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdWIpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3Qgc3ViID0gdGhpcy5uYy5zdWJzY3JpYmUodGhpcy5zdWJqZWN0LCB7XG4gICAgICAgICAgICAgICAgbWF4OiB0aGlzLm1zZ3NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgam9iID0gKGFzeW5jICgpPT57XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBfbSBvZiBzdWIpe1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWFyayhcInN1YlN0YXJ0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tYXJrKFwic3ViU3RvcFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWVhc3VyZShcInN1YlwiLCBcInN1YlN0YXJ0XCIsIFwic3ViU3RvcFwiKTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBqb2JzLnB1c2goam9iKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wdWIpIHtcbiAgICAgICAgICAgIGNvbnN0IGpvYiA9IChhc3luYyAoKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tYXJrKFwicHViU3RhcnRcIik7XG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMubXNnczsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYy5wdWJsaXNoKHRoaXMuc3ViamVjdCwgdGhpcy5wYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5uYy5mbHVzaCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tYXJrKFwicHViU3RvcFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWVhc3VyZShcInB1YlwiLCBcInB1YlN0YXJ0XCIsIFwicHViU3RvcFwiKTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBqb2JzLnB1c2goam9iKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXEpIHtcbiAgICAgICAgICAgIGNvbnN0IGpvYiA9IChhc3luYyAoKT0+e1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFzeW5jUmVxdWVzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1hcmsoXCJyZXFTdGFydFwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5tc2dzOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHRoaXMubmMucmVxdWVzdCh0aGlzLnN1YmplY3QsIHRoaXMucGF5bG9hZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IDIwMDAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoYSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tYXJrKFwicmVxU3RvcFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1lYXN1cmUoXCJyZXFcIiwgXCJyZXFTdGFydFwiLCBcInJlcVN0b3BcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1hcmsoXCJyZXFTdGFydFwiKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMubXNnczsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMubmMucmVxdWVzdCh0aGlzLnN1YmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tYXJrKFwicmVxU3RvcFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1lYXN1cmUoXCJyZXFcIiwgXCJyZXFTdGFydFwiLCBcInJlcVN0b3BcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIGpvYnMucHVzaChqb2IpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGpvYnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRocm91Z2hwdXQoYnl0ZXMsIHNlY29uZHMpIHtcbiAgICByZXR1cm4gYCR7aHVtYW5pemVCeXRlcyhieXRlcyAvIHNlY29uZHMpfS9zZWNgO1xufVxuZnVuY3Rpb24gaHVtYW5pemVCeXRlcyhieXRlcywgc2kgPSBmYWxzZSkge1xuICAgIGNvbnN0IGJhc2UgPSBzaSA/IDEwMDAgOiAxMDI0O1xuICAgIGNvbnN0IHByZSA9IHNpID8gW1xuICAgICAgICBcImtcIixcbiAgICAgICAgXCJNXCIsXG4gICAgICAgIFwiR1wiLFxuICAgICAgICBcIlRcIixcbiAgICAgICAgXCJQXCIsXG4gICAgICAgIFwiRVwiXG4gICAgXSA6IFtcbiAgICAgICAgXCJLXCIsXG4gICAgICAgIFwiTVwiLFxuICAgICAgICBcIkdcIixcbiAgICAgICAgXCJUXCIsXG4gICAgICAgIFwiUFwiLFxuICAgICAgICBcIkVcIlxuICAgIF07XG4gICAgY29uc3QgcG9zdCA9IHNpID8gXCJpQlwiIDogXCJCXCI7XG4gICAgaWYgKGJ5dGVzIDwgYmFzZSkge1xuICAgICAgICByZXR1cm4gYCR7Ynl0ZXMudG9GaXhlZCgyKX0gJHtwb3N0fWA7XG4gICAgfVxuICAgIGNvbnN0IGV4cCA9IHBhcnNlSW50KE1hdGgubG9nKGJ5dGVzKSAvIE1hdGgubG9nKGJhc2UpICsgXCJcIik7XG4gICAgY29uc3QgaW5kZXggPSBwYXJzZUludChleHAgLSAxICsgXCJcIik7XG4gICAgcmV0dXJuIGAkeyhieXRlcyAvIE1hdGgucG93KGJhc2UsIGV4cCkpLnRvRml4ZWQoMil9ICR7cHJlW2luZGV4XX0ke3Bvc3R9YDtcbn1cbmZ1bmN0aW9uIGh1bWFuaXplTnVtYmVyKG4pIHtcbiAgICByZXR1cm4gbi50b1N0cmluZygpLnJlcGxhY2UoL1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csIFwiLFwiKTtcbn1cbmV4cG9ydCB7IGJhY2tvZmYgYXMgYmFja29mZiwgQmVuY2ggYXMgQmVuY2gsIGJ1aWxkQXV0aGVudGljYXRvciBhcyBidWlsZEF1dGhlbnRpY2F0b3IsIGNhbm9uaWNhbE1JTUVIZWFkZXJLZXkgYXMgY2Fub25pY2FsTUlNRUhlYWRlcktleSwgY3JlYXRlSW5ib3ggYXMgY3JlYXRlSW5ib3gsIGNyZWRzQXV0aGVudGljYXRvciBhcyBjcmVkc0F1dGhlbnRpY2F0b3IsIGRlYWRsaW5lIGFzIGRlYWRsaW5lLCBEZWJ1Z0V2ZW50cyBhcyBEZWJ1Z0V2ZW50cywgZGVmZXJyZWQgYXMgZGVmZXJyZWQsIGRlbGF5IGFzIGRlbGF5LCBFbXB0eSBhcyBFbXB0eSwgRXJyb3JDb2RlIGFzIEVycm9yQ29kZSwgRXZlbnRzIGFzIEV2ZW50cywgaGVhZGVycyBhcyBoZWFkZXJzLCBKU09OQ29kZWMgYXMgSlNPTkNvZGVjLCBqd3RBdXRoZW50aWNhdG9yIGFzIGp3dEF1dGhlbnRpY2F0b3IsIE1hdGNoIGFzIE1hdGNoLCBNZXRyaWMgYXMgTWV0cmljLCBtaWxsaXMgYXMgbWlsbGlzLCBNc2dIZHJzSW1wbCBhcyBNc2dIZHJzSW1wbCwgbmFub3MgYXMgbmFub3MsIE5hdHNFcnJvciBhcyBOYXRzRXJyb3IsIG5rZXlBdXRoZW50aWNhdG9yIGFzIG5rZXlBdXRoZW50aWNhdG9yLCBtb2QgYXMgbmtleXMsIE51aWQgYXMgTnVpZCwgbnVpZCBhcyBudWlkLCBSZXF1ZXN0U3RyYXRlZ3kgYXMgUmVxdWVzdFN0cmF0ZWd5LCBTZXJ2aWNlRXJyb3IgYXMgU2VydmljZUVycm9yLCBTZXJ2aWNlRXJyb3JDb2RlSGVhZGVyIGFzIFNlcnZpY2VFcnJvckNvZGVIZWFkZXIsIFNlcnZpY2VFcnJvckhlYWRlciBhcyBTZXJ2aWNlRXJyb3JIZWFkZXIsIFNlcnZpY2VSZXNwb25zZVR5cGUgYXMgU2VydmljZVJlc3BvbnNlVHlwZSwgU2VydmljZVZlcmIgYXMgU2VydmljZVZlcmIsIFN0cmluZ0NvZGVjIGFzIFN0cmluZ0NvZGVjLCBzeW5jSXRlcmF0b3IgYXMgc3luY0l0ZXJhdG9yLCB0b2tlbkF1dGhlbnRpY2F0b3IgYXMgdG9rZW5BdXRoZW50aWNhdG9yLCB1c2VybmFtZVBhc3N3b3JkQXV0aGVudGljYXRvciBhcyB1c2VybmFtZVBhc3N3b3JkQXV0aGVudGljYXRvciB9O1xuZnVuY3Rpb24gTm9vcEt2Q29kZWNzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGtleToge1xuICAgICAgICAgICAgZW5jb2RlIChrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGs7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVjb2RlIChrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICBlbmNvZGUgKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWNvZGUgKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBkZWZhdWx0QnVja2V0T3B0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByZXBsaWNhczogMSxcbiAgICAgICAgaGlzdG9yeTogMSxcbiAgICAgICAgdGltZW91dDogMjAwMCxcbiAgICAgICAgbWF4X2J5dGVzOiAtMSxcbiAgICAgICAgbWF4VmFsdWVTaXplOiAtMSxcbiAgICAgICAgY29kZWM6IE5vb3BLdkNvZGVjcygpLFxuICAgICAgICBzdG9yYWdlOiBTdG9yYWdlVHlwZS5GaWxlXG4gICAgfTtcbn1cbmNvbnN0IGt2T3BlcmF0aW9uSGRyID0gXCJLVi1PcGVyYXRpb25cIjtcbmNvbnN0IGt2U3ViamVjdFByZWZpeCA9IFwiJEtWXCI7XG5jb25zdCB2YWxpZEtleVJlID0gL15bLS89Llxcd10rJC87XG5jb25zdCB2YWxpZFNlYXJjaEtleSA9IC9eWy0vPS4+Klxcd10rJC87XG5jb25zdCB2YWxpZEJ1Y2tldFJlID0gL15bLVxcd10rJC87XG5mdW5jdGlvbiB2YWxpZGF0ZUtleShrKSB7XG4gICAgaWYgKGsuc3RhcnRzV2l0aChcIi5cIikgfHwgay5lbmRzV2l0aChcIi5cIikgfHwgIXZhbGlkS2V5UmUudGVzdChrKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQga2V5OiAke2t9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVTZWFyY2hLZXkoaykge1xuICAgIGlmIChrLnN0YXJ0c1dpdGgoXCIuXCIpIHx8IGsuZW5kc1dpdGgoXCIuXCIpIHx8ICF2YWxpZFNlYXJjaEtleS50ZXN0KGspKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBrZXk6ICR7a31gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYXNXaWxkY2FyZHMoaykge1xuICAgIGlmIChrLnN0YXJ0c1dpdGgoXCIuXCIpIHx8IGsuZW5kc1dpdGgoXCIuXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBrZXk6ICR7a31gKTtcbiAgICB9XG4gICAgY29uc3QgY2h1bmtzID0gay5zcGxpdChcIi5cIik7XG4gICAgbGV0IGhhc1dpbGRjYXJkcyA9IGZhbHNlO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspe1xuICAgICAgICBzd2l0Y2goY2h1bmtzW2ldKXtcbiAgICAgICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgICAgICAgICAgaGFzV2lsZGNhcmRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCI+XCI6XG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IGNodW5rcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBrZXk6ICR7a31gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGFzV2lsZGNhcmRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhhc1dpbGRjYXJkcztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQnVja2V0KG5hbWUpIHtcbiAgICBpZiAoIXZhbGlkQnVja2V0UmUudGVzdChuYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgYnVja2V0IG5hbWU6ICR7bmFtZX1gKTtcbiAgICB9XG59XG52YXIgUHViSGVhZGVycztcbihmdW5jdGlvbihQdWJIZWFkZXJzKSB7XG4gICAgUHViSGVhZGVyc1tcIk1zZ0lkSGRyXCJdID0gXCJOYXRzLU1zZy1JZFwiO1xuICAgIFB1YkhlYWRlcnNbXCJFeHBlY3RlZFN0cmVhbUhkclwiXSA9IFwiTmF0cy1FeHBlY3RlZC1TdHJlYW1cIjtcbiAgICBQdWJIZWFkZXJzW1wiRXhwZWN0ZWRMYXN0U2VxSGRyXCJdID0gXCJOYXRzLUV4cGVjdGVkLUxhc3QtU2VxdWVuY2VcIjtcbiAgICBQdWJIZWFkZXJzW1wiRXhwZWN0ZWRMYXN0TXNnSWRIZHJcIl0gPSBcIk5hdHMtRXhwZWN0ZWQtTGFzdC1Nc2ctSWRcIjtcbiAgICBQdWJIZWFkZXJzW1wiRXhwZWN0ZWRMYXN0U3ViamVjdFNlcXVlbmNlSGRyXCJdID0gXCJOYXRzLUV4cGVjdGVkLUxhc3QtU3ViamVjdC1TZXF1ZW5jZVwiO1xufSkoUHViSGVhZGVycyB8fCAoUHViSGVhZGVycyA9IHt9KSk7XG5jbGFzcyBCdWNrZXQge1xuICAgIGpzO1xuICAgIGpzbTtcbiAgICBzdHJlYW07XG4gICAgYnVja2V0O1xuICAgIGRpcmVjdDtcbiAgICBjb2RlYztcbiAgICBwcmVmaXg7XG4gICAgZWRpdFByZWZpeDtcbiAgICB1c2VKc1ByZWZpeDtcbiAgICBfcHJlZml4TGVuO1xuICAgIGNvbnN0cnVjdG9yKGJ1Y2tldCwganMsIGpzbSl7XG4gICAgICAgIHZhbGlkYXRlQnVja2V0KGJ1Y2tldCk7XG4gICAgICAgIHRoaXMuanMgPSBqcztcbiAgICAgICAgdGhpcy5qc20gPSBqc207XG4gICAgICAgIHRoaXMuYnVja2V0ID0gYnVja2V0O1xuICAgICAgICB0aGlzLnByZWZpeCA9IGt2U3ViamVjdFByZWZpeDtcbiAgICAgICAgdGhpcy5lZGl0UHJlZml4ID0gXCJcIjtcbiAgICAgICAgdGhpcy51c2VKc1ByZWZpeCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcmVmaXhMZW4gPSAwO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlKGpzLCBuYW1lLCBvcHRzID0ge30pIHtcbiAgICAgICAgdmFsaWRhdGVCdWNrZXQobmFtZSk7XG4gICAgICAgIGNvbnN0IGpzbSA9IGF3YWl0IGpzLmpldHN0cmVhbU1hbmFnZXIoKTtcbiAgICAgICAgY29uc3QgYnVja2V0ID0gbmV3IEJ1Y2tldChuYW1lLCBqcywganNtKTtcbiAgICAgICAgYXdhaXQgYnVja2V0LmluaXQob3B0cyk7XG4gICAgICAgIHJldHVybiBidWNrZXQ7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBiaW5kKGpzLCBuYW1lLCBvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3QganNtID0gYXdhaXQganMuamV0c3RyZWFtTWFuYWdlcigpO1xuICAgICAgICBjb25zdCBpbmZvID0ge1xuICAgICAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgICAgICAgYWxsb3dfZGlyZWN0OiBvcHRzLmFsbG93X2RpcmVjdFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YWxpZGF0ZUJ1Y2tldChuYW1lKTtcbiAgICAgICAgY29uc3QgYnVja2V0ID0gbmV3IEJ1Y2tldChuYW1lLCBqcywganNtKTtcbiAgICAgICAgaW5mby5jb25maWcubmFtZSA9IG9wdHMuc3RyZWFtTmFtZSA/PyBidWNrZXQuYnVja2V0TmFtZSgpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGJ1Y2tldCwgaW5mbyk7XG4gICAgICAgIGJ1Y2tldC5zdHJlYW0gPSBpbmZvLmNvbmZpZy5uYW1lO1xuICAgICAgICBidWNrZXQuY29kZWMgPSBvcHRzLmNvZGVjIHx8IE5vb3BLdkNvZGVjcygpO1xuICAgICAgICBidWNrZXQuZGlyZWN0ID0gaW5mby5jb25maWcuYWxsb3dfZGlyZWN0ID8/IGZhbHNlO1xuICAgICAgICBidWNrZXQuaW5pdGlhbGl6ZVByZWZpeGVzKGluZm8pO1xuICAgICAgICByZXR1cm4gYnVja2V0O1xuICAgIH1cbiAgICBhc3luYyBpbml0KG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCBibyA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdEJ1Y2tldE9wdHMoKSwgb3B0cyk7XG4gICAgICAgIHRoaXMuY29kZWMgPSBiby5jb2RlYztcbiAgICAgICAgY29uc3Qgc2MgPSB7fTtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBzYy5uYW1lID0gb3B0cy5zdHJlYW1OYW1lID8/IHRoaXMuYnVja2V0TmFtZSgpO1xuICAgICAgICBzYy5yZXRlbnRpb24gPSBSZXRlbnRpb25Qb2xpY3kuTGltaXRzO1xuICAgICAgICBzYy5tYXhfbXNnc19wZXJfc3ViamVjdCA9IGJvLmhpc3Rvcnk7XG4gICAgICAgIGlmIChiby5tYXhCdWNrZXRTaXplKSB7XG4gICAgICAgICAgICBiby5tYXhfYnl0ZXMgPSBiby5tYXhCdWNrZXRTaXplO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiby5tYXhfYnl0ZXMpIHtcbiAgICAgICAgICAgIHNjLm1heF9ieXRlcyA9IGJvLm1heF9ieXRlcztcbiAgICAgICAgfVxuICAgICAgICBzYy5tYXhfbXNnX3NpemUgPSBiby5tYXhWYWx1ZVNpemU7XG4gICAgICAgIHNjLnN0b3JhZ2UgPSBiby5zdG9yYWdlO1xuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IG9wdHMucGxhY2VtZW50Q2x1c3RlciA/PyBcIlwiO1xuICAgICAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgICAgICAgIG9wdHMucGxhY2VtZW50ID0ge307XG4gICAgICAgICAgICBvcHRzLnBsYWNlbWVudC5jbHVzdGVyID0gbG9jYXRpb247XG4gICAgICAgICAgICBvcHRzLnBsYWNlbWVudC50YWdzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMucGxhY2VtZW50KSB7XG4gICAgICAgICAgICBzYy5wbGFjZW1lbnQgPSBvcHRzLnBsYWNlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5yZXB1Ymxpc2gpIHtcbiAgICAgICAgICAgIHNjLnJlcHVibGlzaCA9IG9wdHMucmVwdWJsaXNoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBzYy5kZXNjcmlwdGlvbiA9IG9wdHMuZGVzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMubWlycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBtaXJyb3IgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRzLm1pcnJvcik7XG4gICAgICAgICAgICBpZiAoIW1pcnJvci5uYW1lLnN0YXJ0c1dpdGgoa3ZQcmVmaXgpKSB7XG4gICAgICAgICAgICAgICAgbWlycm9yLm5hbWUgPSBgJHtrdlByZWZpeH0ke21pcnJvci5uYW1lfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzYy5taXJyb3IgPSBtaXJyb3I7XG4gICAgICAgICAgICBzYy5taXJyb3JfZGlyZWN0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRzLnNvdXJjZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZXMgPSBvcHRzLnNvdXJjZXMubWFwKChzKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBPYmplY3QuYXNzaWduKHt9LCBzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzcmNCdWNrZXROYW1lID0gYy5uYW1lLnN0YXJ0c1dpdGgoa3ZQcmVmaXgpID8gYy5uYW1lLnN1YnN0cmluZyhrdlByZWZpeC5sZW5ndGgpIDogYy5uYW1lO1xuICAgICAgICAgICAgICAgIGlmICghYy5uYW1lLnN0YXJ0c1dpdGgoa3ZQcmVmaXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGMubmFtZSA9IGAke2t2UHJlZml4fSR7Yy5uYW1lfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcy5leHRlcm5hbCAmJiBzcmNCdWNrZXROYW1lICE9PSB0aGlzLmJ1Y2tldCkge1xuICAgICAgICAgICAgICAgICAgICBjLnN1YmplY3RfdHJhbnNmb3JtcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmM6IGAkS1YuJHtzcmNCdWNrZXROYW1lfS4+YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0OiBgJEtWLiR7dGhpcy5idWNrZXR9Lj5gXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzYy5zb3VyY2VzID0gc291cmNlcztcbiAgICAgICAgICAgIHNjLnN1YmplY3RzID0gW1xuICAgICAgICAgICAgICAgIHRoaXMuc3ViamVjdEZvckJ1Y2tldCgpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2Muc3ViamVjdHMgPSBbXG4gICAgICAgICAgICAgICAgdGhpcy5zdWJqZWN0Rm9yQnVja2V0KClcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMubWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHNjLm1ldGFkYXRhID0gb3B0cy5tZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdHMuY29tcHJlc3Npb24gPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBzYy5jb21wcmVzc2lvbiA9IG9wdHMuY29tcHJlc3Npb24gPyBTdG9yZUNvbXByZXNzaW9uLlMyIDogU3RvcmVDb21wcmVzc2lvbi5Ob25lO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5jaSA9IHRoaXMuanMubmM7XG4gICAgICAgIGNvbnN0IGhhdmUgPSBuY2kuZ2V0U2VydmVyVmVyc2lvbigpO1xuICAgICAgICBjb25zdCBkaXNjYXJkTmV3ID0gaGF2ZSA/IGNvbXBhcmUoaGF2ZSwgcGFyc2VTZW1WZXIoXCIyLjcuMlwiKSkgPj0gMCA6IGZhbHNlO1xuICAgICAgICBzYy5kaXNjYXJkID0gZGlzY2FyZE5ldyA/IERpc2NhcmRQb2xpY3kuTmV3IDogRGlzY2FyZFBvbGljeS5PbGQ7XG4gICAgICAgIGNvbnN0IHsgb2s6IGRpcmVjdCwgbWluIH0gPSBuY2kuZmVhdHVyZXMuZ2V0KEZlYXR1cmUuSlNfQUxMT1dfRElSRUNUKTtcbiAgICAgICAgaWYgKCFkaXJlY3QgJiYgb3B0cy5hbGxvd19kaXJlY3QgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBoYXZlID8gYCR7aGF2ZS5tYWpvcn0uJHtoYXZlLm1pbm9yfS4ke2hhdmUubWljcm99YCA6IFwidW5rbm93blwiO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgYWxsb3dfZGlyZWN0IGlzIG5vdCBhdmFpbGFibGUgb24gc2VydmVyIHZlcnNpb24gJHt2fSAtIHJlcXVpcmVzICR7bWlufWApKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRzLmFsbG93X2RpcmVjdCA9IHR5cGVvZiBvcHRzLmFsbG93X2RpcmVjdCA9PT0gXCJib29sZWFuXCIgPyBvcHRzLmFsbG93X2RpcmVjdCA6IGRpcmVjdDtcbiAgICAgICAgc2MuYWxsb3dfZGlyZWN0ID0gb3B0cy5hbGxvd19kaXJlY3Q7XG4gICAgICAgIHRoaXMuZGlyZWN0ID0gc2MuYWxsb3dfZGlyZWN0O1xuICAgICAgICBzYy5udW1fcmVwbGljYXMgPSBiby5yZXBsaWNhcztcbiAgICAgICAgaWYgKGJvLnR0bCkge1xuICAgICAgICAgICAgc2MubWF4X2FnZSA9IG5hbm9zKGJvLnR0bCk7XG4gICAgICAgIH1cbiAgICAgICAgc2MuYWxsb3dfcm9sbHVwX2hkcnMgPSB0cnVlO1xuICAgICAgICBsZXQgaW5mbztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGluZm8gPSBhd2FpdCB0aGlzLmpzbS5zdHJlYW1zLmluZm8oc2MubmFtZSk7XG4gICAgICAgICAgICBpZiAoIWluZm8uY29uZmlnLmFsbG93X2RpcmVjdCAmJiB0aGlzLmRpcmVjdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyci5tZXNzYWdlID09PSBcInN0cmVhbSBub3QgZm91bmRcIikge1xuICAgICAgICAgICAgICAgIGluZm8gPSBhd2FpdCB0aGlzLmpzbS5zdHJlYW1zLmFkZChzYyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRpYWxpemVQcmVmaXhlcyhpbmZvKTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZVByZWZpeGVzKGluZm8pIHtcbiAgICAgICAgdGhpcy5fcHJlZml4TGVuID0gMDtcbiAgICAgICAgdGhpcy5wcmVmaXggPSBgJEtWLiR7dGhpcy5idWNrZXR9YDtcbiAgICAgICAgdGhpcy51c2VKc1ByZWZpeCA9IHRoaXMuanMuYXBpUHJlZml4ICE9PSBcIiRKUy5BUElcIjtcbiAgICAgICAgY29uc3QgeyBtaXJyb3IgfSA9IGluZm8uY29uZmlnO1xuICAgICAgICBpZiAobWlycm9yKSB7XG4gICAgICAgICAgICBsZXQgbiA9IG1pcnJvci5uYW1lO1xuICAgICAgICAgICAgaWYgKG4uc3RhcnRzV2l0aChrdlByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICBuID0gbi5zdWJzdHJpbmcoa3ZQcmVmaXgubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtaXJyb3IuZXh0ZXJuYWwgJiYgbWlycm9yLmV4dGVybmFsLmFwaSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1iID0gbWlycm9yLm5hbWUuc3Vic3RyaW5nKGt2UHJlZml4Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy51c2VKc1ByZWZpeCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMucHJlZml4ID0gYCRLVi4ke21ifWA7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0UHJlZml4ID0gYCR7bWlycm9yLmV4dGVybmFsLmFwaX0uJEtWLiR7bn1gO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRQcmVmaXggPSB0aGlzLnByZWZpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBidWNrZXROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW0gPz8gYCR7a3ZQcmVmaXh9JHt0aGlzLmJ1Y2tldH1gO1xuICAgIH1cbiAgICBzdWJqZWN0Rm9yQnVja2V0KCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5wcmVmaXh9LiR7dGhpcy5idWNrZXR9Lj5gO1xuICAgIH1cbiAgICBzdWJqZWN0Rm9yS2V5KGssIGVkaXQgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBidWlsZGVyID0gW107XG4gICAgICAgIGlmIChlZGl0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy51c2VKc1ByZWZpeCkge1xuICAgICAgICAgICAgICAgIGJ1aWxkZXIucHVzaCh0aGlzLmpzLmFwaVByZWZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5lZGl0UHJlZml4ICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgYnVpbGRlci5wdXNoKHRoaXMuZWRpdFByZWZpeCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1aWxkZXIucHVzaCh0aGlzLnByZWZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmVmaXgpIHtcbiAgICAgICAgICAgICAgICBidWlsZGVyLnB1c2godGhpcy5wcmVmaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJ1aWxkZXIucHVzaChrKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuam9pbihcIi5cIik7XG4gICAgfVxuICAgIGZ1bGxLZXlOYW1lKGspIHtcbiAgICAgICAgaWYgKHRoaXMucHJlZml4ICE9PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5wcmVmaXh9LiR7a31gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtrdlN1YmplY3RQcmVmaXh9LiR7dGhpcy5idWNrZXR9LiR7a31gO1xuICAgIH1cbiAgICBnZXQgcHJlZml4TGVuKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJlZml4TGVuID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9wcmVmaXhMZW4gPSB0aGlzLnByZWZpeC5sZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcmVmaXhMZW47XG4gICAgfVxuICAgIGVuY29kZUtleShrZXkpIHtcbiAgICAgICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgdCBvZiBrZXkuc3BsaXQoXCIuXCIpKXtcbiAgICAgICAgICAgIHN3aXRjaCh0KXtcbiAgICAgICAgICAgICAgICBjYXNlIFwiPlwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBjaHVua3MucHVzaCh0aGlzLmNvZGVjLmtleS5lbmNvZGUodCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2h1bmtzLmpvaW4oXCIuXCIpO1xuICAgIH1cbiAgICBkZWNvZGVLZXkoZWtleSkge1xuICAgICAgICBjb25zdCBjaHVua3MgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB0IG9mIGVrZXkuc3BsaXQoXCIuXCIpKXtcbiAgICAgICAgICAgIHN3aXRjaCh0KXtcbiAgICAgICAgICAgICAgICBjYXNlIFwiPlwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBjaHVua3MucHVzaCh0aGlzLmNvZGVjLmtleS5kZWNvZGUodCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2h1bmtzLmpvaW4oXCIuXCIpO1xuICAgIH1cbiAgICB2YWxpZGF0ZUtleSA9IHZhbGlkYXRlS2V5O1xuICAgIHZhbGlkYXRlU2VhcmNoS2V5ID0gdmFsaWRhdGVTZWFyY2hLZXk7XG4gICAgaGFzV2lsZGNhcmRzID0gaGFzV2lsZGNhcmRzO1xuICAgIGNsb3NlKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGRhdGFMZW4oZGF0YSwgaCkge1xuICAgICAgICBjb25zdCBzbGVuID0gaCA/IGguZ2V0KEpzSGVhZGVycy5NZXNzYWdlU2l6ZUhkcikgfHwgXCJcIiA6IFwiXCI7XG4gICAgICAgIGlmIChzbGVuICE9PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoc2xlbiwgMTApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgc21Ub0VudHJ5KHNtKSB7XG4gICAgICAgIHJldHVybiBuZXcgS3ZTdG9yZWRFbnRyeUltcGwodGhpcy5idWNrZXQsIHRoaXMucHJlZml4TGVuLCBzbSk7XG4gICAgfVxuICAgIGptVG9FbnRyeShqbSkge1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmRlY29kZUtleShqbS5zdWJqZWN0LnN1YnN0cmluZyh0aGlzLnByZWZpeExlbikpO1xuICAgICAgICByZXR1cm4gbmV3IEt2SnNNc2dFbnRyeUltcGwodGhpcy5idWNrZXQsIGtleSwgam0pO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGUoaywgZGF0YSkge1xuICAgICAgICBsZXQgZmlyc3RFcnI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBuID0gYXdhaXQgdGhpcy5wdXQoaywgZGF0YSwge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzU2VxOiAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobik7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZmlyc3RFcnIgPSBlcnI7XG4gICAgICAgICAgICBpZiAoZXJyPy5hcGlfZXJyb3I/LmVycl9jb2RlICE9PSAxMDA3MSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZXYgPSAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZSA9IGF3YWl0IHRoaXMuZ2V0KGspO1xuICAgICAgICAgICAgaWYgKGU/Lm9wZXJhdGlvbiA9PT0gXCJERUxcIiB8fCBlPy5vcGVyYXRpb24gPT09IFwiUFVSR0VcIikge1xuICAgICAgICAgICAgICAgIHJldiA9IGUgIT09IG51bGwgPyBlLnJldmlzaW9uIDogMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoaywgZGF0YSwgcmV2KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGZpcnN0RXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUoaywgZGF0YSwgdmVyc2lvbikge1xuICAgICAgICBpZiAodmVyc2lvbiA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ2ZXJzaW9uIG11c3QgYmUgZ3JlYXRlciB0aGFuIDBcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KGssIGRhdGEsIHtcbiAgICAgICAgICAgIHByZXZpb3VzU2VxOiB2ZXJzaW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBwdXQoaywgZGF0YSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGVrID0gdGhpcy5lbmNvZGVLZXkoayk7XG4gICAgICAgIHRoaXMudmFsaWRhdGVLZXkoZWspO1xuICAgICAgICBjb25zdCBvID0ge307XG4gICAgICAgIGlmIChvcHRzLnByZXZpb3VzU2VxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGggPSBoZWFkZXJzKCk7XG4gICAgICAgICAgICBvLmhlYWRlcnMgPSBoO1xuICAgICAgICAgICAgaC5zZXQoUHViSGVhZGVycy5FeHBlY3RlZExhc3RTdWJqZWN0U2VxdWVuY2VIZHIsIGAke29wdHMucHJldmlvdXNTZXF9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhID0gYXdhaXQgdGhpcy5qcy5wdWJsaXNoKHRoaXMuc3ViamVjdEZvcktleShlaywgdHJ1ZSksIGRhdGEsIG8pO1xuICAgICAgICAgICAgcmV0dXJuIHBhLnNlcTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zdCBuZSA9IGVycjtcbiAgICAgICAgICAgIGlmIChuZS5pc0pldFN0cmVhbUVycm9yKCkpIHtcbiAgICAgICAgICAgICAgICBuZS5tZXNzYWdlID0gbmUuYXBpX2Vycm9yPy5kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICBuZS5jb2RlID0gYCR7bmUuYXBpX2Vycm9yPy5jb2RlfWA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldChrLCBvcHRzKSB7XG4gICAgICAgIGNvbnN0IGVrID0gdGhpcy5lbmNvZGVLZXkoayk7XG4gICAgICAgIHRoaXMudmFsaWRhdGVLZXkoZWspO1xuICAgICAgICBsZXQgYXJnID0ge1xuICAgICAgICAgICAgbGFzdF9ieV9zdWJqOiB0aGlzLnN1YmplY3RGb3JLZXkoZWspXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRzICYmIG9wdHMucmV2aXNpb24gPiAwKSB7XG4gICAgICAgICAgICBhcmcgPSB7XG4gICAgICAgICAgICAgICAgc2VxOiBvcHRzLnJldmlzaW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBzbTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpcmVjdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdCA9IHRoaXMuanNtLmRpcmVjdDtcbiAgICAgICAgICAgICAgICBzbSA9IGF3YWl0IGRpcmVjdC5nZXRNZXNzYWdlKHRoaXMuYnVja2V0TmFtZSgpLCBhcmcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzbSA9IGF3YWl0IHRoaXMuanNtLnN0cmVhbXMuZ2V0TWVzc2FnZSh0aGlzLmJ1Y2tldE5hbWUoKSwgYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGtlID0gdGhpcy5zbVRvRW50cnkoc20pO1xuICAgICAgICAgICAgaWYgKGtlLmtleSAhPT0gZWspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09IEVycm9yQ29kZS5KZXRTdHJlYW00MDROb01lc3NhZ2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHVyZ2Uoaywgb3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVsZXRlT3JQdXJnZShrLCBcIlBVUkdFXCIsIG9wdHMpO1xuICAgIH1cbiAgICBkZWxldGUoaywgb3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVsZXRlT3JQdXJnZShrLCBcIkRFTFwiLCBvcHRzKTtcbiAgICB9XG4gICAgYXN5bmMgcHVyZ2VEZWxldGVzKG9sZGVyTWlsbGlzID0gMzAgKiA2MCAqIDEwMDApIHtcbiAgICAgICAgY29uc3QgZG9uZSA9IGRlZmVycmVkKCk7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IFtdO1xuICAgICAgICBjb25zdCBpID0gYXdhaXQgdGhpcy53YXRjaCh7XG4gICAgICAgICAgICBrZXk6IFwiPlwiLFxuICAgICAgICAgICAgaW5pdGlhbGl6ZWRGbjogKCk9PntcbiAgICAgICAgICAgICAgICBkb25lLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIChhc3luYyAoKT0+e1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBlIG9mIGkpe1xuICAgICAgICAgICAgICAgIGlmIChlLm9wZXJhdGlvbiA9PT0gXCJERUxcIiB8fCBlLm9wZXJhdGlvbiA9PT0gXCJQVVJHRVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1Zi5wdXNoKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKS50aGVuKCk7XG4gICAgICAgIGF3YWl0IGRvbmU7XG4gICAgICAgIGkuc3RvcCgpO1xuICAgICAgICBjb25zdCBtaW4gPSBEYXRlLm5vdygpIC0gb2xkZXJNaWxsaXM7XG4gICAgICAgIGNvbnN0IHByb21zID0gYnVmLm1hcCgoZSk9PntcbiAgICAgICAgICAgIGNvbnN0IHN1YmogPSB0aGlzLnN1YmplY3RGb3JLZXkoZS5rZXkpO1xuICAgICAgICAgICAgaWYgKGUuY3JlYXRlZC5nZXRUaW1lKCkgPj0gbWluKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuanNtLnN0cmVhbXMucHVyZ2UodGhpcy5zdHJlYW0sIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBzdWJqLFxuICAgICAgICAgICAgICAgICAgICBrZWVwOiAxXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmpzbS5zdHJlYW1zLnB1cmdlKHRoaXMuc3RyZWFtLCB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogc3ViaixcbiAgICAgICAgICAgICAgICAgICAga2VlcDogMFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcHVyZ2VkID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbXMpO1xuICAgICAgICBwdXJnZWQudW5zaGlmdCh7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgcHVyZ2VkOiAwXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHVyZ2VkLnJlZHVjZSgocHYsIGN2KT0+e1xuICAgICAgICAgICAgcHYucHVyZ2VkICs9IGN2LnB1cmdlZDtcbiAgICAgICAgICAgIHJldHVybiBwdjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9kZWxldGVPclB1cmdlKGssIG9wLCBvcHRzKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNXaWxkY2FyZHMoaykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kb0RlbGV0ZU9yUHVyZ2Uoaywgb3AsIG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZXIgPSBhd2FpdCB0aGlzLmtleXMoayk7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IFtdO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGsgb2YgaXRlcil7XG4gICAgICAgICAgICBidWYucHVzaCh0aGlzLl9kb0RlbGV0ZU9yUHVyZ2Uoaywgb3ApKTtcbiAgICAgICAgICAgIGlmIChidWYubGVuZ3RoID09PSAxMDApIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChidWYpO1xuICAgICAgICAgICAgICAgIGJ1Zi5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChidWYubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoYnVmKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfZG9EZWxldGVPclB1cmdlKGssIG9wLCBvcHRzKSB7XG4gICAgICAgIGNvbnN0IGVrID0gdGhpcy5lbmNvZGVLZXkoayk7XG4gICAgICAgIHRoaXMudmFsaWRhdGVLZXkoZWspO1xuICAgICAgICBjb25zdCBoID0gaGVhZGVycygpO1xuICAgICAgICBoLnNldChrdk9wZXJhdGlvbkhkciwgb3ApO1xuICAgICAgICBpZiAob3AgPT09IFwiUFVSR0VcIikge1xuICAgICAgICAgICAgaC5zZXQoSnNIZWFkZXJzLlJvbGx1cEhkciwgSnNIZWFkZXJzLlJvbGx1cFZhbHVlU3ViamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHM/LnByZXZpb3VzU2VxKSB7XG4gICAgICAgICAgICBoLnNldChQdWJIZWFkZXJzLkV4cGVjdGVkTGFzdFN1YmplY3RTZXF1ZW5jZUhkciwgYCR7b3B0cy5wcmV2aW91c1NlcX1gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmpzLnB1Ymxpc2godGhpcy5zdWJqZWN0Rm9yS2V5KGVrLCB0cnVlKSwgRW1wdHksIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IGhcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9idWlsZENDKGssIGNvbnRlbnQsIG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCBhID0gIUFycmF5LmlzQXJyYXkoaykgPyBbXG4gICAgICAgICAgICBrXG4gICAgICAgIF0gOiBrO1xuICAgICAgICBsZXQgZmlsdGVyX3N1YmplY3RzID0gYS5tYXAoKGspPT57XG4gICAgICAgICAgICBjb25zdCBlayA9IHRoaXMuZW5jb2RlS2V5KGspO1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVNlYXJjaEtleShrKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bGxLZXlOYW1lKGVrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBkZWxpdmVyX3BvbGljeSA9IERlbGl2ZXJQb2xpY3kuTGFzdFBlclN1YmplY3Q7XG4gICAgICAgIGlmIChjb250ZW50ID09PSBLdldhdGNoSW5jbHVkZS5BbGxIaXN0b3J5KSB7XG4gICAgICAgICAgICBkZWxpdmVyX3BvbGljeSA9IERlbGl2ZXJQb2xpY3kuQWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZW50ID09PSBLdldhdGNoSW5jbHVkZS5VcGRhdGVzT25seSkge1xuICAgICAgICAgICAgZGVsaXZlcl9wb2xpY3kgPSBEZWxpdmVyUG9saWN5Lk5ldztcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmlsdGVyX3N1YmplY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChmaWx0ZXJfc3ViamVjdHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBmaWx0ZXJfc3ViamVjdCA9IGZpbHRlcl9zdWJqZWN0c1swXTtcbiAgICAgICAgICAgIGZpbHRlcl9zdWJqZWN0cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBkZWxpdmVyX3BvbGljeSxcbiAgICAgICAgICAgIFwiYWNrX3BvbGljeVwiOiBBY2tQb2xpY3kuTm9uZSxcbiAgICAgICAgICAgIGZpbHRlcl9zdWJqZWN0cyxcbiAgICAgICAgICAgIGZpbHRlcl9zdWJqZWN0LFxuICAgICAgICAgICAgXCJmbG93X2NvbnRyb2xcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiaWRsZV9oZWFydGJlYXRcIjogbmFub3MoNSAqIDEwMDApXG4gICAgICAgIH0sIG9wdHMpO1xuICAgIH1cbiAgICByZW1vdmUoaykge1xuICAgICAgICByZXR1cm4gdGhpcy5wdXJnZShrKTtcbiAgICB9XG4gICAgYXN5bmMgaGlzdG9yeShvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3QgayA9IG9wdHMua2V5ID8/IFwiPlwiO1xuICAgICAgICBjb25zdCBxaSA9IG5ldyBRdWV1ZWRJdGVyYXRvckltcGwoKTtcbiAgICAgICAgY29uc3QgY28gPSB7fTtcbiAgICAgICAgY28uaGVhZGVyc19vbmx5ID0gb3B0cy5oZWFkZXJzX29ubHkgfHwgZmFsc2U7XG4gICAgICAgIGxldCBmbjtcbiAgICAgICAgZm4gPSAoKT0+e1xuICAgICAgICAgICAgcWkuc3RvcCgpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBjb25zdCBjYyA9IHRoaXMuX2J1aWxkQ0MoaywgS3ZXYXRjaEluY2x1ZGUuQWxsSGlzdG9yeSwgY28pO1xuICAgICAgICBjb25zdCBzdWJqID0gY2MuZmlsdGVyX3N1YmplY3Q7XG4gICAgICAgIGNvbnN0IGNvcHRzID0gY29uc3VtZXJPcHRzKGNjKTtcbiAgICAgICAgY29wdHMuYmluZFN0cmVhbSh0aGlzLnN0cmVhbSk7XG4gICAgICAgIGNvcHRzLm9yZGVyZWRDb25zdW1lcigpO1xuICAgICAgICBjb3B0cy5jYWxsYmFjaygoZXJyLCBqbSk9PntcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBxaS5zdG9wKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGptKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IHRoaXMuam1Ub0VudHJ5KGptKTtcbiAgICAgICAgICAgICAgICBxaS5wdXNoKGUpO1xuICAgICAgICAgICAgICAgIHFpLnJlY2VpdmVkKys7XG4gICAgICAgICAgICAgICAgaWYgKGZuICYmIGNvdW50ID4gMCAmJiBxaS5yZWNlaXZlZCA+PSBjb3VudCB8fCBqbS5pbmZvLnBlbmRpbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcWkucHVzaChmbik7XG4gICAgICAgICAgICAgICAgICAgIGZuID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuanMuc3Vic2NyaWJlKHN1YmosIGNvcHRzKTtcbiAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICBjb25zdCB7IGluZm86IHsgbGFzdCB9IH0gPSBzdWI7XG4gICAgICAgICAgICBjb25zdCBleHBlY3QgPSBsYXN0Lm51bV9wZW5kaW5nICsgbGFzdC5kZWxpdmVyZWQuY29uc3VtZXJfc2VxO1xuICAgICAgICAgICAgaWYgKGV4cGVjdCA9PT0gMCB8fCBxaS5yZWNlaXZlZCA+PSBleHBlY3QpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBxaS5zdG9wKGVycik7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgICAgICAgICBmbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvdW50ID0gZXhwZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHFpLl9kYXRhID0gc3ViO1xuICAgICAgICBxaS5pdGVyQ2xvc2VkLnRoZW4oKCk9PntcbiAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3ViLmNsb3NlZC50aGVuKCgpPT57XG4gICAgICAgICAgICBxaS5zdG9wKCk7XG4gICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICBxaS5zdG9wKGVycik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcWk7XG4gICAgfVxuICAgIGNhblNldFdhdGNoZXJOYW1lKCkge1xuICAgICAgICBjb25zdCBqc2kgPSB0aGlzLmpzO1xuICAgICAgICBjb25zdCBuY2kgPSBqc2kubmM7XG4gICAgICAgIGNvbnN0IHsgb2sgfSA9IG5jaS5mZWF0dXJlcy5nZXQoRmVhdHVyZS5KU19ORVdfQ09OU1VNRVJfQ1JFQVRFX0FQSSk7XG4gICAgICAgIHJldHVybiBvaztcbiAgICB9XG4gICAgYXN5bmMgd2F0Y2gob3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGsgPSBvcHRzLmtleSA/PyBcIj5cIjtcbiAgICAgICAgY29uc3QgcWkgPSBuZXcgUXVldWVkSXRlcmF0b3JJbXBsKCk7XG4gICAgICAgIGNvbnN0IGNvID0ge307XG4gICAgICAgIGNvLmhlYWRlcnNfb25seSA9IG9wdHMuaGVhZGVyc19vbmx5IHx8IGZhbHNlO1xuICAgICAgICBsZXQgY29udGVudCA9IEt2V2F0Y2hJbmNsdWRlLkxhc3RWYWx1ZTtcbiAgICAgICAgaWYgKG9wdHMuaW5jbHVkZSA9PT0gS3ZXYXRjaEluY2x1ZGUuQWxsSGlzdG9yeSkge1xuICAgICAgICAgICAgY29udGVudCA9IEt2V2F0Y2hJbmNsdWRlLkFsbEhpc3Rvcnk7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0cy5pbmNsdWRlID09PSBLdldhdGNoSW5jbHVkZS5VcGRhdGVzT25seSkge1xuICAgICAgICAgICAgY29udGVudCA9IEt2V2F0Y2hJbmNsdWRlLlVwZGF0ZXNPbmx5O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlnbm9yZURlbGV0ZXMgPSBvcHRzLmlnbm9yZURlbGV0ZXMgPT09IHRydWU7XG4gICAgICAgIGxldCBmbiA9IG9wdHMuaW5pdGlhbGl6ZWRGbjtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgY29uc3QgY2MgPSB0aGlzLl9idWlsZENDKGssIGNvbnRlbnQsIGNvKTtcbiAgICAgICAgY29uc3Qgc3ViaiA9IGNjLmZpbHRlcl9zdWJqZWN0O1xuICAgICAgICBjb25zdCBjb3B0cyA9IGNvbnN1bWVyT3B0cyhjYyk7XG4gICAgICAgIGlmICh0aGlzLmNhblNldFdhdGNoZXJOYW1lKCkpIHtcbiAgICAgICAgICAgIGNvcHRzLmNvbnN1bWVyTmFtZShudWlkLm5leHQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29wdHMuYmluZFN0cmVhbSh0aGlzLnN0cmVhbSk7XG4gICAgICAgIGlmIChvcHRzLnJlc3VtZUZyb21SZXZpc2lvbiAmJiBvcHRzLnJlc3VtZUZyb21SZXZpc2lvbiA+IDApIHtcbiAgICAgICAgICAgIGNvcHRzLnN0YXJ0U2VxdWVuY2Uob3B0cy5yZXN1bWVGcm9tUmV2aXNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvcHRzLm9yZGVyZWRDb25zdW1lcigpO1xuICAgICAgICBjb3B0cy5jYWxsYmFjaygoZXJyLCBqbSk9PntcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBxaS5zdG9wKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGptKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IHRoaXMuam1Ub0VudHJ5KGptKTtcbiAgICAgICAgICAgICAgICBpZiAoaWdub3JlRGVsZXRlcyAmJiBlLm9wZXJhdGlvbiA9PT0gXCJERUxcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHFpLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgcWkucmVjZWl2ZWQrKztcbiAgICAgICAgICAgICAgICBpZiAoZm4gJiYgKGNvdW50ID4gMCAmJiBxaS5yZWNlaXZlZCA+PSBjb3VudCB8fCBqbS5pbmZvLnBlbmRpbmcgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIHFpLnB1c2goZm4pO1xuICAgICAgICAgICAgICAgICAgICBmbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLmpzLnN1YnNjcmliZShzdWJqLCBjb3B0cyk7XG4gICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgY29uc3QgeyBpbmZvOiB7IGxhc3QgfSB9ID0gc3ViO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ID0gbGFzdC5udW1fcGVuZGluZyArIGxhc3QuZGVsaXZlcmVkLmNvbnN1bWVyX3NlcTtcbiAgICAgICAgICAgIGlmIChleHBlY3QgPT09IDAgfHwgcWkucmVjZWl2ZWQgPj0gZXhwZWN0KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcWkuc3RvcChlcnIpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgICAgICAgICAgZm4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3VudCA9IGV4cGVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxaS5fZGF0YSA9IHN1YjtcbiAgICAgICAgcWkuaXRlckNsb3NlZC50aGVuKCgpPT57XG4gICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN1Yi5jbG9zZWQudGhlbigoKT0+e1xuICAgICAgICAgICAgcWkuc3RvcCgpO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgcWkuc3RvcChlcnIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHFpO1xuICAgIH1cbiAgICBhc3luYyBrZXlzKGsgPSBcIj5cIikge1xuICAgICAgICBjb25zdCBrZXlzID0gbmV3IFF1ZXVlZEl0ZXJhdG9ySW1wbCgpO1xuICAgICAgICBjb25zdCBjYyA9IHRoaXMuX2J1aWxkQ0MoaywgS3ZXYXRjaEluY2x1ZGUuTGFzdFZhbHVlLCB7XG4gICAgICAgICAgICBoZWFkZXJzX29ubHk6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHN1YmogPSBBcnJheS5pc0FycmF5KGspID8gXCI+XCIgOiBjYy5maWx0ZXJfc3ViamVjdDtcbiAgICAgICAgY29uc3QgY29wdHMgPSBjb25zdW1lck9wdHMoY2MpO1xuICAgICAgICBjb3B0cy5iaW5kU3RyZWFtKHRoaXMuc3RyZWFtKTtcbiAgICAgICAgY29wdHMub3JkZXJlZENvbnN1bWVyKCk7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuanMuc3Vic2NyaWJlKHN1YmosIGNvcHRzKTtcbiAgICAgICAgKGFzeW5jICgpPT57XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGptIG9mIHN1Yil7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3AgPSBqbS5oZWFkZXJzPy5nZXQoa3ZPcGVyYXRpb25IZHIpO1xuICAgICAgICAgICAgICAgIGlmIChvcCAhPT0gXCJERUxcIiAmJiBvcCAhPT0gXCJQVVJHRVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZGVjb2RlS2V5KGptLnN1YmplY3Quc3Vic3RyaW5nKHRoaXMucHJlZml4TGVuKSk7XG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoam0uaW5mby5wZW5kaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKS50aGVuKCgpPT57XG4gICAgICAgICAgICBrZXlzLnN0b3AoKTtcbiAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgIGtleXMuc3RvcChlcnIpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc2kgPSBzdWI7XG4gICAgICAgIGlmIChzaS5pbmZvLmxhc3QubnVtX3BlbmRpbmcgPT09IDApIHtcbiAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cbiAgICBwdXJnZUJ1Y2tldChvcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmpzbS5zdHJlYW1zLnB1cmdlKHRoaXMuYnVja2V0TmFtZSgpLCBvcHRzKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuanNtLnN0cmVhbXMuZGVsZXRlKHRoaXMuYnVja2V0TmFtZSgpKTtcbiAgICB9XG4gICAgYXN5bmMgc3RhdHVzKCkge1xuICAgICAgICBjb25zdCBuYyA9IHRoaXMuanMubmM7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXIgPSBuYy5pbmZvPy5jbHVzdGVyID8/IFwiXCI7XG4gICAgICAgIGNvbnN0IGJuID0gdGhpcy5idWNrZXROYW1lKCk7XG4gICAgICAgIGNvbnN0IHNpID0gYXdhaXQgdGhpcy5qc20uc3RyZWFtcy5pbmZvKGJuKTtcbiAgICAgICAgcmV0dXJuIG5ldyBLdlN0YXR1c0ltcGwoc2ksIGNsdXN0ZXIpO1xuICAgIH1cbn1cbmNsYXNzIEt2U3RhdHVzSW1wbCB7XG4gICAgc2k7XG4gICAgY2x1c3RlcjtcbiAgICBjb25zdHJ1Y3RvcihzaSwgY2x1c3RlciA9IFwiXCIpe1xuICAgICAgICB0aGlzLnNpID0gc2k7XG4gICAgICAgIHRoaXMuY2x1c3RlciA9IGNsdXN0ZXI7XG4gICAgfVxuICAgIGdldCBidWNrZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpLmNvbmZpZy5uYW1lLnN0YXJ0c1dpdGgoa3ZQcmVmaXgpID8gdGhpcy5zaS5jb25maWcubmFtZS5zdWJzdHJpbmcoa3ZQcmVmaXgubGVuZ3RoKSA6IHRoaXMuc2kuY29uZmlnLm5hbWU7XG4gICAgfVxuICAgIGdldCB2YWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpLnN0YXRlLm1lc3NhZ2VzO1xuICAgIH1cbiAgICBnZXQgaGlzdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2kuY29uZmlnLm1heF9tc2dzX3Blcl9zdWJqZWN0O1xuICAgIH1cbiAgICBnZXQgdHRsKCkge1xuICAgICAgICByZXR1cm4gbWlsbGlzKHRoaXMuc2kuY29uZmlnLm1heF9hZ2UpO1xuICAgIH1cbiAgICBnZXQgYnVja2V0X2xvY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbHVzdGVyO1xuICAgIH1cbiAgICBnZXQgYmFja2luZ1N0b3JlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaS5jb25maWcuc3RvcmFnZTtcbiAgICB9XG4gICAgZ2V0IHN0b3JhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpLmNvbmZpZy5zdG9yYWdlO1xuICAgIH1cbiAgICBnZXQgcmVwbGljYXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpLmNvbmZpZy5udW1fcmVwbGljYXM7XG4gICAgfVxuICAgIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2kuY29uZmlnLmRlc2NyaXB0aW9uID8/IFwiXCI7XG4gICAgfVxuICAgIGdldCBtYXhCdWNrZXRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaS5jb25maWcubWF4X2J5dGVzO1xuICAgIH1cbiAgICBnZXQgbWF4VmFsdWVTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaS5jb25maWcubWF4X21zZ19zaXplO1xuICAgIH1cbiAgICBnZXQgbWF4X2J5dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaS5jb25maWcubWF4X2J5dGVzO1xuICAgIH1cbiAgICBnZXQgcGxhY2VtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaS5jb25maWcucGxhY2VtZW50IHx8IHtcbiAgICAgICAgICAgIGNsdXN0ZXI6IFwiXCIsXG4gICAgICAgICAgICB0YWdzOiBbXVxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXQgcGxhY2VtZW50Q2x1c3RlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2kuY29uZmlnLnBsYWNlbWVudD8uY2x1c3RlciA/PyBcIlwiO1xuICAgIH1cbiAgICBnZXQgcmVwdWJsaXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaS5jb25maWcucmVwdWJsaXNoID8/IHtcbiAgICAgICAgICAgIHNyYzogXCJcIixcbiAgICAgICAgICAgIGRlc3Q6IFwiXCJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IHN0cmVhbUluZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2kuc3RhdGUuYnl0ZXM7XG4gICAgfVxuICAgIGdldCBtZXRhZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2kuY29uZmlnLm1ldGFkYXRhID8/IHt9O1xuICAgIH1cbiAgICBnZXQgY29tcHJlc3Npb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnNpLmNvbmZpZy5jb21wcmVzc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2kuY29uZmlnLmNvbXByZXNzaW9uICE9PSBTdG9yZUNvbXByZXNzaW9uLk5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmNvbnN0IG9zUHJlZml4ID0gXCJPQkpfXCI7XG5jb25zdCBkaWdlc3RUeXBlID0gXCJTSEEtMjU2PVwiO1xuZnVuY3Rpb24gb2JqZWN0U3RvcmVTdHJlYW1OYW1lKGJ1Y2tldCkge1xuICAgIHZhbGlkYXRlQnVja2V0KGJ1Y2tldCk7XG4gICAgcmV0dXJuIGAke29zUHJlZml4fSR7YnVja2V0fWA7XG59XG5mdW5jdGlvbiBvYmplY3RTdG9yZUJ1Y2tldE5hbWUoc3RyZWFtKSB7XG4gICAgaWYgKHN0cmVhbS5zdGFydHNXaXRoKG9zUHJlZml4KSkge1xuICAgICAgICByZXR1cm4gc3RyZWFtLnN1YnN0cmluZyg0KTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmVhbTtcbn1cbmNsYXNzIE9iamVjdFN0b3JlU3RhdHVzSW1wbCB7XG4gICAgc2k7XG4gICAgYmFja2luZ1N0b3JlO1xuICAgIGNvbnN0cnVjdG9yKHNpKXtcbiAgICAgICAgdGhpcy5zaSA9IHNpO1xuICAgICAgICB0aGlzLmJhY2tpbmdTdG9yZSA9IFwiSmV0U3RyZWFtXCI7XG4gICAgfVxuICAgIGdldCBidWNrZXQoKSB7XG4gICAgICAgIHJldHVybiBvYmplY3RTdG9yZUJ1Y2tldE5hbWUodGhpcy5zaS5jb25maWcubmFtZSk7XG4gICAgfVxuICAgIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2kuY29uZmlnLmRlc2NyaXB0aW9uID8/IFwiXCI7XG4gICAgfVxuICAgIGdldCB0dGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpLmNvbmZpZy5tYXhfYWdlO1xuICAgIH1cbiAgICBnZXQgc3RvcmFnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2kuY29uZmlnLnN0b3JhZ2U7XG4gICAgfVxuICAgIGdldCByZXBsaWNhcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2kuY29uZmlnLm51bV9yZXBsaWNhcztcbiAgICB9XG4gICAgZ2V0IHNlYWxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2kuY29uZmlnLnNlYWxlZDtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpLnN0YXRlLmJ5dGVzO1xuICAgIH1cbiAgICBnZXQgc3RyZWFtSW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2k7XG4gICAgfVxuICAgIGdldCBtZXRhZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2kuY29uZmlnLm1ldGFkYXRhO1xuICAgIH1cbiAgICBnZXQgY29tcHJlc3Npb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnNpLmNvbmZpZy5jb21wcmVzc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2kuY29uZmlnLmNvbXByZXNzaW9uICE9PSBTdG9yZUNvbXByZXNzaW9uLk5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbnZlcnRTdHJlYW1Tb3VyY2VEb21haW4ocykge1xuICAgIGlmIChzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgeyBkb21haW4gfSA9IHM7XG4gICAgaWYgKGRvbWFpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgcyk7XG4gICAgZGVsZXRlIGNvcHkuZG9tYWluO1xuICAgIGlmIChkb21haW4gPT09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIGlmIChjb3B5LmV4dGVybmFsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImRvbWFpbiBhbmQgZXh0ZXJuYWwgYXJlIGJvdGggc2V0XCIpO1xuICAgIH1cbiAgICBjb3B5LmV4dGVybmFsID0ge1xuICAgICAgICBhcGk6IGAkSlMuJHtkb21haW59LkFQSWBcbiAgICB9O1xuICAgIHJldHVybiBjb3B5O1xufVxudmFyIFB1bGxDb25zdW1lclR5cGU7XG4oZnVuY3Rpb24oUHVsbENvbnN1bWVyVHlwZSkge1xuICAgIFB1bGxDb25zdW1lclR5cGVbUHVsbENvbnN1bWVyVHlwZVtcIlVuc2V0XCJdID0gLTFdID0gXCJVbnNldFwiO1xuICAgIFB1bGxDb25zdW1lclR5cGVbUHVsbENvbnN1bWVyVHlwZVtcIkNvbnN1bWVcIl0gPSAwXSA9IFwiQ29uc3VtZVwiO1xuICAgIFB1bGxDb25zdW1lclR5cGVbUHVsbENvbnN1bWVyVHlwZVtcIkZldGNoXCJdID0gMV0gPSBcIkZldGNoXCI7XG59KShQdWxsQ29uc3VtZXJUeXBlIHx8IChQdWxsQ29uc3VtZXJUeXBlID0ge30pKTtcbnZhciBDb25zdW1lckV2ZW50cztcbihmdW5jdGlvbihDb25zdW1lckV2ZW50cykge1xuICAgIENvbnN1bWVyRXZlbnRzW1wiSGVhcnRiZWF0c01pc3NlZFwiXSA9IFwiaGVhcnRiZWF0c19taXNzZWRcIjtcbiAgICBDb25zdW1lckV2ZW50c1tcIkNvbnN1bWVyTm90Rm91bmRcIl0gPSBcImNvbnN1bWVyX25vdF9mb3VuZFwiO1xuICAgIENvbnN1bWVyRXZlbnRzW1wiU3RyZWFtTm90Rm91bmRcIl0gPSBcInN0cmVhbV9ub3RfZm91bmRcIjtcbiAgICBDb25zdW1lckV2ZW50c1tcIkNvbnN1bWVyRGVsZXRlZFwiXSA9IFwiY29uc3VtZXJfZGVsZXRlZFwiO1xuICAgIENvbnN1bWVyRXZlbnRzW1wiT3JkZXJlZENvbnN1bWVyUmVjcmVhdGVkXCJdID0gXCJvcmRlcmVkX2NvbnN1bWVyX3JlY3JlYXRlZFwiO1xuICAgIENvbnN1bWVyRXZlbnRzW1wiTm9SZXNwb25kZXJzXCJdID0gXCJub19yZXNwb25kZXJzXCI7XG59KShDb25zdW1lckV2ZW50cyB8fCAoQ29uc3VtZXJFdmVudHMgPSB7fSkpO1xudmFyIENvbnN1bWVyRGVidWdFdmVudHM7XG4oZnVuY3Rpb24oQ29uc3VtZXJEZWJ1Z0V2ZW50cykge1xuICAgIENvbnN1bWVyRGVidWdFdmVudHNbXCJEZWJ1Z0V2ZW50XCJdID0gXCJkZWJ1Z1wiO1xuICAgIENvbnN1bWVyRGVidWdFdmVudHNbXCJEaXNjYXJkXCJdID0gXCJkaXNjYXJkXCI7XG4gICAgQ29uc3VtZXJEZWJ1Z0V2ZW50c1tcIlJlc2V0XCJdID0gXCJyZXNldFwiO1xuICAgIENvbnN1bWVyRGVidWdFdmVudHNbXCJOZXh0XCJdID0gXCJuZXh0XCI7XG59KShDb25zdW1lckRlYnVnRXZlbnRzIHx8IChDb25zdW1lckRlYnVnRXZlbnRzID0ge30pKTtcbmNvbnN0IEFDSyA9IFVpbnQ4QXJyYXkub2YoNDMsIDY1LCA2NywgNzUpO1xuY29uc3QgTkFLID0gVWludDhBcnJheS5vZig0NSwgNzgsIDY1LCA3NSk7XG5jb25zdCBXUEkgPSBVaW50OEFycmF5Lm9mKDQzLCA4NywgODAsIDczKTtcbmNvbnN0IE5YVCA9IFVpbnQ4QXJyYXkub2YoNDMsIDc4LCA4OCwgODQpO1xuY29uc3QgVEVSTSA9IFVpbnQ4QXJyYXkub2YoNDMsIDg0LCA2OSwgODIsIDc3KTtcbmNvbnN0IFNQQUNFID0gVWludDhBcnJheS5vZigzMik7XG5mdW5jdGlvbiB0b0pzTXNnKG0sIGFja1RpbWVvdXQgPSA1MDAwKSB7XG4gICAgcmV0dXJuIG5ldyBKc01zZ0ltcGwobSwgYWNrVGltZW91dCk7XG59XG5jbGFzcyBQdWxsQ29uc3VtZXJNZXNzYWdlc0ltcGwgZXh0ZW5kcyBRdWV1ZWRJdGVyYXRvckltcGwge1xuICAgIGNvbnN1bWVyO1xuICAgIG9wdHM7XG4gICAgc3ViO1xuICAgIG1vbml0b3I7XG4gICAgcGVuZGluZztcbiAgICBpbmJveDtcbiAgICByZWZpbGxpbmc7XG4gICAgcG9uZztcbiAgICBjYWxsYmFjaztcbiAgICB0aW1lb3V0O1xuICAgIGNsZWFudXBIYW5kbGVyO1xuICAgIGxpc3RlbmVycztcbiAgICBzdGF0dXNJdGVyYXRvcjtcbiAgICBmb3JPcmRlcmVkQ29uc3VtZXI7XG4gICAgcmVzZXRIYW5kbGVyO1xuICAgIGFib3J0T25NaXNzaW5nUmVzb3VyY2U7XG4gICAgYmluZDtcbiAgICBpbkJhY2tPZmY7XG4gICAgY29uc3RydWN0b3IoYywgb3B0cywgcmVmaWxsaW5nID0gZmFsc2Upe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbnN1bWVyID0gYztcbiAgICAgICAgY29uc3QgY29wdHMgPSBvcHRzO1xuICAgICAgICB0aGlzLm9wdHMgPSB0aGlzLnBhcnNlT3B0aW9ucyhvcHRzLCByZWZpbGxpbmcpO1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY29wdHMuY2FsbGJhY2sgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5ub0l0ZXJhdG9yID0gdHlwZW9mIHRoaXMuY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgdGhpcy5tb25pdG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5wb25nID0gbnVsbDtcbiAgICAgICAgdGhpcy5wZW5kaW5nID0ge1xuICAgICAgICAgICAgbXNnczogMCxcbiAgICAgICAgICAgIGJ5dGVzOiAwLFxuICAgICAgICAgICAgcmVxdWVzdHM6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZWZpbGxpbmcgPSByZWZpbGxpbmc7XG4gICAgICAgIHRoaXMudGltZW91dCA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5ib3ggPSBjcmVhdGVJbmJveChjLmFwaS5uYy5vcHRpb25zLmluYm94UHJlZml4KTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JPcmRlcmVkQ29uc3VtZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hYm9ydE9uTWlzc2luZ1Jlc291cmNlID0gY29wdHMuYWJvcnRfb25fbWlzc2luZ19yZXNvdXJjZSA9PT0gdHJ1ZTtcbiAgICAgICAgdGhpcy5iaW5kID0gY29wdHMuYmluZCA9PT0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pbkJhY2tPZmYgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgY29uc3QgeyBtYXhfbWVzc2FnZXMsIG1heF9ieXRlcywgaWRsZV9oZWFydGJlYXQsIHRocmVzaG9sZF9ieXRlcywgdGhyZXNob2xkX21lc3NhZ2VzIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIHRoaXMuY2xvc2VkKCkudGhlbigoZXJyKT0+e1xuICAgICAgICAgICAgaWYgKHRoaXMuY2xlYW51cEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFudXBIYW5kbGVyKGVycik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoX2Vycikge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgc3ViIH0gPSB0aGlzO1xuICAgICAgICBpZiAoc3ViKSB7XG4gICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1YiA9IHRoaXMuY29uc3VtZXIuYXBpLm5jLnN1YnNjcmliZSh0aGlzLmluYm94LCB7XG4gICAgICAgICAgICBjYWxsYmFjazogKGVyciwgbXNnKT0+e1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5tb25pdG9yPy53b3JrKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNQcm90b2NvbCA9IG1zZy5zdWJqZWN0ID09PSB0aGlzLmluYm94O1xuICAgICAgICAgICAgICAgIGlmIChpc1Byb3RvY29sKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0hlYXJ0YmVhdE1zZyhtc2cpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IG1zZy5oZWFkZXJzPy5jb2RlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IG1zZy5oZWFkZXJzPy5kZXNjcmlwdGlvbj8udG9Mb3dlckNhc2UoKSB8fCBcInVua25vd25cIjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBtc2dzTGVmdCwgYnl0ZXNMZWZ0IH0gPSB0aGlzLnBhcnNlRGlzY2FyZChtc2cuaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtc2dzTGVmdCA+IDAgfHwgYnl0ZXNMZWZ0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nLm1zZ3MgLT0gbXNnc0xlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmcuYnl0ZXMgLT0gYnl0ZXNMZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nLnJlcXVlc3RzLS07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeShDb25zdW1lckRlYnVnRXZlbnRzLkRpc2NhcmQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtc2dzTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlc0xlZnRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IDQwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcChuZXcgTmF0c0Vycm9yKGRlc2NyaXB0aW9uLCBgJHtjb2RlfWApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDQwOSAmJiBkZXNjcmlwdGlvbiA9PT0gXCJjb25zdW1lciBkZWxldGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeShDb25zdW1lckV2ZW50cy5Db25zdW1lckRlbGV0ZWQsIGAke2NvZGV9ICR7ZGVzY3JpcHRpb259YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJlZmlsbGluZyB8fCB0aGlzLmFib3J0T25NaXNzaW5nUmVzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgTmF0c0Vycm9yKGRlc2NyaXB0aW9uLCBgJHtjb2RlfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3AoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSA1MDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeShDb25zdW1lckV2ZW50cy5Ob1Jlc3BvbmRlcnMsIGAke2NvZGV9IE5vIFJlc3BvbmRlcnNgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucmVmaWxsaW5nIHx8IHRoaXMuYWJvcnRPbk1pc3NpbmdSZXNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBOYXRzRXJyb3IoXCJubyByZXNwb25kZXJzXCIsIGAke2NvZGV9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5KENvbnN1bWVyRGVidWdFdmVudHMuRGVidWdFdmVudCwgYCR7Y29kZX0gJHtkZXNjcmlwdGlvbn1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3B1c2godG9Kc01zZyhtc2csIHRoaXMuY29uc3VtZXIuYXBpLnRpbWVvdXQpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNlaXZlZCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nLm1zZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZy5tc2dzLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZy5ieXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nLmJ5dGVzIC09IG1zZy5zaXplKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZy5tc2dzID09PSAwICYmIHRoaXMucGVuZGluZy5ieXRlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmcucmVxdWVzdHMgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWZpbGxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heF9tZXNzYWdlcyAmJiB0aGlzLnBlbmRpbmcubXNncyA8PSB0aHJlc2hvbGRfbWVzc2FnZXMgfHwgbWF4X2J5dGVzICYmIHRoaXMucGVuZGluZy5ieXRlcyA8PSB0aHJlc2hvbGRfYnl0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gdGhpcy5wdWxsT3B0aW9ucygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWxsKGJhdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wZW5kaW5nLnJlcXVlc3RzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3B1c2goKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN1Yi5jbG9zZWQudGhlbigoKT0+e1xuICAgICAgICAgICAgaWYgKHRoaXMuc3ViLmRyYWluaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHVzaCgoKT0+e1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpZGxlX2hlYXJ0YmVhdCkge1xuICAgICAgICAgICAgdGhpcy5tb25pdG9yID0gbmV3IElkbGVIZWFydGJlYXRNb25pdG9yKGlkbGVfaGVhcnRiZWF0LCAoZGF0YSk9PntcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeShDb25zdW1lckV2ZW50cy5IZWFydGJlYXRzTWlzc2VkLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0UGVuZGluZygpLnRoZW4oKCk9Pnt9KS5jYXRjaCgoKT0+e30pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBtYXhPdXQ6IDJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIChhc3luYyAoKT0+e1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gdGhpcy5jb25zdW1lci5hcGkubmMuc3RhdHVzKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c0l0ZXJhdG9yID0gc3RhdHVzO1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBzIG9mIHN0YXR1cyl7XG4gICAgICAgICAgICAgICAgc3dpdGNoKHMudHlwZSl7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRXZlbnRzLkRpc2Nvbm5lY3Q6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbml0b3I/LmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRXZlbnRzLlJlY29ubmVjdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRQZW5kaW5nKCkudGhlbigob2spPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9uaXRvcj8ucmVzdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKCgpPT57fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHRoaXMucHVsbCh0aGlzLnB1bGxPcHRpb25zKCkpO1xuICAgIH1cbiAgICBfcHVzaChyKSB7XG4gICAgICAgIGlmICghdGhpcy5jYWxsYmFjaykge1xuICAgICAgICAgICAgc3VwZXIucHVzaChyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGZuID0gdHlwZW9mIHIgPT09IFwiZnVuY3Rpb25cIiA/IHIgOiBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIWZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2socik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3AoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBub3RpZnkodHlwZSwgZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5saXN0ZW5lcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgKCgpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaCgobCk9PntcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGwucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldFBlbmRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbmQgPyB0aGlzLnJlc2V0UGVuZGluZ05vSW5mbygpIDogdGhpcy5yZXNldFBlbmRpbmdXaXRoSW5mbygpO1xuICAgIH1cbiAgICByZXNldFBlbmRpbmdOb0luZm8oKSB7XG4gICAgICAgIHRoaXMucGVuZGluZy5tc2dzID0gMDtcbiAgICAgICAgdGhpcy5wZW5kaW5nLmJ5dGVzID0gMDtcbiAgICAgICAgdGhpcy5wZW5kaW5nLnJlcXVlc3RzID0gMDtcbiAgICAgICAgdGhpcy5wdWxsKHRoaXMucHVsbE9wdGlvbnMoKSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgfVxuICAgIGFzeW5jIHJlc2V0UGVuZGluZ1dpdGhJbmZvKCkge1xuICAgICAgICBpZiAodGhpcy5pbkJhY2tPZmYpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbm90Rm91bmQgPSAwO1xuICAgICAgICBsZXQgc3RyZWFtTm90Rm91bmQgPSAwO1xuICAgICAgICBjb25zdCBibyA9IGJhY2tvZmYoW1xuICAgICAgICAgICAgdGhpcy5vcHRzLmV4cGlyZXNcbiAgICAgICAgXSk7XG4gICAgICAgIGxldCBhdHRlbXB0ID0gMDtcbiAgICAgICAgd2hpbGUodHJ1ZSl7XG4gICAgICAgICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uc3VtZXIuYXBpLm5jLmlzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiYWJvcnRpbmcgcmVzZXRQZW5kaW5nIC0gY29ubmVjdGlvbiBpcyBjbG9zZWRcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNvbnN1bWVyLmluZm8oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluQmFja09mZiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG5vdEZvdW5kID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmcubXNncyA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nLmJ5dGVzID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmcucmVxdWVzdHMgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMucHVsbCh0aGlzLnB1bGxPcHRpb25zKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyci5tZXNzYWdlID09PSBcInN0cmVhbSBub3QgZm91bmRcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW1Ob3RGb3VuZCsrO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeShDb25zdW1lckV2ZW50cy5TdHJlYW1Ob3RGb3VuZCwgc3RyZWFtTm90Rm91bmQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucmVmaWxsaW5nIHx8IHRoaXMuYWJvcnRPbk1pc3NpbmdSZXNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVyci5tZXNzYWdlID09PSBcImNvbnN1bWVyIG5vdCBmb3VuZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kKys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5KENvbnN1bWVyRXZlbnRzLkNvbnN1bWVyTm90Rm91bmQsIG5vdEZvdW5kKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzZXRIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRIYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChfKSB7fVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5yZWZpbGxpbmcgfHwgdGhpcy5hYm9ydE9uTWlzc2luZ1Jlc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3AoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5mb3JPcmRlcmVkQ29uc3VtZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kID0gMDtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtTm90Rm91bmQgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmluQmFja09mZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgdG8gPSBiby5iYWNrb2ZmKGF0dGVtcHQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlID0gZGVsYXkodG8pO1xuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgICAgICAgICAgIGRlLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVyLmFwaS5uYy5jbG9zZWQoKVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIGRlLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIGF0dGVtcHQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwdWxsKG9wdHMpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nLmJ5dGVzICs9IG9wdHMubWF4X2J5dGVzID8/IDA7XG4gICAgICAgIHRoaXMucGVuZGluZy5tc2dzICs9IG9wdHMuYmF0Y2ggPz8gMDtcbiAgICAgICAgdGhpcy5wZW5kaW5nLnJlcXVlc3RzKys7XG4gICAgICAgIGNvbnN0IG5jID0gdGhpcy5jb25zdW1lci5hcGkubmM7XG4gICAgICAgIHRoaXMuX3B1c2goKCk9PntcbiAgICAgICAgICAgIG5jLnB1Ymxpc2goYCR7dGhpcy5jb25zdW1lci5hcGkucHJlZml4fS5DT05TVU1FUi5NU0cuTkVYVC4ke3RoaXMuY29uc3VtZXIuc3RyZWFtfS4ke3RoaXMuY29uc3VtZXIubmFtZX1gLCB0aGlzLmNvbnN1bWVyLmFwaS5qYy5lbmNvZGUob3B0cyksIHtcbiAgICAgICAgICAgICAgICByZXBseTogdGhpcy5pbmJveFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeShDb25zdW1lckRlYnVnRXZlbnRzLk5leHQsIG9wdHMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcHVsbE9wdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IGJhdGNoID0gdGhpcy5vcHRzLm1heF9tZXNzYWdlcyAtIHRoaXMucGVuZGluZy5tc2dzO1xuICAgICAgICBjb25zdCBtYXhfYnl0ZXMgPSB0aGlzLm9wdHMubWF4X2J5dGVzIC0gdGhpcy5wZW5kaW5nLmJ5dGVzO1xuICAgICAgICBjb25zdCBpZGxlX2hlYXJ0YmVhdCA9IG5hbm9zKHRoaXMub3B0cy5pZGxlX2hlYXJ0YmVhdCk7XG4gICAgICAgIGNvbnN0IGV4cGlyZXMgPSBuYW5vcyh0aGlzLm9wdHMuZXhwaXJlcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBiYXRjaCxcbiAgICAgICAgICAgIG1heF9ieXRlcyxcbiAgICAgICAgICAgIGlkbGVfaGVhcnRiZWF0LFxuICAgICAgICAgICAgZXhwaXJlc1xuICAgICAgICB9O1xuICAgIH1cbiAgICBwYXJzZURpc2NhcmQoaGVhZGVycykge1xuICAgICAgICBjb25zdCBkaXNjYXJkID0ge1xuICAgICAgICAgICAgbXNnc0xlZnQ6IDAsXG4gICAgICAgICAgICBieXRlc0xlZnQ6IDBcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbXNnc0xlZnQgPSBoZWFkZXJzPy5nZXQoSnNIZWFkZXJzLlBlbmRpbmdNZXNzYWdlc0hkcik7XG4gICAgICAgIGlmIChtc2dzTGVmdCkge1xuICAgICAgICAgICAgZGlzY2FyZC5tc2dzTGVmdCA9IHBhcnNlSW50KG1zZ3NMZWZ0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBieXRlc0xlZnQgPSBoZWFkZXJzPy5nZXQoSnNIZWFkZXJzLlBlbmRpbmdCeXRlc0hkcik7XG4gICAgICAgIGlmIChieXRlc0xlZnQpIHtcbiAgICAgICAgICAgIGRpc2NhcmQuYnl0ZXNMZWZ0ID0gcGFyc2VJbnQoYnl0ZXNMZWZ0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlzY2FyZDtcbiAgICB9XG4gICAgdHJhY2tUaW1lb3V0KHQpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gdDtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVyQ2xvc2VkO1xuICAgIH1cbiAgICBjbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZXJDbG9zZWQ7XG4gICAgfVxuICAgIGNsZWFyVGltZXJzKCkge1xuICAgICAgICB0aGlzLm1vbml0b3I/LmNhbmNlbCgpO1xuICAgICAgICB0aGlzLm1vbml0b3IgPSBudWxsO1xuICAgICAgICB0aGlzLnRpbWVvdXQ/LmNhbmNlbCgpO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgICBzZXRDbGVhbnVwSGFuZGxlcihmbikge1xuICAgICAgICB0aGlzLmNsZWFudXBIYW5kbGVyID0gZm47XG4gICAgfVxuICAgIHN0b3AoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1Yj8udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVycygpO1xuICAgICAgICB0aGlzLnN0YXR1c0l0ZXJhdG9yPy5zdG9wKCk7XG4gICAgICAgIHRoaXMuX3B1c2goKCk9PntcbiAgICAgICAgICAgIHN1cGVyLnN0b3AoZXJyKTtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goKG4pPT57XG4gICAgICAgICAgICAgICAgbi5zdG9wKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBhcnNlT3B0aW9ucyhvcHRzLCByZWZpbGxpbmcgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBhcmdzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgYXJncy5tYXhfbWVzc2FnZXMgPSBhcmdzLm1heF9tZXNzYWdlcyB8fCAwO1xuICAgICAgICBhcmdzLm1heF9ieXRlcyA9IGFyZ3MubWF4X2J5dGVzIHx8IDA7XG4gICAgICAgIGlmIChhcmdzLm1heF9tZXNzYWdlcyAhPT0gMCAmJiBhcmdzLm1heF9ieXRlcyAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvbmx5IHNwZWNpZnkgb25lIG9mIG1heF9tZXNzYWdlcyBvciBtYXhfYnl0ZXNgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJncy5tYXhfbWVzc2FnZXMgPT09IDApIHtcbiAgICAgICAgICAgIGFyZ3MubWF4X21lc3NhZ2VzID0gMTAwO1xuICAgICAgICB9XG4gICAgICAgIGFyZ3MuZXhwaXJlcyA9IGFyZ3MuZXhwaXJlcyB8fCAzMF8wMDA7XG4gICAgICAgIGlmIChhcmdzLmV4cGlyZXMgPCAxMDAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHBpcmVzIHNob3VsZCBiZSBhdCBsZWFzdCAxMDAwbXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgYXJncy5pZGxlX2hlYXJ0YmVhdCA9IGFyZ3MuaWRsZV9oZWFydGJlYXQgfHwgYXJncy5leHBpcmVzIC8gMjtcbiAgICAgICAgYXJncy5pZGxlX2hlYXJ0YmVhdCA9IGFyZ3MuaWRsZV9oZWFydGJlYXQgPiAzMF8wMDAgPyAzMF8wMDAgOiBhcmdzLmlkbGVfaGVhcnRiZWF0O1xuICAgICAgICBpZiAocmVmaWxsaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBtaW5Nc2dzID0gTWF0aC5yb3VuZChhcmdzLm1heF9tZXNzYWdlcyAqIC43NSkgfHwgMTtcbiAgICAgICAgICAgIGFyZ3MudGhyZXNob2xkX21lc3NhZ2VzID0gYXJncy50aHJlc2hvbGRfbWVzc2FnZXMgfHwgbWluTXNncztcbiAgICAgICAgICAgIGNvbnN0IG1pbkJ5dGVzID0gTWF0aC5yb3VuZChhcmdzLm1heF9ieXRlcyAqIC43NSkgfHwgMTtcbiAgICAgICAgICAgIGFyZ3MudGhyZXNob2xkX2J5dGVzID0gYXJncy50aHJlc2hvbGRfYnl0ZXMgfHwgbWluQnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfVxuICAgIHN0YXR1cygpIHtcbiAgICAgICAgY29uc3QgaXRlciA9IG5ldyBRdWV1ZWRJdGVyYXRvckltcGwoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaChpdGVyKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShpdGVyKTtcbiAgICB9XG59XG5jbGFzcyBPcmRlcmVkQ29uc3VtZXJNZXNzYWdlcyBleHRlbmRzIFF1ZXVlZEl0ZXJhdG9ySW1wbCB7XG4gICAgc3JjO1xuICAgIGxpc3RlbmVycztcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgIH1cbiAgICBzZXRTb3VyY2Uoc3JjKSB7XG4gICAgICAgIGlmICh0aGlzLnNyYykge1xuICAgICAgICAgICAgdGhpcy5zcmMucmVzZXRIYW5kbGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5zcmMuc2V0Q2xlYW51cEhhbmRsZXIoKTtcbiAgICAgICAgICAgIHRoaXMuc3JjLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNyYyA9IHNyYztcbiAgICAgICAgdGhpcy5zcmMuc2V0Q2xlYW51cEhhbmRsZXIoKGVycik9PntcbiAgICAgICAgICAgIHRoaXMuc3RvcChlcnIgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIChhc3luYyAoKT0+e1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gYXdhaXQgdGhpcy5zcmMuc3RhdHVzKCk7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHMgb2Ygc3RhdHVzKXtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeShzLnR5cGUsIHMuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCkuY2F0Y2goKCk9Pnt9KTtcbiAgICB9XG4gICAgbm90aWZ5KHR5cGUsIGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICgoKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goKGwpPT57XG4gICAgICAgICAgICAgICAgICAgIGlmICghbC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RvcChlcnIpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3JjPy5zdG9wKGVycik7XG4gICAgICAgIHN1cGVyLnN0b3AoZXJyKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaCgobik9PntcbiAgICAgICAgICAgIG4uc3RvcCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVyQ2xvc2VkO1xuICAgIH1cbiAgICBjbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZXJDbG9zZWQ7XG4gICAgfVxuICAgIHN0YXR1cygpIHtcbiAgICAgICAgY29uc3QgaXRlciA9IG5ldyBRdWV1ZWRJdGVyYXRvckltcGwoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaChpdGVyKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShpdGVyKTtcbiAgICB9XG59XG5jbGFzcyBQdWxsQ29uc3VtZXJJbXBsIHtcbiAgICBhcGk7XG4gICAgX2luZm87XG4gICAgc3RyZWFtO1xuICAgIG5hbWU7XG4gICAgY29uc3RydWN0b3IoYXBpLCBpbmZvKXtcbiAgICAgICAgdGhpcy5hcGkgPSBhcGk7XG4gICAgICAgIHRoaXMuX2luZm8gPSBpbmZvO1xuICAgICAgICB0aGlzLnN0cmVhbSA9IGluZm8uc3RyZWFtX25hbWU7XG4gICAgICAgIHRoaXMubmFtZSA9IGluZm8ubmFtZTtcbiAgICB9XG4gICAgY29uc3VtZShvcHRzID0ge1xuICAgICAgICBtYXhfbWVzc2FnZXM6IDEwMCxcbiAgICAgICAgZXhwaXJlczogMzBfMDAwXG4gICAgfSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBQdWxsQ29uc3VtZXJNZXNzYWdlc0ltcGwodGhpcywgb3B0cywgdHJ1ZSkpO1xuICAgIH1cbiAgICBmZXRjaChvcHRzID0ge1xuICAgICAgICBtYXhfbWVzc2FnZXM6IDEwMCxcbiAgICAgICAgZXhwaXJlczogMzBfMDAwXG4gICAgfSkge1xuICAgICAgICBjb25zdCBtID0gbmV3IFB1bGxDb25zdW1lck1lc3NhZ2VzSW1wbCh0aGlzLCBvcHRzLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IHRvID0gTWF0aC5yb3VuZChtLm9wdHMuZXhwaXJlcyAqIDEuMDUpO1xuICAgICAgICBjb25zdCB0aW1lciA9IHRpbWVvdXQodG8pO1xuICAgICAgICBtLmNsb3NlZCgpLmNhdGNoKCgpPT57fSkuZmluYWxseSgoKT0+e1xuICAgICAgICAgICAgdGltZXIuY2FuY2VsKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aW1lci5jYXRjaCgoKT0+e1xuICAgICAgICAgICAgbS5jbG9zZSgpLmNhdGNoKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBtLnRyYWNrVGltZW91dCh0aW1lcik7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobSk7XG4gICAgfVxuICAgIG5leHQob3B0cyA9IHtcbiAgICAgICAgZXhwaXJlczogMzBfMDAwXG4gICAgfSkge1xuICAgICAgICBjb25zdCBkID0gZGVmZXJyZWQoKTtcbiAgICAgICAgY29uc3QgZm9wdHMgPSBvcHRzO1xuICAgICAgICBmb3B0cy5tYXhfbWVzc2FnZXMgPSAxO1xuICAgICAgICBjb25zdCBpdGVyID0gbmV3IFB1bGxDb25zdW1lck1lc3NhZ2VzSW1wbCh0aGlzLCBmb3B0cywgZmFsc2UpO1xuICAgICAgICBjb25zdCB0byA9IE1hdGgucm91bmQoaXRlci5vcHRzLmV4cGlyZXMgKiAxLjA1KTtcbiAgICAgICAgaWYgKHRvID49IDYwXzAwMCkge1xuICAgICAgICAgICAgKGFzeW5jICgpPT57XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBzIG9mIChhd2FpdCBpdGVyLnN0YXR1cygpKSl7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLnR5cGUgPT09IENvbnN1bWVyRXZlbnRzLkhlYXJ0YmVhdHNNaXNzZWQgJiYgcy5kYXRhID49IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQucmVqZWN0KG5ldyBFcnJvcihcImNvbnN1bWVyIG1pc3NlZCBoZWFydGJlYXRzXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKS5jYXRjaCgpO1xuICAgICAgICB9XG4gICAgICAgIChhc3luYyAoKT0+e1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBtIG9mIGl0ZXIpe1xuICAgICAgICAgICAgICAgIGQucmVzb2x2ZShtKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKS5jYXRjaCgoKT0+e30pO1xuICAgICAgICBjb25zdCB0aW1lciA9IHRpbWVvdXQodG8pO1xuICAgICAgICBpdGVyLmNsb3NlZCgpLnRoZW4oKGVycik9PntcbiAgICAgICAgICAgIGVyciA/IGQucmVqZWN0KGVycikgOiBkLnJlc29sdmUobnVsbCk7XG4gICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICBkLnJlamVjdChlcnIpO1xuICAgICAgICB9KS5maW5hbGx5KCgpPT57XG4gICAgICAgICAgICB0aW1lci5jYW5jZWwoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRpbWVyLmNhdGNoKChfZXJyKT0+e1xuICAgICAgICAgICAgZC5yZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgaXRlci5jbG9zZSgpLmNhdGNoKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpdGVyLnRyYWNrVGltZW91dCh0aW1lcik7XG4gICAgICAgIHJldHVybiBkO1xuICAgIH1cbiAgICBkZWxldGUoKSB7XG4gICAgICAgIGNvbnN0IHsgc3RyZWFtX25hbWUsIG5hbWUgfSA9IHRoaXMuX2luZm87XG4gICAgICAgIHJldHVybiB0aGlzLmFwaS5kZWxldGUoc3RyZWFtX25hbWUsIG5hbWUpO1xuICAgIH1cbiAgICBpbmZvKGNhY2hlZCA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5faW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdHJlYW1fbmFtZSwgbmFtZSB9ID0gdGhpcy5faW5mbztcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpLmluZm8oc3RyZWFtX25hbWUsIG5hbWUpLnRoZW4oKGNpKT0+e1xuICAgICAgICAgICAgdGhpcy5faW5mbyA9IGNpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luZm87XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIE9yZGVyZWRQdWxsQ29uc3VtZXJJbXBsIHtcbiAgICBhcGk7XG4gICAgY29uc3VtZXJPcHRzO1xuICAgIGNvbnN1bWVyO1xuICAgIG9wdHM7XG4gICAgY3Vyc29yO1xuICAgIHN0cmVhbTtcbiAgICBuYW1lUHJlZml4O1xuICAgIHNlcmlhbDtcbiAgICBjdXJyZW50Q29uc3VtZXI7XG4gICAgdXNlckNhbGxiYWNrO1xuICAgIGl0ZXI7XG4gICAgdHlwZTtcbiAgICBzdGFydFNlcTtcbiAgICBtYXhJbml0aWFsUmVzZXQ7XG4gICAgY29uc3RydWN0b3IoYXBpLCBzdHJlYW0sIG9wdHMgPSB7fSl7XG4gICAgICAgIHRoaXMuYXBpID0gYXBpO1xuICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSB7XG4gICAgICAgICAgICBzdHJlYW1fc2VxOiAxLFxuICAgICAgICAgICAgZGVsaXZlcl9zZXE6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5uYW1lUHJlZml4ID0gbnVpZC5uZXh0KCk7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5uYW1lX3ByZWZpeCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbWluVmFsaWRhdGlvbihcIm5hbWVfcHJlZml4XCIsIG9wdHMubmFtZV9wcmVmaXgpO1xuICAgICAgICAgICAgdGhpcy5uYW1lUHJlZml4ID0gb3B0cy5uYW1lX3ByZWZpeCArIHRoaXMubmFtZVByZWZpeDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlcmlhbCA9IDA7XG4gICAgICAgIHRoaXMuY3VycmVudENvbnN1bWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy51c2VyQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLml0ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnR5cGUgPSBQdWxsQ29uc3VtZXJUeXBlLlVuc2V0O1xuICAgICAgICB0aGlzLmNvbnN1bWVyT3B0cyA9IG9wdHM7XG4gICAgICAgIHRoaXMubWF4SW5pdGlhbFJlc2V0ID0gMzA7XG4gICAgICAgIHRoaXMuc3RhcnRTZXEgPSB0aGlzLmNvbnN1bWVyT3B0cy5vcHRfc3RhcnRfc2VxIHx8IDA7XG4gICAgICAgIHRoaXMuY3Vyc29yLnN0cmVhbV9zZXEgPSB0aGlzLnN0YXJ0U2VxID4gMCA/IHRoaXMuc3RhcnRTZXEgLSAxIDogMDtcbiAgICB9XG4gICAgZ2V0Q29uc3VtZXJPcHRzKHNlcSkge1xuICAgICAgICB0aGlzLnNlcmlhbCsrO1xuICAgICAgICBjb25zdCBuYW1lID0gYCR7dGhpcy5uYW1lUHJlZml4fV8ke3RoaXMuc2VyaWFsfWA7XG4gICAgICAgIHNlcSA9IHNlcSA9PT0gMCA/IDEgOiBzZXE7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBkZWxpdmVyX3BvbGljeTogRGVsaXZlclBvbGljeS5TdGFydFNlcXVlbmNlLFxuICAgICAgICAgICAgb3B0X3N0YXJ0X3NlcTogc2VxLFxuICAgICAgICAgICAgYWNrX3BvbGljeTogQWNrUG9saWN5Lk5vbmUsXG4gICAgICAgICAgICBpbmFjdGl2ZV90aHJlc2hvbGQ6IG5hbm9zKDUgKiA2MCAqIDEwMDApLFxuICAgICAgICAgICAgbnVtX3JlcGxpY2FzOiAxXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmNvbnN1bWVyT3B0cy5oZWFkZXJzX29ubHkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbmZpZy5oZWFkZXJzX29ubHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuY29uc3VtZXJPcHRzLmZpbHRlclN1YmplY3RzKSkge1xuICAgICAgICAgICAgY29uZmlnLmZpbHRlcl9zdWJqZWN0cyA9IHRoaXMuY29uc3VtZXJPcHRzLmZpbHRlclN1YmplY3RzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5jb25zdW1lck9wdHMuZmlsdGVyU3ViamVjdHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbmZpZy5maWx0ZXJfc3ViamVjdCA9IHRoaXMuY29uc3VtZXJPcHRzLmZpbHRlclN1YmplY3RzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbnN1bWVyT3B0cy5yZXBsYXlfcG9saWN5KSB7XG4gICAgICAgICAgICBjb25maWcucmVwbGF5X3BvbGljeSA9IHRoaXMuY29uc3VtZXJPcHRzLnJlcGxheV9wb2xpY3k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlcSA9PT0gdGhpcy5zdGFydFNlcSArIDEpIHtcbiAgICAgICAgICAgIGNvbmZpZy5kZWxpdmVyX3BvbGljeSA9IHRoaXMuY29uc3VtZXJPcHRzLmRlbGl2ZXJfcG9saWN5IHx8IERlbGl2ZXJQb2xpY3kuU3RhcnRTZXF1ZW5jZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnN1bWVyT3B0cy5kZWxpdmVyX3BvbGljeSA9PT0gRGVsaXZlclBvbGljeS5MYXN0UGVyU3ViamVjdCB8fCB0aGlzLmNvbnN1bWVyT3B0cy5kZWxpdmVyX3BvbGljeSA9PT0gRGVsaXZlclBvbGljeS5OZXcgfHwgdGhpcy5jb25zdW1lck9wdHMuZGVsaXZlcl9wb2xpY3kgPT09IERlbGl2ZXJQb2xpY3kuTGFzdCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjb25maWcub3B0X3N0YXJ0X3NlcTtcbiAgICAgICAgICAgICAgICBjb25maWcuZGVsaXZlcl9wb2xpY3kgPSB0aGlzLmNvbnN1bWVyT3B0cy5kZWxpdmVyX3BvbGljeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcuZGVsaXZlcl9wb2xpY3kgPT09IERlbGl2ZXJQb2xpY3kuTGFzdFBlclN1YmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5maWx0ZXJfc3ViamVjdHMgPT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGNvbmZpZy5maWx0ZXJfc3ViamVjdCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuZmlsdGVyX3N1YmplY3QgPSBcIj5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25zdW1lck9wdHMub3B0X3N0YXJ0X3RpbWUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgY29uZmlnLm9wdF9zdGFydF9zZXE7XG4gICAgICAgICAgICAgICAgY29uZmlnLmRlbGl2ZXJfcG9saWN5ID0gRGVsaXZlclBvbGljeS5TdGFydFRpbWU7XG4gICAgICAgICAgICAgICAgY29uZmlnLm9wdF9zdGFydF90aW1lID0gdGhpcy5jb25zdW1lck9wdHMub3B0X3N0YXJ0X3RpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25zdW1lck9wdHMuaW5hY3RpdmVfdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmluYWN0aXZlX3RocmVzaG9sZCA9IG5hbm9zKHRoaXMuY29uc3VtZXJPcHRzLmluYWN0aXZlX3RocmVzaG9sZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG4gICAgYXN5bmMgcmVzZXRDb25zdW1lcihzZXEgPSAwKSB7XG4gICAgICAgIG51aWQubmV4dCgpO1xuICAgICAgICBjb25zdCBpc05ldyA9IHRoaXMuc2VyaWFsID09PSAwO1xuICAgICAgICB0aGlzLmNvbnN1bWVyPy5kZWxldGUoKS5jYXRjaCgoKT0+e30pO1xuICAgICAgICBzZXEgPSBzZXEgPT09IDAgPyAxIDogc2VxO1xuICAgICAgICB0aGlzLmN1cnNvci5kZWxpdmVyX3NlcSA9IDA7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuZ2V0Q29uc3VtZXJPcHRzKHNlcSk7XG4gICAgICAgIGNvbmZpZy5tYXhfZGVsaXZlciA9IDE7XG4gICAgICAgIGNvbmZpZy5tZW1fc3RvcmFnZSA9IHRydWU7XG4gICAgICAgIGNvbnN0IGJvID0gYmFja29mZihbXG4gICAgICAgICAgICB0aGlzLm9wdHM/LmV4cGlyZXMgfHwgMzBfMDAwXG4gICAgICAgIF0pO1xuICAgICAgICBsZXQgY2k7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7OyBpKyspe1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjaSA9IGF3YWl0IHRoaXMuYXBpLmFkZCh0aGlzLnN0cmVhbSwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICB0aGlzLml0ZXI/Lm5vdGlmeShDb25zdW1lckV2ZW50cy5PcmRlcmVkQ29uc3VtZXJSZWNyZWF0ZWQsIGNpLm5hbWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyci5tZXNzYWdlID09PSBcInN0cmVhbSBub3QgZm91bmRcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZXI/Lm5vdGlmeShDb25zdW1lckV2ZW50cy5TdHJlYW1Ob3RGb3VuZCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFB1bGxDb25zdW1lclR5cGUuRmV0Y2ggfHwgdGhpcy5vcHRzLmFib3J0X29uX21pc3NpbmdfcmVzb3VyY2UgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlcj8uc3RvcChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzTmV3ICYmIGkgPj0gdGhpcy5tYXhJbml0aWFsUmVzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGRlbGF5KGJvLmJhY2tvZmYoaSArIDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNpO1xuICAgIH1cbiAgICBpbnRlcm5hbEhhbmRsZXIoc2VyaWFsKSB7XG4gICAgICAgIHJldHVybiAobSk9PntcbiAgICAgICAgICAgIGlmICh0aGlzLnNlcmlhbCAhPT0gc2VyaWFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZHNlcSA9IG0uaW5mby5kZWxpdmVyeVNlcXVlbmNlO1xuICAgICAgICAgICAgaWYgKGRzZXEgIT09IHRoaXMuY3Vyc29yLmRlbGl2ZXJfc2VxICsgMSkge1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5T3JkZXJlZFJlc2V0QW5kUmVzZXQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmN1cnNvci5kZWxpdmVyX3NlcSA9IGRzZXE7XG4gICAgICAgICAgICB0aGlzLmN1cnNvci5zdHJlYW1fc2VxID0gbS5pbmZvLnN0cmVhbVNlcXVlbmNlO1xuICAgICAgICAgICAgaWYgKHRoaXMudXNlckNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51c2VyQ2FsbGJhY2sobSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaXRlcj8ucHVzaChtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgcmVzZXQob3B0cyA9IHtcbiAgICAgICAgbWF4X21lc3NhZ2VzOiAxMDAsXG4gICAgICAgIGV4cGlyZXM6IDMwXzAwMFxuICAgIH0sIGluZm8pIHtcbiAgICAgICAgaW5mbyA9IGluZm8gfHwge307XG4gICAgICAgIGNvbnN0IGZyb21GZXRjaCA9IGluZm8uZnJvbUZldGNoIHx8IGZhbHNlO1xuICAgICAgICBjb25zdCBvcmRlcmVkUmVzZXQgPSBpbmZvLm9yZGVyZWRSZXNldCB8fCBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gUHVsbENvbnN1bWVyVHlwZS5GZXRjaCAmJiBvcmRlcmVkUmVzZXQpIHtcbiAgICAgICAgICAgIHRoaXMuaXRlcj8uc3JjLnN0b3AoKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaXRlcj8uY2xvc2VkKCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDb25zdW1lciA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudENvbnN1bWVyID09PSBudWxsIHx8IG9yZGVyZWRSZXNldCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29uc3VtZXIgPSBhd2FpdCB0aGlzLnJlc2V0Q29uc3VtZXIodGhpcy5jdXJzb3Iuc3RyZWFtX3NlcSArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLml0ZXIgPT09IG51bGwgfHwgZnJvbUZldGNoKSB7XG4gICAgICAgICAgICB0aGlzLml0ZXIgPSBuZXcgT3JkZXJlZENvbnN1bWVyTWVzc2FnZXMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnN1bWVyID0gbmV3IFB1bGxDb25zdW1lckltcGwodGhpcy5hcGksIHRoaXMuY3VycmVudENvbnN1bWVyKTtcbiAgICAgICAgY29uc3QgY29wdHMgPSBvcHRzO1xuICAgICAgICBjb3B0cy5jYWxsYmFjayA9IHRoaXMuaW50ZXJuYWxIYW5kbGVyKHRoaXMuc2VyaWFsKTtcbiAgICAgICAgbGV0IG1zZ3MgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSBQdWxsQ29uc3VtZXJUeXBlLkZldGNoICYmIGZyb21GZXRjaCkge1xuICAgICAgICAgICAgbXNncyA9IGF3YWl0IHRoaXMuY29uc3VtZXIuZmV0Y2gob3B0cyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSBQdWxsQ29uc3VtZXJUeXBlLkNvbnN1bWUpIHtcbiAgICAgICAgICAgIG1zZ3MgPSBhd2FpdCB0aGlzLmNvbnN1bWVyLmNvbnN1bWUob3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbXNnc0ltcGwgPSBtc2dzO1xuICAgICAgICBtc2dzSW1wbC5mb3JPcmRlcmVkQ29uc3VtZXIgPSB0cnVlO1xuICAgICAgICBtc2dzSW1wbC5yZXNldEhhbmRsZXIgPSAoKT0+e1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlPcmRlcmVkUmVzZXRBbmRSZXNldCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLml0ZXIuc2V0U291cmNlKG1zZ3NJbXBsKTtcbiAgICB9XG4gICAgbm90aWZ5T3JkZXJlZFJlc2V0QW5kUmVzZXQoKSB7XG4gICAgICAgIHRoaXMuaXRlcj8ubm90aWZ5KENvbnN1bWVyRGVidWdFdmVudHMuUmVzZXQsIFwiXCIpO1xuICAgICAgICB0aGlzLnJlc2V0KHRoaXMub3B0cywge1xuICAgICAgICAgICAgb3JkZXJlZFJlc2V0OiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBjb25zdW1lKG9wdHMgPSB7XG4gICAgICAgIG1heF9tZXNzYWdlczogMTAwLFxuICAgICAgICBleHBpcmVzOiAzMF8wMDBcbiAgICB9KSB7XG4gICAgICAgIGNvbnN0IGNvcHRzID0gb3B0cztcbiAgICAgICAgaWYgKGNvcHRzLmJpbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJiaW5kIGlzIG5vdCBzdXBwb3J0ZWRcIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFB1bGxDb25zdW1lclR5cGUuRmV0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJvcmRlcmVkIGNvbnN1bWVyIGluaXRpYWxpemVkIGFzIGZldGNoXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50eXBlID09PSBQdWxsQ29uc3VtZXJUeXBlLkNvbnN1bWUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJvcmRlcmVkIGNvbnN1bWVyIGRvZXNuJ3Qgc3VwcG9ydCBjb25jdXJyZW50IGNvbnN1bWVcIikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY2FsbGJhY2sgfSA9IG9wdHM7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy51c2VyQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnR5cGUgPSBQdWxsQ29uc3VtZXJUeXBlLkNvbnN1bWU7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICAgIGF3YWl0IHRoaXMucmVzZXQob3B0cyk7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZXI7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoKG9wdHMgPSB7XG4gICAgICAgIG1heF9tZXNzYWdlczogMTAwLFxuICAgICAgICBleHBpcmVzOiAzMF8wMDBcbiAgICB9KSB7XG4gICAgICAgIGNvbnN0IGNvcHRzID0gb3B0cztcbiAgICAgICAgaWYgKGNvcHRzLmJpbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJiaW5kIGlzIG5vdCBzdXBwb3J0ZWRcIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFB1bGxDb25zdW1lclR5cGUuQ29uc3VtZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIm9yZGVyZWQgY29uc3VtZXIgYWxyZWFkeSBpbml0aWFsaXplZCBhcyBjb25zdW1lXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pdGVyPy5kb25lID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIm9yZGVyZWQgY29uc3VtZXIgZG9lc24ndCBzdXBwb3J0IGNvbmN1cnJlbnQgZmV0Y2hcIikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY2FsbGJhY2sgfSA9IG9wdHM7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy51c2VyQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnR5cGUgPSBQdWxsQ29uc3VtZXJUeXBlLkZldGNoO1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgICBhd2FpdCB0aGlzLnJlc2V0KG9wdHMsIHtcbiAgICAgICAgICAgIGZyb21GZXRjaDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlcjtcbiAgICB9XG4gICAgYXN5bmMgbmV4dChvcHRzID0ge1xuICAgICAgICBleHBpcmVzOiAzMF8wMDBcbiAgICB9KSB7XG4gICAgICAgIGNvbnN0IGNvcHRzID0gb3B0cztcbiAgICAgICAgaWYgKGNvcHRzLmJpbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJiaW5kIGlzIG5vdCBzdXBwb3J0ZWRcIikpO1xuICAgICAgICB9XG4gICAgICAgIGNvcHRzLm1heF9tZXNzYWdlcyA9IDE7XG4gICAgICAgIGNvbnN0IGQgPSBkZWZlcnJlZCgpO1xuICAgICAgICBjb3B0cy5jYWxsYmFjayA9IChtKT0+e1xuICAgICAgICAgICAgdGhpcy51c2VyQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgZC5yZXNvbHZlKG0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBpdGVyID0gYXdhaXQgdGhpcy5mZXRjaChjb3B0cyk7XG4gICAgICAgIGl0ZXIuaXRlckNsb3NlZC50aGVuKChlcnIpPT57XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGQucmVzb2x2ZShudWxsKTtcbiAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgIGQucmVqZWN0KGVycik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZDtcbiAgICB9XG4gICAgZGVsZXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuY3VycmVudENvbnN1bWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hcGkuZGVsZXRlKHRoaXMuc3RyZWFtLCB0aGlzLmN1cnJlbnRDb25zdW1lci5uYW1lKS50aGVuKCh0Zik9PntcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGYpO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgIH0pLmZpbmFsbHkoKCk9PntcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENvbnN1bWVyID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGluZm8oY2FjaGVkKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRDb25zdW1lciA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDb25zdW1lciA9IGF3YWl0IHRoaXMucmVzZXRDb25zdW1lcih0aGlzLnN0YXJ0U2VxKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5jdXJyZW50Q29uc3VtZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWNoZWQgJiYgdGhpcy5jdXJyZW50Q29uc3VtZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5jdXJyZW50Q29uc3VtZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFwaS5pbmZvKHRoaXMuc3RyZWFtLCB0aGlzLmN1cnJlbnRDb25zdW1lci5uYW1lKTtcbiAgICB9XG59XG5jbGFzcyBDb25zdW1lcnNJbXBsIHtcbiAgICBhcGk7XG4gICAgbm90aWZpZWQ7XG4gICAgY29uc3RydWN0b3IoYXBpKXtcbiAgICAgICAgdGhpcy5hcGkgPSBhcGk7XG4gICAgICAgIHRoaXMubm90aWZpZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgY2hlY2tWZXJzaW9uKCkge1xuICAgICAgICBjb25zdCBmdiA9IHRoaXMuYXBpLm5jLmZlYXR1cmVzLmdldChGZWF0dXJlLkpTX1NJTVBMSUZJQ0FUSU9OKTtcbiAgICAgICAgaWYgKCFmdi5vaykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgY29uc3VtZXJzIGZyYW1ld29yayBpcyBvbmx5IHN1cHBvcnRlZCBvbiBzZXJ2ZXJzICR7ZnYubWlufSBvciBiZXR0ZXJgKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBnZXRQdWxsQ29uc3VtZXJGb3IoY2kpIHtcbiAgICAgICAgaWYgKGNpLmNvbmZpZy5kZWxpdmVyX3N1YmplY3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHVzaCBjb25zdW1lciBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHVsbENvbnN1bWVySW1wbCh0aGlzLmFwaSwgY2kpO1xuICAgIH1cbiAgICBhc3luYyBnZXQoc3RyZWFtLCBuYW1lID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcmRlcmVkKHN0cmVhbSwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5jaGVja1ZlcnNpb24oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpLmluZm8oc3RyZWFtLCBuYW1lKS50aGVuKChjaSk9PntcbiAgICAgICAgICAgIGlmIChjaS5jb25maWcuZGVsaXZlcl9zdWJqZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwicHVzaCBjb25zdW1lciBub3Qgc3VwcG9ydGVkXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHVsbENvbnN1bWVySW1wbCh0aGlzLmFwaSwgY2kpO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBvcmRlcmVkKHN0cmVhbSwgb3B0cykge1xuICAgICAgICBhd2FpdCB0aGlzLmNoZWNrVmVyc2lvbigpO1xuICAgICAgICBjb25zdCBpbXBsID0gdGhpcy5hcGk7XG4gICAgICAgIGNvbnN0IHNhcGkgPSBuZXcgU3RyZWFtQVBJSW1wbChpbXBsLm5jLCBpbXBsLm9wdHMpO1xuICAgICAgICByZXR1cm4gc2FwaS5pbmZvKHN0cmVhbSkudGhlbigoX3NpKT0+e1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgT3JkZXJlZFB1bGxDb25zdW1lckltcGwodGhpcy5hcGksIHN0cmVhbSwgb3B0cykpO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFN0cmVhbUltcGwge1xuICAgIGFwaTtcbiAgICBfaW5mbztcbiAgICBjb25zdHJ1Y3RvcihhcGksIGluZm8pe1xuICAgICAgICB0aGlzLmFwaSA9IGFwaTtcbiAgICAgICAgdGhpcy5faW5mbyA9IGluZm87XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5mby5jb25maWcubmFtZTtcbiAgICB9XG4gICAgYWx0ZXJuYXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5mbygpLnRoZW4oKHNpKT0+e1xuICAgICAgICAgICAgcmV0dXJuIHNpLmFsdGVybmF0ZXMgPyBzaS5hbHRlcm5hdGVzIDogW107XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBiZXN0KCkge1xuICAgICAgICBhd2FpdCB0aGlzLmluZm8oKTtcbiAgICAgICAgaWYgKHRoaXMuX2luZm8uYWx0ZXJuYXRlcykge1xuICAgICAgICAgICAgY29uc3QgYXNpID0gYXdhaXQgdGhpcy5hcGkuaW5mbyh0aGlzLl9pbmZvLmFsdGVybmF0ZXNbMF0ubmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwodGhpcy5hcGksIGFzaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbmZvKGNhY2hlZCA9IGZhbHNlLCBvcHRzKSB7XG4gICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5faW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpLmluZm8odGhpcy5uYW1lLCBvcHRzKS50aGVuKChzaSk9PntcbiAgICAgICAgICAgIHRoaXMuX2luZm8gPSBzaTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbmZvO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0Q29uc3VtZXJGcm9tSW5mbyhjaSkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnN1bWVyc0ltcGwobmV3IENvbnN1bWVyQVBJSW1wbCh0aGlzLmFwaS5uYywgdGhpcy5hcGkub3B0cykpLmdldFB1bGxDb25zdW1lckZvcihjaSk7XG4gICAgfVxuICAgIGdldENvbnN1bWVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb25zdW1lcnNJbXBsKG5ldyBDb25zdW1lckFQSUltcGwodGhpcy5hcGkubmMsIHRoaXMuYXBpLm9wdHMpKS5nZXQodGhpcy5uYW1lLCBuYW1lKTtcbiAgICB9XG4gICAgZ2V0TWVzc2FnZShxdWVyeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcGkuZ2V0TWVzc2FnZSh0aGlzLm5hbWUsIHF1ZXJ5KTtcbiAgICB9XG4gICAgZGVsZXRlTWVzc2FnZShzZXEsIGVyYXNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwaS5kZWxldGVNZXNzYWdlKHRoaXMubmFtZSwgc2VxLCBlcmFzZSk7XG4gICAgfVxufVxuY2xhc3MgU3RyZWFtQVBJSW1wbCBleHRlbmRzIEJhc2VBcGlDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKG5jLCBvcHRzKXtcbiAgICAgICAgc3VwZXIobmMsIG9wdHMpO1xuICAgIH1cbiAgICBjaGVja1N0cmVhbUNvbmZpZ1ZlcnNpb25zKGNmZykge1xuICAgICAgICBjb25zdCBuY2kgPSB0aGlzLm5jO1xuICAgICAgICBpZiAoY2ZnLm1ldGFkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCB7IG1pbiwgb2sgfSA9IG5jaS5mZWF0dXJlcy5nZXQoRmVhdHVyZS5KU19TVFJFQU1fQ09OU1VNRVJfTUVUQURBVEEpO1xuICAgICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc3RyZWFtICdtZXRhZGF0YScgcmVxdWlyZXMgc2VydmVyICR7bWlufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjZmcuZmlyc3Rfc2VxKSB7XG4gICAgICAgICAgICBjb25zdCB7IG1pbiwgb2sgfSA9IG5jaS5mZWF0dXJlcy5nZXQoRmVhdHVyZS5KU19TVFJFQU1fRklSU1RfU0VRKTtcbiAgICAgICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN0cmVhbSAnZmlyc3Rfc2VxJyByZXF1aXJlcyBzZXJ2ZXIgJHttaW59YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNmZy5zdWJqZWN0X3RyYW5zZm9ybSkge1xuICAgICAgICAgICAgY29uc3QgeyBtaW4sIG9rIH0gPSBuY2kuZmVhdHVyZXMuZ2V0KEZlYXR1cmUuSlNfU1RSRUFNX1NVQkpFQ1RfVFJBTlNGT1JNKTtcbiAgICAgICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN0cmVhbSAnc3ViamVjdF90cmFuc2Zvcm0nIHJlcXVpcmVzIHNlcnZlciAke21pbn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ZnLmNvbXByZXNzaW9uKSB7XG4gICAgICAgICAgICBjb25zdCB7IG1pbiwgb2sgfSA9IG5jaS5mZWF0dXJlcy5nZXQoRmVhdHVyZS5KU19TVFJFQU1fQ09NUFJFU1NJT04pO1xuICAgICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc3RyZWFtICdjb21wcmVzc2lvbicgcmVxdWlyZXMgc2VydmVyICR7bWlufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjZmcuY29uc3VtZXJfbGltaXRzKSB7XG4gICAgICAgICAgICBjb25zdCB7IG1pbiwgb2sgfSA9IG5jaS5mZWF0dXJlcy5nZXQoRmVhdHVyZS5KU19ERUZBVUxUX0NPTlNVTUVSX0xJTUlUUyk7XG4gICAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdHJlYW0gJ2NvbnN1bWVyX2xpbWl0cycgcmVxdWlyZXMgc2VydmVyICR7bWlufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlU3RyZWFtU291cmNlKGNvbnRleHQsIHNyYykge1xuICAgICAgICAgICAgY29uc3QgY291bnQgPSBzcmM/LnN1YmplY3RfdHJhbnNmb3Jtcz8ubGVuZ3RoIHx8IDA7XG4gICAgICAgICAgICBpZiAoY291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBtaW4sIG9rIH0gPSBuY2kuZmVhdHVyZXMuZ2V0KEZlYXR1cmUuSlNfU1RSRUFNX1NPVVJDRV9TVUJKRUNUX1RSQU5TRk9STSk7XG4gICAgICAgICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29udGV4dH0gJ3N1YmplY3RfdHJhbnNmb3JtcycgcmVxdWlyZXMgc2VydmVyICR7bWlufWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ZnLnNvdXJjZXMpIHtcbiAgICAgICAgICAgIGNmZy5zb3VyY2VzLmZvckVhY2goKHNyYyk9PntcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZVN0cmVhbVNvdXJjZShcInN0cmVhbSBzb3VyY2VzXCIsIHNyYyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ZnLm1pcnJvcikge1xuICAgICAgICAgICAgdmFsaWRhdGVTdHJlYW1Tb3VyY2UoXCJzdHJlYW0gbWlycm9yXCIsIGNmZy5taXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGFkZChjZmcgPSB7fSkge1xuICAgICAgICB0aGlzLmNoZWNrU3RyZWFtQ29uZmlnVmVyc2lvbnMoY2ZnKTtcbiAgICAgICAgdmFsaWRhdGVTdHJlYW1OYW1lKGNmZy5uYW1lKTtcbiAgICAgICAgY2ZnLm1pcnJvciA9IGNvbnZlcnRTdHJlYW1Tb3VyY2VEb21haW4oY2ZnLm1pcnJvcik7XG4gICAgICAgIGNmZy5zb3VyY2VzID0gY2ZnLnNvdXJjZXM/Lm1hcChjb252ZXJ0U3RyZWFtU291cmNlRG9tYWluKTtcbiAgICAgICAgY29uc3QgciA9IGF3YWl0IHRoaXMuX3JlcXVlc3QoYCR7dGhpcy5wcmVmaXh9LlNUUkVBTS5DUkVBVEUuJHtjZmcubmFtZX1gLCBjZmcpO1xuICAgICAgICBjb25zdCBzaSA9IHI7XG4gICAgICAgIHRoaXMuX2ZpeEluZm8oc2kpO1xuICAgICAgICByZXR1cm4gc2k7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZShzdHJlYW0pIHtcbiAgICAgICAgdmFsaWRhdGVTdHJlYW1OYW1lKHN0cmVhbSk7XG4gICAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLl9yZXF1ZXN0KGAke3RoaXMucHJlZml4fS5TVFJFQU0uREVMRVRFLiR7c3RyZWFtfWApO1xuICAgICAgICBjb25zdCBjciA9IHI7XG4gICAgICAgIHJldHVybiBjci5zdWNjZXNzO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGUobmFtZSwgY2ZnID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBjb25zdCBzYyA9IG5hbWU7XG4gICAgICAgICAgICBuYW1lID0gc2MubmFtZTtcbiAgICAgICAgICAgIGNmZyA9IHNjO1xuICAgICAgICAgICAgY29uc29sZS50cmFjZShgXFx1MDAxQlszM20gPj4gc3RyZWFtcy51cGRhdGUoY29uZmlnOiBTdHJlYW1Db25maWcpIGFwaSBjaGFuZ2VkIHRvIHN0cmVhbXMudXBkYXRlKG5hbWU6IHN0cmluZywgY29uZmlnOiBTdHJlYW1VcGRhdGVDb25maWcpIC0gdGhpcyBzaGltIHdpbGwgYmUgcmVtb3ZlZCAtIHVwZGF0ZSB5b3VyIGNvZGUuICBcXHUwMDFCWzBtYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja1N0cmVhbUNvbmZpZ1ZlcnNpb25zKGNmZyk7XG4gICAgICAgIHZhbGlkYXRlU3RyZWFtTmFtZShuYW1lKTtcbiAgICAgICAgY29uc3Qgb2xkID0gYXdhaXQgdGhpcy5pbmZvKG5hbWUpO1xuICAgICAgICBjb25zdCB1cGRhdGUgPSBPYmplY3QuYXNzaWduKG9sZC5jb25maWcsIGNmZyk7XG4gICAgICAgIHVwZGF0ZS5taXJyb3IgPSBjb252ZXJ0U3RyZWFtU291cmNlRG9tYWluKHVwZGF0ZS5taXJyb3IpO1xuICAgICAgICB1cGRhdGUuc291cmNlcyA9IHVwZGF0ZS5zb3VyY2VzPy5tYXAoY29udmVydFN0cmVhbVNvdXJjZURvbWFpbik7XG4gICAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLl9yZXF1ZXN0KGAke3RoaXMucHJlZml4fS5TVFJFQU0uVVBEQVRFLiR7bmFtZX1gLCB1cGRhdGUpO1xuICAgICAgICBjb25zdCBzaSA9IHI7XG4gICAgICAgIHRoaXMuX2ZpeEluZm8oc2kpO1xuICAgICAgICByZXR1cm4gc2k7XG4gICAgfVxuICAgIGFzeW5jIGluZm8obmFtZSwgZGF0YSkge1xuICAgICAgICB2YWxpZGF0ZVN0cmVhbU5hbWUobmFtZSk7XG4gICAgICAgIGNvbnN0IHN1YmogPSBgJHt0aGlzLnByZWZpeH0uU1RSRUFNLklORk8uJHtuYW1lfWA7XG4gICAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLl9yZXF1ZXN0KHN1YmosIGRhdGEpO1xuICAgICAgICBsZXQgc2kgPSByO1xuICAgICAgICBsZXQgeyB0b3RhbCwgbGltaXQgfSA9IHNpO1xuICAgICAgICBsZXQgaGF2ZSA9IHNpLnN0YXRlLnN1YmplY3RzID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc2kuc3RhdGUuc3ViamVjdHMpLmxlbmd0aCA6IDE7XG4gICAgICAgIGlmICh0b3RhbCAmJiB0b3RhbCA+IGhhdmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZm9zID0gW1xuICAgICAgICAgICAgICAgIHNpXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgY29uc3QgcGFnZWQgPSBkYXRhIHx8IHt9O1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgd2hpbGUodG90YWwgPiBoYXZlKXtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgcGFnZWQub2Zmc2V0ID0gbGltaXQgKiBpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLl9yZXF1ZXN0KHN1YmosIHBhZ2VkKTtcbiAgICAgICAgICAgICAgICB0b3RhbCA9IHIudG90YWw7XG4gICAgICAgICAgICAgICAgaW5mb3MucHVzaChyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3VudCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHIuc3RhdGUuc3ViamVjdHMpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBoYXZlICs9IGNvdW50O1xuICAgICAgICAgICAgICAgIGlmIChjb3VudCA8IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdWJqZWN0cyA9IHt9O1xuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGluZm9zLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICBzaSA9IGluZm9zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChzaS5zdGF0ZS5zdWJqZWN0cykge1xuICAgICAgICAgICAgICAgICAgICBzdWJqZWN0cyA9IE9iamVjdC5hc3NpZ24oc3ViamVjdHMsIHNpLnN0YXRlLnN1YmplY3RzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaS5vZmZzZXQgPSAwO1xuICAgICAgICAgICAgc2kudG90YWwgPSAwO1xuICAgICAgICAgICAgc2kubGltaXQgPSAwO1xuICAgICAgICAgICAgc2kuc3RhdGUuc3ViamVjdHMgPSBzdWJqZWN0cztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9maXhJbmZvKHNpKTtcbiAgICAgICAgcmV0dXJuIHNpO1xuICAgIH1cbiAgICBsaXN0KHN1YmplY3QgPSBcIlwiKSB7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBzdWJqZWN0Py5sZW5ndGggPyB7XG4gICAgICAgICAgICBzdWJqZWN0XG4gICAgICAgIH0gOiB7fTtcbiAgICAgICAgY29uc3QgbGlzdGVyRmlsdGVyID0gKHYpPT57XG4gICAgICAgICAgICBjb25zdCBzbHIgPSB2O1xuICAgICAgICAgICAgc2xyLnN0cmVhbXMuZm9yRWFjaCgoc2kpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5fZml4SW5mbyhzaSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzbHIuc3RyZWFtcztcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3ViaiA9IGAke3RoaXMucHJlZml4fS5TVFJFQU0uTElTVGA7XG4gICAgICAgIHJldHVybiBuZXcgTGlzdGVySW1wbChzdWJqLCBsaXN0ZXJGaWx0ZXIsIHRoaXMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBfZml4SW5mbyhzaSkge1xuICAgICAgICBzaS5jb25maWcuc2VhbGVkID0gc2kuY29uZmlnLnNlYWxlZCB8fCBmYWxzZTtcbiAgICAgICAgc2kuY29uZmlnLmRlbnlfZGVsZXRlID0gc2kuY29uZmlnLmRlbnlfZGVsZXRlIHx8IGZhbHNlO1xuICAgICAgICBzaS5jb25maWcuZGVueV9wdXJnZSA9IHNpLmNvbmZpZy5kZW55X3B1cmdlIHx8IGZhbHNlO1xuICAgICAgICBzaS5jb25maWcuYWxsb3dfcm9sbHVwX2hkcnMgPSBzaS5jb25maWcuYWxsb3dfcm9sbHVwX2hkcnMgfHwgZmFsc2U7XG4gICAgfVxuICAgIGFzeW5jIHB1cmdlKG5hbWUsIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsga2VlcCwgc2VxIH0gPSBvcHRzO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZWVwID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBzZXEgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW4gc3BlY2lmeSBvbmUgb2Yga2VlcCBvciBzZXFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGVTdHJlYW1OYW1lKG5hbWUpO1xuICAgICAgICBjb25zdCB2ID0gYXdhaXQgdGhpcy5fcmVxdWVzdChgJHt0aGlzLnByZWZpeH0uU1RSRUFNLlBVUkdFLiR7bmFtZX1gLCBvcHRzKTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZU1lc3NhZ2Uoc3RyZWFtLCBzZXEsIGVyYXNlID0gdHJ1ZSkge1xuICAgICAgICB2YWxpZGF0ZVN0cmVhbU5hbWUoc3RyZWFtKTtcbiAgICAgICAgY29uc3QgZHIgPSB7XG4gICAgICAgICAgICBzZXFcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFlcmFzZSkge1xuICAgICAgICAgICAgZHIubm9fZXJhc2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLl9yZXF1ZXN0KGAke3RoaXMucHJlZml4fS5TVFJFQU0uTVNHLkRFTEVURS4ke3N0cmVhbX1gLCBkcik7XG4gICAgICAgIGNvbnN0IGNyID0gcjtcbiAgICAgICAgcmV0dXJuIGNyLnN1Y2Nlc3M7XG4gICAgfVxuICAgIGFzeW5jIGdldE1lc3NhZ2Uoc3RyZWFtLCBxdWVyeSkge1xuICAgICAgICB2YWxpZGF0ZVN0cmVhbU5hbWUoc3RyZWFtKTtcbiAgICAgICAgY29uc3QgciA9IGF3YWl0IHRoaXMuX3JlcXVlc3QoYCR7dGhpcy5wcmVmaXh9LlNUUkVBTS5NU0cuR0VULiR7c3RyZWFtfWAsIHF1ZXJ5KTtcbiAgICAgICAgY29uc3Qgc20gPSByO1xuICAgICAgICByZXR1cm4gbmV3IFN0b3JlZE1zZ0ltcGwoc20pO1xuICAgIH1cbiAgICBmaW5kKHN1YmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZFN0cmVhbShzdWJqZWN0KTtcbiAgICB9XG4gICAgbGlzdEt2cygpIHtcbiAgICAgICAgY29uc3QgZmlsdGVyID0gKHYpPT57XG4gICAgICAgICAgICBjb25zdCBzbHIgPSB2O1xuICAgICAgICAgICAgY29uc3Qga3ZTdHJlYW1zID0gc2xyLnN0cmVhbXMuZmlsdGVyKCh2KT0+e1xuICAgICAgICAgICAgICAgIHJldHVybiB2LmNvbmZpZy5uYW1lLnN0YXJ0c1dpdGgoa3ZQcmVmaXgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBrdlN0cmVhbXMuZm9yRWFjaCgoc2kpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5fZml4SW5mbyhzaSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBjbHVzdGVyID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChrdlN0cmVhbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2x1c3RlciA9IHRoaXMubmMuaW5mbz8uY2x1c3RlciA/PyBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0ga3ZTdHJlYW1zLm1hcCgoc2kpPT57XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBLdlN0YXR1c0ltcGwoc2ksIGNsdXN0ZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdWJqID0gYCR7dGhpcy5wcmVmaXh9LlNUUkVBTS5MSVNUYDtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXN0ZXJJbXBsKHN1YmosIGZpbHRlciwgdGhpcyk7XG4gICAgfVxuICAgIGxpc3RPYmplY3RTdG9yZXMoKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9ICh2KT0+e1xuICAgICAgICAgICAgY29uc3Qgc2xyID0gdjtcbiAgICAgICAgICAgIGNvbnN0IG9ialN0cmVhbXMgPSBzbHIuc3RyZWFtcy5maWx0ZXIoKHYpPT57XG4gICAgICAgICAgICAgICAgcmV0dXJuIHYuY29uZmlnLm5hbWUuc3RhcnRzV2l0aChvc1ByZWZpeCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9ialN0cmVhbXMuZm9yRWFjaCgoc2kpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5fZml4SW5mbyhzaSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IG9ialN0cmVhbXMubWFwKChzaSk9PntcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE9iamVjdFN0b3JlU3RhdHVzSW1wbChzaSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN1YmogPSBgJHt0aGlzLnByZWZpeH0uU1RSRUFNLkxJU1RgO1xuICAgICAgICByZXR1cm4gbmV3IExpc3RlckltcGwoc3ViaiwgZmlsdGVyLCB0aGlzKTtcbiAgICB9XG4gICAgbmFtZXMoc3ViamVjdCA9IFwiXCIpIHtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHN1YmplY3Q/Lmxlbmd0aCA/IHtcbiAgICAgICAgICAgIHN1YmplY3RcbiAgICAgICAgfSA6IHt9O1xuICAgICAgICBjb25zdCBsaXN0ZXJGaWx0ZXIgPSAodik9PntcbiAgICAgICAgICAgIGNvbnN0IHNyID0gdjtcbiAgICAgICAgICAgIHJldHVybiBzci5zdHJlYW1zO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdWJqID0gYCR7dGhpcy5wcmVmaXh9LlNUUkVBTS5OQU1FU2A7XG4gICAgICAgIHJldHVybiBuZXcgTGlzdGVySW1wbChzdWJqLCBsaXN0ZXJGaWx0ZXIsIHRoaXMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBhc3luYyBnZXQobmFtZSkge1xuICAgICAgICBjb25zdCBzaSA9IGF3YWl0IHRoaXMuaW5mbyhuYW1lKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgU3RyZWFtSW1wbCh0aGlzLCBzaSkpO1xuICAgIH1cbn1cbmNsYXNzIERpcmVjdFN0cmVhbUFQSUltcGwgZXh0ZW5kcyBCYXNlQXBpQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYywgb3B0cyl7XG4gICAgICAgIHN1cGVyKG5jLCBvcHRzKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TWVzc2FnZShzdHJlYW0sIHF1ZXJ5KSB7XG4gICAgICAgIHZhbGlkYXRlU3RyZWFtTmFtZShzdHJlYW0pO1xuICAgICAgICBsZXQgcXEgPSBxdWVyeTtcbiAgICAgICAgY29uc3QgeyBsYXN0X2J5X3N1YmogfSA9IHFxO1xuICAgICAgICBpZiAobGFzdF9ieV9zdWJqKSB7XG4gICAgICAgICAgICBxcSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHFxID8gdGhpcy5qYy5lbmNvZGUocXEpIDogRW1wdHk7XG4gICAgICAgIGNvbnN0IHByZSA9IHRoaXMub3B0cy5hcGlQcmVmaXggfHwgXCIkSlMuQVBJXCI7XG4gICAgICAgIGNvbnN0IHN1YmogPSBsYXN0X2J5X3N1YmogPyBgJHtwcmV9LkRJUkVDVC5HRVQuJHtzdHJlYW19LiR7bGFzdF9ieV9zdWJqfWAgOiBgJHtwcmV9LkRJUkVDVC5HRVQuJHtzdHJlYW19YDtcbiAgICAgICAgY29uc3QgciA9IGF3YWl0IHRoaXMubmMucmVxdWVzdChzdWJqLCBwYXlsb2FkLCB7XG4gICAgICAgICAgICB0aW1lb3V0OiB0aGlzLnRpbWVvdXRcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGVyciA9IGNoZWNrSnNFcnJvcihyKTtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG0gPSBuZXcgRGlyZWN0TXNnSW1wbChyKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkbSk7XG4gICAgfVxuICAgIGFzeW5jIGdldEJhdGNoKHN0cmVhbSwgb3B0cykge1xuICAgICAgICB2YWxpZGF0ZVN0cmVhbU5hbWUoc3RyZWFtKTtcbiAgICAgICAgY29uc3QgcHJlID0gdGhpcy5vcHRzLmFwaVByZWZpeCB8fCBcIiRKUy5BUElcIjtcbiAgICAgICAgY29uc3Qgc3ViaiA9IGAke3ByZX0uRElSRUNULkdFVC4ke3N0cmVhbX1gO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0cy5tdWx0aV9sYXN0KSB8fCBvcHRzLm11bHRpX2xhc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJtdWx0aV9sYXN0IGlzIHJlcXVpcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnN0cmluZ2lmeShvcHRzLCAoa2V5LCB2YWx1ZSk9PntcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwidXBfdG9fdGltZVwiICYmIHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaXRlciA9IG5ldyBRdWV1ZWRJdGVyYXRvckltcGwoKTtcbiAgICAgICAgY29uc3QgcmF3ID0gYXdhaXQgdGhpcy5uYy5yZXF1ZXN0TWFueShzdWJqLCBwYXlsb2FkLCB7XG4gICAgICAgICAgICBzdHJhdGVneTogUmVxdWVzdFN0cmF0ZWd5LlNlbnRpbmVsTXNnXG4gICAgICAgIH0pO1xuICAgICAgICAoYXN5bmMgKCk9PntcbiAgICAgICAgICAgIGxldCBnb3RGaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGJhZFNlcnZlciA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGJhZFJlcXVlc3Q7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IG0gb2YgcmF3KXtcbiAgICAgICAgICAgICAgICBpZiAoIWdvdEZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGdvdEZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IG0uaGVhZGVycz8uY29kZSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSAhPT0gMCAmJiBjb2RlIDwgMjAwIHx8IGNvZGUgPiAyOTkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhZFJlcXVlc3QgPSBtLmhlYWRlcnM/LmRlc2NyaXB0aW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gbS5oZWFkZXJzPy5nZXQoXCJOYXRzLU51bS1QZW5kaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodiA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFkU2VydmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtLmRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVyLnB1c2gobmV3IERpcmVjdE1zZ0ltcGwobSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlci5wdXNoKCgpPT57XG4gICAgICAgICAgICAgICAgaWYgKGJhZFNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYXRjaCBkaXJlY3QgZ2V0IG5vdCBzdXBwb3J0ZWQgYnkgdGhlIHNlcnZlclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJhZFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiYWQgcmVxdWVzdDogJHtiYWRSZXF1ZXN0fWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVyLnN0b3AoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSgpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGl0ZXIpO1xuICAgIH1cbn1cbmNsYXNzIERpcmVjdE1zZ0ltcGwge1xuICAgIGRhdGE7XG4gICAgaGVhZGVyO1xuICAgIHN0YXRpYyBqYztcbiAgICBjb25zdHJ1Y3RvcihtKXtcbiAgICAgICAgaWYgKCFtLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImhlYWRlcnMgZXhwZWN0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhID0gbS5kYXRhO1xuICAgICAgICB0aGlzLmhlYWRlciA9IG0uaGVhZGVycztcbiAgICB9XG4gICAgZ2V0IHN1YmplY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWRlci5sYXN0KERpcmVjdE1zZ0hlYWRlcnMuU3ViamVjdCk7XG4gICAgfVxuICAgIGdldCBzZXEoKSB7XG4gICAgICAgIGNvbnN0IHYgPSB0aGlzLmhlYWRlci5sYXN0KERpcmVjdE1zZ0hlYWRlcnMuU2VxdWVuY2UpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHYgPT09IFwic3RyaW5nXCIgPyBwYXJzZUludCh2KSA6IDA7XG4gICAgfVxuICAgIGdldCB0aW1lKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5wYXJzZSh0aGlzLnRpbWVzdGFtcCkpO1xuICAgIH1cbiAgICBnZXQgdGltZXN0YW1wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXIubGFzdChEaXJlY3RNc2dIZWFkZXJzLlRpbWVTdGFtcCk7XG4gICAgfVxuICAgIGdldCBzdHJlYW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWRlci5sYXN0KERpcmVjdE1zZ0hlYWRlcnMuU3RyZWFtKTtcbiAgICB9XG4gICAganNvbihyZXZpdmVyKSB7XG4gICAgICAgIHJldHVybiBKU09OQ29kZWMocmV2aXZlcikuZGVjb2RlKHRoaXMuZGF0YSk7XG4gICAgfVxuICAgIHN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFRELmRlY29kZSh0aGlzLmRhdGEpO1xuICAgIH1cbn1cbmNsYXNzIEpldFN0cmVhbU1hbmFnZXJJbXBsIGV4dGVuZHMgQmFzZUFwaUNsaWVudCB7XG4gICAgc3RyZWFtcztcbiAgICBjb25zdW1lcnM7XG4gICAgZGlyZWN0O1xuICAgIGNvbnN0cnVjdG9yKG5jLCBvcHRzKXtcbiAgICAgICAgc3VwZXIobmMsIG9wdHMpO1xuICAgICAgICB0aGlzLnN0cmVhbXMgPSBuZXcgU3RyZWFtQVBJSW1wbChuYywgb3B0cyk7XG4gICAgICAgIHRoaXMuY29uc3VtZXJzID0gbmV3IENvbnN1bWVyQVBJSW1wbChuYywgb3B0cyk7XG4gICAgICAgIHRoaXMuZGlyZWN0ID0gbmV3IERpcmVjdFN0cmVhbUFQSUltcGwobmMsIG9wdHMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRBY2NvdW50SW5mbygpIHtcbiAgICAgICAgY29uc3QgciA9IGF3YWl0IHRoaXMuX3JlcXVlc3QoYCR7dGhpcy5wcmVmaXh9LklORk9gKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGpldHN0cmVhbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmMuamV0c3RyZWFtKHRoaXMuZ2V0T3B0aW9ucygpKTtcbiAgICB9XG4gICAgYWR2aXNvcmllcygpIHtcbiAgICAgICAgY29uc3QgaXRlciA9IG5ldyBRdWV1ZWRJdGVyYXRvckltcGwoKTtcbiAgICAgICAgdGhpcy5uYy5zdWJzY3JpYmUoYCRKUy5FVkVOVC5BRFZJU09SWS4+YCwge1xuICAgICAgICAgICAgY2FsbGJhY2s6IChlcnIsIG1zZyk9PntcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZCA9IHRoaXMucGFyc2VKc1Jlc3BvbnNlKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rcyA9IGQudHlwZS5zcGxpdChcIi5cIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtpbmQgPSBjaHVua3NbY2h1bmtzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpdGVyLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXIuc3RvcChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpdGVyO1xuICAgIH1cbn1cbmNsYXNzIFN0b3JlZE1zZ0ltcGwge1xuICAgIF9oZWFkZXI7XG4gICAgc21yO1xuICAgIHN0YXRpYyBqYztcbiAgICBjb25zdHJ1Y3RvcihzbXIpe1xuICAgICAgICB0aGlzLnNtciA9IHNtcjtcbiAgICB9XG4gICAgZ2V0IHN1YmplY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNtci5tZXNzYWdlLnN1YmplY3Q7XG4gICAgfVxuICAgIGdldCBzZXEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNtci5tZXNzYWdlLnNlcTtcbiAgICB9XG4gICAgZ2V0IHRpbWVzdGFtcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc21yLm1lc3NhZ2UudGltZTtcbiAgICB9XG4gICAgZ2V0IHRpbWUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLnBhcnNlKHRoaXMudGltZXN0YW1wKSk7XG4gICAgfVxuICAgIGdldCBkYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbXIubWVzc2FnZS5kYXRhID8gdGhpcy5fcGFyc2UodGhpcy5zbXIubWVzc2FnZS5kYXRhKSA6IEVtcHR5O1xuICAgIH1cbiAgICBnZXQgaGVhZGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2hlYWRlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuc21yLm1lc3NhZ2UuaGRycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhkID0gdGhpcy5fcGFyc2UodGhpcy5zbXIubWVzc2FnZS5oZHJzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFkZXIgPSBNc2dIZHJzSW1wbC5kZWNvZGUoaGQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFkZXIgPSBoZWFkZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlcjtcbiAgICB9XG4gICAgX3BhcnNlKHMpIHtcbiAgICAgICAgY29uc3QgYnMgPSBhdG9iKHMpO1xuICAgICAgICBjb25zdCBsZW4gPSBicy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICAgICAgICAgIGJ5dGVzW2ldID0gYnMuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICAgIGpzb24ocmV2aXZlcikge1xuICAgICAgICByZXR1cm4gSlNPTkNvZGVjKHJldml2ZXIpLmRlY29kZSh0aGlzLmRhdGEpO1xuICAgIH1cbiAgICBzdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBURC5kZWNvZGUodGhpcy5kYXRhKTtcbiAgICB9XG59XG5jbGFzcyBTdHJlYW1zSW1wbCB7XG4gICAgYXBpO1xuICAgIGNvbnN0cnVjdG9yKGFwaSl7XG4gICAgICAgIHRoaXMuYXBpID0gYXBpO1xuICAgIH1cbiAgICBnZXQoc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwaS5pbmZvKHN0cmVhbSkudGhlbigoc2kpPT57XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwodGhpcy5hcGksIHNpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgT2JqZWN0SW5mb0ltcGwge1xuICAgIGluZm87XG4gICAgaGRycztcbiAgICBjb25zdHJ1Y3RvcihvaSl7XG4gICAgICAgIHRoaXMuaW5mbyA9IG9pO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5mby5uYW1lO1xuICAgIH1cbiAgICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZm8uZGVzY3JpcHRpb24gPz8gXCJcIjtcbiAgICB9XG4gICAgZ2V0IGhlYWRlcnMoKSB7XG4gICAgICAgIGlmICghdGhpcy5oZHJzKSB7XG4gICAgICAgICAgICB0aGlzLmhkcnMgPSBNc2dIZHJzSW1wbC5mcm9tUmVjb3JkKHRoaXMuaW5mby5oZWFkZXJzIHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5oZHJzO1xuICAgIH1cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5mby5vcHRpb25zO1xuICAgIH1cbiAgICBnZXQgYnVja2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmZvLmJ1Y2tldDtcbiAgICB9XG4gICAgZ2V0IGNodW5rcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5mby5jaHVua3M7XG4gICAgfVxuICAgIGdldCBkZWxldGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmZvLmRlbGV0ZWQgPz8gZmFsc2U7XG4gICAgfVxuICAgIGdldCBkaWdlc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZm8uZGlnZXN0O1xuICAgIH1cbiAgICBnZXQgbXRpbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZm8ubXRpbWU7XG4gICAgfVxuICAgIGdldCBudWlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmZvLm51aWQ7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmZvLnNpemU7XG4gICAgfVxuICAgIGdldCByZXZpc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5mby5yZXZpc2lvbjtcbiAgICB9XG4gICAgZ2V0IG1ldGFkYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmZvLm1ldGFkYXRhIHx8IHt9O1xuICAgIH1cbiAgICBpc0xpbmsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZm8ub3B0aW9ucz8ubGluayAhPT0gdW5kZWZpbmVkICYmIHRoaXMuaW5mby5vcHRpb25zPy5saW5rICE9PSBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvU2VydmVyT2JqZWN0U3RvcmVNZXRhKG1ldGEpIHtcbiAgICBjb25zdCB2ID0ge1xuICAgICAgICBuYW1lOiBtZXRhLm5hbWUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBtZXRhLmRlc2NyaXB0aW9uID8/IFwiXCIsXG4gICAgICAgIG9wdGlvbnM6IG1ldGEub3B0aW9ucyxcbiAgICAgICAgbWV0YWRhdGE6IG1ldGEubWV0YWRhdGFcbiAgICB9O1xuICAgIGlmIChtZXRhLmhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgbWhpID0gbWV0YS5oZWFkZXJzO1xuICAgICAgICB2LmhlYWRlcnMgPSBtaGkudG9SZWNvcmQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG5mdW5jdGlvbiBlbXB0eVJlYWRhYmxlU3RyZWFtKCkge1xuICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBwdWxsIChjKSB7XG4gICAgICAgICAgICBjLmVucXVldWUobmV3IFVpbnQ4QXJyYXkoMCkpO1xuICAgICAgICAgICAgYy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5jbGFzcyBPYmplY3RTdG9yZUltcGwge1xuICAgIGpzbTtcbiAgICBqcztcbiAgICBzdHJlYW07XG4gICAgbmFtZTtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBqc20sIGpzKXtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5qc20gPSBqc207XG4gICAgICAgIHRoaXMuanMgPSBqcztcbiAgICB9XG4gICAgX2NoZWNrTm90RW1wdHkobmFtZSkge1xuICAgICAgICBpZiAoIW5hbWUgfHwgbmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKFwibmFtZSBjYW5ub3QgYmUgZW1wdHlcIilcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgaW5mbyhuYW1lKSB7XG4gICAgICAgIGNvbnN0IGluZm8gPSBhd2FpdCB0aGlzLnJhd0luZm8obmFtZSk7XG4gICAgICAgIHJldHVybiBpbmZvID8gbmV3IE9iamVjdEluZm9JbXBsKGluZm8pIDogbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgbGlzdCgpIHtcbiAgICAgICAgY29uc3QgYnVmID0gW107XG4gICAgICAgIGNvbnN0IGl0ZXIgPSBhd2FpdCB0aGlzLndhdGNoKHtcbiAgICAgICAgICAgIGlnbm9yZURlbGV0ZXM6IHRydWUsXG4gICAgICAgICAgICBpbmNsdWRlSGlzdG9yeTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBpbmZvIG9mIGl0ZXIpe1xuICAgICAgICAgICAgaWYgKGluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1Zi5wdXNoKGluZm8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYnVmKTtcbiAgICB9XG4gICAgYXN5bmMgcmF3SW5mbyhuYW1lKSB7XG4gICAgICAgIGNvbnN0IHsgbmFtZTogb2JqLCBlcnJvciB9ID0gdGhpcy5fY2hlY2tOb3RFbXB0eShuYW1lKTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9tZXRhU3ViamVjdChvYmopO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbSA9IGF3YWl0IHRoaXMuanNtLnN0cmVhbXMuZ2V0TWVzc2FnZSh0aGlzLnN0cmVhbSwge1xuICAgICAgICAgICAgICAgIGxhc3RfYnlfc3ViajogbWV0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBqYyA9IEpTT05Db2RlYygpO1xuICAgICAgICAgICAgY29uc3Qgc29pID0gamMuZGVjb2RlKG0uZGF0YSk7XG4gICAgICAgICAgICBzb2kucmV2aXNpb24gPSBtLnNlcTtcbiAgICAgICAgICAgIHJldHVybiBzb2k7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyci5jb2RlID09PSBcIjQwNFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfc2kob3B0cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuanNtLnN0cmVhbXMuaW5mbyh0aGlzLnN0cmVhbSwgb3B0cyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc3QgbmVyciA9IGVycjtcbiAgICAgICAgICAgIGlmIChuZXJyLmNvZGUgPT09IFwiNDA0XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNlYWwoKSB7XG4gICAgICAgIGxldCBpbmZvID0gYXdhaXQgdGhpcy5fc2koKTtcbiAgICAgICAgaWYgKGluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJvYmplY3Qgc3RvcmUgbm90IGZvdW5kXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpbmZvLmNvbmZpZy5zZWFsZWQgPSB0cnVlO1xuICAgICAgICBpbmZvID0gYXdhaXQgdGhpcy5qc20uc3RyZWFtcy51cGRhdGUodGhpcy5zdHJlYW0sIGluZm8uY29uZmlnKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgT2JqZWN0U3RvcmVTdGF0dXNJbXBsKGluZm8pKTtcbiAgICB9XG4gICAgYXN5bmMgc3RhdHVzKG9wdHMpIHtcbiAgICAgICAgY29uc3QgaW5mbyA9IGF3YWl0IHRoaXMuX3NpKG9wdHMpO1xuICAgICAgICBpZiAoaW5mbyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIm9iamVjdCBzdG9yZSBub3QgZm91bmRcIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IE9iamVjdFN0b3JlU3RhdHVzSW1wbChpbmZvKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmpzbS5zdHJlYW1zLmRlbGV0ZSh0aGlzLnN0cmVhbSk7XG4gICAgfVxuICAgIGFzeW5jIF9wdXQobWV0YSwgcnMsIG9wdHMpIHtcbiAgICAgICAgY29uc3QganNvcHRzID0gdGhpcy5qcy5nZXRPcHRpb25zKCk7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHtcbiAgICAgICAgICAgIHRpbWVvdXQ6IGpzb3B0cy50aW1lb3V0XG4gICAgICAgIH07XG4gICAgICAgIG9wdHMudGltZW91dCA9IG9wdHMudGltZW91dCB8fCBqc29wdHMudGltZW91dDtcbiAgICAgICAgb3B0cy5wcmV2aW91c1JldmlzaW9uID0gb3B0cy5wcmV2aW91c1JldmlzaW9uID8/IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgeyB0aW1lb3V0LCBwcmV2aW91c1JldmlzaW9uIH0gPSBvcHRzO1xuICAgICAgICBjb25zdCBzaSA9IHRoaXMuanMubmMuaW5mbztcbiAgICAgICAgY29uc3QgbWF4UGF5bG9hZCA9IHNpPy5tYXhfcGF5bG9hZCB8fCAxMDI0O1xuICAgICAgICBtZXRhID0gbWV0YSB8fCB7fTtcbiAgICAgICAgbWV0YS5vcHRpb25zID0gbWV0YS5vcHRpb25zIHx8IHt9O1xuICAgICAgICBsZXQgbWF4Q2h1bmsgPSBtZXRhLm9wdGlvbnM/Lm1heF9jaHVua19zaXplIHx8IDEyOCAqIDEwMjQ7XG4gICAgICAgIG1heENodW5rID0gbWF4Q2h1bmsgPiBtYXhQYXlsb2FkID8gbWF4UGF5bG9hZCA6IG1heENodW5rO1xuICAgICAgICBtZXRhLm9wdGlvbnMubWF4X2NodW5rX3NpemUgPSBtYXhDaHVuaztcbiAgICAgICAgY29uc3Qgb2xkID0gYXdhaXQgdGhpcy5pbmZvKG1ldGEubmFtZSk7XG4gICAgICAgIGNvbnN0IHsgbmFtZTogbiwgZXJyb3IgfSA9IHRoaXMuX2NoZWNrTm90RW1wdHkobWV0YS5uYW1lKTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkID0gbnVpZC5uZXh0KCk7XG4gICAgICAgIGNvbnN0IGNodW5rU3ViaiA9IHRoaXMuX2NodW5rU3ViamVjdChpZCk7XG4gICAgICAgIGNvbnN0IG1ldGFTdWJqID0gdGhpcy5fbWV0YVN1YmplY3Qobik7XG4gICAgICAgIGNvbnN0IGluZm8gPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGJ1Y2tldDogdGhpcy5uYW1lLFxuICAgICAgICAgICAgbnVpZDogaWQsXG4gICAgICAgICAgICBzaXplOiAwLFxuICAgICAgICAgICAgY2h1bmtzOiAwXG4gICAgICAgIH0sIHRvU2VydmVyT2JqZWN0U3RvcmVNZXRhKG1ldGEpKTtcbiAgICAgICAgY29uc3QgZCA9IGRlZmVycmVkKCk7XG4gICAgICAgIGNvbnN0IHByb21zID0gW107XG4gICAgICAgIGNvbnN0IGRiID0gbmV3IERhdGFCdWZmZXIoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHJzID8gcnMuZ2V0UmVhZGVyKCkgOiBudWxsO1xuICAgICAgICAgICAgY29uc3Qgc2hhID0gSi5jcmVhdGUoKTtcbiAgICAgICAgICAgIHdoaWxlKHRydWUpe1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IHJlYWRlciA/IGF3YWl0IHJlYWRlci5yZWFkKCkgOiB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYi5zaXplKCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZGIuZHJhaW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYS51cGRhdGUocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZvLmNodW5rcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5zaXplICs9IHBheWxvYWQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbXMucHVzaCh0aGlzLmpzLnB1Ymxpc2goY2h1bmtTdWJqLCBwYXlsb2FkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21zKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvbXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaW5mby5tdGltZSA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlnZXN0ID0gQmFzZTY0VXJsUGFkZGVkQ29kZWMuZW5jb2RlKHNoYS5kaWdlc3QoKSk7XG4gICAgICAgICAgICAgICAgICAgIGluZm8uZGlnZXN0ID0gYCR7ZGlnZXN0VHlwZX0ke2RpZ2VzdH1gO1xuICAgICAgICAgICAgICAgICAgICBpbmZvLmRlbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaCA9IGhlYWRlcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmV2aW91c1JldmlzaW9uID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoLnNldChQdWJIZWFkZXJzLkV4cGVjdGVkTGFzdFN1YmplY3RTZXF1ZW5jZUhkciwgYCR7cHJldmlvdXNSZXZpc2lvbn1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBoLnNldChKc0hlYWRlcnMuUm9sbHVwSGRyLCBKc0hlYWRlcnMuUm9sbHVwVmFsdWVTdWJqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGEgPSBhd2FpdCB0aGlzLmpzLnB1Ymxpc2gobWV0YVN1YmosIEpTT05Db2RlYygpLmVuY29kZShpbmZvKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGluZm8ucmV2aXNpb24gPSBwYS5zZXE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5qc20uc3RyZWFtcy5wdXJnZSh0aGlzLnN0cmVhbSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IGAkTy4ke3RoaXMubmFtZX0uQy4ke29sZC5udWlkfWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnIpIHt9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZC5yZXNvbHZlKG5ldyBPYmplY3RJbmZvSW1wbChpbmZvKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGIuZmlsbCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKGRiLnNpemUoKSA+IG1heENodW5rKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm8uY2h1bmtzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZvLnNpemUgKz0gbWF4Q2h1bms7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZGIuZHJhaW4obWV0YS5vcHRpb25zLm1heF9jaHVua19zaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYS51cGRhdGUocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9tcy5wdXNoKHRoaXMuanMucHVibGlzaChjaHVua1N1YmosIHBheWxvYWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5qc20uc3RyZWFtcy5wdXJnZSh0aGlzLnN0cmVhbSwge1xuICAgICAgICAgICAgICAgIGZpbHRlcjogY2h1bmtTdWJqXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGQucmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuICAgIHB1dEJsb2IobWV0YSwgZGF0YSwgb3B0cykge1xuICAgICAgICBmdW5jdGlvbiByZWFkYWJsZVN0cmVhbUZyb20oZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICAgICAgcHVsbCAoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnB1dChtZXRhLCByZWFkYWJsZVN0cmVhbUZyb20oZGF0YSksIG9wdHMpO1xuICAgIH1cbiAgICBwdXQobWV0YSwgcnMsIG9wdHMpIHtcbiAgICAgICAgaWYgKG1ldGE/Lm9wdGlvbnM/LmxpbmspIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJsaW5rIGNhbm5vdCBiZSBzZXQgd2hlbiBwdXR0aW5nIHRoZSBvYmplY3QgaW4gYnVja2V0XCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHV0KG1ldGEsIHJzLCBvcHRzKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QmxvYihuYW1lKSB7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGZyb21SZWFkYWJsZVN0cmVhbShycykge1xuICAgICAgICAgICAgY29uc3QgYnVmID0gbmV3IERhdGFCdWZmZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHJzLmdldFJlYWRlcigpO1xuICAgICAgICAgICAgd2hpbGUodHJ1ZSl7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmLmRyYWluKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmLmZpbGwodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByID0gYXdhaXQgdGhpcy5nZXQobmFtZSk7XG4gICAgICAgIGlmIChyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZzID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgci5lcnJvcixcbiAgICAgICAgICAgIGZyb21SZWFkYWJsZVN0cmVhbShyLmRhdGEpXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAodnNbMF0pIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh2c1swXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZzWzFdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXQobmFtZSkge1xuICAgICAgICBjb25zdCBpbmZvID0gYXdhaXQgdGhpcy5yYXdJbmZvKG5hbWUpO1xuICAgICAgICBpZiAoaW5mbyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5mby5kZWxldGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmZvLm9wdGlvbnMgJiYgaW5mby5vcHRpb25zLmxpbmspIHtcbiAgICAgICAgICAgIGNvbnN0IGxuID0gaW5mby5vcHRpb25zLmxpbmsubmFtZSB8fCBcIlwiO1xuICAgICAgICAgICAgaWYgKGxuID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibGluayBpcyBhIGJ1Y2tldFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9zID0gaW5mby5vcHRpb25zLmxpbmsuYnVja2V0ICE9PSB0aGlzLm5hbWUgPyBhd2FpdCBPYmplY3RTdG9yZUltcGwuY3JlYXRlKHRoaXMuanMsIGluZm8ub3B0aW9ucy5saW5rLmJ1Y2tldCkgOiB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIG9zLmdldChsbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbmZvLmRpZ2VzdC5zdGFydHNXaXRoKGRpZ2VzdFR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGB1bmtub3duIGRpZ2VzdCB0eXBlOiAke2luZm8uZGlnZXN0fWApKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaWdlc3QgPSBwYXJzZVNoYTI1NihpbmZvLmRpZ2VzdC5zdWJzdHJpbmcoOCkpO1xuICAgICAgICBpZiAoZGlnZXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGB1bmFibGUgdG8gcGFyc2UgZGlnZXN0OiAke2luZm8uZGlnZXN0fWApKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkID0gZGVmZXJyZWQoKTtcbiAgICAgICAgY29uc3QgciA9IHtcbiAgICAgICAgICAgIGluZm86IG5ldyBPYmplY3RJbmZvSW1wbChpbmZvKSxcbiAgICAgICAgICAgIGVycm9yOiBkXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpbmZvLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHIuZGF0YSA9IGVtcHR5UmVhZGFibGVTdHJlYW0oKTtcbiAgICAgICAgICAgIGQucmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRyb2xsZXI7XG4gICAgICAgIGNvbnN0IG9jID0gY29uc3VtZXJPcHRzKCk7XG4gICAgICAgIG9jLm9yZGVyZWRDb25zdW1lcigpO1xuICAgICAgICBjb25zdCBzaGEgPSBKLmNyZWF0ZSgpO1xuICAgICAgICBjb25zdCBzdWJqID0gYCRPLiR7dGhpcy5uYW1lfS5DLiR7aW5mby5udWlkfWA7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuanMuc3Vic2NyaWJlKHN1YmosIG9jKTtcbiAgICAgICAgKGFzeW5jICgpPT57XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGptIG9mIHN1Yil7XG4gICAgICAgICAgICAgICAgaWYgKGptLmRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzaGEudXBkYXRlKGptLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoam0uZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChqbS5pbmZvLnBlbmRpbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGVja1NoYTI1NihkaWdlc3QsIHNoYS5kaWdlc3QoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IobmV3IEVycm9yKGByZWNlaXZlZCBhIGNvcnJ1cHQgb2JqZWN0LCBkaWdlc3RzIGRvIG5vdCBtYXRjaCByZWNlaXZlZDogJHtpbmZvLmRpZ2VzdH0gY2FsY3VsYXRlZCAke2RpZ2VzdH1gKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpLnRoZW4oKCk9PntcbiAgICAgICAgICAgIGQucmVzb2x2ZSgpO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihlcnIpO1xuICAgICAgICAgICAgZC5yZWplY3QoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHIuZGF0YSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICBzdGFydCAoYykge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIgPSBjO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbmNlbCAoKSB7XG4gICAgICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgbGlua1N0b3JlKG5hbWUsIGJ1Y2tldCkge1xuICAgICAgICBpZiAoIShidWNrZXQgaW5zdGFuY2VvZiBPYmplY3RTdG9yZUltcGwpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJidWNrZXQgcmVxdWlyZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3NpID0gYnVja2V0O1xuICAgICAgICBjb25zdCB7IG5hbWU6IG4sIGVycm9yIH0gPSB0aGlzLl9jaGVja05vdEVtcHR5KG5hbWUpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6IG4sXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgbGluazoge1xuICAgICAgICAgICAgICAgICAgICBidWNrZXQ6IG9zaS5uYW1lXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fcHV0KG1ldGEsIG51bGwpO1xuICAgIH1cbiAgICBhc3luYyBsaW5rKG5hbWUsIGluZm8pIHtcbiAgICAgICAgY29uc3QgeyBuYW1lOiBuLCBlcnJvciB9ID0gdGhpcy5fY2hlY2tOb3RFbXB0eShuYW1lKTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmZvLmRlbGV0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJzcmMgb2JqZWN0IGlzIGRlbGV0ZWRcIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmZvLmlzTGluaygpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwic3JjIG9iamVjdCBpcyBhIGxpbmtcIikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlc3QgPSBhd2FpdCB0aGlzLnJhd0luZm8obmFtZSk7XG4gICAgICAgIGlmIChkZXN0ICE9PSBudWxsICYmICFkZXN0LmRlbGV0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJhbiBvYmplY3QgYWxyZWFkeSBleGlzdHMgd2l0aCB0aGF0IG5hbWVcIikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpbmsgPSB7XG4gICAgICAgICAgICBidWNrZXQ6IGluZm8uYnVja2V0LFxuICAgICAgICAgICAgbmFtZTogaW5mby5uYW1lXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1tID0ge1xuICAgICAgICAgICAgbmFtZTogbixcbiAgICAgICAgICAgIGJ1Y2tldDogaW5mby5idWNrZXQsXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgbGluazogbGlua1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBhd2FpdCB0aGlzLmpzLnB1Ymxpc2godGhpcy5fbWV0YVN1YmplY3QobmFtZSksIEpTT04uc3RyaW5naWZ5KG1tKSk7XG4gICAgICAgIGNvbnN0IGkgPSBhd2FpdCB0aGlzLmluZm8obmFtZSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaSk7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IGluZm8gPSBhd2FpdCB0aGlzLnJhd0luZm8obmFtZSk7XG4gICAgICAgIGlmIChpbmZvID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBwdXJnZWQ6IDAsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGluZm8uZGVsZXRlZCA9IHRydWU7XG4gICAgICAgIGluZm8uc2l6ZSA9IDA7XG4gICAgICAgIGluZm8uY2h1bmtzID0gMDtcbiAgICAgICAgaW5mby5kaWdlc3QgPSBcIlwiO1xuICAgICAgICBjb25zdCBqYyA9IEpTT05Db2RlYygpO1xuICAgICAgICBjb25zdCBoID0gaGVhZGVycygpO1xuICAgICAgICBoLnNldChKc0hlYWRlcnMuUm9sbHVwSGRyLCBKc0hlYWRlcnMuUm9sbHVwVmFsdWVTdWJqZWN0KTtcbiAgICAgICAgYXdhaXQgdGhpcy5qcy5wdWJsaXNoKHRoaXMuX21ldGFTdWJqZWN0KGluZm8ubmFtZSksIGpjLmVuY29kZShpbmZvKSwge1xuICAgICAgICAgICAgaGVhZGVyczogaFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuanNtLnN0cmVhbXMucHVyZ2UodGhpcy5zdHJlYW0sIHtcbiAgICAgICAgICAgIGZpbHRlcjogdGhpcy5fY2h1bmtTdWJqZWN0KGluZm8ubnVpZClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZShuYW1lLCBtZXRhID0ge30pIHtcbiAgICAgICAgY29uc3QgaW5mbyA9IGF3YWl0IHRoaXMucmF3SW5mbyhuYW1lKTtcbiAgICAgICAgaWYgKGluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJvYmplY3Qgbm90IGZvdW5kXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5mby5kZWxldGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiY2Fubm90IHVwZGF0ZSBtZXRhIGZvciBhIGRlbGV0ZWQgb2JqZWN0XCIpKTtcbiAgICAgICAgfVxuICAgICAgICBtZXRhLm5hbWUgPSBtZXRhLm5hbWUgPz8gaW5mby5uYW1lO1xuICAgICAgICBjb25zdCB7IG5hbWU6IG4sIGVycm9yIH0gPSB0aGlzLl9jaGVja05vdEVtcHR5KG1ldGEubmFtZSk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSAhPT0gbWV0YS5uYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBpID0gYXdhaXQgdGhpcy5pbmZvKG1ldGEubmFtZSk7XG4gICAgICAgICAgICBpZiAoaSAmJiAhaS5kZWxldGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImFuIG9iamVjdCBhbHJlYWR5IGV4aXN0cyB3aXRoIHRoYXQgbmFtZVwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWV0YS5uYW1lID0gbjtcbiAgICAgICAgY29uc3QgaWkgPSBPYmplY3QuYXNzaWduKHt9LCBpbmZvLCB0b1NlcnZlck9iamVjdFN0b3JlTWV0YShtZXRhKSk7XG4gICAgICAgIGNvbnN0IGFjayA9IGF3YWl0IHRoaXMuanMucHVibGlzaCh0aGlzLl9tZXRhU3ViamVjdChpaS5uYW1lKSwgSlNPTi5zdHJpbmdpZnkoaWkpKTtcbiAgICAgICAgaWYgKG5hbWUgIT09IG1ldGEubmFtZSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5qc20uc3RyZWFtcy5wdXJnZSh0aGlzLnN0cmVhbSwge1xuICAgICAgICAgICAgICAgIGZpbHRlcjogdGhpcy5fbWV0YVN1YmplY3QobmFtZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYWNrKTtcbiAgICB9XG4gICAgYXN5bmMgd2F0Y2gob3B0cyA9IHt9KSB7XG4gICAgICAgIG9wdHMuaW5jbHVkZUhpc3RvcnkgPSBvcHRzLmluY2x1ZGVIaXN0b3J5ID8/IGZhbHNlO1xuICAgICAgICBvcHRzLmlnbm9yZURlbGV0ZXMgPSBvcHRzLmlnbm9yZURlbGV0ZXMgPz8gZmFsc2U7XG4gICAgICAgIGxldCBpbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBxaSA9IG5ldyBRdWV1ZWRJdGVyYXRvckltcGwoKTtcbiAgICAgICAgY29uc3Qgc3ViaiA9IHRoaXMuX21ldGFTdWJqZWN0QWxsKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmpzbS5zdHJlYW1zLmdldE1lc3NhZ2UodGhpcy5zdHJlYW0sIHtcbiAgICAgICAgICAgICAgICBsYXN0X2J5X3N1Ymo6IHN1YmpcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gXCI0MDRcIikge1xuICAgICAgICAgICAgICAgIHFpLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBxaS5zdG9wKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgamMgPSBKU09OQ29kZWMoKTtcbiAgICAgICAgY29uc3QgY29wdHMgPSBjb25zdW1lck9wdHMoKTtcbiAgICAgICAgY29wdHMub3JkZXJlZENvbnN1bWVyKCk7XG4gICAgICAgIGlmIChvcHRzLmluY2x1ZGVIaXN0b3J5KSB7XG4gICAgICAgICAgICBjb3B0cy5kZWxpdmVyTGFzdFBlclN1YmplY3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvcHRzLmRlbGl2ZXJOZXcoKTtcbiAgICAgICAgfVxuICAgICAgICBjb3B0cy5jYWxsYmFjaygoZXJyLCBqbSk9PntcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBxaS5zdG9wKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGptICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2kgPSBqYy5kZWNvZGUoam0uZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKG9pLmRlbGV0ZWQgJiYgb3B0cy5pZ25vcmVEZWxldGVzID09PSB0cnVlKSB7fSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcWkucHVzaChvaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChqbS5pbmZvPy5wZW5kaW5nID09PSAwICYmICFpbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgICAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHFpLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgdGhpcy5qcy5zdWJzY3JpYmUoc3ViaiwgY29wdHMpO1xuICAgICAgICBxaS5fZGF0YSA9IHN1YjtcbiAgICAgICAgcWkuaXRlckNsb3NlZC50aGVuKCgpPT57XG4gICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN1Yi5jbG9zZWQudGhlbigoKT0+e1xuICAgICAgICAgICAgcWkuc3RvcCgpO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgcWkuc3RvcChlcnIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHFpO1xuICAgIH1cbiAgICBfY2h1bmtTdWJqZWN0KGlkKSB7XG4gICAgICAgIHJldHVybiBgJE8uJHt0aGlzLm5hbWV9LkMuJHtpZH1gO1xuICAgIH1cbiAgICBfbWV0YVN1YmplY3Qobikge1xuICAgICAgICByZXR1cm4gYCRPLiR7dGhpcy5uYW1lfS5NLiR7QmFzZTY0VXJsUGFkZGVkQ29kZWMuZW5jb2RlKG4pfWA7XG4gICAgfVxuICAgIF9tZXRhU3ViamVjdEFsbCgpIHtcbiAgICAgICAgcmV0dXJuIGAkTy4ke3RoaXMubmFtZX0uTS4+YDtcbiAgICB9XG4gICAgYXN5bmMgaW5pdChvcHRzID0ge30pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtID0gb2JqZWN0U3RvcmVTdHJlYW1OYW1lKHRoaXMubmFtZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF4X2FnZSA9IG9wdHM/LnR0bCB8fCAwO1xuICAgICAgICBkZWxldGUgb3B0cy50dGw7XG4gICAgICAgIGNvbnN0IHNjID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBtYXhfYWdlXG4gICAgICAgIH0sIG9wdHMpO1xuICAgICAgICBzYy5uYW1lID0gdGhpcy5zdHJlYW07XG4gICAgICAgIHNjLm51bV9yZXBsaWNhcyA9IG9wdHMucmVwbGljYXMgPz8gMTtcbiAgICAgICAgc2MuYWxsb3dfZGlyZWN0ID0gdHJ1ZTtcbiAgICAgICAgc2MuYWxsb3dfcm9sbHVwX2hkcnMgPSB0cnVlO1xuICAgICAgICBzYy5kaXNjYXJkID0gRGlzY2FyZFBvbGljeS5OZXc7XG4gICAgICAgIHNjLnN1YmplY3RzID0gW1xuICAgICAgICAgICAgYCRPLiR7dGhpcy5uYW1lfS5DLj5gLFxuICAgICAgICAgICAgYCRPLiR7dGhpcy5uYW1lfS5NLj5gXG4gICAgICAgIF07XG4gICAgICAgIGlmIChvcHRzLnBsYWNlbWVudCkge1xuICAgICAgICAgICAgc2MucGxhY2VtZW50ID0gb3B0cy5wbGFjZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMubWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHNjLm1ldGFkYXRhID0gb3B0cy5tZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdHMuY29tcHJlc3Npb24gPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBzYy5jb21wcmVzc2lvbiA9IG9wdHMuY29tcHJlc3Npb24gPyBTdG9yZUNvbXByZXNzaW9uLlMyIDogU3RvcmVDb21wcmVzc2lvbi5Ob25lO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmpzbS5zdHJlYW1zLmluZm8oc2MubmFtZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyci5tZXNzYWdlID09PSBcInN0cmVhbSBub3QgZm91bmRcIikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuanNtLnN0cmVhbXMuYWRkKHNjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlKGpzLCBuYW1lLCBvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3QganNtID0gYXdhaXQganMuamV0c3RyZWFtTWFuYWdlcigpO1xuICAgICAgICBjb25zdCBvcyA9IG5ldyBPYmplY3RTdG9yZUltcGwobmFtZSwganNtLCBqcyk7XG4gICAgICAgIGF3YWl0IG9zLmluaXQob3B0cyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUob3MpO1xuICAgIH1cbn1cbmNsYXNzIFZpZXdzSW1wbCB7XG4gICAganM7XG4gICAgY29uc3RydWN0b3IoanMpe1xuICAgICAgICB0aGlzLmpzID0ganM7XG4gICAgfVxuICAgIGt2KG5hbWUsIG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCBqc2kgPSB0aGlzLmpzO1xuICAgICAgICBjb25zdCB7IG9rLCBtaW4gfSA9IGpzaS5uYy5mZWF0dXJlcy5nZXQoRmVhdHVyZS5KU19LVik7XG4gICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYGt2IGlzIG9ubHkgc3VwcG9ydGVkIG9uIHNlcnZlcnMgJHttaW59IG9yIGJldHRlcmApKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5iaW5kT25seSkge1xuICAgICAgICAgICAgcmV0dXJuIEJ1Y2tldC5iaW5kKHRoaXMuanMsIG5hbWUsIG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCdWNrZXQuY3JlYXRlKHRoaXMuanMsIG5hbWUsIG9wdHMpO1xuICAgIH1cbiAgICBvcyhuYW1lLCBvcHRzID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8/LnN1YnRsZT8uZGlnZXN0ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJvYmplY3RzdG9yZTogdW5hYmxlIHRvIGNhbGN1bGF0ZSBoYXNoZXMgLSBjcnlwdG8uc3VidGxlLmRpZ2VzdCB3aXRoIHNoYTI1NiBzdXBwb3J0IGlzIHJlcXVpcmVkXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBqc2kgPSB0aGlzLmpzO1xuICAgICAgICBjb25zdCB7IG9rLCBtaW4gfSA9IGpzaS5uYy5mZWF0dXJlcy5nZXQoRmVhdHVyZS5KU19PQkpFQ1RTVE9SRSk7XG4gICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYG9iamVjdHN0b3JlIGlzIG9ubHkgc3VwcG9ydGVkIG9uIHNlcnZlcnMgJHttaW59IG9yIGJldHRlcmApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0U3RvcmVJbXBsLmNyZWF0ZSh0aGlzLmpzLCBuYW1lLCBvcHRzKTtcbiAgICB9XG59XG5jbGFzcyBKZXRTdHJlYW1DbGllbnRJbXBsIGV4dGVuZHMgQmFzZUFwaUNsaWVudCB7XG4gICAgY29uc3VtZXJzO1xuICAgIHN0cmVhbXM7XG4gICAgY29uc3VtZXJBUEk7XG4gICAgc3RyZWFtQVBJO1xuICAgIGNvbnN0cnVjdG9yKG5jLCBvcHRzKXtcbiAgICAgICAgc3VwZXIobmMsIG9wdHMpO1xuICAgICAgICB0aGlzLmNvbnN1bWVyQVBJID0gbmV3IENvbnN1bWVyQVBJSW1wbChuYywgb3B0cyk7XG4gICAgICAgIHRoaXMuc3RyZWFtQVBJID0gbmV3IFN0cmVhbUFQSUltcGwobmMsIG9wdHMpO1xuICAgICAgICB0aGlzLmNvbnN1bWVycyA9IG5ldyBDb25zdW1lcnNJbXBsKHRoaXMuY29uc3VtZXJBUEkpO1xuICAgICAgICB0aGlzLnN0cmVhbXMgPSBuZXcgU3RyZWFtc0ltcGwodGhpcy5zdHJlYW1BUEkpO1xuICAgIH1cbiAgICBqZXRzdHJlYW1NYW5hZ2VyKGNoZWNrQVBJKSB7XG4gICAgICAgIGlmIChjaGVja0FQSSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjaGVja0FQSSA9IHRoaXMub3B0cy5jaGVja0FQSTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRzLCB7XG4gICAgICAgICAgICBjaGVja0FQSVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmMuamV0c3RyZWFtTWFuYWdlcihvcHRzKTtcbiAgICB9XG4gICAgZ2V0IGFwaVByZWZpeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlZml4O1xuICAgIH1cbiAgICBnZXQgdmlld3MoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmlld3NJbXBsKHRoaXMpO1xuICAgIH1cbiAgICBhc3luYyBwdWJsaXNoKHN1YmosIGRhdGEgPSBFbXB0eSwgb3B0cykge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgb3B0cy5leHBlY3QgPSBvcHRzLmV4cGVjdCB8fCB7fTtcbiAgICAgICAgY29uc3QgbWggPSBvcHRzPy5oZWFkZXJzIHx8IGhlYWRlcnMoKTtcbiAgICAgICAgaWYgKG9wdHMpIHtcbiAgICAgICAgICAgIGlmIChvcHRzLm1zZ0lEKSB7XG4gICAgICAgICAgICAgICAgbWguc2V0KFB1YkhlYWRlcnMuTXNnSWRIZHIsIG9wdHMubXNnSUQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMuZXhwZWN0Lmxhc3RNc2dJRCkge1xuICAgICAgICAgICAgICAgIG1oLnNldChQdWJIZWFkZXJzLkV4cGVjdGVkTGFzdE1zZ0lkSGRyLCBvcHRzLmV4cGVjdC5sYXN0TXNnSUQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMuZXhwZWN0LnN0cmVhbU5hbWUpIHtcbiAgICAgICAgICAgICAgICBtaC5zZXQoUHViSGVhZGVycy5FeHBlY3RlZFN0cmVhbUhkciwgb3B0cy5leHBlY3Quc3RyZWFtTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdHMuZXhwZWN0Lmxhc3RTZXF1ZW5jZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIG1oLnNldChQdWJIZWFkZXJzLkV4cGVjdGVkTGFzdFNlcUhkciwgYCR7b3B0cy5leHBlY3QubGFzdFNlcXVlbmNlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRzLmV4cGVjdC5sYXN0U3ViamVjdFNlcXVlbmNlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgbWguc2V0KFB1YkhlYWRlcnMuRXhwZWN0ZWRMYXN0U3ViamVjdFNlcXVlbmNlSGRyLCBgJHtvcHRzLmV4cGVjdC5sYXN0U3ViamVjdFNlcXVlbmNlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvID0gb3B0cy50aW1lb3V0IHx8IHRoaXMudGltZW91dDtcbiAgICAgICAgY29uc3Qgcm8gPSB7fTtcbiAgICAgICAgaWYgKHRvKSB7XG4gICAgICAgICAgICByby50aW1lb3V0ID0gdG87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMpIHtcbiAgICAgICAgICAgIHJvLmhlYWRlcnMgPSBtaDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyByZXRyaWVzLCByZXRyeV9kZWxheSB9ID0gb3B0cztcbiAgICAgICAgcmV0cmllcyA9IHJldHJpZXMgfHwgMTtcbiAgICAgICAgcmV0cnlfZGVsYXkgPSByZXRyeV9kZWxheSB8fCAyNTA7XG4gICAgICAgIGxldCByO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgcmV0cmllczsgaSsrKXtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgciA9IGF3YWl0IHRoaXMubmMucmVxdWVzdChzdWJqLCBkYXRhLCBybyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZSA9IGVycjtcbiAgICAgICAgICAgICAgICBpZiAobmUuY29kZSA9PT0gXCI1MDNcIiAmJiBpICsgMSA8IHJldHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgZGVsYXkocmV0cnlfZGVsYXkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGEgPSB0aGlzLnBhcnNlSnNSZXNwb25zZShyKTtcbiAgICAgICAgaWYgKHBhLnN0cmVhbSA9PT0gXCJcIikge1xuICAgICAgICAgICAgdGhyb3cgTmF0c0Vycm9yLmVycm9yRm9yQ29kZShFcnJvckNvZGUuSmV0U3RyZWFtSW52YWxpZEFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcGEuZHVwbGljYXRlID0gcGEuZHVwbGljYXRlID8gcGEuZHVwbGljYXRlIDogZmFsc2U7XG4gICAgICAgIHJldHVybiBwYTtcbiAgICB9XG4gICAgYXN5bmMgcHVsbChzdHJlYW0sIGR1cmFibGUsIGV4cGlyZXMgPSAwKSB7XG4gICAgICAgIHZhbGlkYXRlU3RyZWFtTmFtZShzdHJlYW0pO1xuICAgICAgICB2YWxpZGF0ZUR1cmFibGVOYW1lKGR1cmFibGUpO1xuICAgICAgICBsZXQgdGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICAgICAgaWYgKGV4cGlyZXMgPiB0aW1lb3V0KSB7XG4gICAgICAgICAgICB0aW1lb3V0ID0gZXhwaXJlcztcbiAgICAgICAgfVxuICAgICAgICBleHBpcmVzID0gZXhwaXJlcyA8IDAgPyAwIDogbmFub3MoZXhwaXJlcyk7XG4gICAgICAgIGNvbnN0IHB1bGxPcHRzID0ge1xuICAgICAgICAgICAgYmF0Y2g6IDEsXG4gICAgICAgICAgICBub193YWl0OiBleHBpcmVzID09PSAwLFxuICAgICAgICAgICAgZXhwaXJlc1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtc2cgPSBhd2FpdCB0aGlzLm5jLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9LkNPTlNVTUVSLk1TRy5ORVhULiR7c3RyZWFtfS4ke2R1cmFibGV9YCwgdGhpcy5qYy5lbmNvZGUocHVsbE9wdHMpLCB7XG4gICAgICAgICAgICBub011eDogdHJ1ZSxcbiAgICAgICAgICAgIHRpbWVvdXRcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGVyciA9IGNoZWNrSnNFcnJvcihtc2cpO1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvSnNNc2cobXNnLCB0aGlzLnRpbWVvdXQpO1xuICAgIH1cbiAgICBmZXRjaChzdHJlYW0sIGR1cmFibGUsIG9wdHMgPSB7fSkge1xuICAgICAgICB2YWxpZGF0ZVN0cmVhbU5hbWUoc3RyZWFtKTtcbiAgICAgICAgdmFsaWRhdGVEdXJhYmxlTmFtZShkdXJhYmxlKTtcbiAgICAgICAgbGV0IHRpbWVyID0gbnVsbDtcbiAgICAgICAgY29uc3QgdHJhY2tCeXRlcyA9IChvcHRzLm1heF9ieXRlcyA/PyAwKSA+IDA7XG4gICAgICAgIGxldCByZWNlaXZlZEJ5dGVzID0gMDtcbiAgICAgICAgY29uc3QgbWF4X2J5dGVzID0gdHJhY2tCeXRlcyA/IG9wdHMubWF4X2J5dGVzIDogMDtcbiAgICAgICAgbGV0IG1vbml0b3IgPSBudWxsO1xuICAgICAgICBjb25zdCBhcmdzID0ge307XG4gICAgICAgIGFyZ3MuYmF0Y2ggPSBvcHRzLmJhdGNoIHx8IDE7XG4gICAgICAgIGlmIChtYXhfYnl0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZ2ID0gdGhpcy5uYy5mZWF0dXJlcy5nZXQoRmVhdHVyZS5KU19QVUxMX01BWF9CWVRFUyk7XG4gICAgICAgICAgICBpZiAoIWZ2Lm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtYXhfYnl0ZXMgaXMgb25seSBzdXBwb3J0ZWQgb24gc2VydmVycyAke2Z2Lm1pbn0gb3IgYmV0dGVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcmdzLm1heF9ieXRlcyA9IG1heF9ieXRlcztcbiAgICAgICAgfVxuICAgICAgICBhcmdzLm5vX3dhaXQgPSBvcHRzLm5vX3dhaXQgfHwgZmFsc2U7XG4gICAgICAgIGlmIChhcmdzLm5vX3dhaXQgJiYgYXJncy5leHBpcmVzKSB7XG4gICAgICAgICAgICBhcmdzLmV4cGlyZXMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4cGlyZXMgPSBvcHRzLmV4cGlyZXMgfHwgMDtcbiAgICAgICAgaWYgKGV4cGlyZXMpIHtcbiAgICAgICAgICAgIGFyZ3MuZXhwaXJlcyA9IG5hbm9zKGV4cGlyZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBpcmVzID09PSAwICYmIGFyZ3Mubm9fd2FpdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4cGlyZXMgb3Igbm9fd2FpdCBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYiA9IG9wdHMuaWRsZV9oZWFydGJlYXQgfHwgMDtcbiAgICAgICAgaWYgKGhiKSB7XG4gICAgICAgICAgICBhcmdzLmlkbGVfaGVhcnRiZWF0ID0gbmFub3MoaGIpO1xuICAgICAgICAgICAgaWYgKG9wdHMuZGVsYXlfaGVhcnRiZWF0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgYXJncy5pZGxlX2hlYXJ0YmVhdCA9IG5hbm9zKGhiICogNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcWkgPSBuZXcgUXVldWVkSXRlcmF0b3JJbXBsKCk7XG4gICAgICAgIGNvbnN0IHdhbnRzID0gYXJncy5iYXRjaDtcbiAgICAgICAgbGV0IHJlY2VpdmVkID0gMDtcbiAgICAgICAgcWkucHJvdG9jb2xGaWx0ZXJGbiA9IChqbSwgX2luZ2VzdCA9IGZhbHNlKT0+e1xuICAgICAgICAgICAgY29uc3QganNtaSA9IGptO1xuICAgICAgICAgICAgaWYgKGlzSGVhcnRiZWF0TXNnKGpzbWkubXNnKSkge1xuICAgICAgICAgICAgICAgIG1vbml0b3I/LndvcmsoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgcWkuZGlzcGF0Y2hlZEZuID0gKG0pPT57XG4gICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgIGlmICh0cmFja0J5dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkQnl0ZXMgKz0gbS5kYXRhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQrKztcbiAgICAgICAgICAgICAgICBpZiAodGltZXIgJiYgbS5pbmZvLnBlbmRpbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocWkuZ2V0UGVuZGluZygpID09PSAxICYmIG0uaW5mby5wZW5kaW5nID09PSAwIHx8IHdhbnRzID09PSByZWNlaXZlZCB8fCBtYXhfYnl0ZXMgPiAwICYmIHJlY2VpdmVkQnl0ZXMgPj0gbWF4X2J5dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHFpLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGluYm94ID0gY3JlYXRlSW5ib3godGhpcy5uYy5vcHRpb25zLmluYm94UHJlZml4KTtcbiAgICAgICAgY29uc3Qgc3ViID0gdGhpcy5uYy5zdWJzY3JpYmUoaW5ib3gsIHtcbiAgICAgICAgICAgIG1heDogb3B0cy5iYXRjaCxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoZXJyLCBtc2cpPT57XG4gICAgICAgICAgICAgICAgaWYgKGVyciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBlcnIgPSBjaGVja0pzRXJyb3IobXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVyciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hdHNFcnJvcihlcnIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxaS5zdG9wKGhpZGVOb25UZXJtaW5hbEpzRXJyb3JzKGVycikgPT09IG51bGwgPyB1bmRlZmluZWQgOiBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcWkuc3RvcChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbW9uaXRvcj8ud29yaygpO1xuICAgICAgICAgICAgICAgICAgICBxaS5yZWNlaXZlZCsrO1xuICAgICAgICAgICAgICAgICAgICBxaS5wdXNoKHRvSnNNc2cobXNnLCB0aGlzLnRpbWVvdXQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZXhwaXJlcykge1xuICAgICAgICAgICAgdGltZXIgPSB0aW1lb3V0KGV4cGlyZXMpO1xuICAgICAgICAgICAgdGltZXIuY2F0Y2goKCk9PntcbiAgICAgICAgICAgICAgICBpZiAoIXN1Yi5pc0Nsb3NlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Yi5kcmFpbigpLmNhdGNoKCgpPT57fSk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1vbml0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9uaXRvci5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAoYXN5bmMgKCk9PntcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGhiKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vbml0b3IgPSBuZXcgSWRsZUhlYXJ0YmVhdE1vbml0b3IoaGIsICh2KT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgcWkucHVzaCgoKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFpLmVyciA9IG5ldyBOYXRzRXJyb3IoYCR7SnM0MDlFcnJvcnMuSWRsZUhlYXJ0YmVhdE1pc3NlZH06ICR7dn1gLCBFcnJvckNvZGUuSmV0U3RyZWFtSWRsZUhlYXJ0QmVhdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChfZXJyKSB7fVxuICAgICAgICAgICAgYXdhaXQgc3ViLmNsb3NlZDtcbiAgICAgICAgICAgIGlmICh0aW1lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRpbWVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb25pdG9yKSB7XG4gICAgICAgICAgICAgICAgbW9uaXRvci5jYW5jZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHFpLnN0b3AoKTtcbiAgICAgICAgfSkoKS5jYXRjaCgpO1xuICAgICAgICB0aGlzLm5jLnB1Ymxpc2goYCR7dGhpcy5wcmVmaXh9LkNPTlNVTUVSLk1TRy5ORVhULiR7c3RyZWFtfS4ke2R1cmFibGV9YCwgdGhpcy5qYy5lbmNvZGUoYXJncyksIHtcbiAgICAgICAgICAgIHJlcGx5OiBpbmJveFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHFpO1xuICAgIH1cbiAgICBhc3luYyBwdWxsU3Vic2NyaWJlKHN1YmplY3QsIG9wdHMgPSBjb25zdW1lck9wdHMoKSkge1xuICAgICAgICBjb25zdCBjc28gPSBhd2FpdCB0aGlzLl9wcm9jZXNzT3B0aW9ucyhzdWJqZWN0LCBvcHRzKTtcbiAgICAgICAgaWYgKGNzby5vcmRlcmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwdWxsIHN1YnNjcmliZXJzIGNhbm5vdCBiZSBiZSBvcmRlcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjc28uY29uZmlnLmRlbGl2ZXJfc3ViamVjdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29uc3VtZXIgaW5mbyBzcGVjaWZpZXMgZGVsaXZlcl9zdWJqZWN0IC0gcHVsbCBjb25zdW1lcnMgY2Fubm90IGhhdmUgZGVsaXZlcl9zdWJqZWN0IHNldFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY2tQb2xpY3kgPSBjc28uY29uZmlnLmFja19wb2xpY3k7XG4gICAgICAgIGlmIChhY2tQb2xpY3kgPT09IEFja1BvbGljeS5Ob25lIHx8IGFja1BvbGljeSA9PT0gQWNrUG9saWN5LkFsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWNrIHBvbGljeSBmb3IgcHVsbCBjb25zdW1lcnMgbXVzdCBiZSBleHBsaWNpdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzbyA9IHRoaXMuX2J1aWxkVHlwZWRTdWJzY3JpcHRpb25PcHRzKGNzbyk7XG4gICAgICAgIGNvbnN0IHN1YiA9IG5ldyBKZXRTdHJlYW1QdWxsU3Vic2NyaXB0aW9uSW1wbCh0aGlzLCBjc28uZGVsaXZlciwgc28pO1xuICAgICAgICBzdWIuaW5mbyA9IGNzbztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX21heWJlQ3JlYXRlQ29uc3VtZXIoY3NvKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3ViO1xuICAgIH1cbiAgICBhc3luYyBzdWJzY3JpYmUoc3ViamVjdCwgb3B0cyA9IGNvbnN1bWVyT3B0cygpKSB7XG4gICAgICAgIGNvbnN0IGNzbyA9IGF3YWl0IHRoaXMuX3Byb2Nlc3NPcHRpb25zKHN1YmplY3QsIG9wdHMpO1xuICAgICAgICBpZiAoIWNzby5pc0JpbmQgJiYgIWNzby5jb25maWcuZGVsaXZlcl9zdWJqZWN0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwdXNoIGNvbnN1bWVyIHJlcXVpcmVzIGRlbGl2ZXJfc3ViamVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzbyA9IHRoaXMuX2J1aWxkVHlwZWRTdWJzY3JpcHRpb25PcHRzKGNzbyk7XG4gICAgICAgIGNvbnN0IHN1YiA9IG5ldyBKZXRTdHJlYW1TdWJzY3JpcHRpb25JbXBsKHRoaXMsIGNzby5kZWxpdmVyLCBzbyk7XG4gICAgICAgIHN1Yi5pbmZvID0gY3NvO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fbWF5YmVDcmVhdGVDb25zdW1lcihjc28pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIHN1Yi5fbWF5YmVTZXR1cEhiTW9uaXRvcmluZygpO1xuICAgICAgICByZXR1cm4gc3ViO1xuICAgIH1cbiAgICBhc3luYyBfcHJvY2Vzc09wdGlvbnMoc3ViamVjdCwgb3B0cyA9IGNvbnN1bWVyT3B0cygpKSB7XG4gICAgICAgIGNvbnN0IGpzaSA9IGlzQ29uc3VtZXJPcHRzQnVpbGRlcihvcHRzKSA/IG9wdHMuZ2V0T3B0cygpIDogb3B0cztcbiAgICAgICAganNpLmlzQmluZCA9IGlzQ29uc3VtZXJPcHRzQnVpbGRlcihvcHRzKSA/IG9wdHMuaXNCaW5kIDogZmFsc2U7XG4gICAgICAgIGpzaS5mbG93X2NvbnRyb2wgPSB7XG4gICAgICAgICAgICBoZWFydGJlYXRfY291bnQ6IDAsXG4gICAgICAgICAgICBmY19jb3VudDogMCxcbiAgICAgICAgICAgIGNvbnN1bWVyX3Jlc3RhcnRzOiAwXG4gICAgICAgIH07XG4gICAgICAgIGlmIChqc2kub3JkZXJlZCkge1xuICAgICAgICAgICAganNpLm9yZGVyZWRfY29uc3VtZXJfc2VxdWVuY2UgPSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtX3NlcTogMCxcbiAgICAgICAgICAgICAgICBkZWxpdmVyeV9zZXE6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoanNpLmNvbmZpZy5hY2tfcG9saWN5ICE9PSBBY2tQb2xpY3kuTm90U2V0ICYmIGpzaS5jb25maWcuYWNrX3BvbGljeSAhPT0gQWNrUG9saWN5Lk5vbmUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTmF0c0Vycm9yKFwib3JkZXJlZCBjb25zdW1lcjogYWNrX3BvbGljeSBjYW4gb25seSBiZSBzZXQgdG8gJ25vbmUnXCIsIEVycm9yQ29kZS5BcGlFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoanNpLmNvbmZpZy5kdXJhYmxlX25hbWUgJiYganNpLmNvbmZpZy5kdXJhYmxlX25hbWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOYXRzRXJyb3IoXCJvcmRlcmVkIGNvbnN1bWVyOiBkdXJhYmxlX25hbWUgY2Fubm90IGJlIHNldFwiLCBFcnJvckNvZGUuQXBpRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGpzaS5jb25maWcuZGVsaXZlcl9zdWJqZWN0ICYmIGpzaS5jb25maWcuZGVsaXZlcl9zdWJqZWN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTmF0c0Vycm9yKFwib3JkZXJlZCBjb25zdW1lcjogZGVsaXZlcl9zdWJqZWN0IGNhbm5vdCBiZSBzZXRcIiwgRXJyb3JDb2RlLkFwaUVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqc2kuY29uZmlnLm1heF9kZWxpdmVyICE9PSB1bmRlZmluZWQgJiYganNpLmNvbmZpZy5tYXhfZGVsaXZlciA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTmF0c0Vycm9yKFwib3JkZXJlZCBjb25zdW1lcjogbWF4X2RlbGl2ZXIgY2Fubm90IGJlIHNldFwiLCBFcnJvckNvZGUuQXBpRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGpzaS5jb25maWcuZGVsaXZlcl9ncm91cCAmJiBqc2kuY29uZmlnLmRlbGl2ZXJfZ3JvdXAubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOYXRzRXJyb3IoXCJvcmRlcmVkIGNvbnN1bWVyOiBkZWxpdmVyX2dyb3VwIGNhbm5vdCBiZSBzZXRcIiwgRXJyb3JDb2RlLkFwaUVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGpzaS5jb25maWcuZGVsaXZlcl9zdWJqZWN0ID0gY3JlYXRlSW5ib3godGhpcy5uYy5vcHRpb25zLmluYm94UHJlZml4KTtcbiAgICAgICAgICAgIGpzaS5jb25maWcuYWNrX3BvbGljeSA9IEFja1BvbGljeS5Ob25lO1xuICAgICAgICAgICAganNpLmNvbmZpZy5tYXhfZGVsaXZlciA9IDE7XG4gICAgICAgICAgICBqc2kuY29uZmlnLmZsb3dfY29udHJvbCA9IHRydWU7XG4gICAgICAgICAgICBqc2kuY29uZmlnLmlkbGVfaGVhcnRiZWF0ID0ganNpLmNvbmZpZy5pZGxlX2hlYXJ0YmVhdCB8fCBuYW5vcyg1MDAwKTtcbiAgICAgICAgICAgIGpzaS5jb25maWcuYWNrX3dhaXQgPSBuYW5vcygyMiAqIDYwICogNjAgKiAxMDAwKTtcbiAgICAgICAgICAgIGpzaS5jb25maWcubWVtX3N0b3JhZ2UgPSB0cnVlO1xuICAgICAgICAgICAganNpLmNvbmZpZy5udW1fcmVwbGljYXMgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqc2kuY29uZmlnLmFja19wb2xpY3kgPT09IEFja1BvbGljeS5Ob3RTZXQpIHtcbiAgICAgICAgICAgIGpzaS5jb25maWcuYWNrX3BvbGljeSA9IEFja1BvbGljeS5BbGw7XG4gICAgICAgIH1cbiAgICAgICAganNpLmFwaSA9IHRoaXM7XG4gICAgICAgIGpzaS5jb25maWcgPSBqc2kuY29uZmlnIHx8IHt9O1xuICAgICAgICBqc2kuc3RyZWFtID0ganNpLnN0cmVhbSA/IGpzaS5zdHJlYW0gOiBhd2FpdCB0aGlzLmZpbmRTdHJlYW0oc3ViamVjdCk7XG4gICAgICAgIGpzaS5hdHRhY2hlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoanNpLmNvbmZpZy5kdXJhYmxlX25hbWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5mbyA9IGF3YWl0IHRoaXMuY29uc3VtZXJBUEkuaW5mbyhqc2kuc3RyZWFtLCBqc2kuY29uZmlnLmR1cmFibGVfbmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8uY29uZmlnLmZpbHRlcl9zdWJqZWN0ICYmIGluZm8uY29uZmlnLmZpbHRlcl9zdWJqZWN0ICE9PSBzdWJqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWJqZWN0IGRvZXMgbm90IG1hdGNoIGNvbnN1bWVyXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHFuID0ganNpLmNvbmZpZy5kZWxpdmVyX2dyb3VwID8/IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxbiA9PT0gXCJcIiAmJiBpbmZvLnB1c2hfYm91bmQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlIHN1YnNjcmlwdGlvbmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJxbiA9IGluZm8uY29uZmlnLmRlbGl2ZXJfZ3JvdXAgPz8gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHFuICE9PSBycW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChycW4gPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGR1cmFibGUgcmVxdWlyZXMgbm8gcXVldWUgZ3JvdXBgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkdXJhYmxlIHJlcXVpcmVzIHF1ZXVlIGdyb3VwICcke3Jxbn0nYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAganNpLmxhc3QgPSBpbmZvO1xuICAgICAgICAgICAgICAgICAgICBqc2kuY29uZmlnID0gaW5mby5jb25maWc7XG4gICAgICAgICAgICAgICAgICAgIGpzaS5hdHRhY2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghanNpLmNvbmZpZy5kdXJhYmxlX25hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzaS5uYW1lID0gaW5mby5uYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyci5jb2RlICE9PSBcIjQwNFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFqc2kuYXR0YWNoZWQgJiYganNpLmNvbmZpZy5maWx0ZXJfc3ViamVjdCA9PT0gdW5kZWZpbmVkICYmIGpzaS5jb25maWcuZmlsdGVyX3N1YmplY3RzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGpzaS5jb25maWcuZmlsdGVyX3N1YmplY3QgPSBzdWJqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGpzaS5kZWxpdmVyID0ganNpLmNvbmZpZy5kZWxpdmVyX3N1YmplY3QgfHwgY3JlYXRlSW5ib3godGhpcy5uYy5vcHRpb25zLmluYm94UHJlZml4KTtcbiAgICAgICAgcmV0dXJuIGpzaTtcbiAgICB9XG4gICAgX2J1aWxkVHlwZWRTdWJzY3JpcHRpb25PcHRzKGpzaSkge1xuICAgICAgICBjb25zdCBzbyA9IHt9O1xuICAgICAgICBzby5hZGFwdGVyID0gbXNnQWRhcHRlcihqc2kuY2FsbGJhY2tGbiA9PT0gdW5kZWZpbmVkLCB0aGlzLnRpbWVvdXQpO1xuICAgICAgICBzby5pbmdlc3Rpb25GaWx0ZXJGbiA9IEpldFN0cmVhbUNsaWVudEltcGwuaW5nZXN0aW9uRm4oanNpLm9yZGVyZWQpO1xuICAgICAgICBzby5wcm90b2NvbEZpbHRlckZuID0gKGptLCBpbmdlc3QgPSBmYWxzZSk9PntcbiAgICAgICAgICAgIGNvbnN0IGpzbWkgPSBqbTtcbiAgICAgICAgICAgIGlmIChpc0Zsb3dDb250cm9sTXNnKGpzbWkubXNnKSkge1xuICAgICAgICAgICAgICAgIGlmICghaW5nZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGpzbWkubXNnLnJlc3BvbmQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIGlmICghanNpLm1hY2sgJiYganNpLmNvbmZpZy5hY2tfcG9saWN5ICE9PSBBY2tQb2xpY3kuTm9uZSkge1xuICAgICAgICAgICAgc28uZGlzcGF0Y2hlZEZuID0gYXV0b0Fja0pzTXNnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqc2kuY2FsbGJhY2tGbikge1xuICAgICAgICAgICAgc28uY2FsbGJhY2sgPSBqc2kuY2FsbGJhY2tGbjtcbiAgICAgICAgfVxuICAgICAgICBzby5tYXggPSBqc2kubWF4IHx8IDA7XG4gICAgICAgIHNvLnF1ZXVlID0ganNpLnF1ZXVlO1xuICAgICAgICByZXR1cm4gc287XG4gICAgfVxuICAgIGFzeW5jIF9tYXliZUNyZWF0ZUNvbnN1bWVyKGpzaSkge1xuICAgICAgICBpZiAoanNpLmF0dGFjaGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGpzaS5pc0JpbmQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5hYmxlIHRvIGJpbmQgLSBkdXJhYmxlIGNvbnN1bWVyICR7anNpLmNvbmZpZy5kdXJhYmxlX25hbWV9IGRvZXNuJ3QgZXhpc3QgaW4gJHtqc2kuc3RyZWFtfWApO1xuICAgICAgICB9XG4gICAgICAgIGpzaS5jb25maWcgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGRlbGl2ZXJfcG9saWN5OiBEZWxpdmVyUG9saWN5LkFsbCxcbiAgICAgICAgICAgIGFja19wb2xpY3k6IEFja1BvbGljeS5FeHBsaWNpdCxcbiAgICAgICAgICAgIGFja193YWl0OiBuYW5vcygzMCAqIDEwMDApLFxuICAgICAgICAgICAgcmVwbGF5X3BvbGljeTogUmVwbGF5UG9saWN5Lkluc3RhbnRcbiAgICAgICAgfSwganNpLmNvbmZpZyk7XG4gICAgICAgIGNvbnN0IGNpID0gYXdhaXQgdGhpcy5jb25zdW1lckFQSS5hZGQoanNpLnN0cmVhbSwganNpLmNvbmZpZyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGpzaS5jb25maWcuZmlsdGVyX3N1YmplY3RzICYmICFBcnJheS5pc0FycmF5KGNpLmNvbmZpZy5maWx0ZXJfc3ViamVjdHMpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBqZXRzdHJlYW0gc2VydmVyIGRvZXNuJ3Qgc3VwcG9ydCBjb25zdW1lcnMgd2l0aCBtdWx0aXBsZSBmaWx0ZXIgc3ViamVjdHNgKTtcbiAgICAgICAgfVxuICAgICAgICBqc2kubmFtZSA9IGNpLm5hbWU7XG4gICAgICAgIGpzaS5jb25maWcgPSBjaS5jb25maWc7XG4gICAgICAgIGpzaS5sYXN0ID0gY2k7XG4gICAgfVxuICAgIHN0YXRpYyBpbmdlc3Rpb25GbihvcmRlcmVkKSB7XG4gICAgICAgIHJldHVybiAoam0sIGN0eCk9PntcbiAgICAgICAgICAgIGNvbnN0IGpzdWIgPSBjdHg7XG4gICAgICAgICAgICBpZiAoIWptKSByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGluZ2VzdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcHJvdG9jb2w6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgam1pID0gam07XG4gICAgICAgICAgICBpZiAoIWNoZWNrSnNFcnJvcihqbWkubXNnKSkge1xuICAgICAgICAgICAgICAgIGpzdWIubW9uaXRvcj8ud29yaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzSGVhcnRiZWF0TXNnKGptaS5tc2cpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5nZXN0ID0gb3JkZXJlZCA/IGpzdWIuX2NoZWNrSGJPcmRlckNvbnN1bWVyKGptaS5tc2cpIDogdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIW9yZGVyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAganN1Yi5pbmZvLmZsb3dfY29udHJvbC5oZWFydGJlYXRfY291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaW5nZXN0LFxuICAgICAgICAgICAgICAgICAgICBwcm90b2NvbDogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzRmxvd0NvbnRyb2xNc2coam1pLm1zZykpIHtcbiAgICAgICAgICAgICAgICBqc3ViLmluZm8uZmxvd19jb250cm9sLmZjX2NvdW50Kys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaW5nZXN0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBwcm90b2NvbDogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbmdlc3QgPSBvcmRlcmVkID8ganN1Yi5fY2hlY2tPcmRlcmVkQ29uc3VtZXIoam0pIDogdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW5nZXN0LFxuICAgICAgICAgICAgICAgIHByb3RvY29sOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5jbGFzcyBOYXRzQ29ubmVjdGlvbkltcGwge1xuICAgIG9wdGlvbnM7XG4gICAgcHJvdG9jb2w7XG4gICAgZHJhaW5pbmc7XG4gICAgbGlzdGVuZXJzO1xuICAgIF9zZXJ2aWNlcztcbiAgICBjb25zdHJ1Y3RvcihvcHRzKXtcbiAgICAgICAgdGhpcy5kcmFpbmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBwYXJzZU9wdGlvbnMob3B0cyk7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgfVxuICAgIHN0YXRpYyBjb25uZWN0KG9wdHMgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgICAgIGNvbnN0IG5jID0gbmV3IE5hdHNDb25uZWN0aW9uSW1wbChvcHRzKTtcbiAgICAgICAgICAgIFByb3RvY29sSGFuZGxlci5jb25uZWN0KG5jLm9wdGlvbnMsIG5jKS50aGVuKChwaCk9PntcbiAgICAgICAgICAgICAgICBuYy5wcm90b2NvbCA9IHBoO1xuICAgICAgICAgICAgICAgIChhc3luYyBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBzIG9mIHBoLnN0YXR1cygpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5jLmxpc3RlbmVycy5mb3JFYWNoKChsKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwucHVzaChzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG5jKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdG9jb2wuY2xvc2VkO1xuICAgIH1cbiAgICBhc3luYyBjbG9zZSgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm90b2NvbC5jbG9zZSgpO1xuICAgIH1cbiAgICBfY2hlY2soc3ViamVjdCwgc3ViLCBwdWIpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgTmF0c0Vycm9yLmVycm9yRm9yQ29kZShFcnJvckNvZGUuQ29ubmVjdGlvbkNsb3NlZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1YiAmJiB0aGlzLmlzRHJhaW5pbmcoKSkge1xuICAgICAgICAgICAgdGhyb3cgTmF0c0Vycm9yLmVycm9yRm9yQ29kZShFcnJvckNvZGUuQ29ubmVjdGlvbkRyYWluaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHViICYmIHRoaXMucHJvdG9jb2wubm9Nb3JlUHVibGlzaGluZykge1xuICAgICAgICAgICAgdGhyb3cgTmF0c0Vycm9yLmVycm9yRm9yQ29kZShFcnJvckNvZGUuQ29ubmVjdGlvbkRyYWluaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJqZWN0ID0gc3ViamVjdCB8fCBcIlwiO1xuICAgICAgICBpZiAoc3ViamVjdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLkJhZFN1YmplY3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHB1Ymxpc2goc3ViamVjdCwgZGF0YSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9jaGVjayhzdWJqZWN0LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMucHJvdG9jb2wucHVibGlzaChzdWJqZWN0LCBkYXRhLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcHVibGlzaE1lc3NhZ2UobXNnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1Ymxpc2gobXNnLnN1YmplY3QsIG1zZy5kYXRhLCB7XG4gICAgICAgICAgICByZXBseTogbXNnLnJlcGx5LFxuICAgICAgICAgICAgaGVhZGVyczogbXNnLmhlYWRlcnNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc3BvbmRNZXNzYWdlKG1zZykge1xuICAgICAgICBpZiAobXNnLnJlcGx5KSB7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2gobXNnLnJlcGx5LCBtc2cuZGF0YSwge1xuICAgICAgICAgICAgICAgIHJlcGx5OiBtc2cucmVwbHksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogbXNnLmhlYWRlcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzdWJzY3JpYmUoc3ViamVjdCwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHRoaXMuX2NoZWNrKHN1YmplY3QsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgY29uc3Qgc3ViID0gbmV3IFN1YnNjcmlwdGlvbkltcGwodGhpcy5wcm90b2NvbCwgc3ViamVjdCwgb3B0cyk7XG4gICAgICAgIHRoaXMucHJvdG9jb2wuc3Vic2NyaWJlKHN1Yik7XG4gICAgICAgIHJldHVybiBzdWI7XG4gICAgfVxuICAgIF9yZXN1YihzLCBzdWJqZWN0LCBtYXgpIHtcbiAgICAgICAgdGhpcy5fY2hlY2soc3ViamVjdCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICBjb25zdCBzaSA9IHM7XG4gICAgICAgIHNpLm1heCA9IG1heDtcbiAgICAgICAgaWYgKG1heCkge1xuICAgICAgICAgICAgc2kubWF4ID0gbWF4ICsgc2kucmVjZWl2ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm90b2NvbC5yZXN1YihzaSwgc3ViamVjdCk7XG4gICAgfVxuICAgIHJlcXVlc3RNYW55KHN1YmplY3QsIGRhdGEgPSBFbXB0eSwgb3B0cyA9IHtcbiAgICAgICAgbWF4V2FpdDogMTAwMCxcbiAgICAgICAgbWF4TWVzc2FnZXM6IC0xXG4gICAgfSkge1xuICAgICAgICBjb25zdCBhc3luY1RyYWNlcyA9ICEodGhpcy5wcm90b2NvbC5vcHRpb25zLm5vQXN5bmNUcmFjZXMgfHwgZmFsc2UpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2soc3ViamVjdCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgICAgb3B0cy5zdHJhdGVneSA9IG9wdHMuc3RyYXRlZ3kgfHwgUmVxdWVzdFN0cmF0ZWd5LlRpbWVyO1xuICAgICAgICBvcHRzLm1heFdhaXQgPSBvcHRzLm1heFdhaXQgfHwgMTAwMDtcbiAgICAgICAgaWYgKG9wdHMubWF4V2FpdCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgTmF0c0Vycm9yKFwidGltZW91dFwiLCBFcnJvckNvZGUuSW52YWxpZE9wdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHFpID0gbmV3IFF1ZXVlZEl0ZXJhdG9ySW1wbCgpO1xuICAgICAgICBmdW5jdGlvbiBzdG9wKGVycikge1xuICAgICAgICAgICAgcWkucHVzaCgoKT0+e1xuICAgICAgICAgICAgICAgIHFpLnN0b3AoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNhbGxiYWNrKGVyciwgbXNnKSB7XG4gICAgICAgICAgICBpZiAoZXJyIHx8IG1zZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN0b3AoZXJyID09PSBudWxsID8gdW5kZWZpbmVkIDogZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcWkucHVzaChtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLm5vTXV4KSB7XG4gICAgICAgICAgICBjb25zdCBzdGFjayA9IGFzeW5jVHJhY2VzID8gbmV3IEVycm9yKCkuc3RhY2sgOiBudWxsO1xuICAgICAgICAgICAgbGV0IG1heCA9IHR5cGVvZiBvcHRzLm1heE1lc3NhZ2VzID09PSBcIm51bWJlclwiICYmIG9wdHMubWF4TWVzc2FnZXMgPiAwID8gb3B0cy5tYXhNZXNzYWdlcyA6IC0xO1xuICAgICAgICAgICAgY29uc3Qgc3ViID0gdGhpcy5zdWJzY3JpYmUoY3JlYXRlSW5ib3godGhpcy5vcHRpb25zLmluYm94UHJlZml4KSwge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiAoZXJyLCBtc2cpPT57XG4gICAgICAgICAgICAgICAgICAgIGlmIChtc2c/LmRhdGE/Lmxlbmd0aCA9PT0gMCAmJiBtc2c/LmhlYWRlcnM/LnN0YXR1cyA9PT0gRXJyb3JDb2RlLk5vUmVzcG9uZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gTmF0c0Vycm9yLmVycm9yRm9yQ29kZShFcnJvckNvZGUuTm9SZXNwb25kZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIuc3RhY2sgKz0gYFxcblxcbiR7c3RhY2t9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG1zZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLnN0cmF0ZWd5ID09PSBSZXF1ZXN0U3RyYXRlZ3kuQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLnN0cmF0ZWd5ID09PSBSZXF1ZXN0U3RyYXRlZ3kuSml0dGVyVGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDMwMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMuc3RyYXRlZ3kgPT09IFJlcXVlc3RTdHJhdGVneS5TZW50aW5lbE1zZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1zZyAmJiBtc2cuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3ViLnJlcXVlc3RTdWJqZWN0ID0gc3ViamVjdDtcbiAgICAgICAgICAgIHN1Yi5jbG9zZWQudGhlbigoKT0+e1xuICAgICAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICAgICAgcWkuc3RvcChlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjYW5jZWwgPSAoZXJyKT0+e1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcWkucHVzaCgoKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lcnMoKTtcbiAgICAgICAgICAgICAgICBzdWIuZHJhaW4oKS50aGVuKCgpPT57XG4gICAgICAgICAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaCgoX2Vycik9PntcbiAgICAgICAgICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHFpLml0ZXJDbG9zZWQudGhlbigoKT0+e1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZXJzKCk7XG4gICAgICAgICAgICAgICAgc3ViPy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfSkuY2F0Y2goKF9lcnIpPT57XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lcnMoKTtcbiAgICAgICAgICAgICAgICBzdWI/LnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHN1YmplY3QsIGRhdGEsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbHk6IHN1Yi5nZXRTdWJqZWN0KClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNhbmNlbChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRpbWVyID0gc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICAgICAgfSwgb3B0cy5tYXhXYWl0KTtcbiAgICAgICAgICAgIGNvbnN0IGNsZWFyVGltZXJzID0gKCk9PntcbiAgICAgICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgcm1vID0gb3B0cztcbiAgICAgICAgICAgIHJtby5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgcWkuaXRlckNsb3NlZC50aGVuKCgpPT57XG4gICAgICAgICAgICAgICAgci5jYW5jZWwoKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICAgICAgci5jYW5jZWwoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgciA9IG5ldyBSZXF1ZXN0TWFueSh0aGlzLnByb3RvY29sLm11eFN1YnNjcmlwdGlvbnMsIHN1YmplY3QsIHJtbyk7XG4gICAgICAgICAgICB0aGlzLnByb3RvY29sLnJlcXVlc3Qocik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaChzdWJqZWN0LCBkYXRhLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGx5OiBgJHt0aGlzLnByb3RvY29sLm11eFN1YnNjcmlwdGlvbnMuYmFzZUluYm94fSR7ci50b2tlbn1gLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBvcHRzLmhlYWRlcnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHIuY2FuY2VsKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShxaSk7XG4gICAgfVxuICAgIHJlcXVlc3Qoc3ViamVjdCwgZGF0YSwgb3B0cyA9IHtcbiAgICAgICAgdGltZW91dDogMTAwMCxcbiAgICAgICAgbm9NdXg6IGZhbHNlXG4gICAgfSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2soc3ViamVjdCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXN5bmNUcmFjZXMgPSAhKHRoaXMucHJvdG9jb2wub3B0aW9ucy5ub0FzeW5jVHJhY2VzIHx8IGZhbHNlKTtcbiAgICAgICAgb3B0cy50aW1lb3V0ID0gb3B0cy50aW1lb3V0IHx8IDEwMDA7XG4gICAgICAgIGlmIChvcHRzLnRpbWVvdXQgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IE5hdHNFcnJvcihcInRpbWVvdXRcIiwgRXJyb3JDb2RlLkludmFsaWRPcHRpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdHMubm9NdXggJiYgb3B0cy5yZXBseSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBOYXRzRXJyb3IoXCJyZXBseSBjYW4gb25seSBiZSB1c2VkIHdpdGggbm9NdXhcIiwgRXJyb3JDb2RlLkludmFsaWRPcHRpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5ub011eCkge1xuICAgICAgICAgICAgY29uc3QgaW5ib3ggPSBvcHRzLnJlcGx5ID8gb3B0cy5yZXBseSA6IGNyZWF0ZUluYm94KHRoaXMub3B0aW9ucy5pbmJveFByZWZpeCk7XG4gICAgICAgICAgICBjb25zdCBkID0gZGVmZXJyZWQoKTtcbiAgICAgICAgICAgIGNvbnN0IGVyckN0eCA9IGFzeW5jVHJhY2VzID8gbmV3IEVycm9yKCkgOiBudWxsO1xuICAgICAgICAgICAgY29uc3Qgc3ViID0gdGhpcy5zdWJzY3JpYmUoaW5ib3gsIHtcbiAgICAgICAgICAgICAgICBtYXg6IDEsXG4gICAgICAgICAgICAgICAgdGltZW91dDogb3B0cy50aW1lb3V0LFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiAoZXJyLCBtc2cpPT57XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJDdHggJiYgZXJyLmNvZGUgIT09IEVycm9yQ29kZS5UaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLnN0YWNrICs9IGBcXG5cXG4ke2VyckN0eC5zdGFja31gO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gaXNSZXF1ZXN0RXJyb3IobXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyQ3R4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyci5zdGFjayArPSBgXFxuXFxuJHtlcnJDdHguc3RhY2t9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5yZXNvbHZlKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN1Yi5yZXF1ZXN0U3ViamVjdCA9IHN1YmplY3Q7XG4gICAgICAgICAgICB0aGlzLnByb3RvY29sLnB1Ymxpc2goc3ViamVjdCwgZGF0YSwge1xuICAgICAgICAgICAgICAgIHJlcGx5OiBpbmJveCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBvcHRzLmhlYWRlcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByID0gbmV3IFJlcXVlc3RPbmUodGhpcy5wcm90b2NvbC5tdXhTdWJzY3JpcHRpb25zLCBzdWJqZWN0LCBvcHRzLCBhc3luY1RyYWNlcyk7XG4gICAgICAgICAgICB0aGlzLnByb3RvY29sLnJlcXVlc3Qocik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaChzdWJqZWN0LCBkYXRhLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGx5OiBgJHt0aGlzLnByb3RvY29sLm11eFN1YnNjcmlwdGlvbnMuYmFzZUluYm94fSR7ci50b2tlbn1gLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBvcHRzLmhlYWRlcnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHIuY2FuY2VsKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwID0gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgICAgICByLnRpbWVyLFxuICAgICAgICAgICAgICAgIHIuZGVmZXJyZWRcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgcC5jYXRjaCgoKT0+e1xuICAgICAgICAgICAgICAgIHIuY2FuY2VsKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZsdXNoKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Nsb3NlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoTmF0c0Vycm9yLmVycm9yRm9yQ29kZShFcnJvckNvZGUuQ29ubmVjdGlvbkNsb3NlZCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb3RvY29sLmZsdXNoKCk7XG4gICAgfVxuICAgIGRyYWluKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Nsb3NlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoTmF0c0Vycm9yLmVycm9yRm9yQ29kZShFcnJvckNvZGUuQ29ubmVjdGlvbkNsb3NlZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzRHJhaW5pbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KE5hdHNFcnJvci5lcnJvckZvckNvZGUoRXJyb3JDb2RlLkNvbm5lY3Rpb25EcmFpbmluZykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHJhaW5pbmcgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm90b2NvbC5kcmFpbigpO1xuICAgIH1cbiAgICBpc0Nsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdG9jb2wuaXNDbG9zZWQoKTtcbiAgICB9XG4gICAgaXNEcmFpbmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhaW5pbmc7XG4gICAgfVxuICAgIGdldFNlcnZlcigpIHtcbiAgICAgICAgY29uc3Qgc3J2ID0gdGhpcy5wcm90b2NvbC5nZXRTZXJ2ZXIoKTtcbiAgICAgICAgcmV0dXJuIHNydiA/IHNydi5saXN0ZW4gOiBcIlwiO1xuICAgIH1cbiAgICBzdGF0dXMoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXIgPSBuZXcgUXVldWVkSXRlcmF0b3JJbXBsKCk7XG4gICAgICAgIGl0ZXIuaXRlckNsb3NlZC50aGVuKCgpPT57XG4gICAgICAgICAgICBjb25zdCBpZHggPSB0aGlzLmxpc3RlbmVycy5pbmRleE9mKGl0ZXIpO1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5wdXNoKGl0ZXIpO1xuICAgICAgICByZXR1cm4gaXRlcjtcbiAgICB9XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3RvY29sLmlzQ2xvc2VkKCkgPyB1bmRlZmluZWQgOiB0aGlzLnByb3RvY29sLmluZm87XG4gICAgfVxuICAgIGFzeW5jIGNvbnRleHQoKSB7XG4gICAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLnJlcXVlc3QoYCRTWVMuUkVRLlVTRVIuSU5GT2ApO1xuICAgICAgICByZXR1cm4gci5qc29uKChrZXksIHZhbHVlKT0+e1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJ0aW1lXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5wYXJzZSh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbkJ5dGVzOiB0aGlzLnByb3RvY29sLmluQnl0ZXMsXG4gICAgICAgICAgICBvdXRCeXRlczogdGhpcy5wcm90b2NvbC5vdXRCeXRlcyxcbiAgICAgICAgICAgIGluTXNnczogdGhpcy5wcm90b2NvbC5pbk1zZ3MsXG4gICAgICAgICAgICBvdXRNc2dzOiB0aGlzLnByb3RvY29sLm91dE1zZ3NcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgamV0c3RyZWFtTWFuYWdlcihvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3QgYWRtID0gbmV3IEpldFN0cmVhbU1hbmFnZXJJbXBsKHRoaXMsIG9wdHMpO1xuICAgICAgICBpZiAob3B0cy5jaGVja0FQSSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgYWRtLmdldEFjY291bnRJbmZvKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZSA9IGVycjtcbiAgICAgICAgICAgICAgICBpZiAobmUuY29kZSA9PT0gRXJyb3JDb2RlLk5vUmVzcG9uZGVycykge1xuICAgICAgICAgICAgICAgICAgICBuZS5jb2RlID0gRXJyb3JDb2RlLkpldFN0cmVhbU5vdEVuYWJsZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZG07XG4gICAgfVxuICAgIGpldHN0cmVhbShvcHRzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBKZXRTdHJlYW1DbGllbnRJbXBsKHRoaXMsIG9wdHMpO1xuICAgIH1cbiAgICBnZXRTZXJ2ZXJWZXJzaW9uKCkge1xuICAgICAgICBjb25zdCBpbmZvID0gdGhpcy5pbmZvO1xuICAgICAgICByZXR1cm4gaW5mbyA/IHBhcnNlU2VtVmVyKGluZm8udmVyc2lvbikgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGFzeW5jIHJ0dCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3RvY29sLl9jbG9zZWQgJiYgIXRoaXMucHJvdG9jb2wuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBOYXRzRXJyb3IuZXJyb3JGb3JDb2RlKEVycm9yQ29kZS5EaXNjb25uZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgICAgIGF3YWl0IHRoaXMuZmx1c2goKTtcbiAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLSBzdGFydDtcbiAgICB9XG4gICAgZ2V0IGZlYXR1cmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm90b2NvbC5mZWF0dXJlcztcbiAgICB9XG4gICAgZ2V0IHNlcnZpY2VzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3NlcnZpY2VzKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXJ2aWNlcyA9IG5ldyBTZXJ2aWNlc0ZhY3RvcnkodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlcnZpY2VzO1xuICAgIH1cbiAgICByZWNvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChOYXRzRXJyb3IuZXJyb3JGb3JDb2RlKEVycm9yQ29kZS5Db25uZWN0aW9uQ2xvc2VkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNEcmFpbmluZygpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoTmF0c0Vycm9yLmVycm9yRm9yQ29kZShFcnJvckNvZGUuQ29ubmVjdGlvbkRyYWluaW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdG9jb2wucmVjb25uZWN0KCk7XG4gICAgfVxufVxuY2xhc3MgU2VydmljZXNGYWN0b3J5IHtcbiAgICBuYztcbiAgICBjb25zdHJ1Y3RvcihuYyl7XG4gICAgICAgIHRoaXMubmMgPSBuYztcbiAgICB9XG4gICAgYWRkKGNvbmZpZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcyA9IG5ldyBTZXJ2aWNlSW1wbCh0aGlzLm5jLCBjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuIHMuc3RhcnQoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGllbnQob3B0cywgcHJlZml4KSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VydmljZUNsaWVudEltcGwodGhpcy5uYywgb3B0cywgcHJlZml4KTtcbiAgICB9XG59XG5jbGFzcyBLdlN0b3JlZEVudHJ5SW1wbCB7XG4gICAgYnVja2V0O1xuICAgIHNtO1xuICAgIHByZWZpeExlbjtcbiAgICBjb25zdHJ1Y3RvcihidWNrZXQsIHByZWZpeExlbiwgc20pe1xuICAgICAgICB0aGlzLmJ1Y2tldCA9IGJ1Y2tldDtcbiAgICAgICAgdGhpcy5wcmVmaXhMZW4gPSBwcmVmaXhMZW47XG4gICAgICAgIHRoaXMuc20gPSBzbTtcbiAgICB9XG4gICAgZ2V0IGtleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc20uc3ViamVjdC5zdWJzdHJpbmcodGhpcy5wcmVmaXhMZW4pO1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNtLmRhdGE7XG4gICAgfVxuICAgIGdldCBkZWx0YSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGdldCBjcmVhdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbS50aW1lO1xuICAgIH1cbiAgICBnZXQgcmV2aXNpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNtLnNlcTtcbiAgICB9XG4gICAgZ2V0IG9wZXJhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc20uaGVhZGVyLmdldChrdk9wZXJhdGlvbkhkcikgfHwgXCJQVVRcIjtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgY29uc3Qgc2xlbiA9IHRoaXMuc20uaGVhZGVyLmdldChKc0hlYWRlcnMuTWVzc2FnZVNpemVIZHIpIHx8IFwiXCI7XG4gICAgICAgIGlmIChzbGVuICE9PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoc2xlbiwgMTApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNtLmRhdGEubGVuZ3RoO1xuICAgIH1cbiAgICBqc29uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbS5qc29uKCk7XG4gICAgfVxuICAgIHN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc20uc3RyaW5nKCk7XG4gICAgfVxufVxuY2xhc3MgS3ZKc01zZ0VudHJ5SW1wbCB7XG4gICAgYnVja2V0O1xuICAgIGtleTtcbiAgICBzbTtcbiAgICBjb25zdHJ1Y3RvcihidWNrZXQsIGtleSwgc20pe1xuICAgICAgICB0aGlzLmJ1Y2tldCA9IGJ1Y2tldDtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMuc20gPSBzbTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbS5kYXRhO1xuICAgIH1cbiAgICBnZXQgY3JlYXRlZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG1pbGxpcyh0aGlzLnNtLmluZm8udGltZXN0YW1wTmFub3MpKTtcbiAgICB9XG4gICAgZ2V0IHJldmlzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbS5zZXE7XG4gICAgfVxuICAgIGdldCBvcGVyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNtLmhlYWRlcnM/LmdldChrdk9wZXJhdGlvbkhkcikgfHwgXCJQVVRcIjtcbiAgICB9XG4gICAgZ2V0IGRlbHRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbS5pbmZvLnBlbmRpbmc7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIGNvbnN0IHNsZW4gPSB0aGlzLnNtLmhlYWRlcnM/LmdldChKc0hlYWRlcnMuTWVzc2FnZVNpemVIZHIpIHx8IFwiXCI7XG4gICAgICAgIGlmIChzbGVuICE9PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoc2xlbiwgMTApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNtLmRhdGEubGVuZ3RoO1xuICAgIH1cbiAgICBqc29uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbS5qc29uKCk7XG4gICAgfVxuICAgIHN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc20uc3RyaW5nKCk7XG4gICAgfVxufVxuY2xhc3MgSmV0U3RyZWFtU3Vic2NyaXB0aW9uSW1wbCBleHRlbmRzIFR5cGVkU3Vic2NyaXB0aW9uIHtcbiAgICBqcztcbiAgICBtb25pdG9yO1xuICAgIGNvbnN0cnVjdG9yKGpzLCBzdWJqZWN0LCBvcHRzKXtcbiAgICAgICAgc3VwZXIoanMubmMsIHN1YmplY3QsIG9wdHMpO1xuICAgICAgICB0aGlzLmpzID0ganM7XG4gICAgICAgIHRoaXMubW9uaXRvciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3ViLmNsb3NlZC50aGVuKCgpPT57XG4gICAgICAgICAgICBpZiAodGhpcy5tb25pdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb25pdG9yLmNhbmNlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0IGluZm8oaW5mbykge1xuICAgICAgICB0aGlzLnN1Yi5pbmZvID0gaW5mbztcbiAgICB9XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1Yi5pbmZvO1xuICAgIH1cbiAgICBfcmVzZXRPcmRlcmVkQ29uc3VtZXIoc3NlcSkge1xuICAgICAgICBpZiAodGhpcy5pbmZvID09PSBudWxsIHx8IHRoaXMuc3ViLmlzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdEZWxpdmVyID0gY3JlYXRlSW5ib3godGhpcy5qcy5uYy5vcHRpb25zLmluYm94UHJlZml4KTtcbiAgICAgICAgY29uc3QgbmNpID0gdGhpcy5qcy5uYztcbiAgICAgICAgbmNpLl9yZXN1Yih0aGlzLnN1YiwgbmV3RGVsaXZlcik7XG4gICAgICAgIGNvbnN0IGluZm8gPSB0aGlzLmluZm87XG4gICAgICAgIGluZm8uY29uZmlnLm5hbWUgPSBudWlkLm5leHQoKTtcbiAgICAgICAgaW5mby5vcmRlcmVkX2NvbnN1bWVyX3NlcXVlbmNlLmRlbGl2ZXJ5X3NlcSA9IDA7XG4gICAgICAgIGluZm8uZmxvd19jb250cm9sLmhlYXJ0YmVhdF9jb3VudCA9IDA7XG4gICAgICAgIGluZm8uZmxvd19jb250cm9sLmZjX2NvdW50ID0gMDtcbiAgICAgICAgaW5mby5mbG93X2NvbnRyb2wuY29uc3VtZXJfcmVzdGFydHMrKztcbiAgICAgICAgaW5mby5kZWxpdmVyID0gbmV3RGVsaXZlcjtcbiAgICAgICAgaW5mby5jb25maWcuZGVsaXZlcl9zdWJqZWN0ID0gbmV3RGVsaXZlcjtcbiAgICAgICAgaW5mby5jb25maWcuZGVsaXZlcl9wb2xpY3kgPSBEZWxpdmVyUG9saWN5LlN0YXJ0U2VxdWVuY2U7XG4gICAgICAgIGluZm8uY29uZmlnLm9wdF9zdGFydF9zZXEgPSBzc2VxO1xuICAgICAgICBjb25zdCByZXEgPSB7fTtcbiAgICAgICAgcmVxLnN0cmVhbV9uYW1lID0gdGhpcy5pbmZvLnN0cmVhbTtcbiAgICAgICAgcmVxLmNvbmZpZyA9IGluZm8uY29uZmlnO1xuICAgICAgICBjb25zdCBzdWJqID0gYCR7aW5mby5hcGkucHJlZml4fS5DT05TVU1FUi5DUkVBVEUuJHtpbmZvLnN0cmVhbX1gO1xuICAgICAgICB0aGlzLmpzLl9yZXF1ZXN0KHN1YmosIHJlcSwge1xuICAgICAgICAgICAgcmV0cmllczogLTFcbiAgICAgICAgfSkudGhlbigodik9PntcbiAgICAgICAgICAgIGNvbnN0IGNpID0gdjtcbiAgICAgICAgICAgIGNvbnN0IGppbmZvID0gdGhpcy5zdWIuaW5mbztcbiAgICAgICAgICAgIGppbmZvLmxhc3QgPSBjaTtcbiAgICAgICAgICAgIHRoaXMuaW5mby5jb25maWcgPSBjaS5jb25maWc7XG4gICAgICAgICAgICB0aGlzLmluZm8ubmFtZSA9IGNpLm5hbWU7XG4gICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICBjb25zdCBuZXJyID0gbmV3IE5hdHNFcnJvcihgdW5hYmxlIHRvIHJlY3JlYXRlIG9yZGVyZWQgY29uc3VtZXIgJHtpbmZvLnN0cmVhbX0gYXQgc2VxICR7c3NlcX1gLCBFcnJvckNvZGUuUmVxdWVzdEVycm9yLCBlcnIpO1xuICAgICAgICAgICAgdGhpcy5zdWIuY2FsbGJhY2sobmVyciwge30pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX21heWJlU2V0dXBIYk1vbml0b3JpbmcoKSB7XG4gICAgICAgIGNvbnN0IG5zID0gdGhpcy5pbmZvPy5jb25maWc/LmlkbGVfaGVhcnRiZWF0IHx8IDA7XG4gICAgICAgIGlmIChucykge1xuICAgICAgICAgICAgdGhpcy5fc2V0dXBIYk1vbml0b3JpbmcobWlsbGlzKG5zKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3NldHVwSGJNb25pdG9yaW5nKG1pbGxpcywgY2FuY2VsQWZ0ZXIgPSAwKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgICAgICBjYW5jZWxBZnRlcjogMCxcbiAgICAgICAgICAgIG1heE91dDogMlxuICAgICAgICB9O1xuICAgICAgICBpZiAoY2FuY2VsQWZ0ZXIpIHtcbiAgICAgICAgICAgIG9wdHMuY2FuY2VsQWZ0ZXIgPSBjYW5jZWxBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWIgPSB0aGlzLnN1YjtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9ICh2KT0+e1xuICAgICAgICAgICAgY29uc3QgbXNnID0gbmV3SnNFcnJvck1zZyg0MDksIGAke0pzNDA5RXJyb3JzLklkbGVIZWFydGJlYXRNaXNzZWR9OiAke3Z9YCwgdGhpcy5zdWIuc3ViamVjdCk7XG4gICAgICAgICAgICBjb25zdCBvcmRlcmVkID0gdGhpcy5pbmZvPy5vcmRlcmVkO1xuICAgICAgICAgICAgaWYgKCFvcmRlcmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWIuY2FsbGJhY2sobnVsbCwgbXNnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmpzLm5jLnByb3RvY29sLmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcSA9IHRoaXMuaW5mbz8ub3JkZXJlZF9jb25zdW1lcl9zZXF1ZW5jZT8uc3RyZWFtX3NlcSB8fCAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2V0T3JkZXJlZENvbnN1bWVyKHNlcSArIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMubW9uaXRvcj8ucmVzdGFydCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhc3ViLm5vSXRlcmF0b3I7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubW9uaXRvciA9IG5ldyBJZGxlSGVhcnRiZWF0TW9uaXRvcihtaWxsaXMsIGhhbmRsZXIsIG9wdHMpO1xuICAgIH1cbiAgICBfY2hlY2tIYk9yZGVyQ29uc3VtZXIobXNnKSB7XG4gICAgICAgIGNvbnN0IHJtID0gbXNnLmhlYWRlcnMuZ2V0KEpzSGVhZGVycy5Db25zdW1lclN0YWxsZWRIZHIpO1xuICAgICAgICBpZiAocm0gIT09IFwiXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5jaSA9IHRoaXMuanMubmM7XG4gICAgICAgICAgICBuY2kucHVibGlzaChybSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFzdERlbGl2ZXJlZCA9IHBhcnNlSW50KG1zZy5oZWFkZXJzLmdldChKc0hlYWRlcnMuTGFzdENvbnN1bWVyU2VxSGRyKSwgMTApO1xuICAgICAgICBjb25zdCBvcmRlcmVkID0gdGhpcy5pbmZvLm9yZGVyZWRfY29uc3VtZXJfc2VxdWVuY2U7XG4gICAgICAgIHRoaXMuaW5mby5mbG93X2NvbnRyb2wuaGVhcnRiZWF0X2NvdW50Kys7XG4gICAgICAgIGlmIChsYXN0RGVsaXZlcmVkICE9PSBvcmRlcmVkLmRlbGl2ZXJ5X3NlcSkge1xuICAgICAgICAgICAgdGhpcy5fcmVzZXRPcmRlcmVkQ29uc3VtZXIob3JkZXJlZC5zdHJlYW1fc2VxICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfY2hlY2tPcmRlcmVkQ29uc3VtZXIoam0pIHtcbiAgICAgICAgY29uc3Qgb3JkZXJlZCA9IHRoaXMuaW5mby5vcmRlcmVkX2NvbnN1bWVyX3NlcXVlbmNlO1xuICAgICAgICBjb25zdCBzc2VxID0gam0uaW5mby5zdHJlYW1TZXF1ZW5jZTtcbiAgICAgICAgY29uc3QgZHNlcSA9IGptLmluZm8uZGVsaXZlcnlTZXF1ZW5jZTtcbiAgICAgICAgaWYgKGRzZXEgIT0gb3JkZXJlZC5kZWxpdmVyeV9zZXEgKyAxKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNldE9yZGVyZWRDb25zdW1lcihvcmRlcmVkLnN0cmVhbV9zZXEgKyAxKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBvcmRlcmVkLmRlbGl2ZXJ5X3NlcSA9IGRzZXE7XG4gICAgICAgIG9yZGVyZWQuc3RyZWFtX3NlcSA9IHNzZXE7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBhc3luYyBkZXN0cm95KCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNDbG9zZWQoKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5kcmFpbigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGppbmZvID0gdGhpcy5zdWIuaW5mbztcbiAgICAgICAgY29uc3QgbmFtZSA9IGppbmZvLmNvbmZpZy5kdXJhYmxlX25hbWUgfHwgamluZm8ubmFtZTtcbiAgICAgICAgY29uc3Qgc3ViaiA9IGAke2ppbmZvLmFwaS5wcmVmaXh9LkNPTlNVTUVSLkRFTEVURS4ke2ppbmZvLnN0cmVhbX0uJHtuYW1lfWA7XG4gICAgICAgIGF3YWl0IGppbmZvLmFwaS5fcmVxdWVzdChzdWJqKTtcbiAgICB9XG4gICAgYXN5bmMgY29uc3VtZXJJbmZvKCkge1xuICAgICAgICBjb25zdCBqaW5mbyA9IHRoaXMuc3ViLmluZm87XG4gICAgICAgIGNvbnN0IG5hbWUgPSBqaW5mby5jb25maWcuZHVyYWJsZV9uYW1lIHx8IGppbmZvLm5hbWU7XG4gICAgICAgIGNvbnN0IHN1YmogPSBgJHtqaW5mby5hcGkucHJlZml4fS5DT05TVU1FUi5JTkZPLiR7amluZm8uc3RyZWFtfS4ke25hbWV9YDtcbiAgICAgICAgY29uc3QgY2kgPSBhd2FpdCBqaW5mby5hcGkuX3JlcXVlc3Qoc3Viaik7XG4gICAgICAgIGppbmZvLmxhc3QgPSBjaTtcbiAgICAgICAgcmV0dXJuIGNpO1xuICAgIH1cbn1cbmNsYXNzIEpldFN0cmVhbVB1bGxTdWJzY3JpcHRpb25JbXBsIGV4dGVuZHMgSmV0U3RyZWFtU3Vic2NyaXB0aW9uSW1wbCB7XG4gICAgY29uc3RydWN0b3IoanMsIHN1YmplY3QsIG9wdHMpe1xuICAgICAgICBzdXBlcihqcywgc3ViamVjdCwgb3B0cyk7XG4gICAgfVxuICAgIHB1bGwob3B0cyA9IHtcbiAgICAgICAgYmF0Y2g6IDFcbiAgICB9KSB7XG4gICAgICAgIGNvbnN0IHsgc3RyZWFtLCBjb25maWcsIG5hbWUgfSA9IHRoaXMuc3ViLmluZm87XG4gICAgICAgIGNvbnN0IGNvbnN1bWVyID0gY29uZmlnLmR1cmFibGVfbmFtZSA/PyBuYW1lO1xuICAgICAgICBjb25zdCBhcmdzID0ge307XG4gICAgICAgIGFyZ3MuYmF0Y2ggPSBvcHRzLmJhdGNoIHx8IDE7XG4gICAgICAgIGFyZ3Mubm9fd2FpdCA9IG9wdHMubm9fd2FpdCB8fCBmYWxzZTtcbiAgICAgICAgaWYgKChvcHRzLm1heF9ieXRlcyA/PyAwKSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGZ2ID0gdGhpcy5qcy5uYy5mZWF0dXJlcy5nZXQoRmVhdHVyZS5KU19QVUxMX01BWF9CWVRFUyk7XG4gICAgICAgICAgICBpZiAoIWZ2Lm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtYXhfYnl0ZXMgaXMgb25seSBzdXBwb3J0ZWQgb24gc2VydmVycyAke2Z2Lm1pbn0gb3IgYmV0dGVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcmdzLm1heF9ieXRlcyA9IG9wdHMubWF4X2J5dGVzO1xuICAgICAgICB9XG4gICAgICAgIGxldCBleHBpcmVzID0gMDtcbiAgICAgICAgaWYgKG9wdHMuZXhwaXJlcyAmJiBvcHRzLmV4cGlyZXMgPiAwKSB7XG4gICAgICAgICAgICBleHBpcmVzID0gb3B0cy5leHBpcmVzO1xuICAgICAgICAgICAgYXJncy5leHBpcmVzID0gbmFub3MoZXhwaXJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGhiID0gMDtcbiAgICAgICAgaWYgKG9wdHMuaWRsZV9oZWFydGJlYXQgJiYgb3B0cy5pZGxlX2hlYXJ0YmVhdCA+IDApIHtcbiAgICAgICAgICAgIGhiID0gb3B0cy5pZGxlX2hlYXJ0YmVhdDtcbiAgICAgICAgICAgIGFyZ3MuaWRsZV9oZWFydGJlYXQgPSBuYW5vcyhoYik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhiICYmIGV4cGlyZXMgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImlkbGVfaGVhcnRiZWF0IHJlcXVpcmVzIGV4cGlyZXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhiID4gZXhwaXJlcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXhwaXJlcyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBpZGxlX2hlYXJ0YmVhdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmZvKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tb25pdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb25pdG9yLmNhbmNlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4cGlyZXMgJiYgaGIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubW9uaXRvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXR1cEhiTW9uaXRvcmluZyhoYiwgZXhwaXJlcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb25pdG9yLl9jaGFuZ2UoaGIsIGV4cGlyZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFwaSA9IHRoaXMuaW5mby5hcGk7XG4gICAgICAgICAgICBjb25zdCBzdWJqID0gYCR7YXBpLnByZWZpeH0uQ09OU1VNRVIuTVNHLk5FWFQuJHtzdHJlYW19LiR7Y29uc3VtZXJ9YDtcbiAgICAgICAgICAgIGNvbnN0IHJlcGx5ID0gdGhpcy5zdWIuc3ViamVjdDtcbiAgICAgICAgICAgIGFwaS5uYy5wdWJsaXNoKHN1YmosIGFwaS5qYy5lbmNvZGUoYXJncyksIHtcbiAgICAgICAgICAgICAgICByZXBseTogcmVwbHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbXNnQWRhcHRlcihpdGVyYXRvciwgYWNrVGltZW91dCkge1xuICAgIGlmIChpdGVyYXRvcikge1xuICAgICAgICByZXR1cm4gaXRlck1zZ0FkYXB0ZXIoYWNrVGltZW91dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNiTXNnQWRhcHRlcihhY2tUaW1lb3V0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjYk1zZ0FkYXB0ZXIoYWNrVGltZW91dCkge1xuICAgIHJldHVybiAoZXJyLCBtc2cpPT57XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZXJyID0gY2hlY2tKc0Vycm9yKG1zZyk7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICB0b0pzTXNnKG1zZywgYWNrVGltZW91dClcbiAgICAgICAgXTtcbiAgICB9O1xufVxuZnVuY3Rpb24gaXRlck1zZ0FkYXB0ZXIoYWNrVGltZW91dCkge1xuICAgIHJldHVybiAoZXJyLCBtc2cpPT57XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmUgPSBjaGVja0pzRXJyb3IobXNnKTtcbiAgICAgICAgaWYgKG5lICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGhpZGVOb25UZXJtaW5hbEpzRXJyb3JzKG5lKSxcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgdG9Kc01zZyhtc2csIGFja1RpbWVvdXQpXG4gICAgICAgIF07XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhpZGVOb25UZXJtaW5hbEpzRXJyb3JzKG5lKSB7XG4gICAgaWYgKG5lICE9PSBudWxsKSB7XG4gICAgICAgIHN3aXRjaChuZS5jb2RlKXtcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLkpldFN0cmVhbTQwNE5vTWVzc2FnZXM6XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5KZXRTdHJlYW00MDhSZXF1ZXN0VGltZW91dDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLkpldFN0cmVhbTQwOTpcbiAgICAgICAgICAgICAgICBpZiAoaXNUZXJtaW5hbDQwOShuZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5lO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gYXV0b0Fja0pzTXNnKGRhdGEpIHtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBkYXRhLmFjaygpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlSW5mbyhzKSB7XG4gICAgY29uc3QgdG9rZW5zID0gcy5zcGxpdChcIi5cIik7XG4gICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDkpIHtcbiAgICAgICAgdG9rZW5zLnNwbGljZSgyLCAwLCBcIl9cIiwgXCJcIik7XG4gICAgfVxuICAgIGlmICh0b2tlbnMubGVuZ3RoIDwgMTEgfHwgdG9rZW5zWzBdICE9PSBcIiRKU1wiIHx8IHRva2Vuc1sxXSAhPT0gXCJBQ0tcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vdCBqcyBtZXNzYWdlYCk7XG4gICAgfVxuICAgIGNvbnN0IGRpID0ge307XG4gICAgZGkuZG9tYWluID0gdG9rZW5zWzJdID09PSBcIl9cIiA/IFwiXCIgOiB0b2tlbnNbMl07XG4gICAgZGkuYWNjb3VudF9oYXNoID0gdG9rZW5zWzNdO1xuICAgIGRpLnN0cmVhbSA9IHRva2Vuc1s0XTtcbiAgICBkaS5jb25zdW1lciA9IHRva2Vuc1s1XTtcbiAgICBkaS5kZWxpdmVyeUNvdW50ID0gcGFyc2VJbnQodG9rZW5zWzZdLCAxMCk7XG4gICAgZGkucmVkZWxpdmVyeUNvdW50ID0gZGkuZGVsaXZlcnlDb3VudDtcbiAgICBkaS5yZWRlbGl2ZXJlZCA9IGRpLmRlbGl2ZXJ5Q291bnQgPiAxO1xuICAgIGRpLnN0cmVhbVNlcXVlbmNlID0gcGFyc2VJbnQodG9rZW5zWzddLCAxMCk7XG4gICAgZGkuZGVsaXZlcnlTZXF1ZW5jZSA9IHBhcnNlSW50KHRva2Vuc1s4XSwgMTApO1xuICAgIGRpLnRpbWVzdGFtcE5hbm9zID0gcGFyc2VJbnQodG9rZW5zWzldLCAxMCk7XG4gICAgZGkucGVuZGluZyA9IHBhcnNlSW50KHRva2Vuc1sxMF0sIDEwKTtcbiAgICByZXR1cm4gZGk7XG59XG5jbGFzcyBKc01zZ0ltcGwge1xuICAgIG1zZztcbiAgICBkaTtcbiAgICBkaWRBY2s7XG4gICAgdGltZW91dDtcbiAgICBjb25zdHJ1Y3Rvcihtc2csIHRpbWVvdXQpe1xuICAgICAgICB0aGlzLm1zZyA9IG1zZztcbiAgICAgICAgdGhpcy5kaWRBY2sgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcbiAgICB9XG4gICAgZ2V0IHN1YmplY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1zZy5zdWJqZWN0O1xuICAgIH1cbiAgICBnZXQgc2lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tc2cuc2lkO1xuICAgIH1cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXNnLmRhdGE7XG4gICAgfVxuICAgIGdldCBoZWFkZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tc2cuaGVhZGVycztcbiAgICB9XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIGlmICghdGhpcy5kaSkge1xuICAgICAgICAgICAgdGhpcy5kaSA9IHBhcnNlSW5mbyh0aGlzLnJlcGx5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kaTtcbiAgICB9XG4gICAgZ2V0IHJlZGVsaXZlcmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmZvLmRlbGl2ZXJ5Q291bnQgPiAxO1xuICAgIH1cbiAgICBnZXQgcmVwbHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1zZy5yZXBseSB8fCBcIlwiO1xuICAgIH1cbiAgICBnZXQgc2VxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmZvLnN0cmVhbVNlcXVlbmNlO1xuICAgIH1cbiAgICBkb0FjayhwYXlsb2FkKSB7XG4gICAgICAgIGlmICghdGhpcy5kaWRBY2spIHtcbiAgICAgICAgICAgIHRoaXMuZGlkQWNrID0gIXRoaXMuaXNXSVAocGF5bG9hZCk7XG4gICAgICAgICAgICB0aGlzLm1zZy5yZXNwb25kKHBheWxvYWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzV0lQKHApIHtcbiAgICAgICAgcmV0dXJuIHAubGVuZ3RoID09PSA0ICYmIHBbMF0gPT09IFdQSVswXSAmJiBwWzFdID09PSBXUElbMV0gJiYgcFsyXSA9PT0gV1BJWzJdICYmIHBbM10gPT09IFdQSVszXTtcbiAgICB9XG4gICAgYXN5bmMgYWNrQWNrKG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIG9wdHMudGltZW91dCA9IG9wdHMudGltZW91dCB8fCB0aGlzLnRpbWVvdXQ7XG4gICAgICAgIGNvbnN0IGQgPSBkZWZlcnJlZCgpO1xuICAgICAgICBpZiAoIXRoaXMuZGlkQWNrKSB7XG4gICAgICAgICAgICB0aGlzLmRpZEFjayA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5tc2cucmVwbHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtaSA9IHRoaXMubXNnO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3RvID0gbWkucHVibGlzaGVyO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNlID0gIShwcm90by5vcHRpb25zPy5ub0FzeW5jVHJhY2VzIHx8IGZhbHNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCByID0gbmV3IFJlcXVlc3RPbmUocHJvdG8ubXV4U3Vic2NyaXB0aW9ucywgdGhpcy5tc2cucmVwbHksIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dDogb3B0cy50aW1lb3V0XG4gICAgICAgICAgICAgICAgfSwgdHJhY2UpO1xuICAgICAgICAgICAgICAgIHByb3RvLnJlcXVlc3Qocik7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdG8ucHVibGlzaCh0aGlzLm1zZy5yZXBseSwgQUNLLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBseTogYCR7cHJvdG8ubXV4U3Vic2NyaXB0aW9ucy5iYXNlSW5ib3h9JHtyLnRva2VufWBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHIuY2FuY2VsKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgICAgICAgICAgICAgICByLnRpbWVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgci5kZWZlcnJlZFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgZC5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByLmNhbmNlbChlcnIpO1xuICAgICAgICAgICAgICAgICAgICBkLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZC5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGQucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuICAgIGFjaygpIHtcbiAgICAgICAgdGhpcy5kb0FjayhBQ0spO1xuICAgIH1cbiAgICBuYWsobWlsbGlzKSB7XG4gICAgICAgIGxldCBwYXlsb2FkID0gTkFLO1xuICAgICAgICBpZiAobWlsbGlzKSB7XG4gICAgICAgICAgICBwYXlsb2FkID0gU3RyaW5nQ29kZWMoKS5lbmNvZGUoYC1OQUsgJHtKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgZGVsYXk6IG5hbm9zKG1pbGxpcylcbiAgICAgICAgICAgIH0pfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9BY2socGF5bG9hZCk7XG4gICAgfVxuICAgIHdvcmtpbmcoKSB7XG4gICAgICAgIHRoaXMuZG9BY2soV1BJKTtcbiAgICB9XG4gICAgbmV4dChzdWJqLCBvcHRzID0ge1xuICAgICAgICBiYXRjaDogMVxuICAgIH0pIHtcbiAgICAgICAgY29uc3QgYXJncyA9IHt9O1xuICAgICAgICBhcmdzLmJhdGNoID0gb3B0cy5iYXRjaCB8fCAxO1xuICAgICAgICBhcmdzLm5vX3dhaXQgPSBvcHRzLm5vX3dhaXQgfHwgZmFsc2U7XG4gICAgICAgIGlmIChvcHRzLmV4cGlyZXMgJiYgb3B0cy5leHBpcmVzID4gMCkge1xuICAgICAgICAgICAgYXJncy5leHBpcmVzID0gbmFub3Mob3B0cy5leHBpcmVzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gSlNPTkNvZGVjKCkuZW5jb2RlKGFyZ3MpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gRGF0YUJ1ZmZlci5jb25jYXQoTlhULCBTUEFDRSwgZGF0YSk7XG4gICAgICAgIGNvbnN0IHJlcU9wdHMgPSBzdWJqID8ge1xuICAgICAgICAgICAgcmVwbHk6IHN1YmpcbiAgICAgICAgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5tc2cucmVzcG9uZChwYXlsb2FkLCByZXFPcHRzKTtcbiAgICB9XG4gICAgdGVybShyZWFzb24gPSBcIlwiKSB7XG4gICAgICAgIGxldCB0ZXJtID0gVEVSTTtcbiAgICAgICAgaWYgKHJlYXNvbj8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGVybSA9IFN0cmluZ0NvZGVjKCkuZW5jb2RlKGArVEVSTSAke3JlYXNvbn1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvQWNrKHRlcm0pO1xuICAgIH1cbiAgICBqc29uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tc2cuanNvbigpO1xuICAgIH1cbiAgICBzdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1zZy5zdHJpbmcoKTtcbiAgICB9XG59XG5leHBvcnQgeyBjaGVja0pzRXJyb3IgYXMgY2hlY2tKc0Vycm9yLCBpc0Zsb3dDb250cm9sTXNnIGFzIGlzRmxvd0NvbnRyb2xNc2csIGlzSGVhcnRiZWF0TXNnIGFzIGlzSGVhcnRiZWF0TXNnIH07XG5leHBvcnQgeyBBY2tQb2xpY3kgYXMgQWNrUG9saWN5LCBBZHZpc29yeUtpbmQgYXMgQWR2aXNvcnlLaW5kLCBDb25zdW1lckRlYnVnRXZlbnRzIGFzIENvbnN1bWVyRGVidWdFdmVudHMsIENvbnN1bWVyRXZlbnRzIGFzIENvbnN1bWVyRXZlbnRzLCBEZWxpdmVyUG9saWN5IGFzIERlbGl2ZXJQb2xpY3ksIERpcmVjdE1zZ0hlYWRlcnMgYXMgRGlyZWN0TXNnSGVhZGVycywgRGlzY2FyZFBvbGljeSBhcyBEaXNjYXJkUG9saWN5LCBKc0hlYWRlcnMgYXMgSnNIZWFkZXJzLCBLdldhdGNoSW5jbHVkZSBhcyBLdldhdGNoSW5jbHVkZSwgUmVwbGF5UG9saWN5IGFzIFJlcGxheVBvbGljeSwgUmVwdWJsaXNoSGVhZGVycyBhcyBSZXB1Ymxpc2hIZWFkZXJzLCBSZXRlbnRpb25Qb2xpY3kgYXMgUmV0ZW50aW9uUG9saWN5LCBTdG9yYWdlVHlwZSBhcyBTdG9yYWdlVHlwZSwgU3RvcmVDb21wcmVzc2lvbiBhcyBTdG9yZUNvbXByZXNzaW9uIH07XG5leHBvcnQgeyBjb25zdW1lck9wdHMgYXMgY29uc3VtZXJPcHRzIH07XG5jb25zdCBWRVJTSU9OID0gXCIxLjMwLjNcIjtcbmNvbnN0IExBTkcgPSBcIm5hdHMud3NcIjtcbmNsYXNzIFdzVHJhbnNwb3J0IHtcbiAgICB2ZXJzaW9uO1xuICAgIGxhbmc7XG4gICAgY2xvc2VFcnJvcjtcbiAgICBjb25uZWN0ZWQ7XG4gICAgZG9uZTtcbiAgICBzb2NrZXQ7XG4gICAgb3B0aW9ucztcbiAgICBzb2NrZXRDbG9zZWQ7XG4gICAgZW5jcnlwdGVkO1xuICAgIHBlZWtlZDtcbiAgICB5aWVsZHM7XG4gICAgc2lnbmFsO1xuICAgIGNsb3NlZE5vdGlmaWNhdGlvbjtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLnZlcnNpb24gPSBWRVJTSU9OO1xuICAgICAgICB0aGlzLmxhbmcgPSBMQU5HO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zb2NrZXRDbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbmNyeXB0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wZWVrZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy55aWVsZHMgPSBbXTtcbiAgICAgICAgdGhpcy5zaWduYWwgPSBkZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLmNsb3NlZE5vdGlmaWNhdGlvbiA9IGRlZmVycmVkKCk7XG4gICAgfVxuICAgIGFzeW5jIGNvbm5lY3Qoc2VydmVyLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjb25uTG9jayA9IGRlZmVycmVkKCk7XG4gICAgICAgIGlmIChvcHRpb25zLnRscykge1xuICAgICAgICAgICAgY29ubkxvY2sucmVqZWN0KG5ldyBOYXRzRXJyb3IoXCJ0bHNcIiwgRXJyb3JDb2RlLkludmFsaWRPcHRpb24pKTtcbiAgICAgICAgICAgIHJldHVybiBjb25uTG9jaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBjb25zdCB1ID0gc2VydmVyLnNyYztcbiAgICAgICAgaWYgKG9wdGlvbnMud3NGYWN0b3J5KSB7XG4gICAgICAgICAgICBjb25zdCB7IHNvY2tldCwgZW5jcnlwdGVkIH0gPSBhd2FpdCBvcHRpb25zLndzRmFjdG9yeShzZXJ2ZXIuc3JjLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0ID0gc29ja2V0O1xuICAgICAgICAgICAgdGhpcy5lbmNyeXB0ZWQgPSBlbmNyeXB0ZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVuY3J5cHRlZCA9IHUuaW5kZXhPZihcIndzczovL1wiKSA9PT0gMDtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0ID0gbmV3IFdlYlNvY2tldCh1KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvY2tldC5iaW5hcnlUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuICAgICAgICB0aGlzLnNvY2tldC5vbm9wZW4gPSAoKT0+e1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEaXNjYXJkZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zb2NrZXQub25tZXNzYWdlID0gKG1lKT0+e1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEaXNjYXJkZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMueWllbGRzLnB1c2gobmV3IFVpbnQ4QXJyYXkobWUuZGF0YSkpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGVla2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaWduYWwucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHQgPSBEYXRhQnVmZmVyLmNvbmNhdCguLi50aGlzLnlpZWxkcyk7XG4gICAgICAgICAgICBjb25zdCBwbSA9IGV4dHJhY3RQcm90b2NvbE1lc3NhZ2UodCk7XG4gICAgICAgICAgICBpZiAocG0gIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtID0gSU5GTy5leGVjKHBtKTtcbiAgICAgICAgICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCIhISFcIiwgcmVuZGVyKHQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25uTG9jay5yZWplY3QobmV3IEVycm9yKFwidW5leHBlY3RlZCByZXNwb25zZSBmcm9tIHNlcnZlclwiKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5mbyA9IEpTT04ucGFyc2UobVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrT3B0aW9ucyhpbmZvLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlZWtlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaWduYWwucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25uTG9jay5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5Mb2NrLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNvY2tldC5vbmNsb3NlID0gKGV2dCk9PntcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRGlzY2FyZGVkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNvY2tldENsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICBsZXQgcmVhc29uO1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9uZSkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCFldnQud2FzQ2xlYW4pIHtcbiAgICAgICAgICAgICAgICByZWFzb24gPSBuZXcgRXJyb3IoZXZ0LnJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jbG9zZWQocmVhc29uKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zb2NrZXQub25lcnJvciA9IChlKT0+e1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEaXNjYXJkZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV2dCA9IGU7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgTmF0c0Vycm9yKGV2dC5tZXNzYWdlLCBFcnJvckNvZGUuVW5rbm93biwgbmV3IEVycm9yKGV2dC5lcnJvcikpO1xuICAgICAgICAgICAgaWYgKCFjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25uTG9jay5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xvc2VkKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjb25uTG9jaztcbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5fY2xvc2VkKHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgfVxuICAgIGFzeW5jIF9jbG9zZWQoZXJyLCBpbnRlcm5hbCA9IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEaXNjYXJkZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jb25uZWN0ZWQpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuZG9uZSkgcmV0dXJuO1xuICAgICAgICB0aGlzLmNsb3NlRXJyb3IgPSBlcnI7XG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICB3aGlsZSghdGhpcy5zb2NrZXRDbG9zZWQgJiYgdGhpcy5zb2NrZXQuYnVmZmVyZWRBbW91bnQgPiAwKXtcbiAgICAgICAgICAgICAgICBhd2FpdCBkZWxheSgxMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5jbG9zZShlcnIgPyAxMDAyIDogMTAwMCwgZXJyID8gZXJyLm1lc3NhZ2UgOiB1bmRlZmluZWQpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgIGlmIChpbnRlcm5hbCkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZWROb3RpZmljYXRpb24ucmVzb2x2ZShlcnIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpc0Nsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9uZTtcbiAgICB9XG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0ZSgpO1xuICAgIH1cbiAgICBhc3luYyAqaXRlcmF0ZSgpIHtcbiAgICAgICAgd2hpbGUodHJ1ZSl7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0Rpc2NhcmRlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMueWllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2lnbmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeWllbGRzID0gdGhpcy55aWVsZHM7XG4gICAgICAgICAgICB0aGlzLnlpZWxkcyA9IFtdO1xuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHlpZWxkcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oYD4gJHtyZW5kZXIoeWllbGRzW2ldKX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeWllbGQgeWllbGRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnlpZWxkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB5aWVsZHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnlpZWxkcyA9IHlpZWxkcztcbiAgICAgICAgICAgICAgICB0aGlzLnNpZ25hbCA9IGRlZmVycmVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNFbmNyeXB0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RlZCAmJiB0aGlzLmVuY3J5cHRlZDtcbiAgICB9XG4gICAgc2VuZChmcmFtZSkge1xuICAgICAgICBpZiAodGhpcy5pc0Rpc2NhcmRlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmQoZnJhbWUuYnVmZmVyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oYDwgJHtyZW5kZXIoZnJhbWUpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGAhISEgJHtyZW5kZXIoZnJhbWUpfTogJHtlcnJ9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xvc2UoZXJyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9zZWQoZXJyLCBmYWxzZSk7XG4gICAgfVxuICAgIGNsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2VkTm90aWZpY2F0aW9uO1xuICAgIH1cbiAgICBpc0Rpc2NhcmRlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICAgICAgdGhpcy5kaXNjYXJkKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRpc2NhcmQoKSB7XG4gICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldD8uY2xvc2UoKTtcbiAgICAgICAgfSBjYXRjaCAoX2Vycikge31cbiAgICB9XG59XG5mdW5jdGlvbiB3c1VybFBhcnNlRm4odSwgZW5jcnlwdGVkKSB7XG4gICAgY29uc3QgdXQgPSAvXiguKjpcXC9cXC8pKC4qKS87XG4gICAgaWYgKCF1dC50ZXN0KHUpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW5jcnlwdGVkID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgdSA9IGAke2VuY3J5cHRlZCA9PT0gdHJ1ZSA/IFwiaHR0cHNcIiA6IFwiaHR0cFwifTovLyR7dX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdSA9IGBodHRwczovLyR7dX1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCB1cmwgPSBuZXcgVVJMKHUpO1xuICAgIGNvbnN0IHNyY1Byb3RvID0gdXJsLnByb3RvY29sLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHNyY1Byb3RvID09PSBcIndzOlwiKSB7XG4gICAgICAgIGVuY3J5cHRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc3JjUHJvdG8gPT09IFwid3NzOlwiKSB7XG4gICAgICAgIGVuY3J5cHRlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChzcmNQcm90byAhPT0gXCJodHRwczpcIiAmJiBzcmNQcm90byAhPT0gXCJodHRwXCIpIHtcbiAgICAgICAgdSA9IHUucmVwbGFjZSgvXiguKjpcXC9cXC8pKC4qKS9nbSwgXCIkMlwiKTtcbiAgICAgICAgdXJsID0gbmV3IFVSTChgaHR0cDovLyR7dX1gKTtcbiAgICB9XG4gICAgbGV0IHByb3RvY29sO1xuICAgIGxldCBwb3J0O1xuICAgIGNvbnN0IGhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgY29uc3QgcGF0aCA9IHVybC5wYXRobmFtZTtcbiAgICBjb25zdCBzZWFyY2ggPSB1cmwuc2VhcmNoIHx8IFwiXCI7XG4gICAgc3dpdGNoKHNyY1Byb3RvKXtcbiAgICAgICAgY2FzZSBcImh0dHA6XCI6XG4gICAgICAgIGNhc2UgXCJ3czpcIjpcbiAgICAgICAgY2FzZSBcIm5hdHM6XCI6XG4gICAgICAgICAgICBwb3J0ID0gdXJsLnBvcnQgfHwgXCI4MFwiO1xuICAgICAgICAgICAgcHJvdG9jb2wgPSBcIndzOlwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJodHRwczpcIjpcbiAgICAgICAgY2FzZSBcIndzczpcIjpcbiAgICAgICAgY2FzZSBcInRsczpcIjpcbiAgICAgICAgICAgIHBvcnQgPSB1cmwucG9ydCB8fCBcIjQ0M1wiO1xuICAgICAgICAgICAgcHJvdG9jb2wgPSBcIndzczpcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcG9ydCA9IHVybC5wb3J0IHx8IGVuY3J5cHRlZCA9PT0gdHJ1ZSA/IFwiNDQzXCIgOiBcIjgwXCI7XG4gICAgICAgICAgICBwcm90b2NvbCA9IGVuY3J5cHRlZCA9PT0gdHJ1ZSA/IFwid3NzOlwiIDogXCJ3czpcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gYCR7cHJvdG9jb2x9Ly8ke2hvc3R9OiR7cG9ydH0ke3BhdGh9JHtzZWFyY2h9YDtcbn1cbmZ1bmN0aW9uIGNvbm5lY3Qob3B0cyA9IHt9KSB7XG4gICAgc2V0VHJhbnNwb3J0RmFjdG9yeSh7XG4gICAgICAgIGRlZmF1bHRQb3J0OiA0NDMsXG4gICAgICAgIHVybFBhcnNlRm46IHdzVXJsUGFyc2VGbixcbiAgICAgICAgZmFjdG9yeTogKCk9PntcbiAgICAgICAgICAgIHJldHVybiBuZXcgV3NUcmFuc3BvcnQoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBOYXRzQ29ubmVjdGlvbkltcGwuY29ubmVjdChvcHRzKTtcbn1cbmV4cG9ydCB7IGNvbm5lY3QgYXMgY29ubmVjdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/nats.ws/esm/nats.js\n");

/***/ })

};
;